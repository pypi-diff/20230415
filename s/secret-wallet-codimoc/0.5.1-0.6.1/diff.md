# Comparing `tmp/secret_wallet_codimoc-0.5.1-py3-none-any.whl.zip` & `tmp/secret_wallet_codimoc-0.6.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,33 +1,39 @@
-Zip file size: 44174 bytes, number of entries: 31
--rw-r--r--  2.0 unx        0 b- defN 22-Oct-23 09:42 secretwallet/__init__.py
--rw-r--r--  2.0 unx      200 b- defN 22-Oct-23 09:46 secretwallet/__main__.py
--rw-r--r--  2.0 unx     7462 b- defN 22-Oct-26 10:39 secretwallet/constants.py
--rw-r--r--  2.0 unx      350 b- defN 22-Oct-23 14:08 secretwallet/main/__init__.py
--rw-r--r--  2.0 unx     8899 b- defN 21-Jul-18 11:04 secretwallet/main/configuration.py
--rw-r--r--  2.0 unx    32529 b- defN 22-Oct-28 10:40 secretwallet/main/myparser.py
--rw-r--r--  2.0 unx        0 b- defN 20-Feb-08 14:19 secretwallet/session/__init__.py
--rw-r--r--  2.0 unx     2101 b- defN 22-Oct-26 10:02 secretwallet/session/client.py
--rw-r--r--  2.0 unx     3465 b- defN 22-Oct-26 10:03 secretwallet/session/service.py
--rw-r--r--  2.0 unx        0 b- defN 20-Feb-08 14:19 secretwallet/utils/__init__.py
--rw-r--r--  2.0 unx     2651 b- defN 21-Jul-18 11:04 secretwallet/utils/cryptutils.py
--rw-r--r--  2.0 unx    17467 b- defN 22-Oct-28 08:32 secretwallet/utils/dbutils.py
--rw-r--r--  2.0 unx      136 b- defN 20-Feb-08 14:19 secretwallet/utils/fileutils.py
--rw-r--r--  2.0 unx     5411 b- defN 22-Oct-26 10:15 secretwallet/utils/ioutils.py
--rw-r--r--  2.0 unx     1204 b- defN 22-Oct-26 10:13 secretwallet/utils/logging.py
--rw-r--r--  2.0 unx     3911 b- defN 22-Oct-26 10:03 secretwallet/utils/password_manager.py
--rw-r--r--  2.0 unx      288 b- defN 22-Oct-26 07:36 tests/__init__.py
--rw-r--r--  2.0 unx     1748 b- defN 20-Feb-08 14:19 tests/aws_config_test.py
--rw-r--r--  2.0 unx    22514 b- defN 22-Oct-28 10:36 tests/cli_test.py
--rw-r--r--  2.0 unx     2586 b- defN 20-Feb-08 14:19 tests/cryptuils_test.py
--rw-r--r--  2.0 unx    16012 b- defN 22-Oct-22 15:15 tests/dbutils_test.py
--rw-r--r--  2.0 unx     1775 b- defN 20-Feb-08 14:19 tests/parameters_test.py
--rw-r--r--  2.0 unx      646 b- defN 20-Feb-08 14:19 tests/password_test.py
--rw-r--r--  2.0 unx     1442 b- defN 22-Oct-26 12:59 tests/session_test.py
--rw-r--r--  2.0 unx      127 b- defN 22-Oct-26 11:29 tests/data/test_integration.json
--rw-r--r--  2.0 unx     1050 b- defN 22-Oct-31 08:22 secret_wallet_codimoc-0.5.1.dist-info/LICENSE
--rw-r--r--  2.0 unx    29083 b- defN 22-Oct-31 08:22 secret_wallet_codimoc-0.5.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Oct-31 08:22 secret_wallet_codimoc-0.5.1.dist-info/WHEEL
--rw-r--r--  2.0 unx      153 b- defN 22-Oct-31 08:22 secret_wallet_codimoc-0.5.1.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       19 b- defN 22-Oct-31 08:22 secret_wallet_codimoc-0.5.1.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2658 b- defN 22-Oct-31 08:22 secret_wallet_codimoc-0.5.1.dist-info/RECORD
-31 files, 165979 bytes uncompressed, 39876 bytes compressed:  76.0%
+Zip file size: 50584 bytes, number of entries: 37
+-rw-r--r--  2.0 unx        0 b- defN 23-Mar-26 10:35 secretwallet/__init__.py
+-rw-r--r--  2.0 unx      200 b- defN 23-Mar-30 08:10 secretwallet/__main__.py
+-rw-r--r--  2.0 unx     8084 b- defN 23-Apr-07 14:16 secretwallet/constants.py
+-rw-r--r--  2.0 unx      160 b- defN 23-Apr-10 09:21 secretwallet/__pycache__/__init__.cpython-39.pyc
+-rw-r--r--  2.0 unx      350 b- defN 23-Mar-26 10:35 secretwallet/main/__init__.py
+-rw-r--r--  2.0 unx     8899 b- defN 23-Mar-26 10:35 secretwallet/main/configuration.py
+-rw-r--r--  2.0 unx    34680 b- defN 23-Apr-09 09:04 secretwallet/main/myparser.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Mar-26 10:35 secretwallet/session/__init__.py
+-rw-r--r--  2.0 unx     2101 b- defN 23-Mar-30 08:10 secretwallet/session/client.py
+-rw-r--r--  2.0 unx     3465 b- defN 23-Mar-30 08:10 secretwallet/session/service.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Mar-30 17:30 secretwallet/storage/__init__.py
+-rw-r--r--  2.0 unx    12290 b- defN 23-Apr-09 08:25 secretwallet/storage/aws_dynamo.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Mar-26 10:35 secretwallet/utils/__init__.py
+-rw-r--r--  2.0 unx     3677 b- defN 23-Apr-06 17:44 secretwallet/utils/cryptutils.py
+-rw-r--r--  2.0 unx    14331 b- defN 23-Apr-09 08:46 secretwallet/utils/dbutils.py
+-rw-r--r--  2.0 unx      136 b- defN 23-Mar-26 10:35 secretwallet/utils/fileutils.py
+-rw-r--r--  2.0 unx     5437 b- defN 23-Apr-07 17:23 secretwallet/utils/ioutils.py
+-rw-r--r--  2.0 unx     1204 b- defN 23-Mar-30 08:10 secretwallet/utils/logging.py
+-rw-r--r--  2.0 unx     3911 b- defN 23-Mar-30 08:10 secretwallet/utils/password_manager.py
+-rw-r--r--  2.0 unx      166 b- defN 23-Apr-10 09:21 secretwallet/utils/__pycache__/__init__.cpython-39.pyc
+-rw-r--r--  2.0 unx     3551 b- defN 23-Apr-10 09:21 secretwallet/utils/__pycache__/cryptutils.cpython-39.pyc
+-rw-r--r--  2.0 unx      372 b- defN 23-Apr-03 20:58 tests/__init__.py
+-rw-r--r--  2.0 unx     1748 b- defN 23-Mar-26 10:35 tests/aws_config_test.py
+-rw-r--r--  2.0 unx     4761 b- defN 23-Apr-07 11:53 tests/aws_dynamo_test.py
+-rw-r--r--  2.0 unx    27512 b- defN 23-Apr-10 09:24 tests/cli_test.py
+-rw-r--r--  2.0 unx     2973 b- defN 23-Apr-07 15:38 tests/cryptuils_test.py
+-rw-r--r--  2.0 unx    15242 b- defN 23-Apr-07 15:38 tests/dbutils_test.py
+-rw-r--r--  2.0 unx     1757 b- defN 23-Apr-03 21:34 tests/parameters_test.py
+-rw-r--r--  2.0 unx      646 b- defN 23-Mar-26 10:35 tests/password_test.py
+-rw-r--r--  2.0 unx     1442 b- defN 23-Mar-30 08:10 tests/session_test.py
+-rw-r--r--  2.0 unx      127 b- defN 23-Mar-30 08:10 tests/data/test_integration.json
+-rw-r--r--  2.0 unx     1050 b- defN 23-Apr-15 08:49 secret_wallet_codimoc-0.6.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx    29333 b- defN 23-Apr-15 08:49 secret_wallet_codimoc-0.6.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Apr-15 08:49 secret_wallet_codimoc-0.6.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx      152 b- defN 23-Apr-15 08:49 secret_wallet_codimoc-0.6.1.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       19 b- defN 23-Apr-15 08:49 secret_wallet_codimoc-0.6.1.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     3244 b- defN 23-Apr-15 08:49 secret_wallet_codimoc-0.6.1.dist-info/RECORD
+37 files, 193112 bytes uncompressed, 45334 bytes compressed:  76.5%
```

## zipnote {}

```diff
@@ -3,14 +3,17 @@
 
 Filename: secretwallet/__main__.py
 Comment: 
 
 Filename: secretwallet/constants.py
 Comment: 
 
+Filename: secretwallet/__pycache__/__init__.cpython-39.pyc
+Comment: 
+
 Filename: secretwallet/main/__init__.py
 Comment: 
 
 Filename: secretwallet/main/configuration.py
 Comment: 
 
 Filename: secretwallet/main/myparser.py
@@ -21,14 +24,20 @@
 
 Filename: secretwallet/session/client.py
 Comment: 
 
 Filename: secretwallet/session/service.py
 Comment: 
 
+Filename: secretwallet/storage/__init__.py
+Comment: 
+
+Filename: secretwallet/storage/aws_dynamo.py
+Comment: 
+
 Filename: secretwallet/utils/__init__.py
 Comment: 
 
 Filename: secretwallet/utils/cryptutils.py
 Comment: 
 
 Filename: secretwallet/utils/dbutils.py
@@ -42,20 +51,29 @@
 
 Filename: secretwallet/utils/logging.py
 Comment: 
 
 Filename: secretwallet/utils/password_manager.py
 Comment: 
 
+Filename: secretwallet/utils/__pycache__/__init__.cpython-39.pyc
+Comment: 
+
+Filename: secretwallet/utils/__pycache__/cryptutils.cpython-39.pyc
+Comment: 
+
 Filename: tests/__init__.py
 Comment: 
 
 Filename: tests/aws_config_test.py
 Comment: 
 
+Filename: tests/aws_dynamo_test.py
+Comment: 
+
 Filename: tests/cli_test.py
 Comment: 
 
 Filename: tests/cryptuils_test.py
 Comment: 
 
 Filename: tests/dbutils_test.py
@@ -69,26 +87,26 @@
 
 Filename: tests/session_test.py
 Comment: 
 
 Filename: tests/data/test_integration.json
 Comment: 
 
-Filename: secret_wallet_codimoc-0.5.1.dist-info/LICENSE
+Filename: secret_wallet_codimoc-0.6.1.dist-info/LICENSE
 Comment: 
 
-Filename: secret_wallet_codimoc-0.5.1.dist-info/METADATA
+Filename: secret_wallet_codimoc-0.6.1.dist-info/METADATA
 Comment: 
 
-Filename: secret_wallet_codimoc-0.5.1.dist-info/WHEEL
+Filename: secret_wallet_codimoc-0.6.1.dist-info/WHEEL
 Comment: 
 
-Filename: secret_wallet_codimoc-0.5.1.dist-info/entry_points.txt
+Filename: secret_wallet_codimoc-0.6.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: secret_wallet_codimoc-0.5.1.dist-info/top_level.txt
+Filename: secret_wallet_codimoc-0.6.1.dist-info/top_level.txt
 Comment: 
 
-Filename: secret_wallet_codimoc-0.5.1.dist-info/RECORD
+Filename: secret_wallet_codimoc-0.6.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## secretwallet/constants.py

```diff
@@ -1,12 +1,13 @@
 import datetime
 import json
 import logging
 import os
 from os.path import expanduser, exists
+from collections import namedtuple
 
 
 if 'HOME_DIR' in globals():
     HOME_FOLDER = eval('HOME_DIR')
 else:
     HOME_FOLDER = expanduser("~")
 
@@ -16,14 +17,15 @@
 CREDENTIALS_FOLDER = f"{HOME_FOLDER}/.aws"
 CREDENTIALS_FILE = f"{CREDENTIALS_FOLDER}/credentials"
 
 PRE_SALT = b"Nel mezzo del cammin di nostra vita"
 
 #dynamoDB variables
 SECRET_ACCESS_TABLE='access_secrets'
+TEST_TABLE = 'test'
 
 #AWS configuration
 AWS_PROFILE='secret-wallet'
 
 #session parameters
 SESSION_ADDRESS = ('localhost',6417)
 SESSION_PWD = b'yooCani3'
@@ -39,14 +41,18 @@
 PWD_UPPER = 1  #at least an upper case
 
 LOG_FILE = f"{CONFIG_FOLDER}/secretwallet.log"
 LOG_LEVEL = "info"
 LOG_MAX_FILE_SIZE =  1000000 #1MB
 LOG_BACKUP_COUNT  = 1        #number of rotated backup files that are retained
 
+#type of storage
+DB_AWS_DYNAMO = 0
+DB_LOCAL_SQLITE = 1
+
 def is_posix()->bool:
     return os.name=='posix'
 
 
 def make_log_level(level):
     if level.lower()=="critical":
         return logging.CRITICAL
@@ -79,14 +85,17 @@
     def __init__(self):
         self.__data = dict()
         self.__loggers = dict()
 
     def set_data(self,data):
         self.__data = dict(data)
         self.update_loggers()
+        
+    def get_data(self):
+        return self.__data
 
     def register_logger(self, name, logger):
         self.__loggers[name] = logger
 
     def update_loggers(self):
         level = make_log_level(self.get_log_level())
         for logger in self.__loggers.values():
@@ -136,14 +145,20 @@
             return PRE_SALT
 
     def get_table_name(self):
         if 'table_name' in self.__data:
             return self.__data['table_name']
         else:
             return SECRET_ACCESS_TABLE
+        
+    def get_storage_type(self):
+        if 'storage_type' in self.__data:
+            return self.__data['storage_type']
+        else:
+            return DB_AWS_DYNAMO
 
     def set_table_name(self, table):
         self.__data['table_name'] = table
 
     def get_salt_key(self):
         if 'key' in self.__data:
             return self.__data['key']
@@ -242,7 +257,13 @@
             return self.__data["sweeper_pid"]
         else:
             return None
 
 
 #single object
 parameters = Parameters()
+
+# a message class containing secret info
+secret_fields = ['domain','access','user_id','password','info', 'encrypted_info','info_key','info_value','timestamp']
+default_vals = [None]*len(secret_fields)
+Secret = namedtuple('Secret', secret_fields, defaults=default_vals)
+
```

## secretwallet/main/myparser.py

```diff
@@ -7,21 +7,21 @@
 import argparse
 import contextlib
 import json
 import shlex
 import sys
 
 import readline
-from secretwallet.constants import parameters
+from secretwallet.constants import parameters, Secret
 from secretwallet.main.configuration import list_configuration, get_configuration, set_configuration_data
 from secretwallet.session.client import get_session_password, set_session_password, stop_service, is_connected
 from secretwallet.session.service import start_my_session
 from secretwallet.utils.cryptutils import encrypt_key
-from secretwallet.utils.dbutils import has_secret, get_secret, insert_secret, list_secrets, update_secret, \
-                                       update_secret_info_dictionary, delete_secret, delete_secrets, rename_secret, \
+from secretwallet.utils.dbutils import has_secret, get_secret, insert_secret, insert_encrypted_secret, list_secrets, \
+                                       update_secret, update_secret_info_dictionary, delete_secret, delete_secrets, rename_secret, \
                                        reconf_memorable, reconf_salt_key, query_secrets_by_field, query_secrets_by_pattern, \
                                        get_all_secrets
 from secretwallet.utils.logging import get_logger
 
 import pkg_resources as pkg
 import secretwallet.utils.ioutils as iou
 import secretwallet.utils.password_manager as pm
@@ -213,19 +213,21 @@
             return
 
         iou.my_output('Running delete with arguments %s' % args)
         try:
             if args.domain is not None and args.access is not None and args.info_key is not None:
                 iou.confirm_delete_key(args.domain, args.access, args.info_key)
                 sec = get_secret(args.domain, args.access, None, None, False) #no decryption
-                info = sec['info']
+                info = sec.info
                 del info[args.info_key]
+                #Here the dictionary passed is already encrypted
                 update_secret_info_dictionary(args.domain, args.access, info)
             elif args.domain is not None and args.access is not None:
-                iou.confirm_delete([(args.domain, args.access)])
+                secret = Secret(domain=args.domain, access=args.access)
+                iou.confirm_delete([secret])
                 delete_secret(args.domain, args.access)
             else:
                 secrets = list_secrets(args.domain)
                 iou.confirm_delete(secrets)
                 delete_secrets(secrets)
         except Exception as e:
             iou.my_output(repr(e))
@@ -268,15 +270,16 @@
             elif not has_secret(args.domain, args.access):
                 iou.my_output("Could not find the secret to rename", True)
             else:
                 if args.new_domain is None:
                     args.new_domain = args.domain
                 if args.new_access is None:
                     args.new_access = args.access
-                iou.confirm_rename([(args.domain, args.access)])
+                secret = Secret(domain=args.domain, access=args.access)
+                iou.confirm_rename([secret])
                 rename_secret(args.domain, args.access, args.new_domain, args.new_access)
         except Exception as e:
             iou.my_output(repr(e))
 
     def list(self):
         """
            List a set of secrets. With no option passed, all secrets are returned. Alternatively it is possible to filter secrets by
@@ -362,15 +365,15 @@
             if (args.pattern is not None):
                 secrets = query_secrets_by_pattern(args.pattern)
             sec = iou.get_secret_by_idx("List of secrets", secrets)
             if sec is None:
                 return
             try:
                 memorable, need_session = pm.get_memorable_password(False)
-                iou.display_secret(get_secret(sec[0], sec[1], memorable))
+                iou.display_secret(get_secret(sec.domain, sec.access, memorable))
                 if need_session:
                     start_my_session(memorable, parameters.get_session_lifetime(), parameters.get_session_timeout())
             except Exception as e:
                 iou.my_output(repr(e))
 
         except Exception as e:
             iou.my_output(repr(e))
@@ -632,15 +635,15 @@
 
         args = iou.my_parse(parser,sys.argv[2:])
 
         iou.my_output('Starting a secret wallet dump with parameters %s'%args)
         try:
             memorable, need_session = pm.get_memorable_password(False)
 
-            secrets = get_all_secrets(memorable)
+            secrets = get_all_secrets(memorable,False) #False -> return as Secret
             if (args.file is not None):
                 with open(args.file,'a') as f:
                     with contextlib.redirect_stdout(f):
                         iou.display_all_secrets(secrets) #send to file
             else:
                 iou.display_all_secrets(secrets) #send to the console
 
@@ -658,59 +661,91 @@
             description=self.save.__doc__,
             prog='secretwallet save')
         #optional arguments
         parser.add_argument('-f',
                             dest='file',
                             required=False,
                             help='The output file. If it is not specified it outputs the json structure to the console (default system out stream)')
+        parser.add_argument('-d',
+                        dest='needs_decrypt',
+                        required=False,
+                        default=False,
+                        action='store_true',
+                        help='A flag. If set, all secret are stored or displayed after being decrypted. It defaults to true (encrypted)')
 
         args = iou.my_parse(parser,sys.argv[2:])
 
         iou.my_output('Starting a secret wallet save with parameters %s'%args)
         try:
-            memorable, need_session = pm.get_memorable_password(False)
-
-            secrets = get_all_secrets(memorable)
-            if (args.file is not None):
-                with open(args.file,'w') as f:
-                    with contextlib.redirect_stdout(f):
-                        json.dump(secrets, f) #send to file
-            else:
-                iou.my_output(json.dumps(secrets), with_logging=False)
-
-            #here start the session (at the end so that we can daemonize)
-            if need_session:
-                start_my_session(memorable, parameters.get_session_lifetime(), parameters.get_session_timeout())
+            if args.needs_decrypt:
+                memorable, need_session = pm.get_memorable_password(False)
+    
+                secrets = get_all_secrets(memorable, True) # True -> return as dictionary
+                if (args.file is not None):
+                    with open(args.file,'w') as f:
+                        with contextlib.redirect_stdout(f):
+                            json.dump(secrets, f) #send to file
+                else:
+                    iou.my_output(json.dumps(secrets), with_logging=False)
+    
+                #here start the session (at the end so that we can daemonize)
+                if need_session:
+                    start_my_session(memorable, parameters.get_session_lifetime(), parameters.get_session_timeout())
+            else: # encrypted
+                secrets = get_all_secrets(as_dictionary=True, needs_decrypt=False)
+                if (args.file is not None):
+                    with open(args.file,'w') as f:
+                        with contextlib.redirect_stdout(f):
+                            json.dump(secrets, f) #send to file
+                else:
+                    iou.my_output(json.dumps(secrets), with_logging=False)
+    
         except Exception as e:
             iou.my_output(repr(e))
 
     def load(self):
         """Reload secrets, previously stored in a json file after a backup operation (save action).
         It requires a json file as input, as specified with the -f option."""
         parser = argparse.ArgumentParser(
             description=self.load.__doc__,
             prog='secretwallet load')
         #optional arguments
         parser.add_argument('-f',
                             dest='file',
                             required=True,
                             help='The input file in json format, containing the backed-up secrets.')
+        parser.add_argument('-d',
+                            dest='needs_decrypt',
+                            required=False,
+                            default=False,
+                            action='store_true',
+                            help='A flag. If set, all secret are loaded from decrypted values. It defaults to true (encrypted)')        
 
         args = iou.my_parse(parser,sys.argv[2:])
         iou.my_output('Starting a secret wallet load with parameters %s'%args)
         try:
-            memorable, need_session = pm.get_memorable_password(True)
-
-            with open(args.file,'r') as f:
-                secrets = json.load(f)
-                for secret in secrets:
-                    domain = secret["domain"]
-                    access = secret["access"]
-                    if not has_secret(domain, access):
-                        iou.my_output(f"inserting secret (domain:{domain}, access:{access})")
-                        insert_secret(domain, access, secret["uid"], secret["pwd"], secret["info"] , memorable, timestamp=secret["timestamp"])
-
-            #here start the session (at the end so that we can daemonize)
-            if need_session:
-                start_my_session(memorable, parameters.get_session_lifetime(), parameters.get_session_timeout())
+            if args.needs_decrypt:
+                memorable, need_session = pm.get_memorable_password(True)
+    
+                with open(args.file,'r') as f:
+                    secrets = json.load(f)
+                    for secret in secrets:
+                        domain = secret["domain"]
+                        access = secret["access"]
+                        if not has_secret(domain, access):
+                            iou.my_output(f"inserting secret (domain:{domain}, access:{access})")
+                            insert_secret(domain, access, secret["uid"], secret["pwd"], secret["info"] , memorable, timestamp=secret["timestamp"])
+    
+                #here start the session (at the end so that we can daemonize)
+                if need_session:
+                    start_my_session(memorable, parameters.get_session_lifetime(), parameters.get_session_timeout())
+            else: #encrypted
+                with open(args.file,'r') as f:
+                    secrets = json.load(f)
+                    for secret in secrets:
+                        domain = secret["domain"]
+                        access = secret["access"]
+                        if not has_secret(domain, access):
+                            iou.my_output(f"inserting secret (domain:{domain}, access:{access})")
+                            insert_encrypted_secret(domain, access, secret["uid"], secret["pwd"], secret["info"],timestamp=secret["timestamp"])
         except Exception as e:
             iou.my_output(repr(e))
```

## secretwallet/utils/cryptutils.py

```diff
@@ -62,8 +62,38 @@
     input:
     secret       encrypted secret
     mem_pswd     memorable password (unicode)
     salt         a string representation of the salt (optional)    
     output:
     The decrypted secret 
     """
-    return _decrypt(secret.encode('latin1'), mem_pswd, salt)    
+    return _decrypt(secret.encode('latin1'), mem_pswd, salt)
+
+def encrypt_info(info,mem_pwd, salt):
+    """Encrypts a a full dictionary of extra info
+    input:
+    info         a dictionary of extra information
+    mem_pwd      memorable password (unicode)
+    salt         a string representation of the salt (optional)    
+    output:
+    The encrypted dictionary of extra information 
+    """
+    einfo = {}
+    if info is not None:
+        for key, value in info.items():
+            einfo[key] = encrypt(value, mem_pwd, salt) #in string format
+    return einfo
+
+def decrypt_info(info, mem_pwd, salt):
+    """Decrypts a a full dictionary of extra info
+    input:
+    info         an encrypted dictionary of extra information
+    mem_pwd      memorable password (unicode)
+    salt         a string representation of the salt (optional)    
+    output:
+    The decrypted dictionary of extra information 
+    """    
+    dinfo = {}
+    if info is not None:
+        for key, value in info.items():
+            dinfo[key] = decrypt(value, mem_pwd, salt) #from string format
+    return dinfo
```

## secretwallet/utils/dbutils.py

```diff
@@ -3,112 +3,83 @@
 
 @author: codimoc
 '''
 
 from datetime import datetime
 import sys
 
-import boto3
-from boto3.dynamodb.conditions import Key
-from secretwallet.constants import parameters
-from secretwallet.utils.cryptutils import encrypt, encrypt_key, decrypt
+from secretwallet.constants import parameters, Secret
+from secretwallet.utils.cryptutils import encrypt_key, decrypt, decrypt_info
 from secretwallet.utils.logging import get_logger
+from secretwallet.storage.aws_dynamo import AWSDynamoTable
 
 import secretwallet.utils.ioutils as iou
 
 
 logger = get_logger(__name__, parameters.get_log_level())
 parameters.register_logger(__name__, logger)
 
 SEPARATOR="#-#"
 
-def _get_table():
-    #TODO: manage Session in a better way. The table resource should be stored in the Session
-    session = boto3.session.Session(profile_name=parameters.get_profile_name())
-    dynamodb = session.resource('dynamodb')
-    return dynamodb.Table(parameters.get_table_name())
-
-def _backup_table(backup_name):
-    session = boto3.session.Session(profile_name=parameters.get_profile_name())
-    client = session.client('dynamodb')
-    res = client.create_backup(TableName = parameters.get_table_name(), BackupName = backup_name)
-    return res['BackupDetails']['BackupArn']
-
-def _cleanup_table_backups(backup_name):
-    session = boto3.session.Session(profile_name=parameters.get_profile_name())
-    client = session.client('dynamodb')
-    res = client.list_backups(TableName=parameters.get_table_name())
-    for bkp in res['BackupSummaries']:
-        if bkp['BackupName'] == backup_name:
-            client.delete_backup(BackupArn=bkp['BackupArn'])
-
-def _drop_table(table_name):
-    #TODO: manage Session in a better way. The table resource should be stored in the Session
-    session = boto3.session.Session(profile_name=parameters.get_profile_name())
-    dynamodb = session.resource('dynamodb')
-    dynamodb.Table(table_name).delete()
+def secret_to_dictionary(secret:Secret, mem_pwd = None, salt = None, needs_decrypt:bool = True):
+    ret = {'domain'    : secret.domain,
+           'access'    : secret.access,
+           'timestamp' : secret.timestamp}
+    if needs_decrypt:
+        ret['uid']  = decrypt(secret.user_id, mem_pwd, salt)
+        ret['pwd']  = decrypt(secret.password, mem_pwd, salt)
+        ret['info'] = decrypt_info(secret.info, mem_pwd, salt)
+    else:
+        ret['uid']  = secret.user_id
+        ret['pwd']  = secret.password
+        ret['info'] = secret.info
+    return ret
+
+def decrypt_secret(secret:Secret, mem_pwd:str, salt:str)->Secret:
+    return Secret(domain = secret.domain,
+                  access = secret.access,
+                  user_id = decrypt(secret.user_id, mem_pwd, salt),
+                  password = decrypt(secret.password, mem_pwd, salt),
+                  info = decrypt_info(secret.info, mem_pwd, salt),
+                  timestamp = secret.timestamp
+                  )
+
+def _get_table()->object:
+    #we hard-code this to a AWS DynamoDB table for now
+    #TODO: this will require a parameter to decide which storage type
+    return AWSDynamoTable(parameters.get_table_name(), parameters.get_profile_name())
+
+def _backup_table(backup_name:str)->object:
+    return _get_table().backup_table(backup_name)
+
+def _cleanup_table_backups(backup_name:str)->None:
+    _get_table().cleanup_table_backups(backup_name)
 
-def has_table(table_name):
+def _drop_table():
+    _get_table().drop_table()
+
+def has_table(table_name:str)->bool:
     "Checks if the table exists"
-    #TODO: manage Session in a better way. The table resource should be stored in the Session
     try:
-        session = boto3.session.Session(profile_name=parameters.get_profile_name())
-        dynamodb = session.resource('dynamodb')
-        names = [x.table_name for x in dynamodb.tables.all()]
-        return table_name in names
+        return _get_table().has_table(table_name)
     except Exception as e:
-        print(e)
+        iou.my_output(e)
         logger.error(e)
         sys.exit(1)
 
 
 def create_table(table_name=parameters.get_table_name()):
     "Creates a table if it does not exist"
-    if has_table(table_name):
-        return
-    session = boto3.session.Session(profile_name=parameters.get_profile_name())
-    dynamodb = session.resource('dynamodb')
     try:
-        dynamodb.create_table(
-            TableName=f"{table_name}",
-            # Declare your Primary Key in the KeySchema argument
-            KeySchema=[
-                {
-                    "KeyType": "HASH",
-                    "AttributeName": "domain"
-                },
-                {
-                    "KeyType": "RANGE",
-                    "AttributeName": "access"
-                }
-            ],
-
-            # Any attributes used in KeySchema or Indexes must be declared in AttributeDefinitions
-            AttributeDefinitions=[
-                {
-                    "AttributeName": "access",
-                    "AttributeType": "S"
-                },
-                {
-                    "AttributeName": "domain",
-                    "AttributeType": "S"
-                }
-            ],
-            # ProvisionedThroughput controls the amount of data you can read or write to DynamoDB per second.
-            # You can control read and write capacity independently.
-            ProvisionedThroughput={
-                "ReadCapacityUnits": 5,
-                "WriteCapacityUnits": 5
-            },
-        )
+        _get_table().create_table(table_name)
     except Exception as e:
         logger.error(e)
     if has_table(table_name):
         logger.info(f"Table {table_name} has been created")
-        print(f"Table {table_name} has been created")
+        iou.my_output(f"Table {table_name} has been created")
 
 
 def insert_secret(domain, access, uid, pwd, info, mem_pwd, salt=None, timestamp = None):
     """Insert a secret access record in the cloud DB
     input:
     domain     the domain, i.e. logical context, of the secret
     access     the secret sub-domain or access specification
@@ -125,20 +96,45 @@
         timestamp = datetime.now().isoformat()
     if uid is None:
         uid = ""
     if pwd is None:
         pwd = ""
     if info is None:
         info = {}
-    _get_table().put_item(Item={'domain'    : domain,
-                                'access'    : access,
-                                'uid'       : encrypt(uid, mem_pwd, salt),
-                                'pwd'       : encrypt(pwd, mem_pwd, salt),
-                                'info'      : encrypt_info(info, mem_pwd, salt),
-                                'timestamp' : timestamp})
+    secret = Secret(domain = domain,
+                    access = access,
+                    user_id = uid,
+                    password = pwd,
+                    info = info)
+    _get_table().insert_record(secret, mem_pwd, salt, timestamp)
+    
+def insert_encrypted_secret(domain, access, uid, pwd, info, timestamp = None):
+    """Insert a secret access record in the cloud DB
+    input:
+    domain     the domain, i.e. logical context, of the secret
+    access     the secret sub-domain or access specification
+    uid        the encrypted user id for that access
+    pwd        the encrypted password for that access
+    info       a map of informations (encryted)
+    timestamp  the secret timestamp. If not passed it is calculated
+    """
+    if timestamp is None:
+        timestamp = datetime.now().isoformat()
+    if uid is None:
+        uid = ""
+    if pwd is None:
+        pwd = ""
+    if info is None:
+        info = {}
+    secret = Secret(domain = domain,
+                    access = access,
+                    user_id = uid,
+                    password = pwd,
+                    info = info)
+    _get_table().insert_encrypted_record(secret,timestamp)    
 
 def update_secret(domain, access, uid, pwd, info_key, info_value, mem_pwd, salt=None):
     """Update a secret access record in the cloud DB
     input:
     domain     the domain, i.e. logical context, of the secret
     access     the secret sub-domain or access specification
     uid        the user id for that access
@@ -147,306 +143,244 @@
     info_value the value for an extra info
     mem_pwd    memorable password to encrypt the secret
     salt       a string representation of the salt (optional)
     """
     if salt is None:
         salt = parameters.get_salt_key()
     timestamp = datetime.now().isoformat()
-    # #domain is the simbolyc field name and maps table column 'domain' to id #domain
-    expression_attributes = {'#domain':'domain',
-                             '#access':'access'}
-    # :domain is the symbolic value to be used in expressions for domain
-    expression_values = {':domain':domain,
-                         ':access':access}
-    update_expression = "SET"
-    condition_expression = "#domain = :domain AND #access = :access"
-
-    if uid is not None:
-        expression_attributes.update({'#uid':'uid'})
-        expression_values.update({':uid' : encrypt(uid, mem_pwd, salt)})
-        update_expression += ' #uid = :uid,'
-    if pwd is not None:
-        expression_attributes.update({'#pwd':'pwd'})
-        expression_values.update({':pwd' : encrypt(pwd, mem_pwd, salt)})
-        update_expression += ' #pwd = :pwd,'
-    if info_key is not None and info_value is not None:
-        expression_attributes.update({'#info':'info','#key':info_key})
-        expression_values.update({':info':encrypt(info_value, mem_pwd, salt)})
-        update_expression += ' #info.#key = :info,'
-    #if nothing to update then return
-    if update_expression == 'SET':
-        return
-    #now add the timestamp
-    expression_attributes.update({'#timestamp':'timestamp'})
-    expression_values.update({':ts': timestamp})
-    update_expression += ' #timestamp = :ts'
-
+    secret = Secret(domain = domain,
+                    access = access,
+                    user_id = uid,
+                    password = pwd,
+                    info_key = info_key,
+                    info_value = info_value)    
     try:
-        _get_table().update_item(Key={"domain": domain, "access": access},
-                                 ExpressionAttributeNames  = expression_attributes,
-                                 ExpressionAttributeValues = expression_values,
-                                 UpdateExpression          = update_expression,
-                                 ConditionExpression       = condition_expression
-                                 )
+        _get_table().update_record_single_info(secret, mem_pwd, salt, timestamp)
     except:
         pass #the condition failed but there should be no side effect
 
 def update_secret_info_dictionary(domain, access, enc_info):
     """Update the info dictionary of a secret
     input:
     domain     the domain, i.e. logical context, of the secret
     access     the secret sub-domain or access specification
     enc_info   the new info dictionary (encrypted) to replace the old one
     """
 
     timestamp = datetime.now().isoformat()
-    expression_attributes = {'#domain':'domain',
-                             '#access':'access',
-                             '#info': 'info',
-                             '#timestamp':'timestamp'}
-    expression_values = {':domain':domain,
-                         ':access':access,
-                         ':info': enc_info,
-                         ':ts': timestamp}
-    update_expression = "SET #info = :info, #timestamp = :ts"
-    condition_expression = "#domain = :domain AND #access = :access"
-
     try:
-        _get_table().update_item(Key={"domain": domain, "access": access},
-                                 ExpressionAttributeNames  = expression_attributes,
-                                 ExpressionAttributeValues = expression_values,
-                                 UpdateExpression          = update_expression,
-                                 ConditionExpression       = condition_expression
-                                 )
+        secret = Secret(domain = domain,
+                        access = access,
+                        encrypted_info = enc_info)
+        _get_table().update_record_info_dictionary(secret, timestamp)
     except:
         pass #the condition failed but there should be no side effect
 
 
 def rename_secret(domain, access, new_domain, new_access):
     """Rename the domain and access of a secret
     input:
     domain     the domain, i.e. logical context, of the secret
     access     the secret sub-domain or access specification
     new_domain the new value for the domain
     new_access the new value for the access
     """
     table = _get_table()
-    resp = table.get_item(Key={'domain'  :domain,
-                               'access'  : access})
-    if 'Item' in resp and len(resp['Item'])>0:
+    filter_secret = Secret(domain = domain, access = access)
+    old_secret = table.get_record(filter_secret)
+    if old_secret is not None:
         try:
-            item = resp['Item']
-            table.put_item(Item={'domain'    : new_domain,
-                                 'access'    : new_access,
-                                 'uid'       : item['uid'],
-                                 'pwd'       : item['pwd'],
-                                 'info'      : item['info'],
-                                 'timestamp' : datetime.now().isoformat()})
-
-            table.delete_item(Key={'domain'  : domain,
-                                   'access'  : access})
+            new_secret = Secret(domain = new_domain,
+                                access = new_access,
+                                user_id = old_secret.user_id,
+                                password = old_secret.password,
+                                info = old_secret.info)
+            table.insert_encrypted_record(new_secret, datetime.now().isoformat())
+            table.delete_record(filter_secret)
         except Exception as e:
             iou.my_output(e)
     else:
         iou.my_output(f"Could not find secret ({domain},{access})")
 
 def has_secret(domain, access):
     """Checks the existence of a secret
     input:
     domain     the domain, i.e. logical context, of the secret
     access     the secret sub-domain or access specification
     """
-    resp = _get_table().get_item(Key={'domain'  :domain,
-                                      'access'  : access})
-    return 'Item' in resp and len(resp['Item'])>0
+    filter_secret = Secret(domain = domain, access = access)
+    secret = _get_table().get_record(filter_secret)
+    return secret is not None
 
 def delete_secret(domain, access):
     """Delete a secret by primary key.
     input:
     domain     the domain, i.e. logical context, of the secret
     access     the secret sub-domain or access specification
     """
-    _get_table().delete_item(Key={'domain'  : domain,
-                                  'access'  : access})
+    filter_secret = Secret(domain = domain, access = access)
+    _get_table().delete_record(filter_secret)
 
 def delete_secrets(secrets):
     """Deletes all secrets passed as list of (domain, access) pairs
     input:
-    secrets    a list of secrets, as domain, asset pairs
+    secrets    a list of secrets, as Secret objects
     """
     for s in secrets:
-        delete_secret(s[0], s[1])
+        delete_secret(s.domain, s.access)
 
-def get_secret(domain, access, mem_pwd, salt=None, need_decrypt=True):
+def get_secret(domain, access, mem_pwd=None, salt=None, needs_decrypt=True):
     """Retrieves a secret by primary key
     input:
     domain          the domain, i.e. logical context, of the secret
     access          the secret sub-domain or access specification
     mem_pwd         memorable password to encrypt the secret
     salt            a string representation of the salt (optional)
     need_decrypt    a flag to indicate if decryption is required (default True)
     output:
-    returns the decrypted secret
+    returns the decrypted secret as a dictionary
     """
     if salt is None:
         salt = parameters.get_salt_key()
 
-    resp = _get_table().get_item(Key={'domain'  :domain,
-                                      'access'  : access})
-    ret = resp['Item']
-    if not need_decrypt:
-        return ret
-
-    if 'uid' in ret and ret['uid'] is not None and 'pwd' in ret and ret['pwd'] is not None:
-        ret['uid'] = decrypt(ret['uid'], mem_pwd, salt)
-        ret['pwd'] = decrypt(ret['pwd'], mem_pwd, salt)
-    if 'info' in ret and ret['info'] is not None:
-        ret['info'] = decrypt_info(ret['info'], mem_pwd, salt)
-    return ret
+    filter_secret = Secret(domain = domain, access = access)
+    secret = _get_table().get_record(filter_secret)
+    if needs_decrypt:
+        return decrypt_secret(secret, mem_pwd, salt)
+    else:
+        return secret
+
 
 def list_secrets(domain):
     """List all secrets by domain
     input:
     domain    the domain of the secrets. If null all records are returned
     output:
-    a list of (domain, access) tuples
+    a list of Secret objects
     """
-    secrets = []
-    if domain is not None:
-        resp = _get_table().query(KeyConditionExpression=Key('domain').eq(domain))
-    else:
-        resp = _get_table().scan()
-    for i in resp['Items']:
-        secrets.append((i['domain'],i['access']))
-    #sort the list
-    secrets.sort(key=lambda x: x[0]+x[1])
+    filter_secret = Secret(domain=domain)
+    return _get_table().query_record(filter_secret)
 
-    return secrets
-
-def get_all_secrets(mem_pwd):
-    """Get all secrets and return them as a list of disctionaries
+def get_all_secrets(mem_pwd=None, as_dictionary=True, needs_decrypt = True):
+    """Get all secrets and return them as a list of dictionaries or secret objects
     input:
-    mem_pwd    the memorable password
+    mem_pwd        the memorable password
+    as_dictionary  a flag to select the type ot representation: dictionary or Secret
+    needs_decrypt  a flag indicatinf that the returned secrets should be decrypted
     output:
-    a list of secrets (each secret is a dictionary)
+    a list of secrets as dictionaries or secret objects depending on the flag passed
     """
     secrets = []
     for s in list_secrets(None):
-        secrets.append(get_secret(s[0], s[1], mem_pwd))
+        if as_dictionary:
+            secret = get_secret(s.domain, s.access, mem_pwd, None, needs_decrypt) #decrypted
+            secrets.append(secret_to_dictionary(secret, needs_decrypt=False))
+        else:
+            secrets.append(get_secret(s.domain, s.access, mem_pwd, None, needs_decrypt)) #decrypted
     return secrets
 
 def query_secrets_by_field(domain_sub, access_sub):
     """Query all secrets with domain and access containing the domain or access substrings
     input:
     domain_sub  the substring to be looked for in the domain keys
     access_sub  the substring to be looked for in the access keys
     output:
-    a list of (domain, access) tuples
+    a list of Secret objects
     """
     secrets = list_secrets(None)
-    filter_secrets = lambda s:(domain_sub is None or domain_sub.lower() in s[0].lower())\
+    filter_secrets = lambda s:(domain_sub is None or domain_sub.lower() in s.domain.lower())\
                                and\
-                               (access_sub is None or access_sub.lower() in s[1].lower())
+                               (access_sub is None or access_sub.lower() in s.access.lower())
     return [s for s in secrets if filter_secrets(s)]
 
 def query_secrets_by_pattern(pattern):
     """Query all secrets with domain or access containing the pattern substrings
     input:
     pattern  the substring to be looked for in the domain or access field
     output:
-    a list of (domain, access) tuples
+    a list of Secret objects
     """
     secrets = list_secrets(None)
     lpt = pattern.lower()
-    filter_secrets = lambda s: pattern is None or lpt in s[0].lower() or lpt in s[1].lower()
+    filter_secrets = lambda s: pattern is None or lpt in s.domain.lower() or lpt in s.access.lower()
 
     return [s for s in secrets if filter_secrets(s)]
 
 def reconf_memorable(secrets, old_mem, new_mem, backup=False):
     """Reconfigure all secrets changing the memorable password
     input:
-    secrets    a list of secrets, as domain, asset pairs
+    secrets    a list of Secret objects
     old_mem    old memorable password
     new_mem    new memorable password
     backup     a boolean flag to request a full baclup of the table
     output:
     the BackupArn of the table
     """
     arn = None
     ns = len(secrets)
     i = 0
     if backup:
-        arn =_backup_table("backup")
+        arn = _get_table().backup_table("backup")
     for s in secrets:
         i+=1
-        domain = s[0]
-        access = s[1]
+        domain = s.domain
+        access = s.access
         try:
             message = f"[{i}/{ns}] - Reconfiguring the secret ({domain},{access})"
             logger.info(message)
-            print(message)
+            iou.my_output(message)
             secret = get_secret(domain, access, old_mem)
-            insert_secret("I", f"{domain}{SEPARATOR}{access}", secret['uid'],  secret['pwd'],  secret['info'], new_mem)
+            insert_secret("I", f"{domain}{SEPARATOR}{access}", secret.user_id,  secret.password,  secret.info, new_mem)
             rename_secret(domain, access, "D", f"{domain}{SEPARATOR}{access}")
             rename_secret("I", f"{domain}{SEPARATOR}{access}", domain, access)
             delete_secret("D", f"{domain}{SEPARATOR}{access}")
         except Exception as e:
             logger.error(e)
             message = f"Could not reconfigure ({domain},{access})"
-            print(message)
+            iou.my_output(message)
             logger.error(message)
     return arn
 
 def reconf_salt_key(secrets, old_mem, new_device_pwd, backup=False):
     """Reconfigure all secrets changing the memorable password
     input:
-    secrets         a list of secrets, as domain, asset pairs
+    secrets         a list of Secret objects
     old_mem         old memorable password
     new_device_pwd  the new device password
     backup          a boolean flag to request a full baclup of the table
     output:
     the BackupArn of the table
     """
     ekey = encrypt_key(new_device_pwd)
     ns = len(secrets)
     i = 0
     arn = None
     if backup:
         arn =_backup_table("backup")
     for s in secrets:
         i += 1
-        domain = s[0]
-        access = s[1]
+        domain = s.domain
+        access = s.access
         try:
             message = f"[{i}/{ns}] - Reconfiguring the secret ({domain},{access})"
             logger.info(message)
-            print(message)
+            iou.my_output(message)
             secret = get_secret(domain, access, old_mem)
-            insert_secret("I", f"{domain}{SEPARATOR}{access}", secret['uid'],  secret['pwd'],  secret['info'], old_mem, ekey)
+            insert_secret("I", f"{domain}{SEPARATOR}{access}", secret.user_id,  secret.password,  secret.info, old_mem, ekey)
             rename_secret(domain, access, "D", f"{domain}{SEPARATOR}{access}")
             rename_secret("I", f"{domain}{SEPARATOR}{access}", domain, access)
             delete_secret("D", f"{domain}{SEPARATOR}{access}")
         except Exception as e:
             logger.error(e)
             message = f"Could not reconfigure ({domain},{access})"
-            print(message)
+            iou.my_output(message)
             logger.error(message)
 
     return arn
 
 
 def count_secrets():
     """Returns the total number of secrets"""
-    return _get_table().scan(Select='COUNT')['Count']
+    filter_secret = Secret()
+    return len(_get_table().query_record(filter_secret))
 
-def encrypt_info(info,mem_pwd, salt):
-    einfo = {}
-    for key, value in info.items():
-        einfo[key] = encrypt(value, mem_pwd, salt) #in string format
-    return einfo
-
-def decrypt_info(info, mem_pwd, salt):
-    dinfo = {}
-    for key, value in info.items():
-        dinfo[key] = decrypt(value, mem_pwd, salt) #from string format
-    return dinfo
```

## secretwallet/utils/ioutils.py

```diff
@@ -4,34 +4,34 @@
 from secretwallet.utils.logging import get_logger
 
 
 logger = get_logger(__name__, parameters.get_log_level())
 parameters.register_logger(__name__, logger)
 
 def display_list(message, secrets):
-    field_lenght = max([len(x[0]) for x in secrets], default=0)+5
+    field_lenght = max([len(x.domain) for x in secrets], default=0)+5
     format_header = f"<%-{field_lenght-1}s: <access>"
     format_record = f"%-{field_lenght}s: %s"
     print("**********************************************************")
     print(f"{message}: ")
     print(format_header%'domain>')
-    for d,a in secrets:
-        print(format_record%(d,a))
+    for s in secrets:
+        print(format_record%(s.domain,s.access))
     print("**********************************************************")
 
 def display_numbered_list(message, secrets):
     field_lenght = max([len(x[0]) for x in secrets], default=0)+5
     format_header = f"%-7s: <%-{field_lenght-1}s: <access>"
     format_record = f"%-7d: %-{field_lenght}s: %s"
     print("**********************************************************")
     print(f"{message}: ")
     print(format_header%('<num>','domain>'))
     idx = 1;
-    for d,a in secrets:
-        print(format_record%(idx, d, a))
+    for s in secrets:
+        print(format_record%(idx, s.domain, s.access))
         idx += 1
     print("**********************************************************")
 
 def get_secret_by_idx(message, secrets):
     display_numbered_list(message, secrets)
     while True:
         answ = my_input("\nWhich secret? Type the index number in the list above or 0 to quit:  ")
@@ -134,23 +134,23 @@
         exit(1)
 
 
 def display_secret(secret):
     "Print a secret in a fixed format"
     print("**********************************************************")
     print("Secret id:")
-    print(f"domain              : {secret['domain']}")
-    print(f"access              : {secret['access']}")
+    print(f"domain              : {secret.domain}")
+    print(f"access              : {secret.access}")
     print("\nSecret credentials:")
-    print(f"login               : {secret['uid']}")
-    print(f"password            : {secret['pwd']}")
-    if 'info' in secret:
+    print(f"login               : {secret.user_id}")
+    print(f"password            : {secret.password}")
+    if secret.info is not None:
         print("\nSecret extra info:")
-        for k,v in secret['info'].items():
+        for k,v in secret.info.items():
             print(f"{k:20}: {v}")
-    print(f"\nLast updated        : {secret['timestamp']}")
+    print(f"\nLast updated        : {secret.timestamp}")
     print("**********************************************************")
 
 def display_all_secrets(secrets):
     "Return a text representation of all the secrets in a readable format"
     for secret in secrets:
         display_secret(secret)
```

## tests/__init__.py

```diff
@@ -1,10 +1,12 @@
 import os
 
 from secretwallet.constants import parameters
 from secretwallet.main.configuration import get_configuration
+import secretwallet.utils.dbutils as du
 
 
 path = os.path.dirname(__file__)
 conf_file = os.path.join(path,'data','test_integration.json')
 conf_data = get_configuration(conf_file)
 parameters.set_data(conf_data)
+du.create_table(parameters.get_table_name())
```

## tests/cli_test.py

```diff
@@ -11,14 +11,15 @@
 from secretwallet.main.myparser import Parser
 from secretwallet.session.client import is_connected, stop_service
 from secretwallet.session.service import my_session
 
 import secretwallet.utils.cryptutils as cu
 import secretwallet.utils.dbutils as du
 import secretwallet.utils.ioutils as iou
+from build.lib.secretwallet.utils.cryptutils import decrypt
 
 
 DOMAIN = 'test_domain'
 ACCESS = 'test_access'
 UID    = 'me@HOME'
 PWD    = 'pass'
 INFO   = {'key':'value'}
@@ -41,14 +42,15 @@
     if is_connected():
         stop_service()
     p =Process(target=my_session, args =(MEM, LIFETIME, TIMEOUT))
     p.start()
     while not is_connected():
         pass
 
+    du.create_table(parameters.get_table_name())
     du.insert_secret(DOMAIN, ACCESS, UID, PWD, INFO, MEM)
 
 
     yield
 
     iou.my_input = old_input
     iou.my_output = old_output
@@ -121,18 +123,18 @@
 @pytest.mark.integration
 def test_update_info(cli_test_set_up):
     sys.argv=['secret_wallet','set','-d',DOMAIN, '-a', ACCESS, '-ik','first_key','-iv','first_value']
     Parser()
     sys.argv=['secret_wallet','set','-d',DOMAIN, '-a', ACCESS, '-ik','second_key','-iv','second_value']
     Parser()
     res = du.get_secret(DOMAIN, ACCESS, 'memorable', parameters.get_salt_key())
-    assert 3 == len(res['info'])
-    assert 'value' == res['info']['key']
-    assert 'first_value' == res['info']['first_key']
-    assert 'second_value' == res['info']['second_key']
+    assert 3 == len(res.info)
+    assert 'value' == res.info['key']
+    assert 'first_value' == res.info['first_key']
+    assert 'second_value' == res.info['second_key']
 
 @pytest.mark.integration
 def test_rename_secret(cli_test_set_up):
     new_domain = "new domain_01"
     new_access = "new_access_01"
 
     #delete first
@@ -527,15 +529,15 @@
             assert "first record" in data
             assert "second record" in data
 
     finally:
         os.remove(path)
 
 @pytest.mark.integration
-def test_save(cli_test_set_up):
+def test_save_decrypted(cli_test_set_up):
     domain1 = 'pera'
     access1 = "cotta"
     domain2 = 'bella'
     access2 = 'pera'
 
     #delete first
     du.delete_secret(domain1, access1)
@@ -544,22 +546,22 @@
     sys.argv=['secret_wallet','set','-d',domain1, '-a', access1, '-ik', 'idx', '-iv','second record']
     Parser()
     sys.argv=['secret_wallet','set','-d',domain2, '-a', access2, '-ik', 'idx', '-iv','first record']
     Parser()
     assert du.has_secret(domain1, access1)
     assert du.has_secret(domain2, access2)
 
-    sys.argv=['secret_wallet','save']
+    sys.argv=['secret_wallet','save','-d']
     with io.StringIO() as buf, redirect_stdout(buf):
         Parser()
         assert "first record" in buf.getvalue() #get the inner value in the secret
         assert "second record" in buf.getvalue()
 
 @pytest.mark.integration
-def test_save_to_file(cli_test_set_up):
+def test_save_to_file_decrypted(cli_test_set_up):
     path = "test_dump_to_file.json"
 
     # first clean up the file if it exists
     if os.path.exists(path):
         os.remove(path)
 
     #the set the data
@@ -577,15 +579,15 @@
     sys.argv=['secret_wallet','set','-d',domain2, '-a', access2, '-ik', 'idx', '-iv','second record']
     Parser()
     assert du.has_secret(domain1, access1)
     assert du.has_secret(domain2, access2)
 
     #now do the test
     try:
-        sys.argv=['secret_wallet','save','-f', path]
+        sys.argv=['secret_wallet','save','-f', path,'-d']
         Parser()
 
         #now assert the file exists
         assert os.path.exists(path)
 
         #and that it contains the data
         with open(path) as f:
@@ -595,15 +597,15 @@
             assert "first record" == first_record["info"]["idx"]
             assert "second record" == second_record["info"]["idx"]
 
     finally:
         os.remove(path)
 
 @pytest.mark.integration
-def test_load_from_file(cli_test_set_up):
+def test_load_from_file_decrypted(cli_test_set_up):
     path = "test_backup_file.json"
 
     # first clean up the file if it exists
     if os.path.exists(path):
         os.remove(path)
 
     #all the pre-existing secrets
@@ -632,25 +634,171 @@
     assert du.has_secret(domain2, access2)
     assert 2 == len(du.list_secrets(None)) #there should be two secrets
     s1a = du.get_secret(domain1, access1, MEM)
     s2a = du.get_secret(domain2, access2, MEM)
 
     #now save to a file
     try:
-        sys.argv=['secret_wallet','save','-f', path]
+        sys.argv=['secret_wallet','save','-f', path,'-d']
         Parser()
 
         #now assert the file exists
         assert os.path.exists(path)
 
         #now clean-up the secrets again
         du.delete_secrets(du.list_secrets(None))
         assert 0 == len(du.list_secrets(None))
 
         #and reload from file
+        sys.argv=['secret_wallet','load','-f', path, '-d']
+        Parser()
+
+        assert du.has_secret(domain1, access1)
+        assert du.has_secret(domain2, access2)
+        assert 2 == len(du.list_secrets(None)) #there should be two secrets  again
+        s1b = du.get_secret(domain1, access1, MEM)
+        s2b = du.get_secret(domain2, access2, MEM)
+        assert s1a == s1b
+        assert s2a == s2b
+
+        #now try to reload the file without cleaning the table,
+        #it should still work without side effects
+        sys.argv=['secret_wallet','load','-f', path,'-d']
+        Parser()
+
+        assert du.has_secret(domain1, access1)
+        assert du.has_secret(domain2, access2)
+        assert 2 == len(du.list_secrets(None)) #there should be two secrets  again
+        s1b = du.get_secret(domain1, access1, MEM)
+        s2b = du.get_secret(domain2, access2, MEM)
+        assert s1a == s1b
+        assert s2a == s2b
+
+    finally:
+        os.remove(path)
+
+@pytest.mark.integration
+def test_save_encrypted(cli_test_set_up):
+    domain1 = 'pera'
+    access1 = "cotta"
+    domain2 = 'bella'
+    access2 = 'pera'
+
+    #delete first
+    du.delete_secret(domain1, access1)
+    du.delete_secret(domain2, access2)
+    #then set
+    sys.argv=['secret_wallet','set','-d',domain1, '-a', access1, '-ik', 'idx', '-iv','second record']
+    Parser()
+    sys.argv=['secret_wallet','set','-d',domain2, '-a', access2, '-ik', 'idx', '-iv','first record']
+    Parser()
+    assert du.has_secret(domain1, access1)
+    assert du.has_secret(domain2, access2)
+
+    sys.argv=['secret_wallet','save'] #without the -d option it is encrypted
+    with io.StringIO() as buf, redirect_stdout(buf):
+        Parser()
+        assert 'pera' in buf.getvalue() #this should be in clear
+        assert 'idx' in buf.getvalue() #this should be in clear
+        assert "first record" not in buf.getvalue() #this should be encrypted
+        assert "second record" not in buf.getvalue()
+        
+@pytest.mark.integration
+def test_save_to_file_encrypted(cli_test_set_up):
+    path = "test_dump_to_file.json"
+
+    # first clean up the file if it exists
+    if os.path.exists(path):
+        os.remove(path)
+
+    #the set the data
+    domain1 = 'pera'
+    access1 = "cotta"
+    domain2 = 'bella'
+    access2 = 'pera'
+
+    #delete first
+    du.delete_secret(domain1, access1)
+    du.delete_secret(domain2, access2)
+    #then set
+    sys.argv=['secret_wallet','set','-d',domain1, '-a', access1, '-ik', 'idx', '-iv','first record']
+    Parser()
+    sys.argv=['secret_wallet','set','-d',domain2, '-a', access2, '-ik', 'idx', '-iv','second record']
+    Parser()
+    assert du.has_secret(domain1, access1)
+    assert du.has_secret(domain2, access2)
+
+    #now do the test
+    try:
+        sys.argv=['secret_wallet','save','-f', path]
+        Parser()
+
+        #now assert the file exists
+        assert os.path.exists(path)
+
+        #and that it contains the data
+        with open(path) as f:
+            data = json.load(f)
+            first_record = [x for x in data if x["domain"]==domain1 and x["access"]==access1][0]
+            second_record = [x for x in data if x["domain"]==domain2 and x["access"]==access2][0]
+            assert "first record"  == decrypt(first_record["info"]["idx"],MEM,parameters.get_salt_key())
+            assert "second record" == decrypt(second_record["info"]["idx"],MEM,parameters.get_salt_key())
+
+    finally:
+        os.remove(path)
+        
+@pytest.mark.integration
+def test_load_from_file_encrypted(cli_test_set_up):
+    path = "test_backup_file.json"
+
+    # first clean up the file if it exists
+    if os.path.exists(path):
+        os.remove(path)
+
+    #all the pre-existing secrets
+    secrets = du.list_secrets(None)
+    #clean-up
+    du.delete_secrets(secrets)
+    secrets = du.list_secrets(None)
+    assert 0 == len(secrets)
+
+    #now add some secrets
+
+    #set the data
+    domain1 = 'pera'
+    access1 = "cotta"
+    domain2 = 'bella'
+    access2 = 'pera'
+
+    #set the secrets
+    sys.argv=['secret_wallet','set','-d',domain1, '-a', access1, '-ik', 'idx', '-iv','first record']
+    Parser()
+    sys.argv=['secret_wallet','set','-d',domain2, '-a', access2, '-ik', 'idx', '-iv','second record']
+    Parser()
+
+    #check the status now
+    assert du.has_secret(domain1, access1)
+    assert du.has_secret(domain2, access2)
+    assert 2 == len(du.list_secrets(None)) #there should be two secrets
+    s1a = du.get_secret(domain1, access1, MEM)
+    s2a = du.get_secret(domain2, access2, MEM)
+
+    #now save to a file
+    try:
+        sys.argv=['secret_wallet','save','-f', path]
+        Parser()
+
+        #now assert the file exists
+        assert os.path.exists(path)
+
+        #now clean-up the secrets again
+        du.delete_secrets(du.list_secrets(None))
+        assert 0 == len(du.list_secrets(None))
+
+        #and reload from the encrypted file
         sys.argv=['secret_wallet','load','-f', path]
         Parser()
 
         assert du.has_secret(domain1, access1)
         assert du.has_secret(domain2, access2)
         assert 2 == len(du.list_secrets(None)) #there should be two secrets  again
         s1b = du.get_secret(domain1, access1, MEM)
@@ -669,8 +817,8 @@
         s1b = du.get_secret(domain1, access1, MEM)
         s2b = du.get_secret(domain2, access2, MEM)
         assert s1a == s1b
         assert s2a == s2b
 
     finally:
         os.remove(path)
-
+
```

## tests/cryptuils_test.py

```diff
@@ -9,22 +9,24 @@
 import secretwallet.utils.cryptutils as cu 
 from secretwallet.main.configuration import set_configuration, get_configuration
 from secretwallet.utils.cryptutils import encrypt_key
 from secretwallet.constants import parameters
 
 @pytest.fixture
 def set_up():
+    old_data = parameters.get_data()
     path = os.path.dirname(__file__)
     conf_file = os.path.join(path,'data','.secretwallet','test.json')
     yield conf_file
     
     if os.path.exists(conf_file):
         os.remove(conf_file)
         os.rmdir(os.path.dirname(conf_file))
-    parameters.clear()
+    #reset the original parameters
+    parameters.set_data(old_data)
     
         
 def test_get_encrypted_key():
     passwd = u"passwd"
     ekey = cu.encrypt_key(passwd)
     assert ekey is not None 
     assert isinstance(ekey, str) 
@@ -79,8 +81,19 @@
     secret = u"mamma"
     key = cu.encrypt_key(c_pwd)    
     esecret = cu.encrypt(secret, m_pwd, key)
     v1 = cu.decrypt(esecret, m_pwd, key)
     esecret2 = cu.encrypt(secret, m_pwd, key)
     v2 = cu.decrypt(esecret2, m_pwd, key)
     assert v1 == v2
-    assert v1 == secret        
+    assert v1 == secret
+    
+def test_encrypt_decrypt_info():
+    c_pwd = u"passwd"
+    m_pwd = u"memorabile"
+    key = cu.encrypt_key(c_pwd)
+
+    info={'first':'value_1','second':'value_2'}
+    ien = cu.encrypt_info(info, m_pwd, key)
+    ide = cu.decrypt_info(ien, m_pwd, key)
+    for key in info:
+        assert ide[key] == info[key]
```

## tests/dbutils_test.py

```diff
@@ -1,26 +1,13 @@
 import cryptography
 import pytest
 from secretwallet.constants import parameters
 
 import secretwallet.utils.cryptutils as cu
 import secretwallet.utils.dbutils as du 
-
-
-@pytest.fixture
-def set_up():
-    c_pwd = u"passwd"
-    table_name = "test" 
-    key = cu.encrypt_key(c_pwd)
-    parameters.set_salt_key(key)
-    parameters.set_table_name(table_name)
-    du.create_table(table_name)
-    yield 
-    
-    parameters.clear()
     
 @pytest.fixture
 def insert_records():
     m_pwd = 'memorable'
     du.insert_secret("d1", "a1", "u1", "p1", {"k1":"v1","k2":"v2"}, m_pwd)
     du.insert_secret("d1", "a2", "u2", "p2", {"k3":"v3"}, m_pwd)
     du.insert_secret("d2", "a3", "u3", "p3", {"k4":"v4"}, m_pwd)
@@ -33,282 +20,272 @@
 def cleanup_backups():
     pass
     yield
     
     du._cleanup_table_backups('backup')
     
 
-def test_insert_delete_login(set_up):
+def test_insert_delete_login():
     m_pwd = u"memorabile"
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     domain = u"my_domain" 
     access = u"my_access"
     ns = du.count_secrets()    
     try:        
         du.insert_secret(domain, access, secret_uid, secret_pwd, None, m_pwd, parameters.get_salt_key())
         assert ns+1 == du.count_secrets()
     finally:
         du.delete_secret(domain, access)
         assert ns == du.count_secrets()
         
-def test_wrong_salt_key(set_up):
+def test_wrong_salt_key():
     c_pwd = 'pirillo'
     wrong_key = cu.encrypt_key(c_pwd)
     m_pwd = u"memorabile"
     domain = u"my_domain" 
     access = u"my_access"    
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     try:        
         du.insert_secret(domain, access, secret_uid, secret_pwd, None, m_pwd, wrong_key)
         with pytest.raises(cryptography.fernet.InvalidToken):
             du.get_secret(domain, access, m_pwd)
     finally:
         du.delete_secret(domain, access)
         
-def test_wrong_memorable(set_up):
+def test_wrong_memorable():
     m_pwd = u"memorabile"
     domain = u"my_domain" 
     access = u"my_access"    
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     try:        
         du.insert_secret(domain, access, secret_uid, secret_pwd, None, m_pwd)
         with pytest.raises(cryptography.fernet.InvalidToken):
             du.get_secret(domain, access, 'pirillo')
     finally:
         du.delete_secret(domain, access)                
         
-def test_insert_select_compare_login(set_up):
+def test_insert_select_compare_login():
     m_pwd = u"memorabile"
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     domain = u"my_domain" 
     access = u"my_access"
     try:        
         du.insert_secret(domain, access, secret_uid, secret_pwd, None, m_pwd, parameters.get_salt_key())
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
-        assert secret_uid == res['uid']
-        assert secret_pwd == res['pwd']
+        assert secret_uid == res.user_id
+        assert secret_pwd == res.password
     finally:
         du.delete_secret(domain, access)
 
 @pytest.mark.integration        
-def test_insert_select_compare_info(set_up):
+def test_insert_select_compare_info():
     m_pwd = u"memorabile"
     secret_info = {'message':'secret'}
     domain = u"my_domain" 
     access = u"my_access"
     try:        
         du.insert_secret(domain, access, None, None, secret_info, m_pwd, parameters.get_salt_key())
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
-        assert secret_info['message'] == res['info']['message']
+        assert secret_info['message'] == res.info['message']
     finally:
         du.delete_secret(domain, access)        
 
 @pytest.mark.integration        
-def test_has_secret(set_up):
+def test_has_secret():
     m_pwd = u"memorabile"
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     domain = u"my_domain" 
     access = u"my_access"    
     try:        
         du.insert_secret(domain, access, secret_uid, secret_pwd, None, m_pwd, parameters.get_salt_key())
         assert du.has_secret(domain, access)
     finally:
         du.delete_secret(domain, access)
 
 @pytest.mark.integration        
-def test_has_not_secret(set_up):
+def test_has_not_secret():
     m_pwd = u"memorabile"
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     domain = u"my_domain" 
     access = u"my_access"    
     try:        
         du.insert_secret(domain, access, secret_uid, secret_pwd, None, m_pwd, parameters.get_salt_key())
         assert not du.has_secret('new_domain', access)
     finally:
         du.delete_secret(domain, access)
 
 @pytest.mark.integration        
-def test_update_secret_login(set_up):
+def test_update_secret_login():
     m_pwd = u"memorabile"
     secret_uid = u"me@home"
     secret_uid2 = u"me@office"
     secret_pwd = u"ciao mamma"
     domain = u"my_domain" 
     access = u"my_access"    
     try:        
         ns = du.count_secrets()
         du.insert_secret(domain, access, secret_uid, secret_pwd, None, m_pwd, parameters.get_salt_key())
         assert ns+1 == du.count_secrets()
         assert du.has_secret(domain, access)
-        old_ts = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())['timestamp']
+        old_ts = du.get_secret(domain, access, m_pwd, parameters.get_salt_key()).timestamp
         
         du.update_secret(domain, access, secret_uid2, None, None, None, m_pwd, parameters.get_salt_key())
         
         assert ns+1 == du.count_secrets() #no change to the number of secrets
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
-        assert secret_uid2 == res['uid']
-        assert secret_pwd == res['pwd'] 
-        assert old_ts <  res['timestamp']            
+        assert secret_uid2 == res.user_id
+        assert secret_pwd == res.password 
+        assert old_ts <  res.timestamp            
     finally:
         du.delete_secret(domain, access)
 
 @pytest.mark.integration        
-def test_update_secret_info_change_value(set_up):
+def test_update_secret_info_change_value():
     m_pwd = u"memorabile"
     domain = u"my_domain" 
     access = u"my_access" 
     secret_info = {'message':'secret'}
     info_key = 'message'
     info_val = 'a new secret'   
     try:        
         du.insert_secret(domain, access, None, None, secret_info, m_pwd, parameters.get_salt_key())
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
-        old_ts = res['timestamp']
-        assert 'secret' == res['info'][info_key]
+        old_ts = res.timestamp
+        assert 'secret' == res.info[info_key]
         
         du.update_secret(domain, access, None, None, info_key, info_val, m_pwd, parameters.get_salt_key())
         
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
-        assert info_val == res['info'][info_key] 
-        assert old_ts <  res['timestamp']            
+        assert info_val == res.info[info_key] 
+        assert old_ts <  res.timestamp            
     finally:
         du.delete_secret(domain, access)
         
 @pytest.mark.integration        
-def test_update_secret_info_insert_value(set_up):
+def test_update_secret_info_insert_value():
     m_pwd = u"memorabile"
     domain = u"my_domain" 
     access = u"my_access" 
     secret_info = {'message':'secret'}
     info_key = 'a new message'
     info_val = 'a new secret'   
     try:        
         du.insert_secret(domain, access, None, None, secret_info, m_pwd, parameters.get_salt_key())
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
-        old_ts = res['timestamp']
-        assert 1 == len(res['info'])
+        old_ts = res.timestamp
+        assert 1 == len(res.info)
         
         du.update_secret(domain, access, None, None, info_key, info_val, m_pwd, parameters.get_salt_key())
         
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
-        assert 2 == len(res['info'])
-        assert info_val == res['info'][info_key]
-        assert 'secret' == res['info']['message'] 
-        assert old_ts <  res['timestamp']            
+        assert 2 == len(res.info)
+        assert info_val == res.info[info_key]
+        assert 'secret' == res.info['message'] 
+        assert old_ts <  res.timestamp            
     finally:
         du.delete_secret(domain, access)
         
 @pytest.mark.integration        
-def test_update_secret_info_change_password_and_a_value(set_up):
+def test_update_secret_info_change_password_and_a_value():
     m_pwd = u"memorabile"
     domain = u"my_domain" 
     access = u"my_access" 
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     secret_pwd2 = u"another password"    
     secret_info = {'message':'secret'}
     info_key = 'message'
     info_val = 'a new secret'   
     try:        
         du.insert_secret(domain, access, secret_uid, secret_pwd, secret_info, m_pwd, parameters.get_salt_key())
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
-        old_ts = res['timestamp']
-        assert 'secret' == res['info'][info_key]
-        assert secret_pwd == res['pwd'] 
+        old_ts = res.timestamp
+        assert 'secret' == res.info[info_key]
+        assert secret_pwd == res.password 
         
         du.update_secret(domain, access, None, secret_pwd2, info_key, info_val, m_pwd, parameters.get_salt_key())
         
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
-        assert info_val == res['info'][info_key] 
-        assert secret_pwd2 == res['pwd']
-        assert old_ts <  res['timestamp']            
+        assert info_val == res.info[info_key] 
+        assert secret_pwd2 == res.password
+        assert old_ts <  res.timestamp            
     finally:
         du.delete_secret(domain, access)
         
 @pytest.mark.integration        
-def test_update_missing_secret_no_effect(set_up):
+def test_update_missing_secret_no_effect():
     m_pwd = u"memorabile"
     domain = u"my_domain" 
     access = u"my_access"
     access2 = u"my_second access" 
     secret_uid = u"me@home"
     secret_pwd = u"ciao mamma"
     secret_pwd2 = u"my second password"    
     secret_info = {'message':'secret'}
     try:
         ns = du.count_secrets()
         du.insert_secret(domain, access, secret_uid, secret_pwd, secret_info, m_pwd, parameters.get_salt_key())
         assert ns + 1 == du.count_secrets()
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
-        old_ts = res['timestamp']
-        assert 'secret' == res['info']['message']
-        assert secret_pwd == res['pwd']
-        assert secret_uid ==  res['uid']
+        old_ts = res.timestamp
+        assert 'secret' == res.info['message']
+        assert secret_pwd == res.password
+        assert secret_uid ==  res.user_id
         
         du.update_secret(domain, access2, None, secret_pwd2, None, None, m_pwd, parameters.get_salt_key())
         
         assert ns + 1 == du.count_secrets()
         res = du.get_secret(domain, access, m_pwd, parameters.get_salt_key())
-        assert old_ts ==  res['timestamp']            
+        assert old_ts ==  res.timestamp            
     finally:
         du.delete_secret(domain, access)
         
 @pytest.mark.integration        
-def test_update_info_dict_remove_key(set_up):
+def test_update_info_dict_remove_key():
     m_pwd = u"memorabile"
     domain = u"my_domain" 
     access = u"my_access" 
     secret_info = {'key1': 'value1',
                    'key2': 'value2'}
     salt = parameters.get_salt_key()
     try:
         ns = du.count_secrets()
         du.insert_secret(domain, access, None, None, secret_info, m_pwd, parameters.get_salt_key())
         assert ns + 1 == du.count_secrets()
         res = du.get_secret(domain, access, m_pwd, salt, False) #no decryption of secret
-        old_ts = res['timestamp']
-        info = res['info']
+        old_ts = res.timestamp
+        info = res.info
         assert 2 == len(info)
         
         del info['key2'] #remove one entry
         du.update_secret_info_dictionary(domain, access, info)
         res = du.get_secret(domain, access, m_pwd, salt)
-        ts = res['timestamp']
-        info = res['info']
+        ts = res.timestamp
+        info = res.info
         assert 1 == len(info)
         assert 'value1' == info['key1']
         assert ts != old_ts
         
     finally:
         du.delete_secret(domain, access)        
         
         
 @pytest.mark.integration        
-def test_has_table(set_up):
+def test_has_table():
     assert True  == du.has_table(parameters.get_table_name())
     assert False == du.has_table('new_table')
     
-def test_encrypt_decrypt_info():
-    c_pwd = u"passwd"
-    m_pwd = u"memorabile"
-    key = cu.encrypt_key(c_pwd)
-
-    info={'first':'value_1','second':'value_2'}
-    ien = du.encrypt_info(info, m_pwd, key)
-    ide = du.decrypt_info(ien, m_pwd, key)
-    for key in info:
-        assert ide[key] == info[key]
     
-def test_delete_secrets(set_up):
+def test_delete_secrets():
     m_pwd = u"memorabile"
     domain = u"my_domain"  
     info = {'message':'secret'}
     #cleanup
     du.delete_secrets(du.list_secrets(None))
     cnt = du.count_secrets()
     for i in range(5):
@@ -319,15 +296,15 @@
     secrets = du.list_secrets(domain)
     #delete them in block
     du.delete_secrets(secrets)    
     #check that they are gone
     assert cnt== du.count_secrets()
     
     
-def test_rename_secret(set_up):
+def test_rename_secret():
     m_pwd = u"memorabile"
     domain = u"my_domain"
     access = u"my_access"
     new_domain = u"new_domain"
     new_access = u"new_access"      
     info = {'message':'secret'}
     try:
@@ -339,67 +316,67 @@
         assert du.has_secret(domain, access)
         assert not du.has_secret(new_domain, new_access)
         #after rename  
         du.rename_secret(domain, access, new_domain, new_access)
         assert not du.has_secret(domain, access)
         assert du.has_secret(new_domain, new_access)
         res = du.get_secret(new_domain, new_access, m_pwd, parameters.get_salt_key())
-        assert info['message'] == res['info']['message']
+        assert info['message'] == res.info['message']
     finally:
         du.delete_secret(domain, access)
         du.delete_secret(new_domain, new_access)
         
-def test_reconf_memorable(set_up, insert_records):
+def test_reconf_memorable(insert_records):
     old_mem = "memorable"
     new_mem = 'another'
     secrets = du.list_secrets("d1") + du.list_secrets("d2")
     assert 3 == len(secrets)
     sec = du.get_secret('d1', 'a1', old_mem)
-    assert "v1" == sec['info']['k1']
+    assert "v1" == sec.info['k1']
     
     du.reconf_memorable(secrets, old_mem, new_mem)
     secrets = du.list_secrets("d1") + du.list_secrets("d2")        
     assert 3 == len(secrets)
     secrets = du.list_secrets("I") + du.list_secrets("D")
     assert 0 == len(secrets)
     sec = du.get_secret('d1', 'a1', new_mem)
-    assert "v1" == sec['info']['k1']
+    assert "v1" == sec.info['k1']
     
     with pytest.raises(cryptography.fernet.InvalidToken):
         du.get_secret('d1', 'a1', old_mem)
             
-def test_reconf_memorable_with_backup(set_up, insert_records, cleanup_backups):
+def test_reconf_memorable_with_backup(insert_records, cleanup_backups):
     old_mem = "memorable"
     new_mem = 'another'
     secrets = du.list_secrets("d1") + du.list_secrets("d2")
     assert 3 == len(secrets)
     arn = du.reconf_memorable(secrets, old_mem, new_mem, True)
     assert arn is not None
         
-def test_reconf_salt_key(set_up, insert_records):
+def test_reconf_salt_key(insert_records):
     old_mem = "memorable"
     c_pwd = 'carpiato'
     new_salt_key = cu.encrypt_key(c_pwd)
     secrets = du.list_secrets("d1") + du.list_secrets("d2")
     assert 3 == len(secrets)
     sec = du.get_secret('d1', 'a1', old_mem)
-    assert "v1" == sec['info']['k1']
+    assert "v1" == sec.info['k1']
     
     du.reconf_salt_key(secrets, old_mem, c_pwd, False)
     secrets = du.list_secrets("d1") + du.list_secrets("d2")        
     assert 3 == len(secrets)
     secrets = du.list_secrets("I") + du.list_secrets("D")
     assert 0 == len(secrets)
     sec = du.get_secret('d1', 'a1', old_mem, new_salt_key)
-    assert "v1" == sec['info']['k1']
+    assert "v1" == sec.info['k1']
     
     with pytest.raises(cryptography.fernet.InvalidToken):
         du.get_secret('d1', 'a1', old_mem)
             
-def test_query_records(set_up, insert_records):
+def test_query_records(insert_records):
     #test with no filter
     ns = du.count_secrets()
     secrets = du.query_secrets_by_field(None, None)
     assert ns == len(secrets)
     
     #test filter on domain with a d   
     secrets = du.query_secrets_by_field("d", None)
@@ -417,28 +394,28 @@
     secrets = du.query_secrets_by_field(None, "1")
     assert 1 == len(secrets)
     
     #test on both
     secrets = du.query_secrets_by_field("1", "2")
     assert 1 == len(secrets)
     
-def test_get_all_secrets(set_up, insert_records):
-    secrets = du.get_all_secrets('memorable')
+def test_get_all_secrets(insert_records):
+    secrets = du.get_all_secrets('memorable',False) # return as Secret
     assert 3 == len(secrets)
-    assert 'd1' == secrets[0]['domain']
-    assert 'a1' == secrets[0]['access']
-    assert 'u1' == secrets[0]['uid']
-    assert 'p1' == secrets[0]['pwd']
-    assert 'v1' == secrets[0]['info']['k1']
-    assert 'v2' == secrets[0]['info']['k2']
-    assert 'd1' == secrets[1]['domain']
-    assert 'a2' == secrets[1]['access']
-    assert 'u2' == secrets[1]['uid']
-    assert 'p2' == secrets[1]['pwd']
-    assert 'v3' == secrets[1]['info']['k3']
-    assert 'd2' == secrets[2]['domain']
-    assert 'a3' == secrets[2]['access']
-    assert 'u3' == secrets[2]['uid']
-    assert 'p3' == secrets[2]['pwd']
-    assert 'v4' == secrets[2]['info']['k4']    
+    assert 'd1' == secrets[0].domain
+    assert 'a1' == secrets[0].access
+    assert 'u1' == secrets[0].user_id
+    assert 'p1' == secrets[0].password
+    assert 'v1' == secrets[0].info['k1']
+    assert 'v2' == secrets[0].info['k2']
+    assert 'd1' == secrets[1].domain
+    assert 'a2' == secrets[1].access
+    assert 'u2' == secrets[1].user_id
+    assert 'p2' == secrets[1].password
+    assert 'v3' == secrets[1].info['k3']
+    assert 'd2' == secrets[2].domain
+    assert 'a3' == secrets[2].access
+    assert 'u3' == secrets[2].user_id
+    assert 'p3' == secrets[2].password
+    assert 'v4' == secrets[2].info['k4']
```

## tests/parameters_test.py

```diff
@@ -1,11 +1,11 @@
 import json
 import os
 import pytest
-from secretwallet.constants import parameters, Parameters, AWS_PROFILE, SECRET_ACCESS_TABLE
+from secretwallet.constants import parameters, Parameters, AWS_PROFILE, TEST_TABLE
 
 @pytest.fixture
 def set_up():
     path = os.path.dirname(__file__)
     conf_file = os.path.join(path,'data','.secretwallet','test.json')
     #overrides
     data_overrides = {'profile'            : 'my profile',
@@ -24,15 +24,15 @@
         os.rmdir(os.path.dirname(conf_file))
         
         
         
 def test_parameters_singleton():
     assert parameters is not None
     assert AWS_PROFILE == parameters.get_profile_name()
-    assert SECRET_ACCESS_TABLE == parameters.get_table_name()
+    assert TEST_TABLE == parameters.get_table_name()
     assert parameters is Parameters() #singleton test
     
 def test_parameters_overrides():
     data_overrides = {'profile'    : 'my profile',
                       'pre_salt'   : 'my salt',
                       'table_name' : 'my table'}
     parameters.set_data(data_overrides)
```

## Comparing `secret_wallet_codimoc-0.5.1.dist-info/LICENSE` & `secret_wallet_codimoc-0.6.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `secret_wallet_codimoc-0.5.1.dist-info/METADATA` & `secret_wallet_codimoc-0.6.1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,27 +1,26 @@
 Metadata-Version: 2.1
 Name: secret-wallet-codimoc
-Version: 0.5.1
+Version: 0.6.1
 Summary: A cloud-based wallet for personal secrets
 Home-page: https://github.com/codimoc/secret-wallet
 Author: codimoc
 Author-email: codimoc@prismoid.uk
-License: UNKNOWN
-Platform: UNKNOWN
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Requires-Python: >=3.6
 Description-Content-Type: text/markdown
+License-File: LICENSE
 Requires-Dist: boto3
 Requires-Dist: cryptography
-Requires-Dist: docutils (<0.16)
 Requires-Dist: password-strength
-Requires-Dist: pyreadline
 Requires-Dist: python-daemon
+Requires-Dist: docutils (<0.16)
+Requires-Dist: pyreadline
 
 ## Disclaimers
 
 + **Privacy disclaimer**: This application is entirely open-source and non-commercial. It is free to download and use for securing personal information. The user of this application is uniquely responsible for setting up his/her own storage account on Amazon AWS. This application is simply a tool to facilitate the communication between the user's machine and the remote store. Under no circumstances does this application have access to, collect, manage or transfer information owned by the the final user of the application.
 
 
 + **Liability disclaimer**: This application does its best to provide means of securing data on a remote store, as explained in the documentation below. By reading this document and/or by browsing through the open source [code](https://github.com/codimoc/secret-wallet), the user will decide if this application satisfies his/her needs. By downloading and using this application the end user accepts full responsibility of any damage incurred as a consequence of the use of this application. To the maximum extent permitted by applicable law, the owner and developers of this application shall not be liable for any indirect, incidental, special, consequential or punitive damages, or any loss of profits or revenues, whether incurred directly or indirectly, or any loss of data, goodwill, or other intangible losses, resulting from the use of this application.
@@ -221,16 +220,16 @@
 *	**reconf**: Reconfigures either the memorable or the device password. All secrets will be re-encryted with the changed password. It is not possible to change both passwords at the same time. Depending on the size of the wallet, this operation might take some time. A backup of the old table is also performed.
 *	**help**: Display the main help.
 *	**version**: Returns the release version number.
 *	**shell**: Works in a separate shell. This is to facilitate usage on a Windows platform, in the absence of backround processes.
 *	**session**: Starts a background session for keeping track of the memorable password for a short while. This is only for testing since this process is started automatically when needed by the secret_wallet. The lifetime parameter sets the lifetime of the session in seconds, the timeout the time in second for which the memorable password is kept, and the value is what has to be remembered.
 *	**client**: Client command to invoke the background session. This is for testing only. The action allows to get the session value, set the value, stop the background session and test if it is running.
 *   **dump**: This command is used to dump a full text representation of the entire secret wallet. This full dump goes directly to the screen terminal or to a chosen file path, if the  _-f_  option is used. Clearly it is up to the user to secure or delete this file, since it contains all the un-encrypted secrets.
-*   **save**: This command is used to save a full representation of the entire secret wallet into  _json_  format. This can be used as a backup for later restoration of the wallet if required. Again this information can be sent directly to the screen terminal or to a file with the  _-f_  option. Clearly it is up to the user to secure (save in encrypted format for future use) or delete this file, since it contains all the un-encrypted secrets.
-*   **load**: This command is used to restore the entire secret wallet from a backup file, stored in  _json_  format. It requires the  _-f_  option to specify the location of this  _json_  file. The command will not overwrite secrets which are already present in the secret store, and only what is missing is reloaded. In this way a full reload will not change the timestamps of existing secrets.
+*   **save**: This command is used to save a full representation of the entire secret wallet into  _json_  format. This can be used as a backup for later restoration of the wallet if required. Again this information can be sent directly to the screen terminal or to a file with the  _-f_  option. By default the information is returned or saved in encrypted format, _i.e._ with the values encrypted and the keys unencrypted. This can be changed with the  _-d_  option, forcing the output to be decrypted. This requires the memorable password for decryption.
+*   **load**: This command is used to restore the entire secret wallet from a backup file, stored in  _json_  format. It requires the  _-f_  option to specify the location of this  _json_  file. The command will not overwrite secrets which are already present in the secret store, and only what is missing is reloaded. In this way a full reload will not change the timestamps of existing secrets. Notice that the  _-d_  option is needed when the backup json file is in a decrypted format, so that encryption can happen when inserting in the DB table.
 
 
 ## <a id="usage"></a>Usage
 As mentioned above, in the early releases of this application the interaction with the secret wallet is limited to the command line interface. A typical user would add secrets, retrieve secrets and look at a list of secrets stored in the remote wallet.
 
 Let's consider a realistic example: the energy provider *Smart Energy Ltd* provides both gas and electricity to our customer. It provides a single access through their web portal, to manage both the gas and electricity accounts. It requires a normal access with a login and password, and gives some customer's support through a telephone hot-line. In summary:
 
@@ -363,9 +362,7 @@
 Help is needed and welcome. Please visit the the [github page](https://github.com/codimoc/secret-wallet) and raise new issues, or contact the author via email from the email address you will find in the secret-wallet page on [pypi](https://pypi.org/).
 
 ## <a id="faq"></a>FAQ
 A *frequently asked questions* is maintained [here](https://github.com/codimoc/secret-wallet/wiki/FAQ).
 
 ## <a id="notes"></a>Release Notes
 The *Release Notes* are maintained [here](https://github.com/codimoc/secret-wallet/wiki/Release-Notes).
-
-
```

## Comparing `secret_wallet_codimoc-0.5.1.dist-info/RECORD` & `secret_wallet_codimoc-0.6.1.dist-info/RECORD`

 * *Files 22% similar despite different names*

```diff
@@ -1,31 +1,37 @@
 secretwallet/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 secretwallet/__main__.py,sha256=HffrDPkueYEQormArbPbjQK51iqvGWvs-N7kE92XK70,200
-secretwallet/constants.py,sha256=H7nfbu7plt450SkGpVVzM9v1QBLaC1gQxEc97CsbXns,7462
+secretwallet/constants.py,sha256=RxVIrCfpDgw0EbxddTFe4wv8fZurafwXdr3r_GyXiHc,8084
+secretwallet/__pycache__/__init__.cpython-39.pyc,sha256=cnrwcqbEzTQa_eVAVsnLSHRp3-i1F1PwIVSY74PNJtI,160
 secretwallet/main/__init__.py,sha256=5LyEMvZRQEIph_hKGwifqaaBP2e9ahx6aiZSpVeAW8s,350
 secretwallet/main/configuration.py,sha256=RdMe4K80H0h3DN0wzl3CCX-0jSqkqLGfxzPCMPZlsTg,8899
-secretwallet/main/myparser.py,sha256=BJmohe9o5uNgalKy5q_L3awaC4FDTf18dOOwAtxRFVA,32529
+secretwallet/main/myparser.py,sha256=AcYmHPoKT1e4RpFTBwL4Q5OhO9ZssG8yiCnyZijhVPU,34680
 secretwallet/session/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 secretwallet/session/client.py,sha256=tKa8ywXCTc1gG_fakDmdjqspxrQDkZAbwmDSNQWIXzY,2101
 secretwallet/session/service.py,sha256=9aH7CLLfFHx0D7q9-ZLgfv7i2xsDIOPfq-Iy1LwxeFo,3465
+secretwallet/storage/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+secretwallet/storage/aws_dynamo.py,sha256=HVcVP6BQZEvK48PPjzlbWuiCutO_OeogaPGYy3rtnm8,12290
 secretwallet/utils/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-secretwallet/utils/cryptutils.py,sha256=YssTBWj0u3jDNqiis9hmvOdv4IclWk7NLw5-ETJUxgU,2651
-secretwallet/utils/dbutils.py,sha256=ZhcN2hb4iqm_WSU6M-oKNKSEIKsbDUKK54LNIbq3854,17467
+secretwallet/utils/cryptutils.py,sha256=-OEtJXAL3atJTYCvsNggh77K0pZ1QEtTh3-d2-ppfKg,3677
+secretwallet/utils/dbutils.py,sha256=BX98aMonKxFPnPoliRndVTrR4IKgES8Vi36CcJBRmfE,14331
 secretwallet/utils/fileutils.py,sha256=0mds_kCNN0hfFEuF8yXESi51PDbn_4ybHNxbbHyJvqk,136
-secretwallet/utils/ioutils.py,sha256=fNhj2cnlmH-w7-lMtTAAEMqfqlrrqyr5qoOyQ4UtMvQ,5411
+secretwallet/utils/ioutils.py,sha256=W2myoLgayB6lXlFKLpWmvvuqiKDT2DqifFylyAm0Ayg,5437
 secretwallet/utils/logging.py,sha256=l9cQGAubH4AiwlVxzgUYUbBpn9ZmNSL3pRB3De4E4Gs,1204
 secretwallet/utils/password_manager.py,sha256=lGtPffWYtyUHjGicR9exZMBgT78sGsNGGVDM9C1TnuU,3911
-tests/__init__.py,sha256=nzNIda37bsDs0Tp4836r7TfXL8uz9bWUZAImXd5KzR0,288
+secretwallet/utils/__pycache__/__init__.cpython-39.pyc,sha256=xlktBgEpoIA80MrsBGNBagM-RIZkf7ZGtTQbbiWL-xE,166
+secretwallet/utils/__pycache__/cryptutils.cpython-39.pyc,sha256=uccbNxD3lWk5Qjj4c5tMVRSel5Lhl5A_gYC8TJp-xdg,3551
+tests/__init__.py,sha256=RFJo0k-P3zYD0Oam6dYCwc_WicFpc4VUtVLUCK2dL7Q,372
 tests/aws_config_test.py,sha256=HsKwa6-Gx4yIHBaK9rhLby3MYKE0Wq16CDj1axDnkrU,1748
-tests/cli_test.py,sha256=FXkFDjZrhaBHckY3l09TXs2B1K7Nluzyx4FTSfmVStM,22514
-tests/cryptuils_test.py,sha256=XOJlXG0TSp9_9Yf99RbgL1sA29lIkGlMNMLNay6keX4,2586
-tests/dbutils_test.py,sha256=aGk21TrejwXrk4q_-1TvYo7vCqrOPvieUh2Fxhx8nP0,16012
-tests/parameters_test.py,sha256=B90c-u8jYygheTHEqQJzNqvF3VJlEVismxxwpfJFh9Q,1775
+tests/aws_dynamo_test.py,sha256=9UXZAjcb-lui1Uooy-gABpfPuZATNEYO5kcbSCWsdDk,4761
+tests/cli_test.py,sha256=v33YQbsQlwSYTlia5f_kI-azZQv2lHlFtvFqheuxnF8,27512
+tests/cryptuils_test.py,sha256=jOh_R-1ViPwkyepEakExwnDNSjFfio4UQyBu--IRUQo,2973
+tests/dbutils_test.py,sha256=0_rmFeaUs_hnGm0EyOcOfZ_kP3A5SEDvo8ArNVRwVe4,15242
+tests/parameters_test.py,sha256=y3wqJFgClL-oZe4Nre5kK9Qj1dsi5T9ww_huFrh-VTc,1757
 tests/password_test.py,sha256=dJFWvMTTx5wZmq_J5q7eTfGGXRtokORvDHT2R-VjWb0,646
 tests/session_test.py,sha256=hgMVmJOwvEllWQiTQTR9cWNwJqCsVIDUno592zqtHE0,1442
 tests/data/test_integration.json,sha256=8tngqrS4N9WV3ijpIb8UUja5BjRfo4eP8J0fygvZmw8,127
-secret_wallet_codimoc-0.5.1.dist-info/LICENSE,sha256=IBXSgfX0buUOUc9OoTg1oEBJ6bP7QIIGMzWWuyylciA,1050
-secret_wallet_codimoc-0.5.1.dist-info/METADATA,sha256=0Nk7Vh-KpYHf7YgB_OyK00-RoZMmPW1e1sa-rxMLFcQ,29083
-secret_wallet_codimoc-0.5.1.dist-info/WHEEL,sha256=ewwEueio1C2XeHTvT17n8dZUJgOvyCWCt0WVNLClP9o,92
-secret_wallet_codimoc-0.5.1.dist-info/entry_points.txt,sha256=BDXZ5Ntv53VJcE63vR5TmVtIz2ogd8GSIZYwpeuUax0,153
-secret_wallet_codimoc-0.5.1.dist-info/top_level.txt,sha256=ZQugHfbeohjvYTYj_HnbRHIzcros1wQjm0bksN4cYgY,19
-secret_wallet_codimoc-0.5.1.dist-info/RECORD,,
+secret_wallet_codimoc-0.6.1.dist-info/LICENSE,sha256=IBXSgfX0buUOUc9OoTg1oEBJ6bP7QIIGMzWWuyylciA,1050
+secret_wallet_codimoc-0.6.1.dist-info/METADATA,sha256=H-eYpD3CWthEaGHvjkhjBsGLEkhae9aWaXmxiPOHp34,29333
+secret_wallet_codimoc-0.6.1.dist-info/WHEEL,sha256=g4nMs7d-Xl9-xC9XovUrsDHGXt-FT0E17Yqo92DEfvY,92
+secret_wallet_codimoc-0.6.1.dist-info/entry_points.txt,sha256=vZgzbpJIjnUYqAIpt_HEaADVcCxpyJBk5gPmDRpN4Ok,152
+secret_wallet_codimoc-0.6.1.dist-info/top_level.txt,sha256=ZQugHfbeohjvYTYj_HnbRHIzcros1wQjm0bksN4cYgY,19
+secret_wallet_codimoc-0.6.1.dist-info/RECORD,,
```

