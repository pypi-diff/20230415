# Comparing `tmp/brainpy-2.3.8-py3-none-any.whl.zip` & `tmp/brainpy-2.4.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,268 +1,274 @@
-Zip file size: 541129 bytes, number of entries: 266
--rw-r--r--  2.0 unx     9508 b- defN 23-Apr-08 07:33 brainpy/__init__.py
--rw-r--r--  2.0 unx      661 b- defN 23-Apr-08 07:33 brainpy/analysis.py
--rw-r--r--  2.0 unx     1308 b- defN 23-Apr-08 07:33 brainpy/channels.py
--rw-r--r--  2.0 unx    18712 b- defN 23-Apr-08 07:33 brainpy/check.py
--rw-r--r--  2.0 unx      245 b- defN 23-Apr-08 07:33 brainpy/checkpoints.py
--rw-r--r--  2.0 unx     1243 b- defN 23-Apr-08 07:33 brainpy/connect.py
--rw-r--r--  2.0 unx      144 b- defN 23-Apr-08 07:33 brainpy/dyn.py
--rw-r--r--  2.0 unx      324 b- defN 23-Apr-08 07:33 brainpy/encoding.py
--rw-r--r--  2.0 unx     8306 b- defN 23-Apr-08 07:33 brainpy/errors.py
--rw-r--r--  2.0 unx      350 b- defN 23-Apr-08 07:33 brainpy/experimental.py
--rw-r--r--  2.0 unx     1123 b- defN 23-Apr-08 07:33 brainpy/initialize.py
--rw-r--r--  2.0 unx      335 b- defN 23-Apr-08 07:33 brainpy/inputs.py
--rw-r--r--  2.0 unx     1890 b- defN 23-Apr-08 07:33 brainpy/layers.py
--rw-r--r--  2.0 unx      963 b- defN 23-Apr-08 07:33 brainpy/losses.py
--rw-r--r--  2.0 unx      487 b- defN 23-Apr-08 07:33 brainpy/measure.py
--rw-r--r--  2.0 unx      119 b- defN 23-Apr-08 07:33 brainpy/modes.py
--rw-r--r--  2.0 unx     1033 b- defN 23-Apr-08 07:33 brainpy/neurons.py
--rw-r--r--  2.0 unx     1013 b- defN 23-Apr-08 07:33 brainpy/optim.py
--rw-r--r--  2.0 unx      303 b- defN 23-Apr-08 07:33 brainpy/rates.py
--rw-r--r--  2.0 unx      466 b- defN 23-Apr-08 07:33 brainpy/running.py
--rw-r--r--  2.0 unx      612 b- defN 23-Apr-08 07:33 brainpy/synapses.py
--rw-r--r--  2.0 unx      180 b- defN 23-Apr-08 07:33 brainpy/synouts.py
--rw-r--r--  2.0 unx      117 b- defN 23-Apr-08 07:33 brainpy/synplast.py
--rw-r--r--  2.0 unx       51 b- defN 23-Apr-08 07:33 brainpy/testing.py
--rw-r--r--  2.0 unx     1120 b- defN 23-Apr-08 07:33 brainpy/tools.py
--rw-r--r--  2.0 unx       72 b- defN 23-Apr-08 07:33 brainpy/train.py
--rw-r--r--  2.0 unx      241 b- defN 23-Apr-08 07:33 brainpy/types.py
--rw-r--r--  2.0 unx       24 b- defN 23-Apr-08 07:33 brainpy/_src/__init__.py
--rw-r--r--  2.0 unx      924 b- defN 23-Apr-08 07:33 brainpy/_src/checking.py
--rw-r--r--  2.0 unx     1359 b- defN 23-Apr-08 07:33 brainpy/_src/test_check.py
--rw-r--r--  2.0 unx      930 b- defN 23-Apr-08 07:33 brainpy/_src/types.py
--rw-r--r--  2.0 unx      846 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/__init__.py
--rw-r--r--  2.0 unx      156 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/base.py
--rw-r--r--  2.0 unx     1721 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/constants.py
--rw-r--r--  2.0 unx     3924 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/plotstyle.py
--rw-r--r--  2.0 unx     5651 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/stability.py
--rw-r--r--  2.0 unx       52 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/highdim/__init__.py
--rw-r--r--  2.0 unx    31123 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/highdim/slow_points.py
--rw-r--r--  2.0 unx       93 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/lowdim/__init__.py
--rw-r--r--  2.0 unx    44705 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/lowdim/lowdim_analyzer.py
--rw-r--r--  2.0 unx    24987 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/lowdim/lowdim_bifurcation.py
--rw-r--r--  2.0 unx    20261 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/lowdim/lowdim_phase_plane.py
--rw-r--r--  2.0 unx      199 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/utils/__init__.py
--rw-r--r--  2.0 unx     2840 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/utils/function.py
--rw-r--r--  2.0 unx     3054 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/utils/measurement.py
--rw-r--r--  2.0 unx     5295 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/utils/model.py
--rw-r--r--  2.0 unx    19551 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/utils/optimization.py
--rw-r--r--  2.0 unx     5827 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/utils/others.py
--rw-r--r--  2.0 unx      158 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/utils/outputs.py
--rw-r--r--  2.0 unx      967 b- defN 23-Apr-08 07:33 brainpy/_src/analysis/utils/visualization.py
--rw-r--r--  2.0 unx      175 b- defN 23-Apr-08 07:33 brainpy/_src/base/__init__.py
--rw-r--r--  2.0 unx       24 b- defN 23-Apr-08 07:33 brainpy/_src/base/base.py
--rw-r--r--  2.0 unx       24 b- defN 23-Apr-08 07:33 brainpy/_src/base/collector.py
--rw-r--r--  2.0 unx       25 b- defN 23-Apr-08 07:33 brainpy/_src/base/function.py
--rw-r--r--  2.0 unx      502 b- defN 23-Apr-08 07:33 brainpy/_src/base/io.py
--rw-r--r--  2.0 unx      289 b- defN 23-Apr-08 07:33 brainpy/_src/base/naming.py
--rw-r--r--  2.0 unx       24 b- defN 23-Apr-08 07:33 brainpy/_src/checkpoints/__init__.py
--rw-r--r--  2.0 unx    12185 b- defN 23-Apr-08 07:33 brainpy/_src/checkpoints/io.py
--rw-r--r--  2.0 unx    57502 b- defN 23-Apr-08 07:33 brainpy/_src/checkpoints/serialization.py
--rw-r--r--  2.0 unx      268 b- defN 23-Apr-08 07:33 brainpy/_src/connect/__init__.py
--rw-r--r--  2.0 unx    24303 b- defN 23-Apr-08 07:33 brainpy/_src/connect/base.py
--rw-r--r--  2.0 unx     4210 b- defN 23-Apr-08 07:33 brainpy/_src/connect/custom_conn.py
--rw-r--r--  2.0 unx    39149 b- defN 23-Apr-08 07:33 brainpy/_src/connect/random_conn.py
--rw-r--r--  2.0 unx     9173 b- defN 23-Apr-08 07:33 brainpy/_src/connect/regular_conn.py
--rw-r--r--  2.0 unx      358 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/__init__.py
--rw-r--r--  2.0 unx      636 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/_utils.py
--rw-r--r--  2.0 unx    48804 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/base.py
--rw-r--r--  2.0 unx     2290 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/context.py
--rw-r--r--  2.0 unx     9980 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/delay.py
--rw-r--r--  2.0 unx    25104 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/runners.py
--rw-r--r--  2.0 unx    10966 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/transform.py
--rw-r--r--  2.0 unx    40141 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/channels/Ca.py
--rw-r--r--  2.0 unx     9130 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/channels/IH.py
--rw-r--r--  2.0 unx    35637 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/channels/K.py
--rw-r--r--  2.0 unx     4491 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/channels/KCa.py
--rw-r--r--  2.0 unx    11936 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/channels/Na.py
--rw-r--r--  2.0 unx      423 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/channels/__init__.py
--rw-r--r--  2.0 unx     4041 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/channels/base.py
--rw-r--r--  2.0 unx     2102 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/channels/leaky.py
--rw-r--r--  2.0 unx      233 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/layers/__init__.py
--rw-r--r--  2.0 unx      199 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/layers/base.py
--rw-r--r--  2.0 unx    30203 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/layers/conv.py
--rw-r--r--  2.0 unx     1472 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/layers/dropout.py
--rw-r--r--  2.0 unx     1803 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/layers/function.py
--rw-r--r--  2.0 unx     6975 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/layers/linear.py
--rw-r--r--  2.0 unx    25691 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/layers/normalization.py
--rw-r--r--  2.0 unx     6737 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/layers/nvar.py
--rw-r--r--  2.0 unx    34199 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/layers/pooling.py
--rw-r--r--  2.0 unx     8906 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/layers/reservoir.py
--rw-r--r--  2.0 unx    26998 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/layers/rnncells.py
--rw-r--r--  2.0 unx       24 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/networks/__init__.py
--rw-r--r--  2.0 unx      252 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/networks/cann.py
--rw-r--r--  2.0 unx      177 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/neurons/__init__.py
--rw-r--r--  2.0 unx    48933 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/neurons/biological_models.py
--rw-r--r--  2.0 unx      595 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/neurons/compat.py
--rw-r--r--  2.0 unx    13060 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/neurons/fractional_models.py
--rw-r--r--  2.0 unx     5687 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/neurons/input_groups.py
--rw-r--r--  2.0 unx     2317 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/neurons/noise_groups.py
--rw-r--r--  2.0 unx    89375 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/neurons/reduced_models.py
--rw-r--r--  2.0 unx       52 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/rates/__init__.py
--rw-r--r--  2.0 unx    41067 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/rates/populations.py
--rw-r--r--  2.0 unx      223 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synapses/__init__.py
--rw-r--r--  2.0 unx    36146 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synapses/abstract_models.py
--rw-r--r--  2.0 unx    21901 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synapses/biological_models.py
--rw-r--r--  2.0 unx    10252 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synapses/compat.py
--rw-r--r--  2.0 unx    11139 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synapses/delay_couplings.py
--rw-r--r--  2.0 unx     2025 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synapses/gap_junction.py
--rw-r--r--  2.0 unx     9214 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synapses/learning_rules.py
--rw-r--r--  2.0 unx        0 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synapses_v2/__init__.py
--rw-r--r--  2.0 unx    13693 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synapses_v2/abstract_synapses.py
--rw-r--r--  2.0 unx     4651 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synapses_v2/base.py
--rw-r--r--  2.0 unx     2666 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synapses_v2/others.py
--rw-r--r--  2.0 unx     2599 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synapses_v2/syn_outs.py
--rw-r--r--  2.0 unx     4730 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synapses_v2/syn_plasticity.py
--rw-r--r--  2.0 unx       73 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synouts/__init__.py
--rw-r--r--  2.0 unx     2636 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synouts/conductances.py
--rw-r--r--  2.0 unx     3281 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synouts/ions.py
--rw-r--r--  2.0 unx       62 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synplast/__init__.py
--rw-r--r--  2.0 unx       24 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synplast/long_term_plasticity.py
--rw-r--r--  2.0 unx     5324 b- defN 23-Apr-08 07:33 brainpy/_src/dyn/synplast/short_term_plasticity.py
--rw-r--r--  2.0 unx      114 b- defN 23-Apr-08 07:33 brainpy/_src/encoding/__init__.py
--rw-r--r--  2.0 unx      364 b- defN 23-Apr-08 07:33 brainpy/_src/encoding/base.py
--rw-r--r--  2.0 unx     4786 b- defN 23-Apr-08 07:33 brainpy/_src/encoding/stateful_encoding.py
--rw-r--r--  2.0 unx     2249 b- defN 23-Apr-08 07:33 brainpy/_src/encoding/stateless_encoding.py
--rw-r--r--  2.0 unx      154 b- defN 23-Apr-08 07:33 brainpy/_src/initialize/__init__.py
--rw-r--r--  2.0 unx      614 b- defN 23-Apr-08 07:33 brainpy/_src/initialize/base.py
--rw-r--r--  2.0 unx    11571 b- defN 23-Apr-08 07:33 brainpy/_src/initialize/decay_inits.py
--rw-r--r--  2.0 unx     9288 b- defN 23-Apr-08 07:33 brainpy/_src/initialize/generic.py
--rw-r--r--  2.0 unx      554 b- defN 23-Apr-08 07:33 brainpy/_src/initialize/others.py
--rw-r--r--  2.0 unx    13484 b- defN 23-Apr-08 07:33 brainpy/_src/initialize/random_inits.py
--rw-r--r--  2.0 unx     2266 b- defN 23-Apr-08 07:33 brainpy/_src/initialize/regular_inits.py
--rw-r--r--  2.0 unx      173 b- defN 23-Apr-08 07:33 brainpy/_src/inputs/__init__.py
--rw-r--r--  2.0 unx    11425 b- defN 23-Apr-08 07:33 brainpy/_src/inputs/currents.py
--rw-r--r--  2.0 unx     1189 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/__init__.py
--rw-r--r--  2.0 unx     4154 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/base.py
--rw-r--r--  2.0 unx     2930 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/constants.py
--rw-r--r--  2.0 unx     8158 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/joint_eq.py
--rw-r--r--  2.0 unx    11874 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/runner.py
--rw-r--r--  2.0 unx     4455 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/utils.py
--rw-r--r--  2.0 unx    15041 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/fde/Caputo.py
--rw-r--r--  2.0 unx     7220 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/fde/GL.py
--rw-r--r--  2.0 unx      110 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/fde/__init__.py
--rw-r--r--  2.0 unx     2771 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/fde/base.py
--rw-r--r--  2.0 unx     2706 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/fde/generic.py
--rw-r--r--  2.0 unx      220 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/ode/__init__.py
--rw-r--r--  2.0 unx    17892 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/ode/adaptive_rk.py
--rw-r--r--  2.0 unx     4845 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/ode/base.py
--rw-r--r--  2.0 unx     1493 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/ode/common.py
--rw-r--r--  2.0 unx    25974 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/ode/explicit_rk.py
--rw-r--r--  2.0 unx    13966 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/ode/exponential.py
--rw-r--r--  2.0 unx     4139 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/ode/generic.py
--rw-r--r--  2.0 unx       24 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/pde/__init__.py
--rw-r--r--  2.0 unx       98 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/pde/base.py
--rw-r--r--  2.0 unx      184 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/sde/__init__.py
--rw-r--r--  2.0 unx     3429 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/sde/base.py
--rw-r--r--  2.0 unx     3877 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/sde/generic.py
--rw-r--r--  2.0 unx    24705 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/sde/normal.py
--rw-r--r--  2.0 unx    17060 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/sde/srk_scalar.py
--rw-r--r--  2.0 unx    17016 b- defN 23-Apr-08 07:33 brainpy/_src/integrators/sde/srk_strong.py
--rw-r--r--  2.0 unx      276 b- defN 23-Apr-08 07:33 brainpy/_src/losses/__init__.py
--rw-r--r--  2.0 unx    22010 b- defN 23-Apr-08 07:33 brainpy/_src/losses/comparison.py
--rw-r--r--  2.0 unx     2370 b- defN 23-Apr-08 07:33 brainpy/_src/losses/regularization.py
--rw-r--r--  2.0 unx      792 b- defN 23-Apr-08 07:33 brainpy/_src/losses/utils.py
--rw-r--r--  2.0 unx     1432 b- defN 23-Apr-08 07:33 brainpy/_src/math/__init__.py
--rw-r--r--  2.0 unx     1788 b- defN 23-Apr-08 07:33 brainpy/_src/math/_utils.py
--rw-r--r--  2.0 unx    12797 b- defN 23-Apr-08 07:33 brainpy/_src/math/activations.py
--rw-r--r--  2.0 unx     2481 b- defN 23-Apr-08 07:33 brainpy/_src/math/arrayinterporate.py
--rw-r--r--  2.0 unx    29884 b- defN 23-Apr-08 07:33 brainpy/_src/math/compat_numpy.py
--rw-r--r--  2.0 unx     6488 b- defN 23-Apr-08 07:33 brainpy/_src/math/compat_pytorch.py
--rw-r--r--  2.0 unx    17877 b- defN 23-Apr-08 07:33 brainpy/_src/math/compat_tensorflow.py
--rw-r--r--  2.0 unx      911 b- defN 23-Apr-08 07:33 brainpy/_src/math/datatypes.py
--rw-r--r--  2.0 unx    15945 b- defN 23-Apr-08 07:33 brainpy/_src/math/delayvars.py
--rw-r--r--  2.0 unx    16732 b- defN 23-Apr-08 07:33 brainpy/_src/math/environment.py
--rw-r--r--  2.0 unx     1498 b- defN 23-Apr-08 07:33 brainpy/_src/math/fft.py
--rw-r--r--  2.0 unx     8866 b- defN 23-Apr-08 07:33 brainpy/_src/math/index_tricks.py
--rw-r--r--  2.0 unx     1792 b- defN 23-Apr-08 07:33 brainpy/_src/math/linalg.py
--rw-r--r--  2.0 unx     1903 b- defN 23-Apr-08 07:33 brainpy/_src/math/modes.py
--rw-r--r--  2.0 unx    54127 b- defN 23-Apr-08 07:33 brainpy/_src/math/ndarray.py
--rw-r--r--  2.0 unx     2255 b- defN 23-Apr-08 07:33 brainpy/_src/math/others.py
--rw-r--r--  2.0 unx    77638 b- defN 23-Apr-08 07:33 brainpy/_src/math/random.py
--rw-r--r--  2.0 unx     2119 b- defN 23-Apr-08 07:33 brainpy/_src/math/remove_vmap.py
--rw-r--r--  2.0 unx     1085 b- defN 23-Apr-08 07:33 brainpy/_src/math/object_transform/__init__.py
--rw-r--r--  2.0 unx      760 b- defN 23-Apr-08 07:33 brainpy/_src/math/object_transform/_utils.py
--rw-r--r--  2.0 unx      403 b- defN 23-Apr-08 07:33 brainpy/_src/math/object_transform/abstract.py
--rw-r--r--  2.0 unx    36857 b- defN 23-Apr-08 07:33 brainpy/_src/math/object_transform/autograd.py
--rw-r--r--  2.0 unx    30300 b- defN 23-Apr-08 07:33 brainpy/_src/math/object_transform/base.py
--rw-r--r--  2.0 unx    29841 b- defN 23-Apr-08 07:33 brainpy/_src/math/object_transform/controls.py
--rw-r--r--  2.0 unx     3014 b- defN 23-Apr-08 07:33 brainpy/_src/math/object_transform/function.py
--rw-r--r--  2.0 unx    10117 b- defN 23-Apr-08 07:33 brainpy/_src/math/object_transform/jit.py
--rw-r--r--  2.0 unx    17779 b- defN 23-Apr-08 07:33 brainpy/_src/math/object_transform/parallels.py
--rw-r--r--  2.0 unx      208 b- defN 23-Apr-08 07:33 brainpy/_src/math/operators/__init__.py
--rw-r--r--  2.0 unx     1857 b- defN 23-Apr-08 07:33 brainpy/_src/math/operators/event_ops.py
--rw-r--r--  2.0 unx    17399 b- defN 23-Apr-08 07:33 brainpy/_src/math/operators/jitconn_ops.py
--rw-r--r--  2.0 unx     3774 b- defN 23-Apr-08 07:33 brainpy/_src/math/operators/op_registers.py
--rw-r--r--  2.0 unx    17347 b- defN 23-Apr-08 07:33 brainpy/_src/math/operators/pre_syn_post.py
--rw-r--r--  2.0 unx     9941 b- defN 23-Apr-08 07:33 brainpy/_src/math/operators/sparse_ops.py
--rw-r--r--  2.0 unx       77 b- defN 23-Apr-08 07:33 brainpy/_src/math/surrogate/__init__.py
--rw-r--r--  2.0 unx     3665 b- defN 23-Apr-08 07:33 brainpy/_src/math/surrogate/_utils.py
--rw-r--r--  2.0 unx     7216 b- defN 23-Apr-08 07:33 brainpy/_src/math/surrogate/compt.py
--rw-r--r--  2.0 unx    40745 b- defN 23-Apr-08 07:33 brainpy/_src/math/surrogate/one_input.py
--rw-r--r--  2.0 unx     1492 b- defN 23-Apr-08 07:33 brainpy/_src/math/surrogate/two_inputs.py
--rw-r--r--  2.0 unx      287 b- defN 23-Apr-08 07:33 brainpy/_src/measure/__init__.py
--rw-r--r--  2.0 unx    10162 b- defN 23-Apr-08 07:33 brainpy/_src/measure/correlation.py
--rw-r--r--  2.0 unx     1770 b- defN 23-Apr-08 07:33 brainpy/_src/measure/firings.py
--rw-r--r--  2.0 unx     3896 b- defN 23-Apr-08 07:33 brainpy/_src/measure/lfp.py
--rw-r--r--  2.0 unx       75 b- defN 23-Apr-08 07:33 brainpy/_src/optimizers/__init__.py
--rw-r--r--  2.0 unx    41335 b- defN 23-Apr-08 07:33 brainpy/_src/optimizers/optimizer.py
--rw-r--r--  2.0 unx    13220 b- defN 23-Apr-08 07:33 brainpy/_src/optimizers/scheduler.py
--rw-r--r--  2.0 unx      525 b- defN 23-Apr-08 07:33 brainpy/_src/running/__init__.py
--rw-r--r--  2.0 unx      269 b- defN 23-Apr-08 07:33 brainpy/_src/running/constants.py
--rw-r--r--  2.0 unx     4913 b- defN 23-Apr-08 07:33 brainpy/_src/running/jax_multiprocessing.py
--rw-r--r--  2.0 unx     2976 b- defN 23-Apr-08 07:33 brainpy/_src/running/native_multiprocessing.py
--rw-r--r--  2.0 unx     6995 b- defN 23-Apr-08 07:33 brainpy/_src/running/pathos_multiprocessing.py
--rw-r--r--  2.0 unx     9777 b- defN 23-Apr-08 07:33 brainpy/_src/running/runner.py
--rw-r--r--  2.0 unx        0 b- defN 23-Apr-08 07:33 brainpy/_src/testing/__init__.py
--rw-r--r--  2.0 unx      347 b- defN 23-Apr-08 07:33 brainpy/_src/testing/base.py
--rw-r--r--  2.0 unx      181 b- defN 23-Apr-08 07:33 brainpy/_src/tools/__init__.py
--rw-r--r--  2.0 unx     7326 b- defN 23-Apr-08 07:33 brainpy/_src/tools/codes.py
--rw-r--r--  2.0 unx     5882 b- defN 23-Apr-08 07:33 brainpy/_src/tools/dicts.py
--rw-r--r--  2.0 unx      223 b- defN 23-Apr-08 07:33 brainpy/_src/tools/math_util.py
--rw-r--r--  2.0 unx     1435 b- defN 23-Apr-08 07:33 brainpy/_src/tools/naming.py
--rw-r--r--  2.0 unx     4424 b- defN 23-Apr-08 07:33 brainpy/_src/tools/others.py
--rw-r--r--  2.0 unx     1406 b- defN 23-Apr-08 07:33 brainpy/_src/tools/package.py
--rw-r--r--  2.0 unx      659 b- defN 23-Apr-08 07:33 brainpy/_src/train/__init__.py
--rw-r--r--  2.0 unx     1972 b- defN 23-Apr-08 07:33 brainpy/_src/train/_utils.py
--rw-r--r--  2.0 unx    24649 b- defN 23-Apr-08 07:33 brainpy/_src/train/back_propagation.py
--rw-r--r--  2.0 unx     2980 b- defN 23-Apr-08 07:33 brainpy/_src/train/base.py
--rw-r--r--  2.0 unx    10067 b- defN 23-Apr-08 07:33 brainpy/_src/train/offline.py
--rw-r--r--  2.0 unx    10514 b- defN 23-Apr-08 07:33 brainpy/_src/train/online.py
--rw-r--r--  2.0 unx       77 b- defN 23-Apr-08 07:33 brainpy/_src/visualization/__init__.py
--rw-r--r--  2.0 unx     3544 b- defN 23-Apr-08 07:33 brainpy/_src/visualization/base.py
--rw-r--r--  2.0 unx      841 b- defN 23-Apr-08 07:33 brainpy/_src/visualization/figures.py
--rw-r--r--  2.0 unx    14603 b- defN 23-Apr-08 07:33 brainpy/_src/visualization/plots.py
--rw-r--r--  2.0 unx     1026 b- defN 23-Apr-08 07:33 brainpy/_src/visualization/styles.py
--rw-r--r--  2.0 unx       90 b- defN 23-Apr-08 07:33 brainpy/algorithms/__init__.py
--rw-r--r--  2.0 unx    17344 b- defN 23-Apr-08 07:33 brainpy/algorithms/offline.py
--rw-r--r--  2.0 unx     6284 b- defN 23-Apr-08 07:33 brainpy/algorithms/online.py
--rw-r--r--  2.0 unx     2656 b- defN 23-Apr-08 07:33 brainpy/algorithms/utils.py
--rw-r--r--  2.0 unx      128 b- defN 23-Apr-08 07:33 brainpy/integrators/__init__.py
--rw-r--r--  2.0 unx      576 b- defN 23-Apr-08 07:33 brainpy/integrators/fde.py
--rw-r--r--  2.0 unx     1061 b- defN 23-Apr-08 07:33 brainpy/integrators/ode.py
--rw-r--r--  2.0 unx      679 b- defN 23-Apr-08 07:33 brainpy/integrators/sde.py
--rw-r--r--  2.0 unx     1563 b- defN 23-Apr-08 07:33 brainpy/math/__init__.py
--rw-r--r--  2.0 unx      612 b- defN 23-Apr-08 07:33 brainpy/math/activations.py
--rw-r--r--  2.0 unx      217 b- defN 23-Apr-08 07:33 brainpy/math/arrayinterporate.py
--rw-r--r--  2.0 unx     8074 b- defN 23-Apr-08 07:33 brainpy/math/compat_numpy.py
--rw-r--r--  2.0 unx      469 b- defN 23-Apr-08 07:33 brainpy/math/compat_pytorch.py
--rw-r--r--  2.0 unx      932 b- defN 23-Apr-08 07:33 brainpy/math/compat_tensorflow.py
--rw-r--r--  2.0 unx      498 b- defN 23-Apr-08 07:33 brainpy/math/datatypes.py
--rw-r--r--  2.0 unx      255 b- defN 23-Apr-08 07:33 brainpy/math/delayvars.py
--rw-r--r--  2.0 unx      941 b- defN 23-Apr-08 07:33 brainpy/math/environment.py
--rw-r--r--  2.0 unx      402 b- defN 23-Apr-08 07:33 brainpy/math/fft.py
--rw-r--r--  2.0 unx      470 b- defN 23-Apr-08 07:33 brainpy/math/linalg.py
--rw-r--r--  2.0 unx      292 b- defN 23-Apr-08 07:33 brainpy/math/modes.py
--rw-r--r--  2.0 unx      182 b- defN 23-Apr-08 07:33 brainpy/math/ndarray.py
--rw-r--r--  2.0 unx      710 b- defN 23-Apr-08 07:33 brainpy/math/object_base.py
--rw-r--r--  2.0 unx      726 b- defN 23-Apr-08 07:33 brainpy/math/object_transform.py
--rw-r--r--  2.0 unx     1113 b- defN 23-Apr-08 07:33 brainpy/math/operators.py
--rw-r--r--  2.0 unx      178 b- defN 23-Apr-08 07:33 brainpy/math/others.py
--rw-r--r--  2.0 unx     1770 b- defN 23-Apr-08 07:33 brainpy/math/random.py
--rw-r--r--  2.0 unx     1184 b- defN 23-Apr-08 07:33 brainpy/math/surrogate.py
--rw-r--r--  2.0 unx    35100 b- defN 23-Apr-08 07:33 brainpy-2.3.8.dist-info/LICENSE
--rw-r--r--  2.0 unx     4438 b- defN 23-Apr-08 07:33 brainpy-2.3.8.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-08 07:33 brainpy-2.3.8.dist-info/WHEEL
--rw-r--r--  2.0 unx        8 b- defN 23-Apr-08 07:33 brainpy-2.3.8.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx    23762 b- defN 23-Apr-08 07:33 brainpy-2.3.8.dist-info/RECORD
-266 files, 2124651 bytes uncompressed, 503461 bytes compressed:  76.3%
+Zip file size: 545278 bytes, number of entries: 272
+-rw-r--r--  2.0 unx     9247 b- defN 23-Apr-15 13:46 brainpy/__init__.py
+-rw-r--r--  2.0 unx      661 b- defN 23-Apr-15 13:46 brainpy/analysis.py
+-rw-r--r--  2.0 unx     1308 b- defN 23-Apr-15 13:46 brainpy/channels.py
+-rw-r--r--  2.0 unx    18712 b- defN 23-Apr-15 13:46 brainpy/check.py
+-rw-r--r--  2.0 unx      245 b- defN 23-Apr-15 13:46 brainpy/checkpoints.py
+-rw-r--r--  2.0 unx     1243 b- defN 23-Apr-15 13:46 brainpy/connect.py
+-rw-r--r--  2.0 unx      154 b- defN 23-Apr-15 13:46 brainpy/dyn.py
+-rw-r--r--  2.0 unx      324 b- defN 23-Apr-15 13:46 brainpy/encoding.py
+-rw-r--r--  2.0 unx     8306 b- defN 23-Apr-15 13:46 brainpy/errors.py
+-rw-r--r--  2.0 unx      350 b- defN 23-Apr-15 13:46 brainpy/experimental.py
+-rw-r--r--  2.0 unx     1123 b- defN 23-Apr-15 13:46 brainpy/initialize.py
+-rw-r--r--  2.0 unx      335 b- defN 23-Apr-15 13:46 brainpy/inputs.py
+-rw-r--r--  2.0 unx     1890 b- defN 23-Apr-15 13:46 brainpy/layers.py
+-rw-r--r--  2.0 unx      963 b- defN 23-Apr-15 13:46 brainpy/losses.py
+-rw-r--r--  2.0 unx      487 b- defN 23-Apr-15 13:46 brainpy/measure.py
+-rw-r--r--  2.0 unx      119 b- defN 23-Apr-15 13:46 brainpy/modes.py
+-rw-r--r--  2.0 unx     1033 b- defN 23-Apr-15 13:46 brainpy/neurons.py
+-rw-r--r--  2.0 unx     1013 b- defN 23-Apr-15 13:46 brainpy/optim.py
+-rw-r--r--  2.0 unx      303 b- defN 23-Apr-15 13:46 brainpy/rates.py
+-rw-r--r--  2.0 unx      466 b- defN 23-Apr-15 13:46 brainpy/running.py
+-rw-r--r--  2.0 unx      612 b- defN 23-Apr-15 13:46 brainpy/synapses.py
+-rw-r--r--  2.0 unx      180 b- defN 23-Apr-15 13:46 brainpy/synouts.py
+-rw-r--r--  2.0 unx      117 b- defN 23-Apr-15 13:46 brainpy/synplast.py
+-rw-r--r--  2.0 unx       51 b- defN 23-Apr-15 13:46 brainpy/testing.py
+-rw-r--r--  2.0 unx      951 b- defN 23-Apr-15 13:46 brainpy/tools.py
+-rw-r--r--  2.0 unx       72 b- defN 23-Apr-15 13:46 brainpy/train.py
+-rw-r--r--  2.0 unx      241 b- defN 23-Apr-15 13:46 brainpy/types.py
+-rw-r--r--  2.0 unx       24 b- defN 23-Apr-15 13:46 brainpy/_src/__init__.py
+-rw-r--r--  2.0 unx      924 b- defN 23-Apr-15 13:46 brainpy/_src/checking.py
+-rw-r--r--  2.0 unx     1359 b- defN 23-Apr-15 13:46 brainpy/_src/test_check.py
+-rw-r--r--  2.0 unx      976 b- defN 23-Apr-15 13:46 brainpy/_src/types.py
+-rw-r--r--  2.0 unx      846 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/__init__.py
+-rw-r--r--  2.0 unx      156 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/base.py
+-rw-r--r--  2.0 unx     1721 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/constants.py
+-rw-r--r--  2.0 unx     3924 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/plotstyle.py
+-rw-r--r--  2.0 unx     5651 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/stability.py
+-rw-r--r--  2.0 unx       52 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/highdim/__init__.py
+-rw-r--r--  2.0 unx    30953 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/highdim/slow_points.py
+-rw-r--r--  2.0 unx       93 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/lowdim/__init__.py
+-rw-r--r--  2.0 unx    44742 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/lowdim/lowdim_analyzer.py
+-rw-r--r--  2.0 unx    25000 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/lowdim/lowdim_bifurcation.py
+-rw-r--r--  2.0 unx    20273 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/lowdim/lowdim_phase_plane.py
+-rw-r--r--  2.0 unx      199 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/utils/__init__.py
+-rw-r--r--  2.0 unx     2840 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/utils/function.py
+-rw-r--r--  2.0 unx     3054 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/utils/measurement.py
+-rw-r--r--  2.0 unx     5304 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/utils/model.py
+-rw-r--r--  2.0 unx    19554 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/utils/optimization.py
+-rw-r--r--  2.0 unx     5822 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/utils/others.py
+-rw-r--r--  2.0 unx      158 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/utils/outputs.py
+-rw-r--r--  2.0 unx      967 b- defN 23-Apr-15 13:46 brainpy/_src/analysis/utils/visualization.py
+-rw-r--r--  2.0 unx      175 b- defN 23-Apr-15 13:46 brainpy/_src/base/__init__.py
+-rw-r--r--  2.0 unx       24 b- defN 23-Apr-15 13:46 brainpy/_src/base/base.py
+-rw-r--r--  2.0 unx       24 b- defN 23-Apr-15 13:46 brainpy/_src/base/collector.py
+-rw-r--r--  2.0 unx       25 b- defN 23-Apr-15 13:46 brainpy/_src/base/function.py
+-rw-r--r--  2.0 unx      502 b- defN 23-Apr-15 13:46 brainpy/_src/base/io.py
+-rw-r--r--  2.0 unx      305 b- defN 23-Apr-15 13:46 brainpy/_src/base/naming.py
+-rw-r--r--  2.0 unx       24 b- defN 23-Apr-15 13:46 brainpy/_src/checkpoints/__init__.py
+-rw-r--r--  2.0 unx    12240 b- defN 23-Apr-15 13:46 brainpy/_src/checkpoints/io.py
+-rw-r--r--  2.0 unx    57388 b- defN 23-Apr-15 13:46 brainpy/_src/checkpoints/serialization.py
+-rw-r--r--  2.0 unx      268 b- defN 23-Apr-15 13:46 brainpy/_src/connect/__init__.py
+-rw-r--r--  2.0 unx    24303 b- defN 23-Apr-15 13:46 brainpy/_src/connect/base.py
+-rw-r--r--  2.0 unx     4210 b- defN 23-Apr-15 13:46 brainpy/_src/connect/custom_conn.py
+-rw-r--r--  2.0 unx    39149 b- defN 23-Apr-15 13:46 brainpy/_src/connect/random_conn.py
+-rw-r--r--  2.0 unx     9173 b- defN 23-Apr-15 13:46 brainpy/_src/connect/regular_conn.py
+-rw-r--r--  2.0 unx      358 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/__init__.py
+-rw-r--r--  2.0 unx      636 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/_utils.py
+-rw-r--r--  2.0 unx    48544 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/base.py
+-rw-r--r--  2.0 unx     2552 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/context.py
+-rw-r--r--  2.0 unx     9980 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/delay.py
+-rw-r--r--  2.0 unx    24978 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/runners.py
+-rw-r--r--  2.0 unx    10906 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/transform.py
+-rw-r--r--  2.0 unx    40141 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/channels/Ca.py
+-rw-r--r--  2.0 unx     9130 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/channels/IH.py
+-rw-r--r--  2.0 unx    35637 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/channels/K.py
+-rw-r--r--  2.0 unx     4491 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/channels/KCa.py
+-rw-r--r--  2.0 unx    11936 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/channels/Na.py
+-rw-r--r--  2.0 unx      423 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/channels/__init__.py
+-rw-r--r--  2.0 unx     4041 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/channels/base.py
+-rw-r--r--  2.0 unx     2102 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/channels/leaky.py
+-rw-r--r--  2.0 unx      233 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/layers/__init__.py
+-rw-r--r--  2.0 unx      199 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/layers/base.py
+-rw-r--r--  2.0 unx    30203 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/layers/conv.py
+-rw-r--r--  2.0 unx     1472 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/layers/dropout.py
+-rw-r--r--  2.0 unx     1803 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/layers/function.py
+-rw-r--r--  2.0 unx     6975 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/layers/linear.py
+-rw-r--r--  2.0 unx    25691 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/layers/normalization.py
+-rw-r--r--  2.0 unx     6737 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/layers/nvar.py
+-rw-r--r--  2.0 unx    34199 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/layers/pooling.py
+-rw-r--r--  2.0 unx     8906 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/layers/reservoir.py
+-rw-r--r--  2.0 unx    26998 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/layers/rnncells.py
+-rw-r--r--  2.0 unx       24 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/networks/__init__.py
+-rw-r--r--  2.0 unx      252 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/networks/cann.py
+-rw-r--r--  2.0 unx      177 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/neurons/__init__.py
+-rw-r--r--  2.0 unx    48955 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/neurons/biological_models.py
+-rw-r--r--  2.0 unx      595 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/neurons/compat.py
+-rw-r--r--  2.0 unx    13060 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/neurons/fractional_models.py
+-rw-r--r--  2.0 unx     5683 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/neurons/input_groups.py
+-rw-r--r--  2.0 unx     2317 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/neurons/noise_groups.py
+-rw-r--r--  2.0 unx    89375 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/neurons/reduced_models.py
+-rw-r--r--  2.0 unx       52 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/rates/__init__.py
+-rw-r--r--  2.0 unx    41067 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/rates/populations.py
+-rw-r--r--  2.0 unx      223 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synapses/__init__.py
+-rw-r--r--  2.0 unx    36107 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synapses/abstract_models.py
+-rw-r--r--  2.0 unx    21901 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synapses/biological_models.py
+-rw-r--r--  2.0 unx    10252 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synapses/compat.py
+-rw-r--r--  2.0 unx    11139 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synapses/delay_couplings.py
+-rw-r--r--  2.0 unx     2025 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synapses/gap_junction.py
+-rw-r--r--  2.0 unx     9214 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synapses/learning_rules.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synapses_v2/__init__.py
+-rw-r--r--  2.0 unx    13693 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synapses_v2/abstract_synapses.py
+-rw-r--r--  2.0 unx     4651 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synapses_v2/base.py
+-rw-r--r--  2.0 unx     2627 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synapses_v2/others.py
+-rw-r--r--  2.0 unx     2599 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synapses_v2/syn_outs.py
+-rw-r--r--  2.0 unx     4730 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synapses_v2/syn_plasticity.py
+-rw-r--r--  2.0 unx       73 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synouts/__init__.py
+-rw-r--r--  2.0 unx     2636 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synouts/conductances.py
+-rw-r--r--  2.0 unx     3281 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synouts/ions.py
+-rw-r--r--  2.0 unx       62 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synplast/__init__.py
+-rw-r--r--  2.0 unx       24 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synplast/long_term_plasticity.py
+-rw-r--r--  2.0 unx     5324 b- defN 23-Apr-15 13:46 brainpy/_src/dyn/synplast/short_term_plasticity.py
+-rw-r--r--  2.0 unx      114 b- defN 23-Apr-15 13:46 brainpy/_src/encoding/__init__.py
+-rw-r--r--  2.0 unx      364 b- defN 23-Apr-15 13:46 brainpy/_src/encoding/base.py
+-rw-r--r--  2.0 unx     4769 b- defN 23-Apr-15 13:46 brainpy/_src/encoding/stateful_encoding.py
+-rw-r--r--  2.0 unx     2249 b- defN 23-Apr-15 13:46 brainpy/_src/encoding/stateless_encoding.py
+-rw-r--r--  2.0 unx      154 b- defN 23-Apr-15 13:46 brainpy/_src/initialize/__init__.py
+-rw-r--r--  2.0 unx      614 b- defN 23-Apr-15 13:46 brainpy/_src/initialize/base.py
+-rw-r--r--  2.0 unx    11571 b- defN 23-Apr-15 13:46 brainpy/_src/initialize/decay_inits.py
+-rw-r--r--  2.0 unx     9288 b- defN 23-Apr-15 13:46 brainpy/_src/initialize/generic.py
+-rw-r--r--  2.0 unx      554 b- defN 23-Apr-15 13:46 brainpy/_src/initialize/others.py
+-rw-r--r--  2.0 unx    13534 b- defN 23-Apr-15 13:46 brainpy/_src/initialize/random_inits.py
+-rw-r--r--  2.0 unx     2266 b- defN 23-Apr-15 13:46 brainpy/_src/initialize/regular_inits.py
+-rw-r--r--  2.0 unx      173 b- defN 23-Apr-15 13:46 brainpy/_src/inputs/__init__.py
+-rw-r--r--  2.0 unx    11406 b- defN 23-Apr-15 13:46 brainpy/_src/inputs/currents.py
+-rw-r--r--  2.0 unx     1189 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/__init__.py
+-rw-r--r--  2.0 unx     4154 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/base.py
+-rw-r--r--  2.0 unx     2946 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/constants.py
+-rw-r--r--  2.0 unx     8158 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/joint_eq.py
+-rw-r--r--  2.0 unx    11802 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/runner.py
+-rw-r--r--  2.0 unx     4455 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/utils.py
+-rw-r--r--  2.0 unx    15058 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/fde/Caputo.py
+-rw-r--r--  2.0 unx     7233 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/fde/GL.py
+-rw-r--r--  2.0 unx      110 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/fde/__init__.py
+-rw-r--r--  2.0 unx     2771 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/fde/base.py
+-rw-r--r--  2.0 unx     2706 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/fde/generic.py
+-rw-r--r--  2.0 unx      220 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/ode/__init__.py
+-rw-r--r--  2.0 unx    17892 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/ode/adaptive_rk.py
+-rw-r--r--  2.0 unx     4845 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/ode/base.py
+-rw-r--r--  2.0 unx     1493 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/ode/common.py
+-rw-r--r--  2.0 unx    25974 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/ode/explicit_rk.py
+-rw-r--r--  2.0 unx    13764 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/ode/exponential.py
+-rw-r--r--  2.0 unx     4139 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/ode/generic.py
+-rw-r--r--  2.0 unx       24 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/pde/__init__.py
+-rw-r--r--  2.0 unx       98 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/pde/base.py
+-rw-r--r--  2.0 unx      184 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/sde/__init__.py
+-rw-r--r--  2.0 unx     3310 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/sde/base.py
+-rw-r--r--  2.0 unx     3877 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/sde/generic.py
+-rw-r--r--  2.0 unx    24171 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/sde/normal.py
+-rw-r--r--  2.0 unx    17060 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/sde/srk_scalar.py
+-rw-r--r--  2.0 unx    17016 b- defN 23-Apr-15 13:46 brainpy/_src/integrators/sde/srk_strong.py
+-rw-r--r--  2.0 unx      276 b- defN 23-Apr-15 13:46 brainpy/_src/losses/__init__.py
+-rw-r--r--  2.0 unx    22010 b- defN 23-Apr-15 13:46 brainpy/_src/losses/comparison.py
+-rw-r--r--  2.0 unx     2370 b- defN 23-Apr-15 13:46 brainpy/_src/losses/regularization.py
+-rw-r--r--  2.0 unx      792 b- defN 23-Apr-15 13:46 brainpy/_src/losses/utils.py
+-rw-r--r--  2.0 unx     1432 b- defN 23-Apr-15 13:46 brainpy/_src/math/__init__.py
+-rw-r--r--  2.0 unx     1792 b- defN 23-Apr-15 13:46 brainpy/_src/math/_utils.py
+-rw-r--r--  2.0 unx    12797 b- defN 23-Apr-15 13:46 brainpy/_src/math/activations.py
+-rw-r--r--  2.0 unx    29884 b- defN 23-Apr-15 13:46 brainpy/_src/math/compat_numpy.py
+-rw-r--r--  2.0 unx     6488 b- defN 23-Apr-15 13:46 brainpy/_src/math/compat_pytorch.py
+-rw-r--r--  2.0 unx    17877 b- defN 23-Apr-15 13:46 brainpy/_src/math/compat_tensorflow.py
+-rw-r--r--  2.0 unx      911 b- defN 23-Apr-15 13:46 brainpy/_src/math/datatypes.py
+-rw-r--r--  2.0 unx    15918 b- defN 23-Apr-15 13:46 brainpy/_src/math/delayvars.py
+-rw-r--r--  2.0 unx    16825 b- defN 23-Apr-15 13:46 brainpy/_src/math/environment.py
+-rw-r--r--  2.0 unx     1498 b- defN 23-Apr-15 13:46 brainpy/_src/math/fft.py
+-rw-r--r--  2.0 unx     8866 b- defN 23-Apr-15 13:46 brainpy/_src/math/index_tricks.py
+-rw-r--r--  2.0 unx     2523 b- defN 23-Apr-15 13:46 brainpy/_src/math/interoperability.py
+-rw-r--r--  2.0 unx     1792 b- defN 23-Apr-15 13:46 brainpy/_src/math/linalg.py
+-rw-r--r--  2.0 unx     1903 b- defN 23-Apr-15 13:46 brainpy/_src/math/modes.py
+-rw-r--r--  2.0 unx    44595 b- defN 23-Apr-15 13:46 brainpy/_src/math/ndarray.py
+-rw-r--r--  2.0 unx     2255 b- defN 23-Apr-15 13:46 brainpy/_src/math/others.py
+-rw-r--r--  2.0 unx    78521 b- defN 23-Apr-15 13:46 brainpy/_src/math/random.py
+-rw-r--r--  2.0 unx     2119 b- defN 23-Apr-15 13:46 brainpy/_src/math/remove_vmap.py
+-rw-r--r--  2.0 unx      914 b- defN 23-Apr-15 13:46 brainpy/_src/math/object_transform/__init__.py
+-rw-r--r--  2.0 unx     2869 b- defN 23-Apr-15 13:46 brainpy/_src/math/object_transform/_tools.py
+-rw-r--r--  2.0 unx      758 b- defN 23-Apr-15 13:46 brainpy/_src/math/object_transform/_utils.py
+-rw-r--r--  2.0 unx    38682 b- defN 23-Apr-15 13:46 brainpy/_src/math/object_transform/autograd.py
+-rw-r--r--  2.0 unx    22499 b- defN 23-Apr-15 13:46 brainpy/_src/math/object_transform/base.py
+-rw-r--r--  2.0 unx     5581 b- defN 23-Apr-15 13:46 brainpy/_src/math/object_transform/collectors.py
+-rw-r--r--  2.0 unx    27560 b- defN 23-Apr-15 13:46 brainpy/_src/math/object_transform/controls.py
+-rw-r--r--  2.0 unx     2999 b- defN 23-Apr-15 13:46 brainpy/_src/math/object_transform/function.py
+-rw-r--r--  2.0 unx    15077 b- defN 23-Apr-15 13:46 brainpy/_src/math/object_transform/jit.py
+-rw-r--r--  2.0 unx     1637 b- defN 23-Apr-15 13:46 brainpy/_src/math/object_transform/naming.py
+-rw-r--r--  2.0 unx    17774 b- defN 23-Apr-15 13:46 brainpy/_src/math/object_transform/parallels.py
+-rw-r--r--  2.0 unx    12059 b- defN 23-Apr-15 13:46 brainpy/_src/math/object_transform/variables.py
+-rw-r--r--  2.0 unx      208 b- defN 23-Apr-15 13:46 brainpy/_src/math/operators/__init__.py
+-rw-r--r--  2.0 unx     1857 b- defN 23-Apr-15 13:46 brainpy/_src/math/operators/event_ops.py
+-rw-r--r--  2.0 unx    17399 b- defN 23-Apr-15 13:46 brainpy/_src/math/operators/jitconn_ops.py
+-rw-r--r--  2.0 unx     3774 b- defN 23-Apr-15 13:46 brainpy/_src/math/operators/op_registers.py
+-rw-r--r--  2.0 unx    17347 b- defN 23-Apr-15 13:46 brainpy/_src/math/operators/pre_syn_post.py
+-rw-r--r--  2.0 unx     9941 b- defN 23-Apr-15 13:46 brainpy/_src/math/operators/sparse_ops.py
+-rw-r--r--  2.0 unx       77 b- defN 23-Apr-15 13:46 brainpy/_src/math/surrogate/__init__.py
+-rw-r--r--  2.0 unx     3665 b- defN 23-Apr-15 13:46 brainpy/_src/math/surrogate/_utils.py
+-rw-r--r--  2.0 unx     7216 b- defN 23-Apr-15 13:46 brainpy/_src/math/surrogate/compt.py
+-rw-r--r--  2.0 unx    40745 b- defN 23-Apr-15 13:46 brainpy/_src/math/surrogate/one_input.py
+-rw-r--r--  2.0 unx     1492 b- defN 23-Apr-15 13:46 brainpy/_src/math/surrogate/two_inputs.py
+-rw-r--r--  2.0 unx      287 b- defN 23-Apr-15 13:46 brainpy/_src/measure/__init__.py
+-rw-r--r--  2.0 unx    10102 b- defN 23-Apr-15 13:46 brainpy/_src/measure/correlation.py
+-rw-r--r--  2.0 unx     1770 b- defN 23-Apr-15 13:46 brainpy/_src/measure/firings.py
+-rw-r--r--  2.0 unx     3896 b- defN 23-Apr-15 13:46 brainpy/_src/measure/lfp.py
+-rw-r--r--  2.0 unx       75 b- defN 23-Apr-15 13:46 brainpy/_src/optimizers/__init__.py
+-rw-r--r--  2.0 unx    41331 b- defN 23-Apr-15 13:46 brainpy/_src/optimizers/optimizer.py
+-rw-r--r--  2.0 unx    13240 b- defN 23-Apr-15 13:46 brainpy/_src/optimizers/scheduler.py
+-rw-r--r--  2.0 unx      525 b- defN 23-Apr-15 13:46 brainpy/_src/running/__init__.py
+-rw-r--r--  2.0 unx      269 b- defN 23-Apr-15 13:46 brainpy/_src/running/constants.py
+-rw-r--r--  2.0 unx     4913 b- defN 23-Apr-15 13:46 brainpy/_src/running/jax_multiprocessing.py
+-rw-r--r--  2.0 unx     2976 b- defN 23-Apr-15 13:46 brainpy/_src/running/native_multiprocessing.py
+-rw-r--r--  2.0 unx     6995 b- defN 23-Apr-15 13:46 brainpy/_src/running/pathos_multiprocessing.py
+-rw-r--r--  2.0 unx     9777 b- defN 23-Apr-15 13:46 brainpy/_src/running/runner.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-15 13:46 brainpy/_src/testing/__init__.py
+-rw-r--r--  2.0 unx      347 b- defN 23-Apr-15 13:46 brainpy/_src/testing/base.py
+-rw-r--r--  2.0 unx      159 b- defN 23-Apr-15 13:46 brainpy/_src/tools/__init__.py
+-rw-r--r--  2.0 unx     7326 b- defN 23-Apr-15 13:46 brainpy/_src/tools/codes.py
+-rw-r--r--  2.0 unx     5882 b- defN 23-Apr-15 13:46 brainpy/_src/tools/dicts.py
+-rw-r--r--  2.0 unx      223 b- defN 23-Apr-15 13:46 brainpy/_src/tools/math_util.py
+-rw-r--r--  2.0 unx     4424 b- defN 23-Apr-15 13:46 brainpy/_src/tools/others.py
+-rw-r--r--  2.0 unx     1406 b- defN 23-Apr-15 13:46 brainpy/_src/tools/package.py
+-rw-r--r--  2.0 unx      659 b- defN 23-Apr-15 13:46 brainpy/_src/train/__init__.py
+-rw-r--r--  2.0 unx     1972 b- defN 23-Apr-15 13:46 brainpy/_src/train/_utils.py
+-rw-r--r--  2.0 unx    24073 b- defN 23-Apr-15 13:46 brainpy/_src/train/back_propagation.py
+-rw-r--r--  2.0 unx     2980 b- defN 23-Apr-15 13:46 brainpy/_src/train/base.py
+-rw-r--r--  2.0 unx    10036 b- defN 23-Apr-15 13:46 brainpy/_src/train/offline.py
+-rw-r--r--  2.0 unx    10373 b- defN 23-Apr-15 13:46 brainpy/_src/train/online.py
+-rw-r--r--  2.0 unx       77 b- defN 23-Apr-15 13:46 brainpy/_src/visualization/__init__.py
+-rw-r--r--  2.0 unx     3544 b- defN 23-Apr-15 13:46 brainpy/_src/visualization/base.py
+-rw-r--r--  2.0 unx      841 b- defN 23-Apr-15 13:46 brainpy/_src/visualization/figures.py
+-rw-r--r--  2.0 unx    14603 b- defN 23-Apr-15 13:46 brainpy/_src/visualization/plots.py
+-rw-r--r--  2.0 unx     1026 b- defN 23-Apr-15 13:46 brainpy/_src/visualization/styles.py
+-rw-r--r--  2.0 unx       90 b- defN 23-Apr-15 13:46 brainpy/algorithms/__init__.py
+-rw-r--r--  2.0 unx    17344 b- defN 23-Apr-15 13:46 brainpy/algorithms/offline.py
+-rw-r--r--  2.0 unx     6284 b- defN 23-Apr-15 13:46 brainpy/algorithms/online.py
+-rw-r--r--  2.0 unx     2656 b- defN 23-Apr-15 13:46 brainpy/algorithms/utils.py
+-rw-r--r--  2.0 unx      128 b- defN 23-Apr-15 13:46 brainpy/integrators/__init__.py
+-rw-r--r--  2.0 unx      576 b- defN 23-Apr-15 13:46 brainpy/integrators/fde.py
+-rw-r--r--  2.0 unx     1061 b- defN 23-Apr-15 13:46 brainpy/integrators/ode.py
+-rw-r--r--  2.0 unx      679 b- defN 23-Apr-15 13:46 brainpy/integrators/sde.py
+-rw-r--r--  2.0 unx     1561 b- defN 23-Apr-15 13:46 brainpy/math/__init__.py
+-rw-r--r--  2.0 unx      612 b- defN 23-Apr-15 13:46 brainpy/math/activations.py
+-rw-r--r--  2.0 unx     8074 b- defN 23-Apr-15 13:46 brainpy/math/compat_numpy.py
+-rw-r--r--  2.0 unx      469 b- defN 23-Apr-15 13:46 brainpy/math/compat_pytorch.py
+-rw-r--r--  2.0 unx      932 b- defN 23-Apr-15 13:46 brainpy/math/compat_tensorflow.py
+-rw-r--r--  2.0 unx      498 b- defN 23-Apr-15 13:46 brainpy/math/datatypes.py
+-rw-r--r--  2.0 unx      255 b- defN 23-Apr-15 13:46 brainpy/math/delayvars.py
+-rw-r--r--  2.0 unx      943 b- defN 23-Apr-15 13:46 brainpy/math/environment.py
+-rw-r--r--  2.0 unx       89 b- defN 23-Apr-15 13:46 brainpy/math/event_ops.py
+-rw-r--r--  2.0 unx      402 b- defN 23-Apr-15 13:46 brainpy/math/fft.py
+-rw-r--r--  2.0 unx      217 b- defN 23-Apr-15 13:46 brainpy/math/interoperability.py
+-rw-r--r--  2.0 unx      379 b- defN 23-Apr-15 13:46 brainpy/math/jitconn_ops.py
+-rw-r--r--  2.0 unx      470 b- defN 23-Apr-15 13:46 brainpy/math/linalg.py
+-rw-r--r--  2.0 unx      292 b- defN 23-Apr-15 13:46 brainpy/math/modes.py
+-rw-r--r--  2.0 unx      150 b- defN 23-Apr-15 13:46 brainpy/math/ndarray.py
+-rw-r--r--  2.0 unx      909 b- defN 23-Apr-15 13:46 brainpy/math/object_base.py
+-rw-r--r--  2.0 unx      651 b- defN 23-Apr-15 13:46 brainpy/math/object_transform.py
+-rw-r--r--  2.0 unx      137 b- defN 23-Apr-15 13:46 brainpy/math/op_register.py
+-rw-r--r--  2.0 unx      257 b- defN 23-Apr-15 13:46 brainpy/math/others.py
+-rw-r--r--  2.0 unx      336 b- defN 23-Apr-15 13:46 brainpy/math/pre_syn_post.py
+-rw-r--r--  2.0 unx     1770 b- defN 23-Apr-15 13:46 brainpy/math/random.py
+-rw-r--r--  2.0 unx      175 b- defN 23-Apr-15 13:46 brainpy/math/sparse_ops.py
+-rw-r--r--  2.0 unx     1184 b- defN 23-Apr-15 13:46 brainpy/math/surrogate.py
+-rw-r--r--  2.0 unx    35100 b- defN 23-Apr-15 13:46 brainpy-2.4.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     4489 b- defN 23-Apr-15 13:46 brainpy-2.4.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Apr-15 13:46 brainpy-2.4.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        8 b- defN 23-Apr-15 13:46 brainpy-2.4.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx    24315 b- defN 23-Apr-15 13:46 brainpy-2.4.0.dist-info/RECORD
+272 files, 2131267 bytes uncompressed, 506720 bytes compressed:  76.2%
```

## zipnote {}

```diff
@@ -492,17 +492,14 @@
 
 Filename: brainpy/_src/math/_utils.py
 Comment: 
 
 Filename: brainpy/_src/math/activations.py
 Comment: 
 
-Filename: brainpy/_src/math/arrayinterporate.py
-Comment: 
-
 Filename: brainpy/_src/math/compat_numpy.py
 Comment: 
 
 Filename: brainpy/_src/math/compat_pytorch.py
 Comment: 
 
 Filename: brainpy/_src/math/compat_tensorflow.py
@@ -519,14 +516,17 @@
 
 Filename: brainpy/_src/math/fft.py
 Comment: 
 
 Filename: brainpy/_src/math/index_tricks.py
 Comment: 
 
+Filename: brainpy/_src/math/interoperability.py
+Comment: 
+
 Filename: brainpy/_src/math/linalg.py
 Comment: 
 
 Filename: brainpy/_src/math/modes.py
 Comment: 
 
 Filename: brainpy/_src/math/ndarray.py
@@ -540,38 +540,47 @@
 
 Filename: brainpy/_src/math/remove_vmap.py
 Comment: 
 
 Filename: brainpy/_src/math/object_transform/__init__.py
 Comment: 
 
-Filename: brainpy/_src/math/object_transform/_utils.py
+Filename: brainpy/_src/math/object_transform/_tools.py
 Comment: 
 
-Filename: brainpy/_src/math/object_transform/abstract.py
+Filename: brainpy/_src/math/object_transform/_utils.py
 Comment: 
 
 Filename: brainpy/_src/math/object_transform/autograd.py
 Comment: 
 
 Filename: brainpy/_src/math/object_transform/base.py
 Comment: 
 
+Filename: brainpy/_src/math/object_transform/collectors.py
+Comment: 
+
 Filename: brainpy/_src/math/object_transform/controls.py
 Comment: 
 
 Filename: brainpy/_src/math/object_transform/function.py
 Comment: 
 
 Filename: brainpy/_src/math/object_transform/jit.py
 Comment: 
 
+Filename: brainpy/_src/math/object_transform/naming.py
+Comment: 
+
 Filename: brainpy/_src/math/object_transform/parallels.py
 Comment: 
 
+Filename: brainpy/_src/math/object_transform/variables.py
+Comment: 
+
 Filename: brainpy/_src/math/operators/__init__.py
 Comment: 
 
 Filename: brainpy/_src/math/operators/event_ops.py
 Comment: 
 
 Filename: brainpy/_src/math/operators/jitconn_ops.py
@@ -654,17 +663,14 @@
 
 Filename: brainpy/_src/tools/dicts.py
 Comment: 
 
 Filename: brainpy/_src/tools/math_util.py
 Comment: 
 
-Filename: brainpy/_src/tools/naming.py
-Comment: 
-
 Filename: brainpy/_src/tools/others.py
 Comment: 
 
 Filename: brainpy/_src/tools/package.py
 Comment: 
 
 Filename: brainpy/_src/train/__init__.py
@@ -726,17 +732,14 @@
 
 Filename: brainpy/math/__init__.py
 Comment: 
 
 Filename: brainpy/math/activations.py
 Comment: 
 
-Filename: brainpy/math/arrayinterporate.py
-Comment: 
-
 Filename: brainpy/math/compat_numpy.py
 Comment: 
 
 Filename: brainpy/math/compat_pytorch.py
 Comment: 
 
 Filename: brainpy/math/compat_tensorflow.py
@@ -747,17 +750,26 @@
 
 Filename: brainpy/math/delayvars.py
 Comment: 
 
 Filename: brainpy/math/environment.py
 Comment: 
 
+Filename: brainpy/math/event_ops.py
+Comment: 
+
 Filename: brainpy/math/fft.py
 Comment: 
 
+Filename: brainpy/math/interoperability.py
+Comment: 
+
+Filename: brainpy/math/jitconn_ops.py
+Comment: 
+
 Filename: brainpy/math/linalg.py
 Comment: 
 
 Filename: brainpy/math/modes.py
 Comment: 
 
 Filename: brainpy/math/ndarray.py
@@ -765,35 +777,41 @@
 
 Filename: brainpy/math/object_base.py
 Comment: 
 
 Filename: brainpy/math/object_transform.py
 Comment: 
 
-Filename: brainpy/math/operators.py
+Filename: brainpy/math/op_register.py
 Comment: 
 
 Filename: brainpy/math/others.py
 Comment: 
 
+Filename: brainpy/math/pre_syn_post.py
+Comment: 
+
 Filename: brainpy/math/random.py
 Comment: 
 
+Filename: brainpy/math/sparse_ops.py
+Comment: 
+
 Filename: brainpy/math/surrogate.py
 Comment: 
 
-Filename: brainpy-2.3.8.dist-info/LICENSE
+Filename: brainpy-2.4.0.dist-info/LICENSE
 Comment: 
 
-Filename: brainpy-2.3.8.dist-info/METADATA
+Filename: brainpy-2.4.0.dist-info/METADATA
 Comment: 
 
-Filename: brainpy-2.3.8.dist-info/WHEEL
+Filename: brainpy-2.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: brainpy-2.3.8.dist-info/top_level.txt
+Filename: brainpy-2.4.0.dist-info/top_level.txt
 Comment: 
 
-Filename: brainpy-2.3.8.dist-info/RECORD
+Filename: brainpy-2.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## brainpy/__init__.py

```diff
@@ -1,10 +1,10 @@
 # -*- coding: utf-8 -*-
 
-__version__ = "2.3.8"
+__version__ = "2.4.0"
 
 
 # fundamental supporting modules
 from brainpy import errors, check, tools
 
 
 #  Part 1: Math Foundation  #
@@ -128,65 +128,60 @@
 ode.__dict__['odeint'] = odeint
 sde.__dict__['sdeint'] = sdeint
 fde.__dict__['fdeint'] = fdeint
 
 
 # deprecated
 from brainpy._src.math.object_transform.base import (Base as Base,
-                                                     DynVarCollector,
+                                                     ArrayCollector,
                                                      Collector as Collector, )
-globals()['ArrayCollector'] = DynVarCollector
-globals()['TensorCollector'] = DynVarCollector
+globals()['TensorCollector'] = ArrayCollector
 
 train.__dict__['DSTrainer'] = DSTrainer
 train.__dict__['BPTT'] = BPTT
 train.__dict__['BPFF'] = BPFF
 train.__dict__['OnlineTrainer'] = OnlineTrainer
 train.__dict__['ForceTrainer'] = ForceTrainer
 train.__dict__['OfflineTrainer'] = OfflineTrainer
 train.__dict__['RidgeTrainer'] = RidgeTrainer
 
 
 from ._src import base
 base.base.__dict__['BrainPyObject'] = BrainPyObject
 base.base.__dict__['Base'] = Base
 base.collector.__dict__['Collector'] = Collector
-base.collector.__dict__['ArrayCollector'] = DynVarCollector
-base.collector.__dict__['TensorCollector'] = DynVarCollector
+base.collector.__dict__['ArrayCollector'] = ArrayCollector
+base.collector.__dict__['TensorCollector'] = ArrayCollector
 base.function.__dict__['FunAsObject'] = math.FunAsObject
 base.function.__dict__['Function'] = math.FunAsObject
 base.io.__dict__['save_as_h5'] = checkpoints.io.save_as_h5
 base.io.__dict__['save_as_npz'] = checkpoints.io.save_as_npz
 base.io.__dict__['save_as_pkl'] = checkpoints.io.save_as_pkl
 base.io.__dict__['save_as_mat'] = checkpoints.io.save_as_mat
 base.io.__dict__['load_by_h5'] = checkpoints.io.load_by_h5
 base.io.__dict__['load_by_npz'] = checkpoints.io.load_by_npz
 base.io.__dict__['load_by_pkl'] = checkpoints.io.load_by_pkl
 base.io.__dict__['load_by_mat'] = checkpoints.io.load_by_mat
-base.naming.__dict__['check_name_uniqueness'] = tools.check_name_uniqueness
-base.naming.__dict__['clear_name_cache'] = tools.clear_name_cache
-base.naming.__dict__['get_unique_name'] = tools.get_unique_name
+base.naming.__dict__['clear_name_cache'] = math.clear_name_cache
 base.__dict__['BrainPyObject'] = BrainPyObject
 base.__dict__['Base'] = Base
 base.__dict__['Collector'] = Collector
-base.__dict__['ArrayCollector'] = DynVarCollector
-base.__dict__['TensorCollector'] = DynVarCollector
+base.__dict__['ArrayCollector'] = ArrayCollector
+base.__dict__['TensorCollector'] = ArrayCollector
 base.__dict__['FunAsObject'] = math.FunAsObject
 base.__dict__['Function'] = math.FunAsObject
 base.__dict__['save_as_h5'] = checkpoints.io.save_as_h5
 base.__dict__['save_as_npz'] = checkpoints.io.save_as_npz
 base.__dict__['save_as_pkl'] = checkpoints.io.save_as_pkl
 base.__dict__['save_as_mat'] = checkpoints.io.save_as_mat
 base.__dict__['load_by_h5'] = checkpoints.io.load_by_h5
 base.__dict__['load_by_npz'] = checkpoints.io.load_by_npz
 base.__dict__['load_by_pkl'] = checkpoints.io.load_by_pkl
 base.__dict__['load_by_mat'] = checkpoints.io.load_by_mat
-base.__dict__['check_name_uniqueness'] = tools.check_name_uniqueness
-base.__dict__['clear_name_cache'] = tools.clear_name_cache
-base.__dict__['get_unique_name'] = tools.get_unique_name
+base.__dict__['clear_name_cache'] = math.clear_name_cache
 
 
 from . import modes
 modes.__dict__['Mode'] = math.Mode
 modes.__dict__['NormalMode'] = math.NonBatchingMode
 modes.__dict__['BatchingMode'] = math.BatchingMode
 modes.__dict__['TrainingMode'] = math.TrainingMode
@@ -248,8 +243,9 @@
 dyn.__dict__['AlphaCOBA'] = compat.AlphaCOBA
 dyn.__dict__['NMDA'] = compat.NMDA
 del compat
 
 
 from brainpy._src import checking
 tools.__dict__['checking'] = checking
+tools.__dict__['clear_name_cache'] = math.clear_name_cache
 del checking
```

## brainpy/check.py

```diff
@@ -552,16 +552,16 @@
   else:
     raise KeyError
 
 
 def is_all_vars(dyn_vars: Any, out_as: str = 'tuple'):
   global var_obs
   if var_obs is None:
-    from brainpy.math import Variable, ListVar, DictVar
-    var_obs = (ListVar, DictVar, Variable)
+    from brainpy.math import Variable, VarList, VarDict
+    var_obs = (VarList, VarDict, Variable)
 
   return is_elem_or_seq_or_dict(dyn_vars, var_obs, out_as)
 
 
 def is_all_objs(targets: Any, out_as: str = 'tuple'):
   global BrainPyObject
   if BrainPyObject is None:
```

## brainpy/dyn.py

```diff
@@ -1,10 +1,10 @@
 # -*- coding: utf-8 -*-
 
 """
 Deprecated. Use ``brainpy.xxx`` instead.
 """
 
-from . import neurons, synouts, synapses, synplast, layers, rates
+from . import neurons, synouts, synapses, synplast, layers, rates, channels
```

## brainpy/tools.py

```diff
@@ -1,9 +1,10 @@
 # -*- coding: utf-8 -*-
 
+
 from brainpy._src.tools.codes import (
   repr_object as repr_object,
   repr_context as repr_context,
   copy_doc as copy_doc,
   code_lines_to_func as code_lines_to_func,
   get_identifiers as get_identifiers,
   indent as indent,
@@ -34,12 +35,7 @@
   not_customized as not_customized,
   to_size as to_size,
   size2num as size2num,
   timeout as timeout,
   init_progress_bar as init_progress_bar,
 )
 
-from brainpy._src.tools.naming import (
-  check_name_uniqueness as check_name_uniqueness,
-  get_unique_name as get_unique_name,
-  clear_name_cache as clear_name_cache,
-)
```

## brainpy/_src/types.py

```diff
@@ -1,15 +1,16 @@
 # -*- coding: utf-8 -*-
 
 from typing import TypeVar, Tuple, Union, Callable
 
 import jax.numpy as jnp
 import numpy as np
 
-from brainpy._src.math.ndarray import Array, Variable, TrainVar
+from brainpy._src.math.ndarray import Array
+from brainpy._src.math.object_transform import Variable, TrainVar
 from brainpy._src import connect as conn
 from brainpy._src import initialize as init
 
 __all__ = [
   'ArrayType', 'Parameter', 'PyTree',
   'Shape', 'Initializer',
   'Output', 'Monitor'
```

## brainpy/_src/analysis/highdim/slow_points.py

```diff
@@ -2,20 +2,20 @@
 
 import math
 import time
 from typing import Callable, Union, Dict, Sequence, Tuple
 
 import jax.numpy as jnp
 import numpy as np
-from jax import vmap
+import jax
 from jax.scipy.optimize import minimize
 from jax.tree_util import tree_flatten, tree_map
 
 import brainpy._src.math as bm
-from brainpy import optimizers as optim, losses
+from brainpy import optim, losses
 from brainpy._src.analysis import utils, base, constants
 from brainpy._src.dyn.base import DynamicalSystem
 from brainpy._src.dyn.runners import check_and_format_inputs, _f_ops
 from brainpy._src.tools.dicts import DotDict
 from brainpy.errors import AnalyzerError, UnsupportedError
 from brainpy.types import ArrayType
 
@@ -128,19 +128,19 @@
     # static arguments
     if not isinstance(args, tuple):
       raise ValueError(f'args must be an instance of tuple, but we got {type(args)}')
     self.args = args
 
     # update function
     if target_vars is None:
-      self.target_vars = bm.DynVarCollector()
+      self.target_vars = bm.ArrayCollector()
     else:
       if not isinstance(target_vars, dict):
         raise TypeError(f'"target_vars" must be a dict but we got {type(target_vars)}')
-      self.target_vars = bm.DynVarCollector(target_vars)
+      self.target_vars = bm.ArrayCollector(target_vars)
     excluded_vars = () if excluded_vars is None else excluded_vars
     if isinstance(excluded_vars, dict):
       excluded_vars = tuple(excluded_vars.values())
     if not isinstance(excluded_vars, (tuple, list)):
       raise TypeError(f'"excluded_vars" must be a sequence but we got {type(excluded_vars)}')
     for v in excluded_vars:
       if not isinstance(v, bm.Variable):
@@ -230,14 +230,16 @@
     self.verbose = verbose
     self.f_type = f_type
 
     # loss functon
     if f_loss_batch is not None:
       raise UnsupportedError('"f_loss_batch" is no longer supported, please '
                              'use "f_loss" instead.')
+    if fun_inputs is not None:
+      raise UnsupportedError('"fun_inputs" is no longer supported.')
     if f_loss is None:
       f_loss = losses.mean_squared_error if f_type == constants.DISCRETE else losses.mean_square
     self.f_loss = f_loss
 
     # essential variables
     self._losses = None
     self._fixed_points = None
@@ -333,31 +335,29 @@
     num_candidate = self._check_candidates(candidates)
     if not (isinstance(candidates, (bm.ndarray, jnp.ndarray, np.ndarray)) or isinstance(candidates, dict)):
       raise ValueError('Candidates must be instance of ArrayType or dict of ArrayType.')
     fixed_points = tree_map(lambda a: bm.TrainVar(a), candidates, is_leaf=lambda x: isinstance(x, bm.Array))
     f_eval_loss = self._get_f_eval_loss()
 
     def f_loss():
-      return f_eval_loss(tree_map(lambda a: bm.as_device_array(a),
+      return f_eval_loss(tree_map(lambda a: bm.as_jax(a),
                                   fixed_points,
                                   is_leaf=lambda x: isinstance(x, bm.Array))).mean()
 
     grad_f = bm.grad(f_loss, grad_vars=fixed_points, return_value=True)
     optimizer.register_train_vars(fixed_points if isinstance(fixed_points, dict) else {'a': fixed_points})
-    dyn_vars = optimizer.vars() + (fixed_points if isinstance(fixed_points, dict) else {'a': fixed_points})
-    dyn_vars = dyn_vars.unique()
 
     def train(idx):
       gradients, loss = grad_f()
       optimizer.update(gradients if isinstance(gradients, dict) else {'a': gradients})
       optimizer.lr.step_epoch()
       return loss
 
     def batch_train(start_i, n_batch):
-      return bm.for_loop(train, bm.arange(start_i, start_i + n_batch), dyn_vars=dyn_vars)
+      return bm.for_loop(train, bm.arange(start_i, start_i + n_batch))
 
     # Run the optimization
     if self.verbose:
       print(f"Optimizing with {optimizer} to find fixed points:")
     opt_losses = []
     do_stop = False
     num_opt_loops = int(num_opt / num_batch)
@@ -379,18 +379,18 @@
         do_stop = True
         if self.verbose:
           print(f'    '
                 f'Stop optimization as mean training loss {train_losses[-1]:0.10f} '
                 f'is below tolerance {tolerance:0.10f}.')
 
     self._opt_losses = jnp.concatenate(opt_losses)
-    self._losses = f_eval_loss(tree_map(lambda a: bm.as_device_array(a),
+    self._losses = f_eval_loss(tree_map(lambda a: bm.as_jax(a),
                                         fixed_points,
                                         is_leaf=lambda x: isinstance(x, bm.Array)))
-    self._fixed_points = tree_map(lambda a: bm.as_device_array(a),
+    self._fixed_points = tree_map(lambda a: bm.as_jax(a),
                                   fixed_points,
                                   is_leaf=lambda x: isinstance(x, bm.Array))
     self._selected_ids = jnp.arange(num_candidate)
 
     if isinstance(self.target, DynamicalSystem):
       for k, v in self.excluded_vars.items():
         v.value = self.excluded_data[k]
@@ -420,17 +420,15 @@
       self._opt_functions[F_OPT_SOLVER] = self._get_f_for_opt_solver(candidates, SUPPORTED_OPT_SOLVERS[opt_solver])
     f_opt = self._opt_functions[F_OPT_SOLVER]
 
     if self.verbose:
       print(f"Optimizing with {opt_solver} to find fixed points:")
 
     # optimizing
-    res = f_opt(tree_map(lambda a: bm.as_device_array(a),
-                         candidates,
-                         is_leaf=lambda a: isinstance(a, bm.Array)))
+    res = f_opt(tree_map(lambda a: bm.as_jax(a), candidates, is_leaf=lambda a: isinstance(a, bm.Array)))
 
     # results
     valid_ids = jnp.where(res.success)[0]
     fixed_points = res.x[valid_ids]
     if isinstance(candidates, dict):
       indices = [0]
       for v in candidates.values():
@@ -662,56 +660,56 @@
     if name not in self._opt_functions:
       self._opt_functions[name] = self._generate_f_eval_loss()
     return self._opt_functions[name]
 
   def _generate_f_eval_loss(self):
     # evaluate losses of a batch of inputs
     if self.f_type == constants.DISCRETE:
-      f_eval_loss = lambda h: self.f_loss(h, vmap(self.f_cell)(h), axis=1)
+      f_eval_loss = lambda h: self.f_loss(h, jax.vmap(self.f_cell)(h), axis=1)
     else:
-      f_eval_loss = lambda h: self.f_loss(vmap(self.f_cell)(h), axis=1)
+      f_eval_loss = lambda h: self.f_loss(jax.vmap(self.f_cell)(h), axis=1)
 
     if isinstance(self.target, DynamicalSystem):
-      @bm.jit
+      @jax.jit
       def loss_func(h):
         r = f_eval_loss(h)
         for k, v in self.excluded_vars.items():
           v.value = self.excluded_data[k]
         for k, v in self.target_vars.items():
           v.value = self.target_data[k]
         return r
 
       return loss_func
     else:
-      return bm.jit(f_eval_loss)
+      return jax.jit(f_eval_loss)
 
   def _get_f_for_opt_solver(self, candidates, opt_method):
     # loss function
     if self.f_type == constants.DISCRETE:
       # overall loss function for fixed points optimization
       if isinstance(candidates, dict):
         keys = tuple(self.target_vars.keys())
         indices = [0]
         for v in self.target_vars.values():
           indices.append(v.shape[0])
         indices = np.cumsum(indices)
 
         def f_loss(h):
           h = {key: h[indices[i]: indices[i + 1]] for i, key in enumerate(keys)}
-          return bm.as_device_array(self.f_loss(h, self.f_cell(h)))
+          return bm.as_jax(self.f_loss(h, self.f_cell(h)))
       else:
         def f_loss(h):
-          return bm.as_device_array(self.f_loss(h, self.f_cell(h)))
+          return bm.as_jax(self.f_loss(h, self.f_cell(h)))
     else:
       # overall loss function for fixed points optimization
       def f_loss(h):
         return self.f_loss(self.f_cell(h))
 
-    @bm.jit
-    @vmap
+    @jax.jit
+    @jax.vmap
     def f_opt(x0):
       for k, v in self.target_vars.items():
         v.value = x0[k] if (v.batch_axis is None) else jnp.expand_dims(x0[k], axis=v.batch_axis)
       for k, v in self.excluded_vars.items():
         v.value = self.excluded_data[k]
       if isinstance(x0, dict):
         x0 = jnp.concatenate(tuple(x0.values()))
@@ -781,15 +779,15 @@
       def jacob(x0):
         x0 = {k: x0[indices[i]:indices[i + 1]] for i, k in enumerate(self.target_vars.keys())}
         r = self.f_cell(x0)
         return jnp.concatenate(list(r.values()))
     else:
       jacob = self.f_cell
 
-    f_jac = bm.jit(vmap(bm.jacobian(jacob)))
+    f_jac = jax.jit(jax.vmap(bm.jacobian(jacob)))
 
     if isinstance(self.target, DynamicalSystem):
       def jacobian_func(x):
         r = f_jac(x)
         for k, v in self.excluded_vars.items():
           v.value = self.excluded_data[k]
         for k, v in self.target_vars.items():
```

## brainpy/_src/analysis/lowdim/lowdim_analyzer.py

```diff
@@ -1,13 +1,14 @@
 # -*- coding: utf-8 -*-
 
 import warnings
 from functools import partial
 
 import numpy as np
+import jax
 from jax import numpy as jnp
 from jax import vmap
 from jax.scipy.optimize import minimize
 
 from brainpy import errors, tools
 import brainpy._src.math as bm
 from brainpy._src.math.object_transform.base import Collector
@@ -270,29 +271,29 @@
     if C.F_fx not in self.analyzed_results:
       _, arguments = utils.get_args(self.model.f_derivatives[self.x_var])
       wrapper = utils.std_derivative(arguments, self.target_var_names, self.target_par_names)
       f = wrapper(self.model.f_derivatives[self.x_var])
       f = partial(f, **(self.pars_update + self.fixed_vars))
       f = utils.f_without_jaxarray_return(f)
       f = utils.remove_return_shape(f)
-      self.analyzed_results[C.F_fx] = bm.jit(f, device=self.jit_device)
+      self.analyzed_results[C.F_fx] = jax.jit(f, device=self.jit_device)
     return self.analyzed_results[C.F_fx]
 
   @property
   def F_vmap_fx(self):
     if C.F_vmap_fx not in self.analyzed_results:
-      self.analyzed_results[C.F_vmap_fx] = bm.jit(vmap(self.F_fx), device=self.jit_device)
+      self.analyzed_results[C.F_vmap_fx] = jax.jit(vmap(self.F_fx), device=self.jit_device)
     return self.analyzed_results[C.F_vmap_fx]
 
   @property
   def F_dfxdx(self):
     """The function to evaluate :math:`\frac{df_x(*\mathrm{vars}, *\mathrm{pars})}{dx}`."""
     if C.F_dfxdx not in self.analyzed_results:
       dfx = bm.vector_grad(self.F_fx, argnums=0)
-      self.analyzed_results[C.F_dfxdx] = bm.jit(dfx, device=self.jit_device)
+      self.analyzed_results[C.F_dfxdx] = jax.jit(dfx, device=self.jit_device)
     return self.analyzed_results[C.F_dfxdx]
 
   @property
   def F_fixed_point_aux(self):
     if C.F_fixed_point_aux not in self.analyzed_results:
       def aux_fun(x, *args):
         return jnp.abs(self.F_fx(x, *args)).sum()
@@ -303,15 +304,15 @@
   @property
   def F_vmap_fp_aux(self):
     if C.F_vmap_fp_aux not in self.analyzed_results:
       # The arguments of this function are:
       # ---
       # "X": a two-dimensional matrix: (num_batch, num_var)
       # "args": a list of one-dimensional vectors, each has the shape of (num_batch,)
-      self.analyzed_results[C.F_vmap_fp_aux] = bm.jit(vmap(self.F_fixed_point_aux))
+      self.analyzed_results[C.F_vmap_fp_aux] = jax.jit(vmap(self.F_fixed_point_aux))
     return self.analyzed_results[C.F_vmap_fp_aux]
 
   @property
   def F_fixed_point_opt(self):
     if C.F_fixed_point_opt not in self.analyzed_results:
       def f(start_and_end, *args):
         return utils.jax_brentq(self.F_fx)(start_and_end[0], start_and_end[1], args)
@@ -322,15 +323,15 @@
   @property
   def F_vmap_fp_opt(self):
     if C.F_vmap_fp_opt not in self.analyzed_results:
       # The arguments of this function are:
       # ---
       # "X": a two-dimensional matrix: (num_batch, num_var)
       # "args": a list of one-dimensional vectors, each has the shape of (num_batch,)
-      self.analyzed_results[C.F_vmap_fp_opt] = bm.jit(vmap(self.F_fixed_point_opt))
+      self.analyzed_results[C.F_vmap_fp_opt] = jax.jit(vmap(self.F_fixed_point_opt))
     return self.analyzed_results[C.F_vmap_fp_opt]
 
   def _get_fixed_points(self, candidates, *args, num_seg=None, tol_aux=1e-7, loss_screen=None):
     """
 
     "candidates" and "args" can be obtained through:
 
@@ -515,52 +516,52 @@
       else:
         self.analyzed_results[C.F_y_by_x_in_fy] = None
     return self.analyzed_results[C.F_y_by_x_in_fy]
 
   @property
   def F_vmap_fy(self):
     if C.F_vmap_fy not in self.analyzed_results:
-      self.analyzed_results[C.F_vmap_fy] = bm.jit(vmap(self.F_fy), device=self.jit_device)
+      self.analyzed_results[C.F_vmap_fy] = jax.jit(vmap(self.F_fy), device=self.jit_device)
     return self.analyzed_results[C.F_vmap_fy]
 
   @property
   def F_dfxdy(self):
     """The function to evaluate :math:`\frac{df_x (*\mathrm{vars}, *\mathrm{pars})}{dy}`."""
     if C.F_dfxdy not in self.analyzed_results:
       dfxdy = bm.vector_grad(self.F_fx, argnums=1)
-      self.analyzed_results[C.F_dfxdy] = bm.jit(dfxdy, device=self.jit_device)
+      self.analyzed_results[C.F_dfxdy] = jax.jit(dfxdy, device=self.jit_device)
     return self.analyzed_results[C.F_dfxdy]
 
   @property
   def F_dfydx(self):
     """The function to evaluate :math:`\frac{df_y (*\mathrm{vars}, *\mathrm{pars})}{dx}`."""
     if C.F_dfydx not in self.analyzed_results:
       dfydx = bm.vector_grad(self.F_fy, argnums=0)
-      self.analyzed_results[C.F_dfydx] = bm.jit(dfydx, device=self.jit_device)
+      self.analyzed_results[C.F_dfydx] = jax.jit(dfydx, device=self.jit_device)
     return self.analyzed_results[C.F_dfydx]
 
   @property
   def F_dfydy(self):
     """The function to evaluate :math:`\frac{df_y (*\mathrm{vars}, *\mathrm{pars})}{dy}`."""
     if C.F_dfydy not in self.analyzed_results:
       dfydy = bm.vector_grad(self.F_fy, argnums=1)
-      self.analyzed_results[C.F_dfydy] = bm.jit(dfydy, device=self.jit_device)
+      self.analyzed_results[C.F_dfydy] = jax.jit(dfydy, device=self.jit_device)
     return self.analyzed_results[C.F_dfydy]
 
   @property
   def F_jacobian(self):
     """The function to evaluate :math:`J(*\mathrm{vars}, *\mathrm{pars})`."""
     if C.F_jacobian not in self.analyzed_results:
       @partial(bm.jacobian, argnums=(0, 1))
       def f_jacobian(*var_and_pars):
         return self.F_fx(*var_and_pars), self.F_fy(*var_and_pars)
 
       def call(*var_and_pars):
         var_and_pars = tuple((vp.value if isinstance(vp, bm.Array) else vp) for vp in var_and_pars)
-        return jnp.array(bm.jit(f_jacobian, device=self.jit_device)(*var_and_pars))
+        return jnp.array(jax.jit(f_jacobian, device=self.jit_device)(*var_and_pars))
 
       self.analyzed_results[C.F_jacobian] = call
     return self.analyzed_results[C.F_jacobian]
 
   @property
   def F_fixed_point_opt(self):
     if C.F_fixed_point_opt not in self.analyzed_results:
@@ -677,15 +678,15 @@
       xs = self.resolutions[self.x_var]
       ys = self.resolutions[self.y_var]
       par_seg = utils.Segment(targets=tuple(self.resolutions[p] for p in self.target_par_names),
                               num_segments=num_segments)
 
       if self.F_x_by_y_in_fx is not None:
         utils.output("I am evaluating fx-nullcline by F_x_by_y_in_fx ...")
-        vmap_f = bm.jit(vmap(self.F_x_by_y_in_fx), device=self.jit_device)
+        vmap_f = jax.jit(vmap(self.F_x_by_y_in_fx), device=self.jit_device)
         for j, pars in enumerate(par_seg):
           if len(par_seg.arg_id_segments[0]) > 1: utils.output(f"{C.prefix}segment {j} ...")
           mesh_values = jnp.meshgrid(*((ys,) + pars))
           x_values_in_fx = vmap_f(*mesh_values)
           y_values_in_fx = mesh_values[0]
           p_values_in_fx = mesh_values[1:]
           losses = self.F_vmap_fx(x_values_in_fx, y_values_in_fx, *p_values_in_fx)
@@ -693,15 +694,15 @@
           all_x_values_in_fx.append(x_values_in_fx)
           all_y_values_in_fx.append(y_values_in_fx)
           for i, arg in enumerate(p_values_in_fx):
             all_p_values_in_fx[i].append(arg)
 
       elif self.F_y_by_x_in_fx is not None:
         utils.output("I am evaluating fx-nullcline by F_y_by_x_in_fx ...")
-        vmap_f = bm.jit(vmap(self.F_y_by_x_in_fx), device=self.jit_device)
+        vmap_f = jax.jit(vmap(self.F_y_by_x_in_fx), device=self.jit_device)
         for j, pars in enumerate(par_seg):
           if len(par_seg.arg_id_segments[0]) > 1: utils.output(f"{C.prefix}segment {j} ...")
           mesh_values = jnp.meshgrid(*((xs,) + pars))
           y_values_in_fx = vmap_f(*mesh_values)
           x_values_in_fx = mesh_values[0]
           p_values_in_fx = mesh_values[1:]
           losses = self.F_vmap_fx(x_values_in_fx, y_values_in_fx, *p_values_in_fx)
@@ -711,17 +712,17 @@
           for i, arg in enumerate(p_values_in_fx):
             all_p_values_in_fx[i].append(arg)
 
       else:
         utils.output("I am evaluating fx-nullcline by optimization ...")
         # auxiliary functions
         f2 = lambda y, x, *pars: self.F_fx(x, y, *pars)
-        vmap_f2 = bm.jit(vmap(f2), device=self.jit_device)
-        vmap_brentq_f2 = bm.jit(vmap(utils.jax_brentq(f2)), device=self.jit_device)
-        vmap_brentq_f1 = bm.jit(vmap(utils.jax_brentq(self.F_fx)), device=self.jit_device)
+        vmap_f2 = jax.jit(vmap(f2), device=self.jit_device)
+        vmap_brentq_f2 = jax.jit(vmap(utils.jax_brentq(f2)), device=self.jit_device)
+        vmap_brentq_f1 = jax.jit(vmap(utils.jax_brentq(self.F_fx)), device=self.jit_device)
 
         # num segments
         for _j, Ps in enumerate(par_seg):
           if len(par_seg.arg_id_segments[0]) > 1:
             utils.output(f"{C.prefix}segment {_j} ...")
           if coords == self.x_var + '-' + self.y_var:
             x0s, x1s, vps = utils.brentq_candidates(self.F_vmap_fx, *((xs, ys) + Ps))
@@ -770,15 +771,15 @@
       xs = self.resolutions[self.x_var]
       ys = self.resolutions[self.y_var]
       par_seg = utils.Segment(tuple(self.resolutions[p] for p in self.target_par_names),
                               num_segments=num_segments)
 
       if self.F_x_by_y_in_fy is not None:
         utils.output("I am evaluating fy-nullcline by F_x_by_y_in_fy ...")
-        vmap_f = bm.jit(vmap(self.F_x_by_y_in_fy), device=self.jit_device)
+        vmap_f = jax.jit(vmap(self.F_x_by_y_in_fy), device=self.jit_device)
         for j, pars in enumerate(par_seg):
           if len(par_seg.arg_id_segments[0]) > 1: utils.output(f"{C.prefix}segment {j} ...")
           mesh_values = jnp.meshgrid(*((ys,) + pars))
           x_values_in_fy = vmap_f(*mesh_values)
           y_values_in_fy = mesh_values[0]
           p_values_in_fy = mesh_values[1:]
           losses = self.F_vmap_fy(x_values_in_fy, y_values_in_fy, *p_values_in_fy)
@@ -786,15 +787,15 @@
           all_x_values_in_fy.append(x_values_in_fy)
           all_y_values_in_fy.append(y_values_in_fy)
           for i, arg in enumerate(p_values_in_fy):
             all_p_values_in_fy[i].append(arg)
 
       elif self.F_y_by_x_in_fy is not None:
         utils.output("I am evaluating fy-nullcline by F_y_by_x_in_fy ...")
-        vmap_f = bm.jit(vmap(self.F_y_by_x_in_fy), device=self.jit_device)
+        vmap_f = jax.jit(vmap(self.F_y_by_x_in_fy), device=self.jit_device)
         for j, pars in enumerate(par_seg):
           if len(par_seg.arg_id_segments[0]) > 1: utils.output(f"{C.prefix}segment {j} ...")
           mesh_values = jnp.meshgrid(*((xs,) + pars))
           y_values_in_fy = vmap_f(*mesh_values)
           x_values_in_fy = mesh_values[0]
           p_values_in_fy = mesh_values[1:]
           losses = self.F_vmap_fy(x_values_in_fy, y_values_in_fy, *p_values_in_fy)
@@ -805,17 +806,17 @@
             all_p_values_in_fy[i].append(arg)
 
       else:
         utils.output("I am evaluating fy-nullcline by optimization ...")
 
         # auxiliary functions
         f2 = lambda y, x, *pars: self.F_fy(x, y, *pars)
-        vmap_f2 = bm.jit(vmap(f2), device=self.jit_device)
-        vmap_brentq_f2 = bm.jit(vmap(utils.jax_brentq(f2)), device=self.jit_device)
-        vmap_brentq_f1 = bm.jit(vmap(utils.jax_brentq(self.F_fy)), device=self.jit_device)
+        vmap_f2 = jax.jit(vmap(f2), device=self.jit_device)
+        vmap_brentq_f2 = jax.jit(vmap(utils.jax_brentq(f2)), device=self.jit_device)
+        vmap_brentq_f1 = jax.jit(vmap(utils.jax_brentq(self.F_fy)), device=self.jit_device)
 
         for j, Ps in enumerate(par_seg):
           if len(par_seg.arg_id_segments[0]) > 1: utils.output(f"{C.prefix}segment {j} ...")
           if coords == self.x_var + '-' + self.y_var:
             starts, ends, vps = utils.brentq_candidates(self.F_vmap_fy, *((xs, ys) + Ps))
             x_values_in_fy, out_args = utils.brentq_roots2(vmap_brentq_f1, starts, ends, *vps)
             y_values_in_fy = out_args[0]
@@ -855,15 +856,15 @@
     all_ys = []
     all_ps = tuple([] for _ in range(len(self.target_par_names)))
 
     # points of variables and parameters
     xs = self.resolutions[self.x_var]
     ys = self.resolutions[self.y_var]
     P = tuple(self.resolutions[p] for p in self.target_par_names)
-    f_select = bm.jit(vmap(lambda vals, ids: vals[ids], in_axes=(1, 1)))
+    f_select = jax.jit(vmap(lambda vals, ids: vals[ids], in_axes=(1, 1)))
 
     # num seguments
     if isinstance(num_segments, int):
       num_segments = tuple([num_segments] * len(self.target_par_names))
     assert isinstance(num_segments, (tuple, list)) and len(num_segments) == len(self.target_par_names)
     arg_lens = tuple(len(p) for p in P)
     arg_pre_len = tuple(int(np.ceil(l / num_segments[i])) for i, l in enumerate(arg_lens))
@@ -935,18 +936,18 @@
       candidates = candidates.value if isinstance(candidates, bm.Array) else candidates
       selected_ids = np.arange(len(candidates))
       args = tuple(a.value if isinstance(candidates, bm.Array) else a for a in args)
       for a in args: assert len(a) == len(candidates)
 
       if self.convert_type() == C.x_by_y:
         num_seg = len(self.resolutions[self.y_var])
-        f_vmap = bm.jit(vmap(self.F_y_convert[1]))
+        f_vmap = jax.jit(vmap(self.F_y_convert[1]))
       else:
         num_seg = len(self.resolutions[self.x_var])
-        f_vmap = bm.jit(vmap(self.F_x_convert[1]))
+        f_vmap = jax.jit(vmap(self.F_x_convert[1]))
       # get the signs
       signs = jnp.sign(f_vmap(candidates, *args))
       signs = signs.reshape((num_seg, -1))
       par_len = signs.shape[1]
       signs1 = signs.at[-1].set(1)
       signs2 = jnp.vstack((signs[1:], signs[:1])).at[-1].set(1)
       ids = jnp.where((signs1 * signs2).flatten() <= 0)[0]
@@ -968,18 +969,18 @@
       fps = np.asarray(res['root'])[ids]
       args = tuple(a[ids] for a in args)
       selected_ids = selected_ids[np.asarray(ids)]
 
       # get another value
       if self.convert_type() == C.x_by_y:
         y_values = fps
-        x_values = bm.jit(vmap(self.F_y_convert[0]))(y_values, *args)
+        x_values = jax.jit(vmap(self.F_y_convert[0]))(y_values, *args)
       else:
         x_values = fps
-        y_values = bm.jit(vmap(self.F_x_convert[0]))(x_values, *args)
+        y_values = jax.jit(vmap(self.F_x_convert[0]))(x_values, *args)
       fps = jnp.stack([x_values, y_values]).T
       return fps, selected_ids, args
 
     else:
       utils.output("I am trying to find fixed points by optimization ...")
       utils.output(f"{C.prefix}There are {len(candidates)} candidates")
 
@@ -1038,13 +1039,13 @@
   def F_fz(self):
     """The function to evaluate :math:`f_y(*\mathrm{vars}, *\mathrm{pars})`."""
     if C.F_fz not in self.analyzed_results:
       variables, arguments = utils.get_args(self.model.f_derivatives[self.z_var])
       wrapper = utils.std_derivative(arguments, self.target_var_names, self.target_par_names)
       f = wrapper(self.model.f_derivatives[self.z_var])
       f = partial(f, **(self.pars_update + self.fixed_vars))
-      self.analyzed_results[C.F_fz] = bm.jit(f, device=self.jit_device)
+      self.analyzed_results[C.F_fz] = jax.jit(f, device=self.jit_device)
     return self.analyzed_results[C.F_fz]
 
   def fz_signs(self, pars=(), cache=False):
     xyz = tuple(self.resolutions.values())
     return utils.get_sign2(self.F_fz, *xyz, args=pars)
```

## brainpy/_src/analysis/lowdim/lowdim_bifurcation.py

```diff
@@ -1,11 +1,12 @@
 # -*- coding: utf-8 -*-
 
 from functools import partial
 
+import jax
 import jax.numpy as jnp
 from jax import vmap
 import numpy as np
 from copy import deepcopy
 
 from brainpy import errors
 import brainpy._src.math as bm
@@ -40,15 +41,15 @@
 
     if len(self.target_pars) == 0:
       raise ValueError
 
   @property
   def F_vmap_dfxdx(self):
     if C.F_vmap_dfxdx not in self.analyzed_results:
-      f = bm.jit(vmap(bm.vector_grad(self.F_fx, argnums=0)), device=self.jit_device)
+      f = jax.jit(vmap(bm.vector_grad(self.F_fx, argnums=0)), device=self.jit_device)
       self.analyzed_results[C.F_vmap_dfxdx] = f
     return self.analyzed_results[C.F_vmap_dfxdx]
 
   def plot_bifurcation(self, with_plot=True, show=False, with_return=False,
                        tol_aux=1e-8, loss_screen=None):
     global pyplot
     if pyplot is None: from matplotlib import pyplot
@@ -159,15 +160,15 @@
     self._fixed_points = None
 
   @property
   def F_vmap_jacobian(self):
     if C.F_vmap_jacobian not in self.analyzed_results:
       f1 = lambda xy, *args: jnp.array([self.F_fx(xy[0], xy[1], *args),
                                         self.F_fy(xy[0], xy[1], *args)])
-      f2 = bm.jit(vmap(bm.jacobian(f1)), device=self.jit_device)
+      f2 = jax.jit(vmap(bm.jacobian(f1)), device=self.jit_device)
       self.analyzed_results[C.F_vmap_jacobian] = f2
     return self.analyzed_results[C.F_vmap_jacobian]
 
   def plot_bifurcation(self, with_plot=True, show=False, with_return=False,
                        tol_aux=1e-8, tol_unique=1e-2, tol_opt_candidate=None,
                        num_par_segments=1, num_fp_segment=1, nullcline_aux_filter=1.,
                        select_candidates='aux_rank', num_rank=100):
```

## brainpy/_src/analysis/lowdim/lowdim_phase_plane.py

```diff
@@ -1,9 +1,10 @@
 # -*- coding: utf-8 -*-
 
+import jax
 import jax.numpy as jnp
 import numpy as np
 from jax import vmap
 
 from copy import deepcopy
 import brainpy.math as bm
 from brainpy import errors, math
@@ -156,15 +157,15 @@
                                        pars_update=pars_update,
                                        resolutions=resolutions,
                                        **kwargs)
 
   @property
   def F_vmap_brentq_fy(self):
     if C.F_vmap_brentq_fy not in self.analyzed_results:
-      f_opt = bm.jit(vmap(utils.jax_brentq(self.F_fy)))
+      f_opt = jax.jit(vmap(utils.jax_brentq(self.F_fy)))
       self.analyzed_results[C.F_vmap_brentq_fy] = f_opt
     return self.analyzed_results[C.F_vmap_brentq_fy]
 
   def plot_vector_field(self, with_plot=True, with_return=False,
                         plot_method='streamplot', plot_style=None, show=False):
     """Plot the vector field.
```

## brainpy/_src/analysis/utils/model.py

```diff
@@ -1,13 +1,13 @@
 # -*- coding: utf-8 -*-
 
 
-from brainpy._src.math.ndarray import Variable
+from brainpy._src.math.object_transform import Variable
 from brainpy._src.math.environment import get_float
-from brainpy._src.math.arrayinterporate import as_jax
+from brainpy._src.math.interoperability import as_jax
 from brainpy._src.dyn.base import DynamicalSystem
 from brainpy._src.dyn.runners import DSRunner
 from brainpy._src.integrators.base import Integrator
 from brainpy._src.integrators.joint_eq import JointEq
 from brainpy._src.integrators.ode.base import ODEIntegrator
 from brainpy._src.integrators.ode.generic import odeint
 from brainpy.errors import AnalyzerError, UnsupportedError
```

## brainpy/_src/analysis/utils/optimization.py

```diff
@@ -193,15 +193,15 @@
   x_ends = mesh_values[0][ids + par_len]
   other_vals = tuple(v[ids] for v in mesh_values[1:])
   return x_starts, x_ends, other_vals
 
 
 def brentq_roots(f, starts, ends, *vmap_args, args=()):
   in_axes = (0, 0, tuple([0] * len(vmap_args)) + tuple([None] * len(args)))
-  vmap_f_opt = bm.jit(vmap(jax_brentq(f), in_axes=in_axes))
+  vmap_f_opt = jax.jit(vmap(jax_brentq(f), in_axes=in_axes))
   all_args = vmap_args + args
   if len(all_args):
     res = vmap_f_opt(starts, ends, all_args)
   else:
     res = vmap_f_opt(starts, ends, )
   valid_idx = jnp.where(res['status'] == ECONVERGED)[0]
   roots = res['root'][valid_idx]
@@ -393,24 +393,24 @@
   zero_sign_idx = jnp.where(signs == 0)[0]
   fps = candidates[zero_sign_idx]
   candidate_ids = jnp.where(signs[:-1] * signs[1:] < 0)[0]
   if len(candidate_ids) <= 0:
     return fps
   starts = candidates[candidate_ids]
   ends = candidates[candidate_ids + 1]
-  f_opt = bm.jit(vmap(jax_brentq(f), in_axes=(0, 0, None)))
+  f_opt = jax.jit(vmap(jax_brentq(f), in_axes=(0, 0, None)))
   res = f_opt(starts, ends, args)
   valid_idx = jnp.where(res['status'] == ECONVERGED)[0]
   fps2 = res['root'][valid_idx]
   return jnp.concatenate([fps, fps2])
 
 
 def roots_of_1d_by_xy(f, starts, ends, args):
   f = f_without_jaxarray_return(f)
-  f_opt = bm.jit(vmap(jax_brentq(f)))
+  f_opt = jax.jit(vmap(jax_brentq(f)))
   res = f_opt(starts, ends, (args,))
   valid_idx = jnp.where(res['status'] == ECONVERGED)[0]
   xs = res['root'][valid_idx]
   ys = args[valid_idx]
   return xs, ys
```

## brainpy/_src/analysis/utils/others.py

```diff
@@ -1,14 +1,14 @@
 # -*- coding: utf-8 -*-
 
 from typing import Union, Dict
 
+import jax
 import jax.numpy as jnp
 import numpy as np
-from jax import vmap
 from jax.tree_util import tree_map
 
 import brainpy.math as bm
 from .function import f_without_jaxarray_return
 from .measurement import euclidean_distance_jax
 
 __all__ = [
@@ -76,15 +76,15 @@
   ys = ys.value if isinstance(ys, bm.Array) else ys
   Y, X = jnp.meshgrid(ys, xs)
   return jnp.sign(f(X, Y))
 
 
 def get_sign2(f, *xyz, args=()):
   in_axes = tuple(range(len(xyz))) + tuple([None] * len(args))
-  f = bm.jit(vmap(f_without_jaxarray_return(f), in_axes=in_axes))
+  f = jax.jit(jax.vmap(f_without_jaxarray_return(f), in_axes=in_axes))
   xyz = tuple((v.value if isinstance(v, bm.Array) else v) for v in xyz)
   XYZ = jnp.meshgrid(*xyz)
   XYZ = tuple(jnp.moveaxis(v, 1, 0).flatten() for v in XYZ)
   shape = (len(v) for v in xyz)
   return jnp.sign(f(*(XYZ + args))).reshape(shape)
```

## brainpy/_src/base/naming.py

```diff
@@ -1,10 +1,10 @@
 # -*- coding: utf-8 -*-
 
-from brainpy._src.tools import naming
+from brainpy._src.math.object_transform import naming
 
 __all__ = [
   'check_name_uniqueness',
   'get_unique_name',
   'clear_name_cache',
 ]
```

## brainpy/_src/checkpoints/io.py

```diff
@@ -4,15 +4,16 @@
 import logging
 import pickle
 
 import numpy as np
 
 from brainpy import errors
 import brainpy.math as bm
-from brainpy._src.math.object_transform.base import BrainPyObject, DynVarCollector
+from brainpy._src.math.object_transform.base import BrainPyObject
+from brainpy._src.math.object_transform.collectors import ArrayCollector
 
 
 logger = logging.getLogger('brainpy.brainpy_object.io')
 
 __all__ = [
   'SUPPORTED_FORMATS',
   'save_as_h5', 'load_by_h5',
@@ -116,15 +117,15 @@
   # check missing names
   if len(var_names_in_obj):
     logger.warning(f'There are variable states missed in {filename}. '
                    f'The missed variables are: {var_names_in_obj}.')
 
 
 def _unique_and_duplicate(collector: dict):
-  gather = DynVarCollector()
+  gather = ArrayCollector()
   id2name = dict()
   duplicates = ([], [])
   for k, v in collector.items():
     id_ = id(v)
     if id_ not in id2name:
       gather[k] = v
       id2name[id_] = k
```

## brainpy/_src/checkpoints/serialization.py

```diff
@@ -947,15 +947,15 @@
   Args:
     checkpoint_start_time: Start time of current checkpoint.
   """
   global _LAST_CHECKPOINT_WRITE_TIME
   # Note: for the very first checkpoint, this is the interval between program
   # init and the current checkpoint start time.
   duration_since_last_checkpoint = checkpoint_start_time - _LAST_CHECKPOINT_WRITE_TIME
-  if jax.version.__version_info__ > (0, 3, 25):
+  if monitoring is not None:
     monitoring.record_event_duration_secs(
       '/jax/checkpoint/write/duration_since_last_checkpoint_secs',
       duration_since_last_checkpoint)
   _LAST_CHECKPOINT_WRITE_TIME = checkpoint_start_time
 
 
 def _save_commit(ckpt_tmp_path: str,
@@ -1147,15 +1147,15 @@
                                 keep_every_n_steps, start_time)
 
   if async_manager:
     async_manager.save_async(save_main_ckpt_task)
   else:
     save_main_ckpt_task()
   end_time = time.time()
-  if jax.version.__version_info__ > (0, 3, 25):
+  if monitoring is not None:
     monitoring.record_event_duration_secs(_WRITE_CHECKPOINT_EVENT,
                                           end_time - start_time)
   return ckpt_path
 
 
 def _save_commit2(filename: str,
                   overwrite: bool,
@@ -1277,15 +1277,15 @@
     return _save_main_ckpt_file2(target, False, filename, overwrite, start_time)
 
   if async_manager:
     async_manager.save_async(save_main_ckpt_task)
   else:
     save_main_ckpt_task()
   end_time = time.time()
-  if jax.version.__version_info__ > (0, 3, 25):
+  if monitoring is not None:
     monitoring.record_event_duration_secs(_WRITE_CHECKPOINT_EVENT,
                                           end_time - start_time)
 
 
 def multiprocess_save(
     ckpt_dir: Union[str, os.PathLike],
     target: PyTree,
@@ -1386,15 +1386,15 @@
     if process_index() == 0:
       _make_mpa_dirs(mpa_targets, ckpt_tmp_path)
     sync_global_devices('Flax:Checkpointing:AfterCreateMPADir')
     _save_mpas(gda_manager, mpa_targets, ckpt_tmp_path, ckpt_path, base_path,
                keep, overwrite, keep_every_n_steps, start_time, async_manager)
 
   end_time = time.time()
-  if jax.version.__version_info__ > (0, 3, 25):
+  if monitoring is not None:
     monitoring.record_event_duration_secs(_WRITE_CHECKPOINT_EVENT,
                                           end_time - start_time)
   return ckpt_path
 
 
 def _load_latest_fn(
     ckpt_dir: Union[str, os.PathLike],
@@ -1549,15 +1549,15 @@
 
   if target is None:
     restored_checkpoint = state_dict
   else:
     restored_checkpoint = from_state_dict(target, state_dict)
 
   end_time = time.time()
-  if jax.version.__version_info__ > (0, 3, 25):
+  if monitoring is not None:
     monitoring.record_event_duration_secs(_READ_CHECKPOINT_EVENT, end_time - start_time)
 
   return restored_checkpoint
 
 
 def load_pytree(
     filename: str,
@@ -1612,11 +1612,11 @@
       pool.shutdown(wait=False)
       logging.debug(f'results: {list(results)}')
     else:
       checkpoint_contents = fp.read()
 
   state_dict = msgpack_restore(checkpoint_contents)
   end_time = time.time()
-  if jax.version.__version_info__ > (0, 3, 25):
+  if monitoring is not None:
     monitoring.record_event_duration_secs(_READ_CHECKPOINT_EVENT, end_time - start_time)
 
   return state_dict
```

## brainpy/_src/dyn/base.py

```diff
@@ -10,15 +10,15 @@
 import numpy as np
 
 from brainpy import tools
 from brainpy._src import math as bm
 from brainpy._src.connect import TwoEndConnector, MatConn, IJConn, One2One, All2All
 from brainpy._src.initialize import Initializer, parameter, variable, Uniform, noise as init_noise
 from brainpy._src.integrators import odeint, sdeint
-from brainpy._src.math.ndarray import Variable, VariableView
+from brainpy._src.math.object_transform.variables import Variable, VariableView
 from brainpy._src.math.object_transform.base import BrainPyObject, Collector
 from brainpy.errors import NoImplementationError, UnsupportedError
 from brainpy.types import ArrayType, Shape
 
 share = None
 
 __all__ = [
@@ -1471,24 +1471,18 @@
       elif key in self._static_modules:
         return self._static_modules[key]
       else:
         raise KeyError(f'Does not find a component named {key} in\n {str(self)}')
     elif isinstance(key, slice):
       return Sequential(*(self.__all_nodes()[key]))
     elif isinstance(key, int):
-      key = self.__format_key(key)
-      return self._static_modules[key] if (key not in self._dyn_modules) else self._dyn_modules[key]
+      return self.__all_nodes()[key]
     elif isinstance(key, (tuple, list)):
-      nodes = []
-      for i in key:
-        if isinstance(i, int):
-          i = self.__format_key(i)
-        assert isinstance(i, str)
-        nodes.append(self._static_modules[i] if (i not in self._dyn_modules) else self._dyn_modules[i])
-      return Sequential(*nodes)
+      _all_nodes = self.__all_nodes()
+      return Sequential(*[_all_nodes[k] for k in key])
     else:
       raise KeyError(f'Unknown type of key: {type(key)}')
 
   def __repr__(self):
     nodes = self.__all_nodes()
     entries = '\n'.join(f'  [{i}] {tools.repr_object(x)}' for i, x in enumerate(nodes))
     return f'{self.__class__.__name__}(\n{entries}\n)'
```

## brainpy/_src/dyn/context.py

```diff
@@ -61,14 +61,22 @@
     for i in range(0, len(args), 2):
       identifier = args[i * 2]
       data = args[i * 2 + 1]
       self._arguments[identifier] = data
     for identifier, data in kwargs.items():
       self._arguments[identifier] = data
 
+  def __setitem__(self, key, value):
+    """Enable setting the shared item by ``bp.share[key] = value``."""
+    self.save(key, value)
+
+  def __getitem__(self, item):
+    """Enable loading the shared parameter by ``bp.share[key]``."""
+    return self.load(item)
+
   def get_shargs(self) -> DotDict:
     """Get all shared arguments in the global context."""
     return self._arguments.copy()
 
   def clear_shargs(self, *args) -> None:
     """Clear all shared arguments in the global context."""
     if len(args) > 0:
```

## brainpy/_src/dyn/runners.py

```diff
@@ -297,14 +297,21 @@
   data_first_axis: str
     Set the default data dimension arrangement.
     To indicate whether the first axis is the batch size (``data_first_axis='B'``) or the
     time length (``data_first_axis='T'``).
     In order to be compatible with previous API, default is set to be ``False``.
 
     .. versionadded:: 2.3.1
+
+  memory_efficient: bool
+    Whether using the memory-efficient way to just-in-time compile the given target.
+    Default is False.
+
+    .. versionadded:: 2.3.8
+
   """
 
   target: DynamicalSystem
 
   def __init__(
       self,
       target: DynamicalSystem,
@@ -629,71 +636,66 @@
       self.mon[key].append(val)
 
   def _step_func_predict(self, shared_args, t, i, x):
     # input step
     shared = tools.DotDict(t=t, i=i, dt=self.dt)
     shared.update(shared_args)
     share.save(**shared)
-    self.target.clear_input()
     self._step_func_input(shared)
 
     # dynamics update step
     args = () if x is None else (x,)
     out = self.target(*args)
 
     # monitor step
     shared['t'] += self.dt
     mon = self._step_func_monitor(shared)
 
     # finally
     if self.progress_bar:
       id_tap(lambda *arg: self._pbar.update(), ())
     share.clear_shargs()
+    self.target.clear_input()
 
     if self._memory_efficient:
       id_tap(self._step_mon_on_cpu, mon)
       return out, None
     else:
       return out, mon
 
   def _get_f_predict(self, shared_args: Dict = None):
     if shared_args is None:
       shared_args = dict()
 
     shared_kwargs_str = serialize_kwargs(shared_args)
     if shared_kwargs_str not in self._f_predict_compiled:
-      dyn_vars = self.target.vars()
-      dyn_vars.update(self._dyn_vars)
-      dyn_vars.update(self.vars(level=0))
-      dyn_vars = dyn_vars.unique()
 
       if self._memory_efficient:
-        _jit_step = bm.jit(partial(self._step_func_predict, shared_args), dyn_vars=dyn_vars)
+        _jit_step = bm.jit(partial(self._step_func_predict, shared_args))
 
         def run_func(all_inputs):
           outs = None
           times, indices, xs = all_inputs
           for i in range(times.shape[0]):
             out, _ = _jit_step(times[i], indices[i], tree_map(lambda a: a[i], xs))
             if outs is None:
               outs = tree_map(lambda a: [], out)
             outs = tree_map(lambda a, o: o.append(a), out, outs)
           outs = tree_map(lambda a: bm.as_jax(a), outs)
           return outs, None
 
       else:
-        @bm.jit(dyn_vars=dyn_vars)
+        step = partial(self._step_func_predict, shared_args)
+
         def run_func(all_inputs):
-          return bm.for_loop(partial(self._step_func_predict, shared_args),
-                             all_inputs,
-                             dyn_vars=dyn_vars,
-                             jit=self.jit['predict'])
+          return bm.for_loop(step, all_inputs, jit=self.jit['predict'])
 
       self._f_predict_compiled[shared_kwargs_str] = run_func
 
     return self._f_predict_compiled[shared_kwargs_str]
 
   def __del__(self):
     if hasattr(self, '_f_predict_compiled'):
       for key in tuple(self._f_predict_compiled.keys()):
         self._f_predict_compiled.pop(key)
     super(DSRunner, self).__del__()
+
```

## brainpy/_src/dyn/transform.py

```diff
@@ -274,23 +274,22 @@
           self.i0 += length[0]
         if self.t0 is not None:
           self.t0 += length[0] * self.dt
         return results
 
       else:
         shared = tools.DotDict()
-        if  self.t0 is not None:
+        if self.t0 is not None:
           shared['t'] = jnp.arange(0, self.dt * length[0], self.dt) + self.t0.value
         if self.i0 is not None:
           shared['i'] = jnp.arange(0, length[0]) + self.i0.value
 
     assert not self.no_state
     results = bm.for_loop(functools.partial(self._run, self.shared_arg),
                           (shared, xs),
-                          child_objs=(self.target, share),
                           jit=self.jit,
                           remat=self.remat)
     if self.i0 is not None:
       self.i0 += length[0]
     if self.t0 is not None:
       self.t0 += length[0] * self.dt
     return results
```

## brainpy/_src/dyn/neurons/biological_models.py

```diff
@@ -313,15 +313,15 @@
     dt = share.load('dt')
     if self.input_var:
       if x is not None:
         self.input += x
       x = self.input.value
     else:
       x = 0. if x is None else x
-    V, m, h, n = self.integral(self.V, self.m, self.h, self.n, t, x, dt)
+    V, m, h, n = self.integral(self.V.value, self.m.value, self.h.value, self.n.value, t, x, dt)
     self.spike.value = bm.logical_and(self.V < self.V_th, V >= self.V_th)
     self.V.value = V
     self.m.value = m
     self.h.value = h
     self.n.value = n
     return self.spike.value
 
@@ -452,16 +452,16 @@
     self.V4 = parameter(V4, self.varshape, allow_none=False)
     self.phi = parameter(phi, self.varshape, allow_none=False)
     self.V_th = parameter(V_th, self.varshape, allow_none=False)
     self.noise = init_noise(noise, self.varshape, num_vars=2)
     self.input_var = input_var
 
     # initializers
-    self._W_initializer = check.is_initializer(V_initializer, allow_none=False)
-    self._V_initializer = check.is_initializer(W_initializer, allow_none=False)
+    self._W_initializer = check.is_initializer(W_initializer, allow_none=False)
+    self._V_initializer = check.is_initializer(V_initializer, allow_none=False)
 
     # variables
     self.reset_state(self.mode)
 
     # integral
     if self.noise is None:
       self.integral = odeint(method=method, f=self.derivative)
@@ -487,15 +487,15 @@
     tau_W = 1 / (self.phi * bm.cosh((V - self.V3) / (2 * self.V4)))
     W_inf = (1 / 2) * (1 + bm.tanh((V - self.V3) / self.V4))
     dWdt = (W_inf - W) / tau_W
     return dWdt
 
   @property
   def derivative(self):
-    return JointEq([self.dV, self.dW])
+    return JointEq(self.dV, self.dW)
 
   def update(self, x=None):
     t = share.load('t')
     dt = share.load('dt')
     if self.input_var:
       if x is not None:
         self.input += x
```

## brainpy/_src/dyn/neurons/input_groups.py

```diff
@@ -127,28 +127,28 @@
       raise NotImplementedError(f'Do not support keep_size=True in {self.__class__.__name__}')
     if len(indices) != len(times):
       raise ValueError(f'The length of "indices" and "times" must be the same. '
                        f'However, we got {len(indices)} != {len(times)}.')
     self.num_times = len(times)
 
     # data about times and indices
-    self.times = jnp.asarray(times)
-    self.indices = jnp.asarray(indices, dtype=bm.int_)
+    self.times = bm.asarray(times)
+    self.indices = bm.asarray(indices, dtype=bm.int_)
     if need_sort:
-      sort_idx = jnp.argsort(self.times)
+      sort_idx = bm.argsort(self.times)
       self.indices.value = self.indices[sort_idx]
       self.times.value = self.times[sort_idx]
 
     # variables
     self.reset_state(self.mode)
 
     # functions
     def cond_fun(t):
       i = self.i.value
-      return jnp.logical_and(i < self.num_times, t >= self.times[i])
+      return bm.logical_and(i < self.num_times, t >= self.times[i])
 
     def body_fun(t):
       i = self.i.value
       if isinstance(self.mode, bm.BatchingMode):
         self.spike[:, self.indices[i]] = True
       else:
         self.spike[self.indices[i]] = True
```

## brainpy/_src/dyn/synapses/abstract_models.py

```diff
@@ -973,16 +973,15 @@
       else:
         inp = self.rng.binomial(self.num_input, p, self.target_var.shape)
 
     else:  # dt is in tracing
       inp = bm.cond((a > 5) * (b > 5),
                     lambda _: self.rng.normal(a, b * p, self.target_var.shape),
                     lambda _: self.rng.binomial(self.num_input, p, self.target_var.shape),
-                    None,
-                    dyn_vars=self.rng)
+                    None)
     self.target_var += inp * self.weight
 
   def __repr__(self):
     names = self.__class__.__name__
     return f'{names}(name={self.name}, num_input={self.num_input}, freq={self.freq}, weight={self.weight})'
 
   def reset_state(self, batch_size=None):
```

## brainpy/_src/dyn/synapses_v2/others.py

```diff
@@ -64,16 +64,15 @@
       else:
         inp = self.rng.binomial(self.num_input, p, self.target_shape)
 
     else:  # dt is in tracing
       inp = bm.cond((a > 5) * (b > 5),
                     lambda _: self.rng.normal(a, b * p, self.target_shape),
                     lambda _: self.rng.binomial(self.num_input, p, self.target_shape),
-                    None,
-                    dyn_vars=self.rng)
+                    None)
     return inp * self.weight
 
   def __repr__(self):
     names = self.__class__.__name__
     return f'{names}(shape={self.target_shape}, num_input={self.num_input}, freq={self.freq}, weight={self.weight})'
 
   def reset_state(self, batch_size=None):
```

## brainpy/_src/encoding/stateful_encoding.py

```diff
@@ -80,15 +80,15 @@
 
     def f(i):
       w = self.weight_fun(i)
       spike = inputs >= w
       inputs.value -= w * spike
       return spike
 
-    return bm.for_loop(f, bm.arange(num_step).value, dyn_vars=inputs)
+    return bm.for_loop(f, bm.arange(num_step).value)
 
 
 class LatencyEncoder(Encoder):
   r"""Encode the rate input as the spike train.
 
   The latency encoder will encode ``x`` (normalized into ``[0, 1]`` according to
   :math:`x_{\text{normalize}} = \frac{x-\text{min_val}}{\text{max_val} - \text{min_val}}`)
```

## brainpy/_src/initialize/random_inits.py

```diff
@@ -73,14 +73,16 @@
   elif nonlinearity == 'selu':
     return 3.0 / 4
   else:
     raise ValueError("Unsupported nonlinearity {}".format(nonlinearity))
 
 
 def _format_shape(shape):
+  if isinstance(shape, int):
+    return (shape, )
   if len(shape) == 0:
     raise ValueError('Please provide shape.')
   if len(shape) == 1:
     if isinstance(shape, (tuple, list)):
       return shape[0]
     else:
       return shape
```

## brainpy/_src/inputs/currents.py

```diff
@@ -305,15 +305,15 @@
   rng = bm.random.default_rng(seed)
   x = bm.Variable(jnp.ones(n) * mean)
 
   def _f(t):
     x.value = x + dt * ((mean - x) / tau) + sigma * dt_sqrt * rng.rand(n)
     return x.value
 
-  noises = bm.for_loop(_f, jnp.arange(t_start, t_end, dt), dyn_vars=[x, rng])
+  noises = bm.for_loop(_f, jnp.arange(t_start, t_end, dt))
 
   t_end = duration if t_end is None else t_end
   i_start = int(t_start / dt)
   i_end = int(t_end / dt)
   currents = bm.zeros((int(duration / dt), n))
   currents[i_start: i_end] = noises
   return currents
```

## brainpy/_src/integrators/constants.py

```diff
@@ -1,11 +1,11 @@
 # -*- coding: utf-8 -*-
 
 # import brainpy.math as bm
-from brainpy._src.tools import naming
+from brainpy._src.math.object_transform import naming
 
 __all__ = [
   'DT',
   'F',
 
   'SUPPORTED_VAR_TYPE',
   'SCALAR_VAR',
```

## brainpy/_src/integrators/runner.py

```diff
@@ -226,18 +226,16 @@
       self._dyn_args = dict()
 
     # start simulation time and index
     self.start_t = bm.Variable(bm.zeros(1))
     self.idx = bm.Variable(bm.zeros(1, dtype=bm.int_))
 
   def _run_fun_integration(self, static_args, dyn_args, times, indices):
-    dyn_vars = self.vars().unique()
     return bm.for_loop(partial(self._step_fun_integrator, static_args),
                        (dyn_args, times, indices),
-                       dyn_vars=dyn_vars,
                        jit=self.jit['predict'])
 
   def _step_fun_integrator(self, static_args, dyn_args, t, i):
     # arguments
     kwargs = Collector(dt=self.dt, t=t)
     kwargs.update(static_args)
     kwargs.update(dyn_args)
@@ -303,15 +301,15 @@
 
     # time step
     if start_t is None:
       start_t = self.start_t[0]
     end_t = start_t + duration
     # times
     times = bm.arange(start_t, end_t, self.dt).value
-    indices = bm.arange(times.size).value + self.idx
+    indices = bm.arange(times.size).value + self.idx.value
 
     _dyn_args, _ = tree_flatten(dyn_args)
     for _d in _dyn_args:
       if jnp.shape(_d)[0] != times.size:
         raise ValueError(f'The shape of `dyn_args` does not match the given duration. '
                          f'{jnp.shape(_d)[0]} != {times.size} (duration={duration}, dt={self.dt}).')
       del _d
```

## brainpy/_src/integrators/fde/Caputo.py

```diff
@@ -325,24 +325,24 @@
     if not bm.all(bm.logical_and(self.alpha <= 1, self.alpha > 0)):
       raise UnsupportedError(f'Only support the fractional order in (0, 1), '
                              f'but we got {self.alpha}.')
     self.gamma_alpha = bm.asarray(gamma(bm.as_numpy(2 - self.alpha)))
 
     # initial values
     inits = check_inits(inits, self.variables)
-    self.inits = bm.DictVar({v: bm.asarray(inits[v]) for v in self.variables})
+    self.inits = bm.VarDict({v: bm.Variable(inits[v]) for v in self.variables})
 
     # coefficients
     ranges = bm.asarray([bm.arange(1, num_memory + 2) for _ in self.variables]).T
     coef = bm.diff(bm.power(ranges, 1 - self.alpha), axis=0)
     self.coef = bm.flip(coef, axis=0)
 
     # used to save the difference of two adjacent states
-    self.diff_states = bm.DictVar({v + "_diff": bm.zeros((num_memory,) + self.inits[v].shape,
-                                                         dtype=self.inits[v].dtype)
+    self.diff_states = bm.VarDict({v + "_diff": bm.Variable(bm.zeros((num_memory,) + self.inits[v].shape,
+                                                            dtype=self.inits[v].dtype))
                                    for v in self.variables})
     self.idx = bm.Variable(bm.asarray([self.num_memory - 1]))
 
     # integral function
     self.set_integral(self._integral_func)
 
   def reset(self, inits):
```

## brainpy/_src/integrators/fde/GL.py

```diff
@@ -146,19 +146,19 @@
       raise UnsupportedError(f'Only support the fractional order in (0, 1), '
                              f'but we got {self.alpha}.')
 
     # initial values
     inits = check_inits(inits, self.variables)
 
     # delays
-    self.delays = bm.DictVar()
+    self.delays = bm.VarDict()
     for key, val in inits.items():
       delay = bm.zeros((self.num_memory,) + val.shape, dtype=val.dtype)
       delay[0] = val
-      self.delays[key+'_delay'] = delay
+      self.delays[key+'_delay'] = bm.Variable(delay)
     self._idx = bm.Variable(bm.asarray([1]))
 
     # binomial coefficients
     bc = (1 - (1 + self.alpha.reshape((-1, 1))) / bm.arange(1, num_memory + 1))
     bc = bm.cumprod(bm.vstack([bm.ones_like(self.alpha), bc.T]), axis=0)
     self._binomial_coef = bm.flip(bc[1:], axis=0)
```

## brainpy/_src/integrators/ode/exponential.py

```diff
@@ -110,15 +110,14 @@
 from functools import wraps
 from brainpy import errors
 from brainpy._src import math as bm
 from brainpy._src.integrators import constants as C, utils, joint_eq
 from brainpy._src.integrators.ode.base import ODEIntegrator
 from .generic import register_ode_integrator
 
-logger = logging.getLogger('brainpy.integrators.ode.exponential')
 
 __all__ = [
   'ExponentialEuler',
 ]
 
 
 class ExponentialEuler(ODEIntegrator):
@@ -280,40 +279,37 @@
     The derivative function.
   var_type : optional, str
     The variable type.
   dt : optional, float
     The default numerical integration step.
   name : optional, str
     The integrator name.
-  dyn_vars : optional, dict, sequence of ArrayType, ArrayType
   """
 
   def __init__(
       self,
       f,
       var_type=None,
       dt=None,
       name=None,
       show_code=False,
-      dyn_vars=None,
       state_delays=None,
       neutral_delays=None
   ):
     super(ExponentialEuler, self).__init__(f=f,
                                            var_type=var_type,
                                            dt=dt,
                                            name=name,
                                            show_code=show_code,
                                            state_delays=state_delays,
                                            neutral_delays=neutral_delays)
 
     if var_type == C.SYSTEM_VAR:
       raise NotImplementedError(f'{self.__class__.__name__} does not support {C.SYSTEM_VAR}, '
                                 f'because the auto-differentiation ')
-    self.dyn_vars = dyn_vars
 
     # build the integrator
     self.code_lines = []
     self.code_scope = {}
     self.integral = self.build()
 
   def build(self):
@@ -353,15 +349,15 @@
       # checking
       if len(vars) != 1:
         raise errors.DiffEqError(C.multi_vars_msg.format(cls=self.__class__.__name__,
                                                          vars=str(vars),
                                                          eq=str(eq)))
 
       # gradient function
-      value_and_grad = bm.vector_grad(eq, argnums=0, dyn_vars=self.dyn_vars, return_value=True)
+      value_and_grad = bm.vector_grad(eq, argnums=0, return_value=True)
 
       # integration function
       def integral(*args, **kwargs):
         assert len(args) > 0
         dt = kwargs.pop(C.DT, self.dt)
         linear, derivative = value_and_grad(*args, **kwargs)
         phi = bm.where(linear == 0.,
```

## brainpy/_src/integrators/sde/base.py

```diff
@@ -32,17 +32,15 @@
       dt: float = None,
       name: str = None,
       show_code: bool = False,
       var_type: str = None,
       intg_type: str = None,
       wiener_type: str = None,
       state_delays: Dict[str, AbstractDelay] = None,
-      dyn_vars: Union[bm.Variable, Sequence[bm.Variable], Dict[str, bm.Variable]] = None,
   ):
-    self.dyn_vars = dyn_vars
     dt = bm.get_dt() if dt is None else dt
     parses = utils.get_args(f)
     variables = parses[0]  # variable names, (before 't')
     parameters = parses[1]  # parameter names, (after 't')
     arguments = parses[2]  # function arguments
 
     # super initialization
```

## brainpy/_src/integrators/sde/normal.py

```diff
@@ -80,21 +80,20 @@
   Heun
 
   """
 
   def __init__(
       self, f, g, dt=None, name=None, show_code=False,
       var_type=None, intg_type=None, wiener_type=None,
-      state_delays=None, dyn_vars=None
+      state_delays=None,
   ):
     super(Euler, self).__init__(f=f, g=g, dt=dt, name=name,
                                 var_type=var_type, intg_type=intg_type,
                                 wiener_type=wiener_type,
-                                state_delays=state_delays,
-                                dyn_vars=dyn_vars)
+                                state_delays=state_delays)
 
     self.set_integral(self.step)
 
   def step(self, *args, **kwargs):
     all_args = format_args(args, kwargs, self.arg_names)
     dt = all_args.pop(DT, self.dt)
 
@@ -205,22 +204,21 @@
   --------
   Euler
 
   """
 
   def __init__(self, f, g, dt=None, name=None, show_code=False,
                var_type=None, intg_type=None, wiener_type=None,
-               state_delays=None, dyn_vars=None):
+               state_delays=None, ):
     if intg_type != constants.STRA_SDE:
       raise errors.IntegratorError(f'Heun method only supports Stranovich '
                                    f'integral of SDEs, but we got {intg_type} integral.')
     super(Heun, self).__init__(f=f, g=g, dt=dt, name=name,
                                var_type=var_type, intg_type=intg_type,
-                               wiener_type=wiener_type, state_delays=state_delays,
-                               dyn_vars=dyn_vars)
+                               wiener_type=wiener_type, state_delays=state_delays)
 
 
 register_sde_integrator('heun', Heun)
 
 
 class Milstein(SDEIntegrator):
   r"""Milstein method for Ito or Stratonovich integrals.
@@ -255,25 +253,23 @@
       dt: float = None,
       name: str = None,
       show_code=False,
       var_type: str = None,
       intg_type: str = None,
       wiener_type: str = None,
       state_delays: Dict[str, bm.AbstractDelay] = None,
-      dyn_vars: Union[bm.Variable, Sequence[bm.Variable], Dict[str, bm.Variable]] = None,
   ):
     super(Milstein, self).__init__(f=f,
                                    g=g,
                                    dt=dt,
                                    name=name,
                                    var_type=var_type,
                                    intg_type=intg_type,
                                    wiener_type=wiener_type,
-                                   state_delays=state_delays,
-                                   dyn_vars=dyn_vars)
+                                   state_delays=state_delays)
     self.set_integral(self.step)
 
   def _get_g_grad(self, f, allow_raise=False, need_grad=True):
     if isinstance(f, joint_eq.JointEq):
       results = []
       state = True
       for sub_eq in f.eqs:
@@ -292,15 +288,15 @@
         res[1] = vars
         res[2] = pars
       except errors.DiffEqError as e:
         state = False
         if not allow_raise:
           raise e
       if need_grad:
-        res[0] = bm.vector_grad(f, argnums=0, dyn_vars=self.dyn_vars)
+        res[0] = bm.vector_grad(f, argnums=0)
       return [tuple(res)], state
 
   def step(self, *args, **kwargs):
     # parse grad function and individual arguments
     parses, state = self._get_g_grad(self.g, allow_raise=False, need_grad=True)
     if not state:
       parses2 = self._get_g_grad(self.f, allow_raise=True, need_grad=False)
@@ -412,25 +408,23 @@
       dt: float = None,
       name: str = None,
       show_code=False,
       var_type: str = None,
       intg_type: str = None,
       wiener_type: str = None,
       state_delays: Dict[str, bm.AbstractDelay] = None,
-      dyn_vars: Union[bm.Variable, Sequence[bm.Variable], Dict[str, bm.Variable]] = None,
   ):
     super(MilsteinGradFree, self).__init__(f=f,
                                            g=g,
                                            dt=dt,
                                            name=name,
                                            var_type=var_type,
                                            intg_type=intg_type,
                                            wiener_type=wiener_type,
-                                           state_delays=state_delays,
-                                           dyn_vars=dyn_vars)
+                                           state_delays=state_delays)
     self.set_integral(self.step)
 
   def step(self, *args, **kwargs):
     # input arguments
     all_args = format_args(args, kwargs, self.arg_names)
     dt = all_args.pop(DT, self.dt)
 
@@ -554,15 +548,14 @@
                                            g=g,
                                            dt=dt,
                                            show_code=show_code,
                                            name=name,
                                            var_type=var_type,
                                            intg_type=intg_type,
                                            wiener_type=wiener_type,
-                                           dyn_vars=dyn_vars,
                                            state_delays=state_delays)
 
     if self.intg_type == constants.STRA_SDE:
       raise NotImplementedError(f'{self.__class__.__name__} does not support integral type of {constants.STRA_SDE}. '
                                 f'It only supports {constants.ITO_SDE} now. ')
 
     # build the integrator
@@ -622,15 +615,15 @@
       return results
 
     else:
       vars, pars, _ = utils.get_args(f)
       if len(vars) != 1:
         raise errors.DiffEqError(constants.multi_vars_msg.format(cls=self.__class__.__name__,
                                                                  vars=str(vars), eq=str(f)))
-      value_and_grad = bm.vector_grad(f, argnums=0, dyn_vars=self.dyn_vars, return_value=True)
+      value_and_grad = bm.vector_grad(f, argnums=0, return_value=True)
 
       # integration function
       def integral(*args, **kwargs):
         assert len(args) > 0
         dt = kwargs.pop('dt', self.dt)
         linear, derivative = value_and_grad(*args, **kwargs)
         linear = bm.as_jax(linear)
```

## brainpy/_src/math/__init__.py

```diff
@@ -36,15 +36,15 @@
 
 # functions
 from .activations import *
 from . import activations
 
 # high-level numpy operations
 from .datatypes import *
-from .arrayinterporate import *
+from .interoperability import *
 from .compat_numpy import *
 from .compat_tensorflow import *
 from .others import *
 from . import random, linalg, fft
 
 # operators
 from .operators import *
```

## brainpy/_src/math/_utils.py

```diff
@@ -13,15 +13,16 @@
 
 
 def _is_leaf(a):
   return isinstance(a, Array)
 
 
 def _compatible_with_brainpy_array(
-    fun: Callable, module: str = ''
+    fun: Callable,
+    module: str = ''
 ):
   func_to_wrap = fun.__np_wrapped__ if hasattr(fun, '__np_wrapped__') else fun
 
   @functools.wraps(func_to_wrap)
   def new_fun(*args, **kwargs):
     args = tree_map(_as_jax_array_, args, is_leaf=_is_leaf)
     out = None
```

## brainpy/_src/math/compat_numpy.py

```diff
@@ -2,15 +2,15 @@
 import jax
 import jax.numpy as jnp
 import numpy as np
 from jax.tree_util import tree_flatten, tree_unflatten
 from jax.tree_util import tree_map
 
 from ._utils import _compatible_with_brainpy_array, _as_jax_array_
-from .arrayinterporate import *
+from .interoperability import *
 from .ndarray import Array
 
 
 __all__ = [
   'full', 'full_like', 'eye', 'identity', 'diag', 'tri', 'tril', 'triu',
   'empty', 'empty_like', 'ones', 'ones_like', 'zeros', 'zeros_like',
   'array', 'asarray', 'arange', 'linspace', 'logspace', 'fill_diagonal',
```

## brainpy/_src/math/compat_tensorflow.py

```diff
@@ -1,14 +1,14 @@
 from typing import Union, Optional
 
 import jax.numpy as jnp
 import jax.ops
 from jax import lax
 
-from brainpy._src.math.arrayinterporate import as_jax
+from brainpy._src.math.interoperability import as_jax
 from brainpy._src.math.ndarray import Array
 from .compat_numpy import (
   prod, min, sum, all, any, mean, std, var, concatenate, clip,
   asarray,
 )
 from .ndarray import _return, _as_jax_array_
```

## brainpy/_src/math/delayvars.py

```diff
@@ -1,25 +1,26 @@
 # -*- coding: utf-8 -*-
 
-from typing import Union, Callable, Optional, Dict
+from typing import Union, Callable
 
 import jax
 import jax.numpy as jnp
-import numpy as np
 from jax import vmap
-from jax.lax import cond, stop_gradient
+from jax.lax import stop_gradient
 
 from brainpy import check
 from brainpy.check import is_float, is_integer, jit_error_checking
 from brainpy.errors import UnsupportedError
-from .arrayinterporate import as_jax
 from .compat_numpy import vstack, broadcast_to
-from .environment import get_dt, get_float, get_int
-from .ndarray import ndarray, Variable, Array
+from .environment import get_dt, get_float
+from .interoperability import as_jax
+from .ndarray import ndarray, Array
 from .object_transform.base import BrainPyObject
+from .object_transform.controls import cond
+from .object_transform.variables import Variable
 
 __all__ = [
   'AbstractDelay',
   'TimeDelay', 'LengthDelay',
   'NeuTimeDelay', 'NeuLenDelay',
   'ROTATE_UPDATE',
   'CONCAT_UPDATE',
@@ -154,16 +155,16 @@
       batch_axis = delay_target.batch_axis + 1
     self.data = Variable(jnp.zeros((self.num_delay_step,) + delay_target.shape,
                                    dtype=delay_target.dtype),
                          batch_axis=batch_axis)
     if before_t0 is None:
       self._before_type = _DATA_BEFORE
     elif callable(before_t0):
-      self._before_t0 = lambda t: jnp.asarray(jnp.broadcast_to(before_t0(t), delay_target.shape),
-                                              dtype=delay_target.dtype)
+      self._before_t0 = lambda t: as_jax(broadcast_to(before_t0(t), delay_target.shape),
+                                         dtype=delay_target.dtype)
       self._before_type = _FUNC_BEFORE
     elif isinstance(before_t0, (ndarray, jnp.ndarray, float, int)):
       self._before_type = _DATA_BEFORE
       self.data[:-1] = before_t0
     else:
       raise ValueError(f'"before_t0" does not support {type(before_t0)}')
     # set initial data
@@ -243,25 +244,23 @@
       diff = diff.value
     if self.interp_method == _INTERP_LINEAR:
       req_num_step = jnp.asarray(diff / self.dt, dtype=jnp.int32)
       extra = diff - req_num_step * self.dt
       return cond(extra == 0., self._true_fn, self._false_fn, (req_num_step, extra))
     elif self.interp_method == _INTERP_ROUND:
       req_num_step = jnp.asarray(jnp.round(diff / self.dt), dtype=jnp.int32)
-      return self._true_fn([req_num_step, 0.])
+      return self._true_fn(req_num_step, 0.)
     else:
       raise UnsupportedError(f'Un-supported interpolation method {self.interp_method}, '
                              f'we only support: {[_INTERP_LINEAR, _INTERP_ROUND]}')
 
-  def _true_fn(self, div_mod):
-    req_num_step, extra = div_mod
+  def _true_fn(self, req_num_step, extra):
     return self.data[self.idx[0] + req_num_step]
 
-  def _false_fn(self, div_mod):
-    req_num_step, extra = div_mod
+  def _false_fn(self, req_num_step, extra):
     idx = jnp.asarray([self.idx[0] + req_num_step,
                        self.idx[0] + req_num_step + 1])
     idx %= self.num_delay_step
     return self._interp_fun(extra, jnp.asarray([0., self.dt]), self.data[idx])
 
   def update(self, value):
     self.data[self.idx[0]] = value
```

## brainpy/_src/math/environment.py

```diff
@@ -11,32 +11,35 @@
 from jax import config, numpy as jnp, devices
 from jax.lib import xla_bridge
 
 from . import modes
 
 bm = None
 
+
 __all__ = [
+  # context manage for environment setting
+  'environment',
+  'batching_environment',
+  'training_environment',
+  'set_environment',
+  'set',
+
   # default data types
   'set_float', 'get_float',
   'set_int', 'get_int',
   'set_bool', 'get_bool',
   'set_complex', 'get_complex',
 
   # default numerical integration step
   'set_dt', 'get_dt',
 
   # default computation modes
   'set_mode', 'get_mode',
 
-  # context manage for environment setting
-  'environment',
-  'batching_environment',
-  'training_environment',
-  'set_environment',
 
   # set jax environments
   'enable_x64', 'disable_x64',
   'set_platform', 'get_platform',
   'set_host_device_count',
 
   # device memory
@@ -47,213 +50,14 @@
   # deprecated
   'ditype',
   'dftype',
 
 ]
 
 
-# default dtype
-# --------------------------
-
-
-def ditype():
-  """Default int type.
-
-  .. deprecated:: 2.3.1
-     Use `brainpy.math.int_` instead.
-  """
-  # raise errors.NoLongerSupportError('\nGet default integer data type through `ditype()` has been deprecated. \n'
-  #                                   'Use `brainpy.math.int_` instead.')
-  global bm
-  if bm is None: from brainpy import math as bm
-  return bm.int_
-
-
-def dftype():
-  """Default float type.
-
-  .. deprecated:: 2.3.1
-     Use `brainpy.math.float_` instead.
-  """
-
-  # raise errors.NoLongerSupportError('\nGet default floating data type through `dftype()` has been deprecated. \n'
-  #                                   'Use `brainpy.math.float_` instead.')
-  global bm
-  if bm is None: from brainpy import math as bm
-  return bm.float_
-
-
-def set_float(dtype: type):
-  """Set global default float type.
-
-  Parameters
-  ----------
-  dtype: type
-    The float type.
-  """
-  if dtype not in [jnp.float16, jnp.float32, jnp.float64, ]:
-    raise TypeError(f'Float data type {dtype} is not supported.')
-  global bm
-  if bm is None: from brainpy import math as bm
-  bm.__dict__['float_'] = dtype
-
-
-def get_float():
-  """Get the default float data type.
-  
-  Returns
-  -------
-  dftype: type
-    The default float data type.
-  """
-  global bm
-  if bm is None: from brainpy import math as bm
-  return bm.float_
-
-
-def set_int(dtype: type):
-  """Set global default integer type.
-
-  Parameters
-  ----------
-  dtype: type
-    The integer type.
-  """
-  if dtype not in [jnp.int8, jnp.int16, jnp.int32, jnp.int64,
-                   jnp.uint8, jnp.uint16, jnp.uint32, jnp.uint64, ]:
-    raise TypeError(f'Integer data type {dtype} is not supported.')
-  global bm
-  if bm is None: from brainpy import math as bm
-  bm.__dict__['int_'] = dtype
-
-
-def get_int():
-  """Get the default int data type.
-
-  Returns
-  -------
-  dftype: type
-    The default int data type.
-  """
-  global bm
-  if bm is None: from brainpy import math as bm
-  return bm.int_
-
-
-def set_bool(dtype: type):
-  """Set global default boolean type.
-
-  Parameters
-  ----------
-  dtype: type
-    The bool type.
-  """
-  global bm
-  if bm is None: from brainpy import math as bm
-  bm.__dict__['bool_'] = dtype
-
-
-def get_bool():
-  """Get the default boolean data type.
-
-  Returns
-  -------
-  dftype: type
-    The default bool data type.
-  """
-  global bm
-  if bm is None: from brainpy import math as bm
-  return bm.bool_
-
-
-def set_complex(dtype: type):
-  """Set global default complex type.
-
-  Parameters
-  ----------
-  dtype: type
-    The complex type.
-  """
-  global bm
-  if bm is None: from brainpy import math as bm
-  bm.__dict__['complex_'] = dtype
-
-
-def get_complex():
-  """Get the default complex data type.
-
-  Returns
-  -------
-  dftype: type
-    The default complex data type.
-  """
-  global bm
-  if bm is None: from brainpy import math as bm
-  return bm.complex_
-
-
-# numerical precision
-# --------------------------
-
-def set_dt(dt):
-  """Set the default numerical integrator precision.
-
-  Parameters
-  ----------
-  dt : float
-      Numerical integration precision.
-  """
-  assert isinstance(dt, float), f'"dt" must a float, but we got {dt}'
-  global bm
-  if bm is None: from brainpy import math as bm
-  bm.__dict__['dt'] = dt
-
-
-def get_dt():
-  """Get the numerical integrator precision.
-
-  Returns
-  -------
-  dt : float
-      Numerical integration precision.
-  """
-  global bm
-  if bm is None: from brainpy import math as bm
-  return bm.dt
-
-
-def set_mode(mode: modes.Mode):
-  """Set the default computing mode.
-
-  Parameters
-  ----------
-  mode: Mode
-    The instance of :py:class:`~.Mode`.
-  """
-  if not isinstance(mode, modes.Mode):
-    raise TypeError(f'Must be instance of brainpy.math.Mode. '
-                    f'But we got {type(mode)}: {mode}')
-  global bm
-  if bm is None: from brainpy import math as bm
-  bm.__dict__['mode'] = mode
-
-
-def get_mode() -> modes.Mode:
-  """Get the default computing mode.
-
-  References
-  ----------
-  mode: Mode
-    The default computing mode.
-  """
-  global bm
-  if bm is None: from brainpy import math as bm
-  return bm.mode
-
-
 # See https://mypy.readthedocs.io/en/latest/generics.html#declaring-decorators
 FuncType = Callable[..., Any]
 F = TypeVar('F', bound=FuncType)
 
 
 class _DecoratorContextManager:
   """Allow a context manager to be used as a decorator"""
@@ -320,74 +124,14 @@
     raise NotImplementedError
 
   def clone(self):
     # override this method if your children class takes __init__ parameters
     return self.__class__()
 
 
-def set(
-    mode: modes.Mode = None,
-    dt: float = None,
-    x64: bool = None,
-    complex_: type = None,
-    float_: type = None,
-    int_: type = None,
-    bool_: type = None,
-):
-  """Set the default computation environment.
-
-  Parameters
-  ----------
-  mode: Mode
-    The computing mode.
-  dt: float
-    The numerical integration precision.
-  x64: bool
-    Enable x64 computation.
-  complex_: type
-    The complex data type.
-  float_
-    The floating data type.
-  int_
-    The integer data type.
-  bool_
-    The bool data type.
-  """
-  if dt is not None:
-    assert isinstance(dt, float), '"dt" must a float.'
-    set_dt(dt)
-
-  if mode is not None:
-    assert isinstance(mode, modes.Mode), f'"mode" must a {modes.Mode}.'
-    set_mode(mode)
-
-  if x64 is not None:
-    assert isinstance(x64, bool), f'"x64" must be a bool.'
-    set_x64(x64)
-
-  if float_ is not None:
-    assert isinstance(float_, type), '"float_" must a float.'
-    set_float(float_)
-
-  if int_ is not None:
-    assert isinstance(int_, type), '"int_" must a type.'
-    set_int(int_)
-
-  if bool_ is not None:
-    assert isinstance(bool_, type), '"bool_" must a type.'
-    set_bool(bool_)
-
-  if complex_ is not None:
-    assert isinstance(complex_, type), '"complex_" must a type.'
-    set_complex(complex_)
-
-
-set_environment = set
-
-
 class environment(_DecoratorContextManager):
   r"""Context-manager that sets a computing environment for brain dynamics computation.
 
   In BrainPy, there are several basic computation settings when constructing models,
   including ``mode`` for controlling model computing behavior, ``dt`` for numerical
   integration, ``int_`` for integer precision, and ``float_`` for floating precision.
   :py:class:`~.environment`` provides a context for model construction and
@@ -401,50 +145,56 @@
     >>>
     >>> with bm.environment(mode=bm.training_mode, dt=0.1):
     >>>   lif1 = bp.neurons.LIF(1)
     >>>
     >>> with bm.environment(mode=bm.nonbatching_mode, dt=0.05, float_=bm.float64):
     >>>   lif2 = bp.neurons.LIF(1)
 
-
   """
 
   def __init__(
       self,
       mode: modes.Mode = None,
       dt: float = None,
       x64: bool = None,
       complex_: type = None,
       float_: type = None,
       int_: type = None,
       bool_: type = None,
   ) -> None:
     super().__init__()
-    self.old_dt = get_dt()
-    self.old_mode = get_mode()
-    self.old_x64 = config.read("jax_enable_x64")
-    self.old_int = get_int()
-    self.old_bool = get_bool()
-    self.old_float = get_float()
-    self.old_complex = get_complex()
 
     if dt is not None:
       assert isinstance(dt, float), '"dt" must a float.'
+      self.old_dt = get_dt()
+
     if mode is not None:
       assert isinstance(mode, modes.Mode), f'"mode" must a {modes.Mode}.'
+      self.old_mode = get_mode()
+
     if x64 is not None:
       assert isinstance(x64, bool), f'"x64" must be a bool.'
+      self.old_x64 = config.read("jax_enable_x64")
+
     if float_ is not None:
       assert isinstance(float_, type), '"float_" must a float.'
+      self.old_float = get_float()
+
     if int_ is not None:
       assert isinstance(int_, type), '"int_" must a type.'
+      self.old_int = get_int()
+
     if bool_ is not None:
       assert isinstance(bool_, type), '"bool_" must a type.'
+      self.old_bool = get_bool()
+
     if complex_ is not None:
       assert isinstance(complex_, type), '"complex_" must a type.'
+      self.old_complex = get_complex()
+
     self.dt = dt
     self.mode = mode
     self.x64 = x64
     self.complex_ = complex_
     self.float_ = float_
     self.int_ = int_
     self.bool_ = bool_
@@ -473,14 +223,17 @@
                           mode=self.mode,
                           x64=self.x64,
                           bool_=self.bool_,
                           complex_=self.complex_,
                           float_=self.float_,
                           int_=self.int_)
 
+  def __eq__(self, other):
+    return id(self) == id(other)
+
 
 class training_environment(environment):
   """Environment with the training mode.
 
   This is a short-cut context setting for an environment with the training mode.
   It is equivalent to::
 
@@ -537,14 +290,273 @@
                      complex_=complex_,
                      float_=float_,
                      int_=int_,
                      bool_=bool_,
                      mode=modes.BatchingMode(batch_size))
 
 
+def set(
+    mode: modes.Mode = None,
+    dt: float = None,
+    x64: bool = None,
+    complex_: type = None,
+    float_: type = None,
+    int_: type = None,
+    bool_: type = None,
+):
+  """Set the default computation environment.
+
+  Parameters
+  ----------
+  mode: Mode
+    The computing mode.
+  dt: float
+    The numerical integration precision.
+  x64: bool
+    Enable x64 computation.
+  complex_: type
+    The complex data type.
+  float_
+    The floating data type.
+  int_
+    The integer data type.
+  bool_
+    The bool data type.
+  """
+  if dt is not None:
+    assert isinstance(dt, float), '"dt" must a float.'
+    set_dt(dt)
+
+  if mode is not None:
+    assert isinstance(mode, modes.Mode), f'"mode" must a {modes.Mode}.'
+    set_mode(mode)
+
+  if x64 is not None:
+    assert isinstance(x64, bool), f'"x64" must be a bool.'
+    set_x64(x64)
+
+  if float_ is not None:
+    assert isinstance(float_, type), '"float_" must a float.'
+    set_float(float_)
+
+  if int_ is not None:
+    assert isinstance(int_, type), '"int_" must a type.'
+    set_int(int_)
+
+  if bool_ is not None:
+    assert isinstance(bool_, type), '"bool_" must a type.'
+    set_bool(bool_)
+
+  if complex_ is not None:
+    assert isinstance(complex_, type), '"complex_" must a type.'
+    set_complex(complex_)
+
+
+set_environment = set
+
+
+# default dtype
+# --------------------------
+
+
+def ditype():
+  """Default int type.
+
+  .. deprecated:: 2.3.1
+     Use `brainpy.math.int_` instead.
+  """
+  # raise errors.NoLongerSupportError('\nGet default integer data type through `ditype()` has been deprecated. \n'
+  #                                   'Use `brainpy.math.int_` instead.')
+  global bm
+  if bm is None: from brainpy import math as bm
+  return bm.int_
+
+
+def dftype():
+  """Default float type.
+
+  .. deprecated:: 2.3.1
+     Use `brainpy.math.float_` instead.
+  """
+
+  # raise errors.NoLongerSupportError('\nGet default floating data type through `dftype()` has been deprecated. \n'
+  #                                   'Use `brainpy.math.float_` instead.')
+  global bm
+  if bm is None: from brainpy import math as bm
+  return bm.float_
+
+
+def set_float(dtype: type):
+  """Set global default float type.
+
+  Parameters
+  ----------
+  dtype: type
+    The float type.
+  """
+  if dtype not in [jnp.float16, jnp.float32, jnp.float64, ]:
+    raise TypeError(f'Float data type {dtype} is not supported.')
+  global bm
+  if bm is None: from brainpy import math as bm
+  bm.__dict__['float_'] = dtype
+
+
+def get_float():
+  """Get the default float data type.
+  
+  Returns
+  -------
+  dftype: type
+    The default float data type.
+  """
+  global bm
+  if bm is None: from brainpy import math as bm
+  return bm.float_
+
+
+def set_int(dtype: type):
+  """Set global default integer type.
+
+  Parameters
+  ----------
+  dtype: type
+    The integer type.
+  """
+  if dtype not in [jnp.int8, jnp.int16, jnp.int32, jnp.int64,
+                   jnp.uint8, jnp.uint16, jnp.uint32, jnp.uint64, ]:
+    raise TypeError(f'Integer data type {dtype} is not supported.')
+  global bm
+  if bm is None: from brainpy import math as bm
+  bm.__dict__['int_'] = dtype
+
+
+def get_int():
+  """Get the default int data type.
+
+  Returns
+  -------
+  dftype: type
+    The default int data type.
+  """
+  global bm
+  if bm is None: from brainpy import math as bm
+  return bm.int_
+
+
+def set_bool(dtype: type):
+  """Set global default boolean type.
+
+  Parameters
+  ----------
+  dtype: type
+    The bool type.
+  """
+  global bm
+  if bm is None: from brainpy import math as bm
+  bm.__dict__['bool_'] = dtype
+
+
+def get_bool():
+  """Get the default boolean data type.
+
+  Returns
+  -------
+  dftype: type
+    The default bool data type.
+  """
+  global bm
+  if bm is None: from brainpy import math as bm
+  return bm.bool_
+
+
+def set_complex(dtype: type):
+  """Set global default complex type.
+
+  Parameters
+  ----------
+  dtype: type
+    The complex type.
+  """
+  global bm
+  if bm is None: from brainpy import math as bm
+  bm.__dict__['complex_'] = dtype
+
+
+def get_complex():
+  """Get the default complex data type.
+
+  Returns
+  -------
+  dftype: type
+    The default complex data type.
+  """
+  global bm
+  if bm is None: from brainpy import math as bm
+  return bm.complex_
+
+
+# numerical precision
+# --------------------------
+
+def set_dt(dt):
+  """Set the default numerical integrator precision.
+
+  Parameters
+  ----------
+  dt : float
+      Numerical integration precision.
+  """
+  assert isinstance(dt, float), f'"dt" must a float, but we got {dt}'
+  global bm
+  if bm is None: from brainpy import math as bm
+  bm.__dict__['dt'] = dt
+
+
+def get_dt():
+  """Get the numerical integrator precision.
+
+  Returns
+  -------
+  dt : float
+      Numerical integration precision.
+  """
+  global bm
+  if bm is None: from brainpy import math as bm
+  return bm.dt
+
+
+def set_mode(mode: modes.Mode):
+  """Set the default computing mode.
+
+  Parameters
+  ----------
+  mode: Mode
+    The instance of :py:class:`~.Mode`.
+  """
+  if not isinstance(mode, modes.Mode):
+    raise TypeError(f'Must be instance of brainpy.math.Mode. '
+                    f'But we got {type(mode)}: {mode}')
+  global bm
+  if bm is None: from brainpy import math as bm
+  bm.__dict__['mode'] = mode
+
+
+def get_mode() -> modes.Mode:
+  """Get the default computing mode.
+
+  References
+  ----------
+  mode: Mode
+    The default computing mode.
+  """
+  global bm
+  if bm is None: from brainpy import math as bm
+  return bm.mode
+
+
 def enable_x64():
   config.update("jax_enable_x64", True)
   set_int(jnp.int64)
   set_float(jnp.float64)
   set_complex(jnp.complex128)
 
 
@@ -633,7 +645,8 @@
   os.environ['XLA_PYTHON_CLIENT_ALLOCATOR'] = 'platform'
 
 
 def enable_gpu_memory_preallocation():
   """Disable pre-allocating the GPU memory."""
   os.environ['XLA_PYTHON_CLIENT_PREALLOCATE'] = 'true'
   os.environ.pop('XLA_PYTHON_CLIENT_ALLOCATOR')
+
```

## brainpy/_src/math/ndarray.py

```diff
@@ -1,68 +1,36 @@
 # -*- coding: utf-8 -*-
 
-from typing import Union, Optional, NoReturn, Sequence, Any, Tuple as TupleType
-import warnings
 import operator
+from typing import Union, Optional, Sequence
 
 import jax
 import numpy as np
 from jax import numpy as jnp
 from jax.dtypes import canonicalize_dtype
-from jax.tree_util import register_pytree_node
+from jax.tree_util import register_pytree_node_class
 
 import brainpy.math
 from brainpy.errors import MathError
 
 __all__ = [
   'Array', 'ndarray', 'JaxArray',  # alias of Array
-  'Variable',
-  'TrainVar',
-  'Parameter',
-  'VariableView',
 ]
 
 # Ways to change values in a zero-dimensional array
 # -----
 # Reference: https://stackoverflow.com/questions/56954714/how-do-i-assign-to-a-zero-dimensional-numpy-array
 #
 #   >>> x = np.array(10)
 # 1. index the original array with ellipsis or an empty tuple
 #    >>> x[...] = 2
 #    >>> x[()] = 2
 
 _all_slice = slice(None, None, None)
 
-msg = ('ArrayType created outside of the jit function '
-       'cannot be updated in JIT mode. You should '
-       'mark it as brainpy.math.Variable instead.')
-
-_jax_transformation_context_ = []
-
-
-def add_context(name) -> None:
-  _jax_transformation_context_.append(name)
-
-
-def del_context(name=None) -> None:
-  try:
-    context = _jax_transformation_context_.pop(-1)
-    if name is not None:
-      if context != name:
-        raise MathError('Transformation context is different!')
-  except IndexError:
-    raise MathError('No transformation context!')
-
-
-def get_context():
-  if len(_jax_transformation_context_) > 0:
-    return _jax_transformation_context_[-1]
-  else:
-    return None
-
 
 def _check_input_array(array):
   if isinstance(array, Array):
     return array.value
   elif isinstance(array, np.ndarray):
     return jnp.asarray(array)
   else:
@@ -80,63 +48,46 @@
 
 
 def _check_out(out):
   if not isinstance(out, Array):
     raise TypeError(f'out must be an instance of brainpy Array. But got {type(out)}')
 
 
+def _get_dtype(v):
+  if hasattr(v, 'dtype'):
+    dtype = v.dtype
+  else:
+    dtype = canonicalize_dtype(type(v))
+  return dtype
+
+
+@register_pytree_node_class
 class Array(object):
   """Multiple-dimensional array in BrainPy.
   """
 
   is_brainpy_array = True
-  _need_check_context = True
-  __slots__ = ("_value", "_transform_context")
+  __slots__ = ("_value",)
 
   def __init__(self, value, dtype=None):
     # array value
     if isinstance(value, Array):
       value = value._value
     elif isinstance(value, (tuple, list, np.ndarray)):
       value = jnp.asarray(value)
     if dtype is not None:
       value = jnp.asarray(value, dtype=dtype)
     self._value = value
-    # jit mode
-    self._transform_context = get_context()
-
-  def __check_context(self) -> None:
-    # raise error when in-place updating a
-    if self._need_check_context:
-      if self._transform_context is None:
-        if len(_jax_transformation_context_) > 0:
-          raise MathError(f'Array created outside of the transformation functions '
-                          f'({_jax_transformation_context_[-1]}) cannot be updated. '
-                          f'You should mark it as a brainpy.math.Variable instead.')
-      else:
-        if len(_jax_transformation_context_) > 0:
-          if self._transform_context != _jax_transformation_context_[-1]:
-            raise MathError(f'Array context "{self._transform_context}" differs from the JAX '
-                            f'transformation context "{_jax_transformation_context_[-1]}"'
-                            '\n\n'
-                            'Array created in one transformation function '
-                            'cannot be updated another transformation function. '
-                            'You should mark it as a brainpy.math.Variable instead.')
 
   @property
   def value(self):
     return self._value
 
   @value.setter
   def value(self, value):
-    self.update(value)
-
-  def update(self, value):
-    """Update the value of this Array.
-    """
     if isinstance(value, Array):
       value = value.value
     elif isinstance(value, np.ndarray):
       value = jnp.asarray(value)
     elif isinstance(value, jax.Array):
       pass
     else:
@@ -146,18 +97,23 @@
       raise MathError(f"The shape of the original data is {self.value.shape}, "
                       f"while we got {value.shape}.")
     if value.dtype != self.value.dtype:
       raise MathError(f"The dtype of the original data is {self.value.dtype}, "
                       f"while we got {value.dtype}.")
     self._value = value.value if isinstance(value, Array) else value
 
+  def update(self, value):
+    """Update the value of this Array.
+    """
+    self.value = value
+
   @property
   def dtype(self):
     """Variable dtype."""
-    return self._value.dtype
+    return _get_dtype(self._value)
 
   @property
   def shape(self):
     """Variable shape."""
     return self.value.shape
 
   @property
@@ -211,16 +167,16 @@
     """Solve the issue of DeviceArray.__iter__.
 
     Details please see JAX issues:
 
     - https://github.com/google/jax/issues/7713
     - https://github.com/google/jax/pull/3821
     """
-    for v in self.value:
-      yield v
+    for i in range(self.value.shape[0]):
+      yield self.value[i]
 
   def __getitem__(self, index):
     if isinstance(index, slice) and (index == _all_slice):
       return self.value
     elif isinstance(index, tuple):
       index = tuple((x.value if isinstance(x, Array) else x) for x in index)
     elif isinstance(index, Array):
@@ -1045,14 +1001,15 @@
     return np.asarray(self.value, dtype=dtype)
 
   def __jax_array__(self):
     return self.value
 
   def as_variable(self):
     """As an instance of Variable."""
+    from brainpy.math import Variable
     return Variable(self)
 
   def __format__(self, specification):
     return self.value.__format__(specification)
 
   def __bool__(self) -> bool:
     return self.value.__bool__()
@@ -1142,19 +1099,16 @@
         typically not contiguous. Furthermore, more than one element of a
         expanded array may refer to a single memory location.
     """
     if not isinstance(array, Array):
       array = Array(array)
     return Array(jnp.broadcast_to(self.value, array.value.shape))
 
-  # def item(self, *args) -> Any:
-  #   return self.value.item(*args)
-
   def pow(self, index: int):
-    return _return(self._value ** index)
+    return _return(self.value ** index)
 
   def addr(
       self,
       vec1: Union['Array', jax.Array, np.ndarray],
       vec2: Union['Array', jax.Array, np.ndarray],
       *,
       beta: float = 1.0,
@@ -1421,255 +1375,17 @@
       sizes_list[base + i] = v if sizes_list[base + i] == -1 else sizes_list[base + i]
       if v != 1 and sizes_list[base + i] != v:
         raise ValueError(
           f'The expanded size of the tensor ({sizes_list[base + i]}) must match the existing size ({v}) at non-singleton '
           f'dimension {i}.  Target sizes: {sizes}.  Tensor sizes: {self.shape}')
     return Array(jnp.broadcast_to(self.value, sizes_list))
 
+  def tree_flatten(self):
+    return (self._value,), None
 
-JaxArray = Array
-ndarray = Array
+  @classmethod
+  def tree_unflatten(cls, aux_data, flat_contents):
+    return cls(*flat_contents)
 
 
-class Variable(Array):
-  """The pointer to specify the dynamical variable.
-
-  Initializing an instance of ``Variable`` by two ways:
-
-  >>> import brainpy.math as bm
-  >>> # 1. init a Variable by the concreate data
-  >>> v1 = bm.Variable(bm.zeros(10))
-  >>> # 2. init a Variable by the data shape
-  >>> v2 = bm.Variable(10)
-
-  Note that when initializing a `Variable` by the data shape,
-  all values in this `Variable` will be initialized as zeros.
-
-  Parameters
-  ----------
-  value_or_size: Shape, Array, int
-    The value or the size of the value.
-  dtype:
-    The type of the data.
-  batch_axis: optional, int
-    The batch axis.
-  """
-
-  _need_check_context = False
-  __slots__ = ('_value', '_batch_axis')
-
-  def __init__(
-      self,
-      value_or_size,
-      dtype: type = None,
-      batch_axis: int = None,
-  ):
-    if isinstance(value_or_size, int):
-      value = jnp.zeros(value_or_size, dtype=dtype)
-    elif isinstance(value_or_size, (tuple, list)) and all([isinstance(s, int) for s in value_or_size]):
-      value = jnp.zeros(value_or_size, dtype=dtype)
-    else:
-      value = value_or_size
-
-    super(Variable, self).__init__(value, dtype=dtype)
-
-    # check batch axis
-    if isinstance(value, Variable):
-      if value.batch_axis is not None and batch_axis is not None:
-        if batch_axis != value.batch_axis:
-          raise ValueError(f'"batch_axis" is not consistent. Got batch_axis in the given value '
-                           f'is {value.batch_axis}, but the specified batch_axis is {batch_axis}')
-      batch_axis = value.batch_axis
-
-    # assign batch axis
-    self._batch_axis = batch_axis
-    if batch_axis is not None:
-      if batch_axis >= self.ndim:
-        raise MathError(f'This variables has {self.ndim} dimension, '
-                        f'but the batch axis is set to be {batch_axis}.')
-
-  @property
-  def nobatch_shape(self) -> TupleType[int, ...]:
-    """Shape without batch axis."""
-    if self.batch_axis is not None:
-      shape = list(self.value.shape)
-      shape.pop(self.batch_axis)
-      return tuple(shape)
-    else:
-      return self.shape
-
-  @property
-  def batch_axis(self) -> Optional[int]:
-    return self._batch_axis
-
-  @batch_axis.setter
-  def batch_axis(self, val):
-    raise ValueError(f'Cannot set "batch_axis" after creating a {self.__class__.__name__} instance.')
-
-  @property
-  def batch_size(self) -> Optional[int]:
-    if self.batch_axis is None:
-      return None
-    else:
-      return self.shape[self.batch_axis]
-
-  @batch_size.setter
-  def batch_size(self, val):
-    raise ValueError(f'Cannot set "batch_size" manually.')
-
-  def update(self, value):
-    """Update the value of this Array.
-    """
-    if self._batch_axis is None:
-      ext_shape = jnp.shape(value)
-      int_shape = self.shape
-    else:
-      ext_shape = value.shape[:self._batch_axis] + value.shape[self._batch_axis + 1:]
-      int_shape = self.shape[:self._batch_axis] + self.shape[self._batch_axis + 1:]
-    if ext_shape != int_shape:
-      error = f"The shape of the original data is {self.shape}, while we got {value.shape}"
-      error += f' with batch_axis={self._batch_axis}.'
-      raise MathError(error)
-    if hasattr(value, 'dtype'):
-      dtype = value.dtype
-    else:
-      dtype = canonicalize_dtype(type(value))
-    if dtype != self.dtype:
-      raise MathError(f"The dtype of the original data is {self.dtype}, "
-                      f"while we got {dtype}.")
-    self._value = value.value if isinstance(value, Array) else value
-
-
-class TrainVar(Variable):
-  """The pointer to specify the trainable variable.
-  """
-  __slots__ = ('_value', '_batch_axis')
-
-  def __init__(self,
-               value_or_size,
-               dtype: type = None,
-               batch_axis: int = None):
-    super(TrainVar, self).__init__(value_or_size,
-                                   dtype=dtype,
-                                   batch_axis=batch_axis)
-
-
-class Parameter(Variable):
-  """The pointer to specify the parameter.
-  """
-  __slots__ = ('_value', '_batch_axis')
-
-  def __init__(self,
-               value_or_size,
-               dtype: type = None,
-               batch_axis: int = None):
-    super(Parameter, self).__init__(value_or_size,
-                                    dtype=dtype,
-                                    batch_axis=batch_axis)
-
-
-class ParallelVariable(Variable):
-  pass
-
-
-class BatchVariable(Variable):
-  pass
-
-
-class VariableView(Variable):
-  """A view of a Variable instance.
-
-  This class is used to create a subset view of ``brainpy.math.Variable``.
-
-  >>> import brainpy.math as bm
-  >>> bm.random.seed(123)
-  >>> origin = bm.Variable(bm.random.random(5))
-  >>> view = bm.VariableView(origin, slice(None, 2, None))  # origin[:2]
-  VariableView([0.02920651, 0.19066381], dtype=float32)
-
-  ``VariableView`` can be used to update the subset of the original
-  Variable instance, and make operations on this subset of the Variable.
-
-  >>> view[:] = 1.
-  >>> view
-  VariableView([1., 1.], dtype=float32)
-  >>> origin
-  Variable([1.       , 1.       , 0.5482849, 0.6564884, 0.8446237], dtype=float32)
-  >>> view + 10
-  Array([11., 11.], dtype=float32)
-  >>> view *= 10
-  VariableView([10., 10.], dtype=float32)
-
-  The above example demonstrates that the updating of an ``VariableView`` instance
-  is actually made in the original ``Variable`` instance.
-
-  Moreover, it's worthy to note that ``VariableView`` is not a PyTree.
-  """
-
-  def __init__(self, value: Variable, index):
-    self.index = jax.tree_util.tree_map(_as_jax_array_, index, is_leaf=lambda a: isinstance(a, Array))
-    if not isinstance(value, Variable):
-      raise ValueError('Must be instance of Variable.')
-    super(VariableView, self).__init__(value.value, batch_axis=value.batch_axis)
-    self._value = value
-
-  def __repr__(self) -> str:
-    print_code = repr(self._value)
-    prefix = f'{self.__class__.__name__}'
-    blank = " " * (len(prefix) + 1)
-    lines = print_code.split("\n")
-    lines[0] = prefix + "(" + lines[0]
-    for i in range(1, len(lines)):
-      lines[i] = blank + lines[i]
-    lines[-1] += ","
-    lines.append(blank + f'index={self.index})')
-    print_code = "\n".join(lines)
-    return print_code
-
-  @property
-  def value(self):
-    return self._value[self.index]
-
-  @value.setter
-  def value(self, v):
-    self.update(v)
-
-  def update(self, value):
-    int_shape = self.shape
-    if self.batch_axis is None:
-      ext_shape = value.shape
-    else:
-      ext_shape = value.shape[:self.batch_axis] + value.shape[self.batch_axis + 1:]
-      int_shape = int_shape[:self.batch_axis] + int_shape[self.batch_axis + 1:]
-    if ext_shape != int_shape:
-      error = f"The shape of the original data is {self.shape}, while we got {value.shape}"
-      if self.batch_axis is None:
-        error += '. Do you forget to set "batch_axis" when initialize this variable?'
-      else:
-        error += f' with batch_axis={self.batch_axis}.'
-      raise MathError(error)
-    if value.dtype != self._value.dtype:
-      raise MathError(f"The dtype of the original data is {self._value.dtype}, "
-                      f"while we got {value.dtype}.")
-    self._value[self.index] = value.value if isinstance(value, Array) else value
-
-
-def _jaxarray_unflatten(aux_data, flat_contents):
-  r = Array(*flat_contents)
-  return r
-
-
-register_pytree_node(Array,
-                     lambda t: ((t.value,), None),
-                     _jaxarray_unflatten)
-
-register_pytree_node(Variable,
-                     lambda t: ((t.value,), None),
-                     lambda aux_data, flat_contents: Variable(*flat_contents))
-
-register_pytree_node(TrainVar,
-                     lambda t: ((t.value,), None),
-                     lambda aux_data, flat_contents: TrainVar(*flat_contents))
-
-register_pytree_node(Parameter,
-                     lambda t: ((t.value,), None),
-                     lambda aux_data, flat_contents: Parameter(*flat_contents))
+JaxArray = Array
+ndarray = Array
```

## brainpy/_src/math/random.py

```diff
@@ -10,4844 +10,4899 @@
 00000090: 2069 6d70 6f72 7420 4f70 7469 6f6e 616c   import Optional
 000000a0: 2c20 556e 696f 6e0a 0a69 6d70 6f72 7420  , Union..import 
 000000b0: 6a61 780a 696d 706f 7274 206e 756d 7079  jax.import numpy
 000000c0: 2061 7320 6e70 0a66 726f 6d20 6a61 7820   as np.from jax 
 000000d0: 696d 706f 7274 206c 6178 2c20 6a69 742c  import lax, jit,
 000000e0: 2076 6d61 702c 206e 756d 7079 2061 7320   vmap, numpy as 
 000000f0: 6a6e 702c 2072 616e 646f 6d20 6173 206a  jnp, random as j
-00000100: 722c 2063 6f72 650a 6672 6f6d 206a 6178  r, core.from jax
-00000110: 2e5f 7372 6320 696d 706f 7274 2064 7479  ._src import dty
-00000120: 7065 730a 6672 6f6d 206a 6178 2e65 7870  pes.from jax.exp
-00000130: 6572 696d 656e 7461 6c2e 686f 7374 5f63  erimental.host_c
-00000140: 616c 6c62 6163 6b20 696d 706f 7274 2063  allback import c
-00000150: 616c 6c0a 6672 6f6d 206a 6178 2e74 7265  all.from jax.tre
-00000160: 655f 7574 696c 2069 6d70 6f72 7420 7265  e_util import re
-00000170: 6769 7374 6572 5f70 7974 7265 655f 6e6f  gister_pytree_no
-00000180: 6465 0a0a 6672 6f6d 2062 7261 696e 7079  de..from brainpy
-00000190: 2e63 6865 636b 2069 6d70 6f72 7420 6a69  .check import ji
-000001a0: 745f 6572 726f 725f 6368 6563 6b69 6e67  t_error_checking
-000001b0: 0a66 726f 6d20 2e6e 6461 7272 6179 2069  .from .ndarray i
-000001c0: 6d70 6f72 7420 4172 7261 792c 2056 6172  mport Array, Var
-000001d0: 6961 626c 652c 205f 7265 7475 726e 0a66  iable, _return.f
-000001e0: 726f 6d20 2e63 6f6d 7061 745f 6e75 6d70  rom .compat_nump
-000001f0: 7920 696d 706f 7274 2073 6861 7065 0a66  y import shape.f
-00000200: 726f 6d20 2e65 6e76 6972 6f6e 6d65 6e74  rom .environment
-00000210: 2069 6d70 6f72 7420 6765 745f 696e 740a   import get_int.
-00000220: 0a5f 5f61 6c6c 5f5f 203d 205b 0a20 2027  .__all__ = [.  '
-00000230: 5261 6e64 6f6d 5374 6174 6527 2c20 2747  RandomState', 'G
-00000240: 656e 6572 6174 6f72 272c 2027 4445 4641  enerator', 'DEFA
-00000250: 554c 5427 2c0a 0a20 2027 7365 6564 272c  ULT',..  'seed',
-00000260: 2027 6465 6661 756c 745f 726e 6727 2c20   'default_rng', 
-00000270: 2773 706c 6974 5f6b 6579 272c 0a0a 2020  'split_key',..  
-00000280: 2320 6e75 6d70 7920 636f 6d70 6174 6962  # numpy compatib
-00000290: 696c 6974 790a 2020 2772 616e 6427 2c20  ility.  'rand', 
-000002a0: 2772 616e 6469 6e74 272c 2027 7261 6e64  'randint', 'rand
-000002b0: 6f6d 5f69 6e74 6567 6572 7327 2c20 2772  om_integers', 'r
-000002c0: 616e 646e 272c 2027 7261 6e64 6f6d 272c  andn', 'random',
-000002d0: 0a20 2027 7261 6e64 6f6d 5f73 616d 706c  .  'random_sampl
-000002e0: 6527 2c20 2772 616e 6627 2c20 2773 616d  e', 'ranf', 'sam
-000002f0: 706c 6527 2c20 2763 686f 6963 6527 2c20  ple', 'choice', 
-00000300: 2770 6572 6d75 7461 7469 6f6e 272c 2027  'permutation', '
-00000310: 7368 7566 666c 6527 2c20 2762 6574 6127  shuffle', 'beta'
-00000320: 2c0a 2020 2765 7870 6f6e 656e 7469 616c  ,.  'exponential
-00000330: 272c 2027 6761 6d6d 6127 2c20 2767 756d  ', 'gamma', 'gum
-00000340: 6265 6c27 2c20 276c 6170 6c61 6365 272c  bel', 'laplace',
-00000350: 2027 6c6f 6769 7374 6963 272c 2027 6e6f   'logistic', 'no
-00000360: 726d 616c 272c 2027 7061 7265 746f 272c  rmal', 'pareto',
-00000370: 0a20 2027 706f 6973 736f 6e27 2c20 2773  .  'poisson', 's
-00000380: 7461 6e64 6172 645f 6361 7563 6879 272c  tandard_cauchy',
-00000390: 2027 7374 616e 6461 7264 5f65 7870 6f6e   'standard_expon
-000003a0: 656e 7469 616c 272c 2027 7374 616e 6461  ential', 'standa
-000003b0: 7264 5f67 616d 6d61 272c 0a20 2027 7374  rd_gamma',.  'st
-000003c0: 616e 6461 7264 5f6e 6f72 6d61 6c27 2c20  andard_normal', 
-000003d0: 2773 7461 6e64 6172 645f 7427 2c20 2775  'standard_t', 'u
-000003e0: 6e69 666f 726d 272c 2027 7472 756e 6361  niform', 'trunca
-000003f0: 7465 645f 6e6f 726d 616c 272c 2027 6265  ted_normal', 'be
-00000400: 726e 6f75 6c6c 6927 2c0a 2020 276c 6f67  rnoulli',.  'log
-00000410: 6e6f 726d 616c 272c 2027 6269 6e6f 6d69  normal', 'binomi
-00000420: 616c 272c 2027 6368 6973 7175 6172 6527  al', 'chisquare'
-00000430: 2c20 2764 6972 6963 686c 6574 272c 2027  , 'dirichlet', '
-00000440: 6765 6f6d 6574 7269 6327 2c20 2766 272c  geometric', 'f',
-00000450: 0a20 2027 6879 7065 7267 656f 6d65 7472  .  'hypergeometr
-00000460: 6963 272c 2027 6c6f 6773 6572 6965 7327  ic', 'logseries'
-00000470: 2c20 276d 756c 7469 6e6f 6d69 616c 272c  , 'multinomial',
-00000480: 2027 6d75 6c74 6976 6172 6961 7465 5f6e   'multivariate_n
-00000490: 6f72 6d61 6c27 2c0a 2020 276e 6567 6174  ormal',.  'negat
-000004a0: 6976 655f 6269 6e6f 6d69 616c 272c 2027  ive_binomial', '
-000004b0: 6e6f 6e63 656e 7472 616c 5f63 6869 7371  noncentral_chisq
-000004c0: 7561 7265 272c 2027 6e6f 6e63 656e 7472  uare', 'noncentr
-000004d0: 616c 5f66 272c 2027 706f 7765 7227 2c0a  al_f', 'power',.
-000004e0: 2020 2772 6179 6c65 6967 6827 2c20 2774    'rayleigh', 't
-000004f0: 7269 616e 6775 6c61 7227 2c20 2776 6f6e  riangular', 'von
-00000500: 6d69 7365 7327 2c20 2777 616c 6427 2c20  mises', 'wald', 
-00000510: 2777 6569 6275 6c6c 272c 2027 7765 6962  'weibull', 'weib
-00000520: 756c 6c5f 6d69 6e27 2c0a 2020 277a 6970  ull_min',.  'zip
-00000530: 6627 2c20 276d 6178 7765 6c6c 272c 2027  f', 'maxwell', '
-00000540: 7427 2c20 276f 7274 686f 676f 6e61 6c27  t', 'orthogonal'
-00000550: 2c20 276c 6f67 6761 6d6d 6127 2c20 2763  , 'loggamma', 'c
-00000560: 6174 6567 6f72 6963 616c 272c 0a0a 2020  ategorical',..  
-00000570: 2320 7079 746f 7263 6820 636f 6d70 6174  # pytorch compat
-00000580: 6962 696c 6974 790a 2020 2772 616e 645f  ibility.  'rand_
-00000590: 6c69 6b65 272c 2027 7261 6e64 696e 745f  like', 'randint_
-000005a0: 6c69 6b65 272c 2027 7261 6e64 6e5f 6c69  like', 'randn_li
-000005b0: 6b65 272c 0a5d 0a0a 0a64 6566 205f 666f  ke',.]...def _fo
-000005c0: 726d 616c 697a 655f 6b65 7928 6b65 7929  rmalize_key(key)
-000005d0: 3a0a 2020 6966 2069 7369 6e73 7461 6e63  :.  if isinstanc
-000005e0: 6528 6b65 792c 2069 6e74 293a 0a20 2020  e(key, int):.   
-000005f0: 2072 6574 7572 6e20 6a72 2e50 524e 474b   return jr.PRNGK
-00000600: 6579 286b 6579 290a 2020 656c 6966 2069  ey(key).  elif i
-00000610: 7369 6e73 7461 6e63 6528 6b65 792c 2028  sinstance(key, (
-00000620: 4172 7261 792c 206a 6e70 2e6e 6461 7272  Array, jnp.ndarr
-00000630: 6179 2c20 6e70 2e6e 6461 7272 6179 2929  ay, np.ndarray))
-00000640: 3a0a 2020 2020 6966 206b 6579 2e64 7479  :.    if key.dty
-00000650: 7065 2021 3d20 6a6e 702e 7569 6e74 3332  pe != jnp.uint32
-00000660: 3a0a 2020 2020 2020 7261 6973 6520 5479  :.      raise Ty
-00000670: 7065 4572 726f 7228 276b 6579 206d 7573  peError('key mus
-00000680: 7420 6265 2061 2069 6e74 206f 7220 616e  t be a int or an
-00000690: 2061 7272 6179 2077 6974 6820 7477 6f20   array with two 
-000006a0: 7569 6e74 3332 2e27 290a 2020 2020 6966  uint32.').    if
-000006b0: 206b 6579 2e73 697a 6520 213d 2032 3a0a   key.size != 2:.
-000006c0: 2020 2020 2020 7261 6973 6520 5479 7065        raise Type
-000006d0: 4572 726f 7228 276b 6579 206d 7573 7420  Error('key must 
-000006e0: 6265 2061 2069 6e74 206f 7220 616e 2061  be a int or an a
-000006f0: 7272 6179 2077 6974 6820 7477 6f20 7569  rray with two ui
-00000700: 6e74 3332 2e27 290a 2020 2020 7265 7475  nt32.').    retu
-00000710: 726e 206a 6e70 2e61 7361 7272 6179 286b  rn jnp.asarray(k
-00000720: 6579 290a 2020 656c 7365 3a0a 2020 2020  ey).  else:.    
-00000730: 7261 6973 6520 5479 7065 4572 726f 7228  raise TypeError(
-00000740: 276b 6579 206d 7573 7420 6265 2061 2069  'key must be a i
-00000750: 6e74 206f 7220 616e 2061 7272 6179 2077  nt or an array w
-00000760: 6974 6820 7477 6f20 7569 6e74 3332 2e27  ith two uint32.'
-00000770: 290a 0a0a 6465 6620 5f73 697a 6532 7368  )...def _size2sh
-00000780: 6170 6528 7369 7a65 293a 0a20 2069 6620  ape(size):.  if 
-00000790: 7369 7a65 2069 7320 4e6f 6e65 3a0a 2020  size is None:.  
-000007a0: 2020 7265 7475 726e 2028 290a 2020 656c    return ().  el
-000007b0: 6966 2069 7369 6e73 7461 6e63 6528 7369  if isinstance(si
-000007c0: 7a65 2c20 696e 7429 3a0a 2020 2020 7265  ze, int):.    re
-000007d0: 7475 726e 2028 7369 7a65 2c29 0a20 2065  turn (size,).  e
-000007e0: 6c69 6620 6973 696e 7374 616e 6365 2873  lif isinstance(s
-000007f0: 697a 652c 2028 7475 706c 652c 206c 6973  ize, (tuple, lis
-00000800: 7429 293a 0a20 2020 2072 6574 7572 6e20  t)):.    return 
-00000810: 7475 706c 6528 7369 7a65 290a 2020 656c  tuple(size).  el
-00000820: 7365 3a0a 2020 2020 7261 6973 6520 5661  se:.    raise Va
-00000830: 6c75 6545 7272 6f72 2866 274d 7573 7420  lueError(f'Must 
-00000840: 6265 2061 206c 6973 742f 7475 706c 6520  be a list/tuple 
-00000850: 6f66 2069 6e74 2c20 6275 7420 676f 7420  of int, but got 
-00000860: 7b73 697a 657d 2729 0a0a 0a64 6566 205f  {size}')...def _
-00000870: 6368 6563 6b5f 7368 6170 6528 6e61 6d65  check_shape(name
-00000880: 2c20 7368 6170 652c 202a 7061 7261 6d5f  , shape, *param_
-00000890: 7368 6170 6573 293a 0a20 2073 6861 7065  shapes):.  shape
-000008a0: 203d 2063 6f72 652e 6173 5f6e 616d 6564   = core.as_named
-000008b0: 5f73 6861 7065 2873 6861 7065 290a 2020  _shape(shape).  
-000008c0: 6966 2070 6172 616d 5f73 6861 7065 733a  if param_shapes:
-000008d0: 0a20 2020 2073 6861 7065 5f20 3d20 6c61  .    shape_ = la
-000008e0: 782e 6272 6f61 6463 6173 745f 7368 6170  x.broadcast_shap
-000008f0: 6573 2873 6861 7065 2e70 6f73 6974 696f  es(shape.positio
-00000900: 6e61 6c2c 202a 7061 7261 6d5f 7368 6170  nal, *param_shap
-00000910: 6573 290a 2020 2020 6966 2073 6861 7065  es).    if shape
-00000920: 2e70 6f73 6974 696f 6e61 6c20 213d 2073  .positional != s
-00000930: 6861 7065 5f3a 0a20 2020 2020 206d 7367  hape_:.      msg
-00000940: 203d 2028 227b 7d20 7061 7261 6d65 7465   = ("{} paramete
-00000950: 7220 7368 6170 6573 206d 7573 7420 6265  r shapes must be
-00000960: 2062 726f 6164 6361 7374 2d63 6f6d 7061   broadcast-compa
-00000970: 7469 626c 6520 7769 7468 2073 6861 7065  tible with shape
-00000980: 2022 0a20 2020 2020 2020 2020 2020 2020   ".             
-00000990: 2261 7267 756d 656e 742c 2061 6e64 2074  "argument, and t
-000009a0: 6865 2072 6573 756c 7420 6f66 2062 726f  he result of bro
-000009b0: 6164 6361 7374 696e 6720 7468 6520 7368  adcasting the sh
-000009c0: 6170 6573 206d 7573 7420 6571 7561 6c20  apes must equal 
-000009d0: 220a 2020 2020 2020 2020 2020 2020 2022  ".             "
-000009e0: 7468 6520 7368 6170 6520 6172 6775 6d65  the shape argume
-000009f0: 6e74 2c20 6275 7420 676f 7420 7265 7375  nt, but got resu
-00000a00: 6c74 207b 7d20 666f 7220 7368 6170 6520  lt {} for shape 
-00000a10: 6172 6775 6d65 6e74 207b 7d2e 2229 0a20  argument {}."). 
-00000a20: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-00000a30: 4572 726f 7228 6d73 672e 666f 726d 6174  Error(msg.format
-00000a40: 286e 616d 652c 2073 6861 7065 5f2c 2073  (name, shape_, s
-00000a50: 6861 7065 2929 0a0a 0a64 6566 205f 6173  hape))...def _as
-00000a60: 5f6a 6178 5f61 7272 6179 2861 293a 0a20  _jax_array(a):. 
-00000a70: 2072 6574 7572 6e20 612e 7661 6c75 6520   return a.value 
-00000a80: 6966 2069 7369 6e73 7461 6e63 6528 612c  if isinstance(a,
-00000a90: 2041 7272 6179 2920 656c 7365 2061 0a0a   Array) else a..
-00000aa0: 0a64 6566 205f 636f 6e73 7428 6578 616d  .def _const(exam
-00000ab0: 706c 652c 2076 616c 293a 0a20 2069 6620  ple, val):.  if 
-00000ac0: 6474 7970 6573 2e69 735f 7079 7468 6f6e  dtypes.is_python
-00000ad0: 5f73 6361 6c61 7228 6578 616d 706c 6529  _scalar(example)
-00000ae0: 3a0a 2020 2020 6474 7970 6520 3d20 6474  :.    dtype = dt
-00000af0: 7970 6573 2e63 616e 6f6e 6963 616c 697a  ypes.canonicaliz
-00000b00: 655f 6474 7970 6528 7479 7065 2865 7861  e_dtype(type(exa
-00000b10: 6d70 6c65 2929 0a20 2020 2076 616c 203d  mple)).    val =
-00000b20: 2064 7479 7065 732e 7363 616c 6172 5f74   dtypes.scalar_t
-00000b30: 7970 655f 6f66 2865 7861 6d70 6c65 2928  ype_of(example)(
-00000b40: 7661 6c29 0a20 2020 2072 6574 7572 6e20  val).    return 
-00000b50: 7661 6c20 6966 2064 7479 7065 203d 3d20  val if dtype == 
-00000b60: 6474 7970 6573 2e64 7479 7065 2876 616c  dtypes.dtype(val
-00000b70: 2c20 6361 6e6f 6e69 6361 6c69 7a65 3d54  , canonicalize=T
-00000b80: 7275 6529 2065 6c73 6520 6e70 2e61 7272  rue) else np.arr
-00000b90: 6179 2876 616c 2c20 6474 7970 6529 0a20  ay(val, dtype). 
-00000ba0: 2065 6c73 653a 0a20 2020 2064 7479 7065   else:.    dtype
-00000bb0: 203d 2064 7479 7065 732e 6361 6e6f 6e69   = dtypes.canoni
-00000bc0: 6361 6c69 7a65 5f64 7479 7065 2865 7861  calize_dtype(exa
-00000bd0: 6d70 6c65 2e64 7479 7065 290a 2020 7265  mple.dtype).  re
-00000be0: 7475 726e 206e 702e 6172 7261 7928 7661  turn np.array(va
-00000bf0: 6c2c 2064 7479 7065 290a 0a0a 5f74 725f  l, dtype)..._tr_
-00000c00: 7061 7261 6d73 203d 206e 616d 6564 7475  params = namedtu
-00000c10: 706c 6528 0a20 2022 7472 5f70 6172 616d  ple(.  "tr_param
-00000c20: 7322 2c20 5b22 6322 2c20 2262 222c 2022  s", ["c", "b", "
-00000c30: 6122 2c20 2261 6c70 6861 222c 2022 755f  a", "alpha", "u_
-00000c40: 7222 2c20 2276 5f72 222c 2022 6d22 2c20  r", "v_r", "m", 
-00000c50: 226c 6f67 5f70 222c 2022 6c6f 6731 5f70  "log_p", "log1_p
-00000c60: 222c 2022 6c6f 675f 6822 5d0a 290a 0a0a  ", "log_h"].)...
-00000c70: 6465 6620 5f67 6574 5f74 725f 7061 7261  def _get_tr_para
-00000c80: 6d73 286e 2c20 7029 3a0a 2020 2320 5365  ms(n, p):.  # Se
-00000c90: 6520 5461 626c 6520 312e 2041 6464 6974  e Table 1. Addit
-00000ca0: 696f 6e61 6c6c 792c 2077 6520 7072 652d  ionally, we pre-
-00000cb0: 636f 6d70 7574 6520 6c6f 6728 7029 2c20  compute log(p), 
-00000cc0: 6c6f 6731 282d 7029 2061 6e64 2074 6865  log1(-p) and the
-00000cd0: 0a20 2023 2063 6f6e 7374 616e 7420 7465  .  # constant te
-00000ce0: 726d 732c 2074 6861 7420 6465 7065 6e64  rms, that depend
-00000cf0: 206f 6e6c 7920 6f6e 2028 6e2c 2070 2c20   only on (n, p, 
-00000d00: 6d29 2069 6e20 6c6f 6728 6628 6b29 2920  m) in log(f(k)) 
-00000d10: 2862 6f74 746f 6d20 6f66 2070 6167 6520  (bottom of page 
-00000d20: 3529 2e0a 2020 6d75 203d 206e 202a 2070  5)..  mu = n * p
-00000d30: 0a20 2073 7071 203d 206a 6e70 2e73 7172  .  spq = jnp.sqr
-00000d40: 7428 6d75 202a 2028 3120 2d20 7029 290a  t(mu * (1 - p)).
-00000d50: 2020 6320 3d20 6d75 202b 2030 2e35 0a20    c = mu + 0.5. 
-00000d60: 2062 203d 2031 2e31 3520 2b20 322e 3533   b = 1.15 + 2.53
-00000d70: 202a 2073 7071 0a20 2061 203d 202d 302e   * spq.  a = -0.
-00000d80: 3038 3733 202b 2030 2e30 3234 3820 2a20  0873 + 0.0248 * 
-00000d90: 6220 2b20 302e 3031 202a 2070 0a20 2061  b + 0.01 * p.  a
-00000da0: 6c70 6861 203d 2028 322e 3833 202b 2035  lpha = (2.83 + 5
-00000db0: 2e31 202f 2062 2920 2a20 7370 710a 2020  .1 / b) * spq.  
-00000dc0: 755f 7220 3d20 302e 3433 0a20 2076 5f72  u_r = 0.43.  v_r
-00000dd0: 203d 2030 2e39 3220 2d20 342e 3220 2f20   = 0.92 - 4.2 / 
-00000de0: 620a 2020 6d20 3d20 6a6e 702e 666c 6f6f  b.  m = jnp.floo
-00000df0: 7228 286e 202b 2031 2920 2a20 7029 2e61  r((n + 1) * p).a
-00000e00: 7374 7970 6528 6e2e 6474 7970 6529 0a20  stype(n.dtype). 
-00000e10: 206c 6f67 5f70 203d 206a 6e70 2e6c 6f67   log_p = jnp.log
-00000e20: 2870 290a 2020 6c6f 6731 5f70 203d 206a  (p).  log1_p = j
-00000e30: 6e70 2e6c 6f67 3170 282d 7029 0a20 206c  np.log1p(-p).  l
-00000e40: 6f67 5f68 203d 2028 286d 202b 2030 2e35  og_h = ((m + 0.5
-00000e50: 2920 2a20 286a 6e70 2e6c 6f67 2828 6d20  ) * (jnp.log((m 
-00000e60: 2b20 312e 3029 202f 2028 6e20 2d20 6d20  + 1.0) / (n - m 
-00000e70: 2b20 312e 3029 2920 2b20 6c6f 6731 5f70  + 1.0)) + log1_p
-00000e80: 202d 206c 6f67 5f70 2920 2b0a 2020 2020   - log_p) +.    
-00000e90: 2020 2020 2020 205f 7374 6972 6c69 6e67         _stirling
-00000ea0: 5f61 7070 726f 785f 7461 696c 286d 2920  _approx_tail(m) 
-00000eb0: 2b20 5f73 7469 726c 696e 675f 6170 7072  + _stirling_appr
-00000ec0: 6f78 5f74 6169 6c28 6e20 2d20 6d29 290a  ox_tail(n - m)).
-00000ed0: 2020 7265 7475 726e 205f 7472 5f70 6172    return _tr_par
-00000ee0: 616d 7328 632c 2062 2c20 612c 2061 6c70  ams(c, b, a, alp
-00000ef0: 6861 2c20 755f 722c 2076 5f72 2c20 6d2c  ha, u_r, v_r, m,
-00000f00: 206c 6f67 5f70 2c20 6c6f 6731 5f70 2c20   log_p, log1_p, 
-00000f10: 6c6f 675f 6829 0a0a 0a64 6566 205f 7374  log_h)...def _st
-00000f20: 6972 6c69 6e67 5f61 7070 726f 785f 7461  irling_approx_ta
-00000f30: 696c 286b 293a 0a20 2070 7265 636f 6d70  il(k):.  precomp
-00000f40: 7574 6564 203d 206a 6e70 2e61 7272 6179  uted = jnp.array
-00000f50: 285b 302e 3038 3130 3631 3436 3637 3935  ([0.081061466795
-00000f60: 3332 3732 362c 0a20 2020 2020 2020 2020  32726,.         
-00000f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000f80: 2020 302e 3034 3133 3430 3639 3539 3535    0.041340695955
-00000f90: 3430 3932 392c 0a20 2020 2020 2020 2020  40929,.         
-00000fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000fb0: 2020 302e 3032 3736 3737 3932 3536 3834    0.027677925684
-00000fc0: 3939 3833 342c 0a20 2020 2020 2020 2020  99834,.         
-00000fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000fe0: 2020 302e 3032 3037 3930 3637 3231 3033    0.020790672103
-00000ff0: 3736 3530 392c 0a20 2020 2020 2020 2020  76509,.         
-00001000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001010: 2020 302e 3031 3636 3434 3639 3131 3839    0.016644691189
-00001020: 3832 3131 392c 0a20 2020 2020 2020 2020  82119,.         
-00001030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001040: 2020 302e 3031 3338 3736 3132 3838 3233    0.013876128823
-00001050: 3037 3037 352c 0a20 2020 2020 2020 2020  07075,.         
-00001060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001070: 2020 302e 3031 3138 3936 3730 3939 3435    0.011896709945
-00001080: 3839 3137 372c 0a20 2020 2020 2020 2020  89177,.         
-00001090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000010a0: 2020 302e 3031 3034 3131 3236 3532 3631    0.010411265261
-000010b0: 3937 3230 392c 0a20 2020 2020 2020 2020  97209,.         
-000010c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000010d0: 2020 302e 3030 3932 3535 3436 3231 3832    0.009255462182
-000010e0: 3731 3237 3333 2c0a 2020 2020 2020 2020  712733,.        
-000010f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001100: 2020 2030 2e30 3038 3333 3035 3633 3433     0.00833056343
-00001110: 3333 3632 3837 312c 205d 290a 2020 6b70  3362871, ]).  kp
-00001120: 3120 3d20 6b20 2b20 310a 2020 6b70 3173  1 = k + 1.  kp1s
-00001130: 7120 3d20 286b 202b 2031 2920 2a2a 2032  q = (k + 1) ** 2
-00001140: 0a20 2072 6574 7572 6e20 6a6e 702e 7768  .  return jnp.wh
-00001150: 6572 6528 6b20 3c20 3130 2c0a 2020 2020  ere(k < 10,.    
-00001160: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00001170: 7265 636f 6d70 7574 6564 5b6b 5d2c 0a20  recomputed[k],. 
-00001180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001190: 2020 2831 2e30 202f 2031 3220 2d20 2831    (1.0 / 12 - (1
-000011a0: 2e30 202f 2033 3630 202d 2028 312e 3020  .0 / 360 - (1.0 
-000011b0: 2f20 3132 3630 2920 2f20 6b70 3173 7129  / 1260) / kp1sq)
-000011c0: 202f 206b 7031 7371 2920 2f20 6b70 3129   / kp1sq) / kp1)
-000011d0: 0a0a 0a64 6566 205f 6269 6e6f 6d69 616c  ...def _binomial
-000011e0: 5f62 7472 7328 6b65 792c 2070 2c20 6e29  _btrs(key, p, n)
-000011f0: 3a0a 2020 2222 220a 2020 4261 7365 6420  :.  """.  Based 
-00001200: 6f6e 2074 6865 2074 7261 6e73 666f 726d  on the transform
-00001210: 6564 2072 656a 6563 7469 6f6e 2073 616d  ed rejection sam
-00001220: 706c 696e 6720 616c 676f 7269 7468 6d20  pling algorithm 
-00001230: 2842 5452 5329 2066 726f 6d20 7468 650a  (BTRS) from the.
-00001240: 2020 666f 6c6c 6f77 696e 6720 7265 6665    following refe
-00001250: 7265 6e63 653a 0a0a 2020 486f 726d 616e  rence:..  Horman
-00001260: 6e2c 2022 5468 6520 4765 6e65 7261 7469  n, "The Generati
-00001270: 6f6e 206f 6620 4269 6e6f 6e6d 6961 6c20  on of Binonmial 
-00001280: 5261 6e64 6f6d 2056 6172 6961 7465 7322  Random Variates"
-00001290: 0a20 2028 6874 7470 733a 2f2f 636f 7265  .  (https://core
-000012a0: 2e61 632e 756b 2f64 6f77 6e6c 6f61 642f  .ac.uk/download/
-000012b0: 7064 662f 3131 3030 3732 3534 2e70 6466  pdf/11007254.pdf
-000012c0: 290a 2020 2222 220a 0a20 2064 6566 205f  ).  """..  def _
-000012d0: 6274 7273 5f62 6f64 795f 666e 2876 616c  btrs_body_fn(val
-000012e0: 293a 0a20 2020 205f 2c20 6b65 792c 205f  ):.    _, key, _
-000012f0: 2c20 5f20 3d20 7661 6c0a 2020 2020 6b65  , _ = val.    ke
-00001300: 792c 206b 6579 5f75 2c20 6b65 795f 7620  y, key_u, key_v 
-00001310: 3d20 6a72 2e73 706c 6974 286b 6579 2c20  = jr.split(key, 
-00001320: 3329 0a20 2020 2075 203d 206a 722e 756e  3).    u = jr.un
-00001330: 6966 6f72 6d28 6b65 795f 7529 0a20 2020  iform(key_u).   
-00001340: 2076 203d 206a 722e 756e 6966 6f72 6d28   v = jr.uniform(
-00001350: 6b65 795f 7629 0a20 2020 2075 203d 2075  key_v).    u = u
-00001360: 202d 2030 2e35 0a20 2020 206b 203d 206a   - 0.5.    k = j
-00001370: 6e70 2e66 6c6f 6f72 280a 2020 2020 2020  np.floor(.      
-00001380: 2832 202a 2074 725f 7061 7261 6d73 2e61  (2 * tr_params.a
-00001390: 202f 2028 302e 3520 2d20 6a6e 702e 6162   / (0.5 - jnp.ab
-000013a0: 7328 7529 2920 2b20 7472 5f70 6172 616d  s(u)) + tr_param
-000013b0: 732e 6229 202a 2075 202b 2074 725f 7061  s.b) * u + tr_pa
-000013c0: 7261 6d73 2e63 0a20 2020 2029 2e61 7374  rams.c.    ).ast
-000013d0: 7970 6528 6e2e 6474 7970 6529 0a20 2020  ype(n.dtype).   
-000013e0: 2072 6574 7572 6e20 6b2c 206b 6579 2c20   return k, key, 
-000013f0: 752c 2076 0a0a 2020 6465 6620 5f62 7472  u, v..  def _btr
-00001400: 735f 636f 6e64 5f66 6e28 7661 6c29 3a0a  s_cond_fn(val):.
-00001410: 2020 2020 6465 6620 6163 6365 7074 5f66      def accept_f
-00001420: 6e28 6b2c 2075 2c20 7629 3a0a 2020 2020  n(k, u, v):.    
-00001430: 2020 2320 5365 6520 6163 6365 7074 616e    # See acceptan
-00001440: 6365 2063 6f6e 6469 7469 6f6e 2069 6e20  ce condition in 
-00001450: 5374 6570 2033 2e20 2850 6167 6520 3329  Step 3. (Page 3)
-00001460: 206f 6620 5452 5320 616c 676f 7269 7468   of TRS algorith
-00001470: 6d0a 2020 2020 2020 2320 7620 3c3d 2066  m.      # v <= f
-00001480: 286b 2920 2a20 675f 6772 6164 2875 2920  (k) * g_grad(u) 
-00001490: 2f20 616c 7068 610a 0a20 2020 2020 206d  / alpha..      m
-000014a0: 203d 2074 725f 7061 7261 6d73 2e6d 0a20   = tr_params.m. 
-000014b0: 2020 2020 206c 6f67 5f70 203d 2074 725f       log_p = tr_
-000014c0: 7061 7261 6d73 2e6c 6f67 5f70 0a20 2020  params.log_p.   
-000014d0: 2020 206c 6f67 315f 7020 3d20 7472 5f70     log1_p = tr_p
-000014e0: 6172 616d 732e 6c6f 6731 5f70 0a20 2020  arams.log1_p.   
-000014f0: 2020 2023 2053 6565 3a20 666f 726d 756c     # See: formul
-00001500: 6120 666f 7220 6c6f 6728 6628 6b29 2920  a for log(f(k)) 
-00001510: 6174 2062 6f74 746f 6d20 6f66 2050 6167  at bottom of Pag
-00001520: 6520 352e 0a20 2020 2020 206c 6f67 5f66  e 5..      log_f
-00001530: 203d 2028 0a20 2020 2020 2020 2020 2028   = (.          (
-00001540: 6e20 2b20 312e 3029 202a 206a 6e70 2e6c  n + 1.0) * jnp.l
-00001550: 6f67 2828 6e20 2d20 6d20 2b20 312e 3029  og((n - m + 1.0)
-00001560: 202f 2028 6e20 2d20 6b20 2b20 312e 3029   / (n - k + 1.0)
-00001570: 290a 2020 2020 2020 2020 2020 2b20 286b  ).          + (k
-00001580: 202b 2030 2e35 2920 2a20 286a 6e70 2e6c   + 0.5) * (jnp.l
-00001590: 6f67 2828 6e20 2d20 6b20 2b20 312e 3029  og((n - k + 1.0)
-000015a0: 202f 2028 6b20 2b20 312e 3029 2920 2b20   / (k + 1.0)) + 
-000015b0: 6c6f 675f 7020 2d20 6c6f 6731 5f70 290a  log_p - log1_p).
-000015c0: 2020 2020 2020 2020 2020 2b20 285f 7374            + (_st
-000015d0: 6972 6c69 6e67 5f61 7070 726f 785f 7461  irling_approx_ta
-000015e0: 696c 286b 2920 2d20 5f73 7469 726c 696e  il(k) - _stirlin
-000015f0: 675f 6170 7072 6f78 5f74 6169 6c28 6e20  g_approx_tail(n 
-00001600: 2d20 6b29 290a 2020 2020 2020 2020 2020  - k)).          
-00001610: 2b20 7472 5f70 6172 616d 732e 6c6f 675f  + tr_params.log_
-00001620: 680a 2020 2020 2020 290a 2020 2020 2020  h.      ).      
-00001630: 6720 3d20 2874 725f 7061 7261 6d73 2e61  g = (tr_params.a
-00001640: 202f 2028 302e 3520 2d20 6a6e 702e 6162   / (0.5 - jnp.ab
-00001650: 7328 7529 2920 2a2a 2032 2920 2b20 7472  s(u)) ** 2) + tr
-00001660: 5f70 6172 616d 732e 620a 2020 2020 2020  _params.b.      
-00001670: 7265 7475 726e 206a 6e70 2e6c 6f67 2828  return jnp.log((
-00001680: 7620 2a20 7472 5f70 6172 616d 732e 616c  v * tr_params.al
-00001690: 7068 6129 202f 2067 2920 3c3d 206c 6f67  pha) / g) <= log
-000016a0: 5f66 0a0a 2020 2020 6b2c 206b 6579 2c20  _f..    k, key, 
-000016b0: 752c 2076 203d 2076 616c 0a20 2020 2065  u, v = val.    e
-000016c0: 6172 6c79 5f61 6363 6570 7420 3d20 286a  arly_accept = (j
-000016d0: 6e70 2e61 6273 2875 2920 3c3d 2074 725f  np.abs(u) <= tr_
-000016e0: 7061 7261 6d73 2e75 5f72 2920 2620 2876  params.u_r) & (v
-000016f0: 203c 3d20 7472 5f70 6172 616d 732e 765f   <= tr_params.v_
-00001700: 7229 0a20 2020 2065 6172 6c79 5f72 656a  r).    early_rej
-00001710: 6563 7420 3d20 286b 203c 2030 2920 7c20  ect = (k < 0) | 
-00001720: 286b 203e 206e 290a 2020 2020 7265 7475  (k > n).    retu
-00001730: 726e 206c 6178 2e63 6f6e 6428 0a20 2020  rn lax.cond(.   
-00001740: 2020 2065 6172 6c79 5f61 6363 6570 7420     early_accept 
-00001750: 7c20 6561 726c 795f 7265 6a65 6374 2c0a  | early_reject,.
-00001760: 2020 2020 2020 2829 2c0a 2020 2020 2020        (),.      
-00001770: 6c61 6d62 6461 205f 3a20 7e65 6172 6c79  lambda _: ~early
-00001780: 5f61 6363 6570 742c 0a20 2020 2020 2028  _accept,.      (
-00001790: 6b2c 2075 2c20 7629 2c0a 2020 2020 2020  k, u, v),.      
-000017a0: 6c61 6d62 6461 2078 3a20 7e61 6363 6570  lambda x: ~accep
-000017b0: 745f 666e 282a 7829 2c0a 2020 2020 290a  t_fn(*x),.    ).
-000017c0: 0a20 2074 725f 7061 7261 6d73 203d 205f  .  tr_params = _
-000017d0: 6765 745f 7472 5f70 6172 616d 7328 6e2c  get_tr_params(n,
-000017e0: 2070 290a 2020 7265 7420 3d20 6c61 782e   p).  ret = lax.
-000017f0: 7768 696c 655f 6c6f 6f70 280a 2020 2020  while_loop(.    
-00001800: 5f62 7472 735f 636f 6e64 5f66 6e2c 205f  _btrs_cond_fn, _
-00001810: 6274 7273 5f62 6f64 795f 666e 2c20 282d  btrs_body_fn, (-
-00001820: 312c 206b 6579 2c20 312e 302c 2031 2e30  1, key, 1.0, 1.0
-00001830: 290a 2020 2920 2023 2075 7365 206b 3d2d  ).  )  # use k=-
-00001840: 3120 696e 6974 6961 6c6c 7920 736f 2074  1 initially so t
-00001850: 6861 7420 636f 6e64 5f66 6e20 7265 7475  hat cond_fn retu
-00001860: 726e 7320 5472 7565 0a20 2072 6574 7572  rns True.  retur
-00001870: 6e20 7265 745b 305d 0a0a 0a64 6566 205f  n ret[0]...def _
-00001880: 6269 6e6f 6d69 616c 5f69 6e76 6572 7369  binomial_inversi
-00001890: 6f6e 286b 6579 2c20 702c 206e 293a 0a20  on(key, p, n):. 
-000018a0: 2064 6566 205f 6269 6e6f 6d5f 696e 765f   def _binom_inv_
-000018b0: 626f 6479 5f66 6e28 7661 6c29 3a0a 2020  body_fn(val):.  
-000018c0: 2020 692c 206b 6579 2c20 6765 6f6d 5f61    i, key, geom_a
-000018d0: 6363 203d 2076 616c 0a20 2020 206b 6579  cc = val.    key
-000018e0: 2c20 6b65 795f 7520 3d20 6a72 2e73 706c  , key_u = jr.spl
-000018f0: 6974 286b 6579 290a 2020 2020 7520 3d20  it(key).    u = 
-00001900: 6a72 2e75 6e69 666f 726d 286b 6579 5f75  jr.uniform(key_u
-00001910: 290a 2020 2020 6765 6f6d 203d 206a 6e70  ).    geom = jnp
-00001920: 2e66 6c6f 6f72 286a 6e70 2e6c 6f67 3170  .floor(jnp.log1p
-00001930: 282d 7529 202f 206c 6f67 315f 7029 202b  (-u) / log1_p) +
-00001940: 2031 0a20 2020 2067 656f 6d5f 6163 6320   1.    geom_acc 
-00001950: 3d20 6765 6f6d 5f61 6363 202b 2067 656f  = geom_acc + geo
-00001960: 6d0a 2020 2020 7265 7475 726e 2069 202b  m.    return i +
-00001970: 2031 2c20 6b65 792c 2067 656f 6d5f 6163   1, key, geom_ac
-00001980: 630a 0a20 2064 6566 205f 6269 6e6f 6d5f  c..  def _binom_
-00001990: 696e 765f 636f 6e64 5f66 6e28 7661 6c29  inv_cond_fn(val)
-000019a0: 3a0a 2020 2020 692c 205f 2c20 6765 6f6d  :.    i, _, geom
-000019b0: 5f61 6363 203d 2076 616c 0a20 2020 2072  _acc = val.    r
-000019c0: 6574 7572 6e20 6765 6f6d 5f61 6363 203c  eturn geom_acc <
-000019d0: 3d20 6e0a 0a20 206c 6f67 315f 7020 3d20  = n..  log1_p = 
-000019e0: 6a6e 702e 6c6f 6731 7028 2d70 290a 2020  jnp.log1p(-p).  
-000019f0: 7265 7420 3d20 6c61 782e 7768 696c 655f  ret = lax.while_
-00001a00: 6c6f 6f70 285f 6269 6e6f 6d5f 696e 765f  loop(_binom_inv_
-00001a10: 636f 6e64 5f66 6e2c 205f 6269 6e6f 6d5f  cond_fn, _binom_
-00001a20: 696e 765f 626f 6479 5f66 6e2c 2028 2d31  inv_body_fn, (-1
-00001a30: 2c20 6b65 792c 2030 2e30 2929 0a20 2072  , key, 0.0)).  r
-00001a40: 6574 7572 6e20 7265 745b 305d 0a0a 0a64  eturn ret[0]...d
-00001a50: 6566 205f 6269 6e6f 6d69 616c 5f64 6973  ef _binomial_dis
-00001a60: 7061 7463 6828 6b65 792c 2070 2c20 6e29  patch(key, p, n)
-00001a70: 3a0a 2020 6465 6620 6469 7370 6174 6368  :.  def dispatch
-00001a80: 286b 6579 2c20 702c 206e 293a 0a20 2020  (key, p, n):.   
-00001a90: 2069 735f 6c65 5f6d 6964 203d 2070 203c   is_le_mid = p <
-00001aa0: 3d20 302e 350a 2020 2020 7071 203d 206a  = 0.5.    pq = j
-00001ab0: 6e70 2e77 6865 7265 2869 735f 6c65 5f6d  np.where(is_le_m
-00001ac0: 6964 2c20 702c 2031 202d 2070 290a 2020  id, p, 1 - p).  
-00001ad0: 2020 6d75 203d 206e 202a 2070 710a 2020    mu = n * pq.  
-00001ae0: 2020 6b20 3d20 6c61 782e 636f 6e64 280a    k = lax.cond(.
-00001af0: 2020 2020 2020 6d75 203c 2031 302c 0a20        mu < 10,. 
-00001b00: 2020 2020 2028 6b65 792c 2070 712c 206e       (key, pq, n
-00001b10: 292c 0a20 2020 2020 206c 616d 6264 6120  ),.      lambda 
-00001b20: 783a 205f 6269 6e6f 6d69 616c 5f69 6e76  x: _binomial_inv
-00001b30: 6572 7369 6f6e 282a 7829 2c0a 2020 2020  ersion(*x),.    
-00001b40: 2020 286b 6579 2c20 7071 2c20 6e29 2c0a    (key, pq, n),.
-00001b50: 2020 2020 2020 6c61 6d62 6461 2078 3a20        lambda x: 
-00001b60: 5f62 696e 6f6d 6961 6c5f 6274 7273 282a  _binomial_btrs(*
-00001b70: 7829 2c0a 2020 2020 290a 2020 2020 7265  x),.    ).    re
-00001b80: 7475 726e 206a 6e70 2e77 6865 7265 2869  turn jnp.where(i
-00001b90: 735f 6c65 5f6d 6964 2c20 6b2c 206e 202d  s_le_mid, k, n -
-00001ba0: 206b 290a 0a20 2023 2052 6574 7572 6e20   k)..  # Return 
-00001bb0: 3020 666f 7220 6e61 6e20 6070 6020 6f72  0 for nan `p` or
-00001bc0: 206e 6567 6174 6976 6520 606e 602c 2073   negative `n`, s
-00001bd0: 696e 6365 206e 616e 2076 616c 7565 7320  ince nan values 
-00001be0: 6172 6520 6e6f 7420 616c 6c6f 7765 6420  are not allowed 
-00001bf0: 666f 7220 696e 7465 6765 7220 7479 7065  for integer type
-00001c00: 730a 2020 636f 6e64 3020 3d20 6a6e 702e  s.  cond0 = jnp.
-00001c10: 6973 6669 6e69 7465 2870 2920 2620 286e  isfinite(p) & (n
-00001c20: 203e 2030 2920 2620 2870 203e 2030 290a   > 0) & (p > 0).
-00001c30: 2020 7265 7475 726e 206c 6178 2e63 6f6e    return lax.con
-00001c40: 6428 0a20 2020 2063 6f6e 6430 2026 2028  d(.    cond0 & (
-00001c50: 7020 3c20 3129 2c0a 2020 2020 286b 6579  p < 1),.    (key
-00001c60: 2c20 702c 206e 292c 0a20 2020 206c 616d  , p, n),.    lam
-00001c70: 6264 6120 783a 2064 6973 7061 7463 6828  bda x: dispatch(
-00001c80: 2a78 292c 0a20 2020 2028 292c 0a20 2020  *x),.    (),.   
-00001c90: 206c 616d 6264 6120 5f3a 206a 6e70 2e77   lambda _: jnp.w
-00001ca0: 6865 7265 2863 6f6e 6430 2c20 6e2c 2030  here(cond0, n, 0
-00001cb0: 292c 0a20 2029 0a0a 0a40 7061 7274 6961  ),.  )...@partia
-00001cc0: 6c28 6a69 742c 2073 7461 7469 635f 6172  l(jit, static_ar
-00001cd0: 676e 756d 733d 2833 2c29 290a 6465 6620  gnums=(3,)).def 
-00001ce0: 5f62 696e 6f6d 6961 6c28 6b65 792c 2070  _binomial(key, p
-00001cf0: 2c20 6e2c 2073 6861 7065 293a 0a20 2073  , n, shape):.  s
-00001d00: 6861 7065 203d 2073 6861 7065 206f 7220  hape = shape or 
-00001d10: 6c61 782e 6272 6f61 6463 6173 745f 7368  lax.broadcast_sh
-00001d20: 6170 6573 286a 6e70 2e73 6861 7065 2870  apes(jnp.shape(p
-00001d30: 292c 206a 6e70 2e73 6861 7065 286e 2929  ), jnp.shape(n))
-00001d40: 0a20 2023 2072 6573 6861 7065 2074 6f20  .  # reshape to 
-00001d50: 6d61 7020 6f76 6572 2061 7869 7320 300a  map over axis 0.
-00001d60: 2020 7020 3d20 6a6e 702e 7265 7368 6170    p = jnp.reshap
-00001d70: 6528 6a6e 702e 6272 6f61 6463 6173 745f  e(jnp.broadcast_
-00001d80: 746f 2870 2c20 7368 6170 6529 2c20 2d31  to(p, shape), -1
-00001d90: 290a 2020 6e20 3d20 6a6e 702e 7265 7368  ).  n = jnp.resh
-00001da0: 6170 6528 6a6e 702e 6272 6f61 6463 6173  ape(jnp.broadcas
-00001db0: 745f 746f 286e 2c20 7368 6170 6529 2c20  t_to(n, shape), 
-00001dc0: 2d31 290a 2020 6b65 7920 3d20 6a72 2e73  -1).  key = jr.s
-00001dd0: 706c 6974 286b 6579 2c20 6a6e 702e 7369  plit(key, jnp.si
-00001de0: 7a65 2870 2929 0a20 2069 6620 6a61 782e  ze(p)).  if jax.
-00001df0: 6465 6661 756c 745f 6261 636b 656e 6428  default_backend(
-00001e00: 2920 3d3d 2022 6370 7522 3a0a 2020 2020  ) == "cpu":.    
-00001e10: 7265 7420 3d20 6c61 782e 6d61 7028 6c61  ret = lax.map(la
-00001e20: 6d62 6461 2078 3a20 5f62 696e 6f6d 6961  mbda x: _binomia
-00001e30: 6c5f 6469 7370 6174 6368 282a 7829 2c20  l_dispatch(*x), 
-00001e40: 286b 6579 2c20 702c 206e 2929 0a20 2065  (key, p, n)).  e
-00001e50: 6c73 653a 0a20 2020 2072 6574 203d 2076  lse:.    ret = v
-00001e60: 6d61 7028 6c61 6d62 6461 202a 783a 205f  map(lambda *x: _
-00001e70: 6269 6e6f 6d69 616c 5f64 6973 7061 7463  binomial_dispatc
-00001e80: 6828 2a78 2929 286b 6579 2c20 702c 206e  h(*x))(key, p, n
-00001e90: 290a 2020 7265 7475 726e 206a 6e70 2e72  ).  return jnp.r
-00001ea0: 6573 6861 7065 2872 6574 2c20 7368 6170  eshape(ret, shap
-00001eb0: 6529 0a0a 0a40 7061 7274 6961 6c28 6a69  e)...@partial(ji
-00001ec0: 742c 2073 7461 7469 635f 6172 676e 756d  t, static_argnum
-00001ed0: 733d 2832 2c29 290a 6465 6620 5f63 6174  s=(2,)).def _cat
-00001ee0: 6567 6f72 6963 616c 286b 6579 2c20 702c  egorical(key, p,
-00001ef0: 2073 6861 7065 293a 0a20 2023 2074 6869   shape):.  # thi
-00001f00: 7320 696d 706c 656d 656e 7461 7469 6f6e  s implementation
-00001f10: 2069 7320 6661 7374 2077 6865 6e20 6576   is fast when ev
-00001f20: 656e 7420 7368 6170 6520 6973 2073 6d61  ent shape is sma
-00001f30: 6c6c 2c20 616e 6420 736c 6f77 206f 7468  ll, and slow oth
-00001f40: 6572 7769 7365 0a20 2023 2052 6566 3a20  erwise.  # Ref: 
-00001f50: 6874 7470 733a 2f2f 7374 6163 6b6f 7665  https://stackove
-00001f60: 7266 6c6f 772e 636f 6d2f 612f 3334 3139  rflow.com/a/3419
-00001f70: 3030 3335 0a20 2073 6861 7065 203d 2073  0035.  shape = s
-00001f80: 6861 7065 206f 7220 702e 7368 6170 655b  hape or p.shape[
-00001f90: 3a2d 315d 0a20 2073 203d 206a 6e70 2e63  :-1].  s = jnp.c
-00001fa0: 756d 7375 6d28 702c 2061 7869 733d 2d31  umsum(p, axis=-1
-00001fb0: 290a 2020 7220 3d20 6a72 2e75 6e69 666f  ).  r = jr.unifo
-00001fc0: 726d 286b 6579 2c20 7368 6170 653d 7368  rm(key, shape=sh
-00001fd0: 6170 6520 2b20 2831 2c29 290a 2020 7265  ape + (1,)).  re
-00001fe0: 7475 726e 206a 6e70 2e73 756d 2873 203c  turn jnp.sum(s <
-00001ff0: 2072 2c20 6178 6973 3d2d 3129 0a0a 0a64   r, axis=-1)...d
-00002000: 6566 205f 7363 6174 7465 725f 6164 645f  ef _scatter_add_
-00002010: 6f6e 6528 6f70 6572 616e 642c 2069 6e64  one(operand, ind
-00002020: 6963 6573 2c20 7570 6461 7465 7329 3a0a  ices, updates):.
-00002030: 2020 7265 7475 726e 206c 6178 2e73 6361    return lax.sca
-00002040: 7474 6572 5f61 6464 280a 2020 2020 6f70  tter_add(.    op
-00002050: 6572 616e 642c 0a20 2020 2069 6e64 6963  erand,.    indic
-00002060: 6573 2c0a 2020 2020 7570 6461 7465 732c  es,.    updates,
-00002070: 0a20 2020 206c 6178 2e53 6361 7474 6572  .    lax.Scatter
-00002080: 4469 6d65 6e73 696f 6e4e 756d 6265 7273  DimensionNumbers
-00002090: 280a 2020 2020 2020 7570 6461 7465 5f77  (.      update_w
-000020a0: 696e 646f 775f 6469 6d73 3d28 292c 0a20  indow_dims=(),. 
-000020b0: 2020 2020 2069 6e73 6572 7465 645f 7769       inserted_wi
-000020c0: 6e64 6f77 5f64 696d 733d 2830 2c29 2c0a  ndow_dims=(0,),.
-000020d0: 2020 2020 2020 7363 6174 7465 725f 6469        scatter_di
-000020e0: 6d73 5f74 6f5f 6f70 6572 616e 645f 6469  ms_to_operand_di
-000020f0: 6d73 3d28 302c 292c 0a20 2020 2029 2c0a  ms=(0,),.    ),.
-00002100: 2020 290a 0a0a 6465 6620 5f72 6573 6861    )...def _resha
-00002110: 7065 2878 2c20 7368 6170 6529 3a0a 2020  pe(x, shape):.  
-00002120: 6966 2069 7369 6e73 7461 6e63 6528 782c  if isinstance(x,
-00002130: 2028 696e 742c 2066 6c6f 6174 2c20 6e70   (int, float, np
-00002140: 2e6e 6461 7272 6179 2c20 6e70 2e67 656e  .ndarray, np.gen
-00002150: 6572 6963 2929 3a0a 2020 2020 7265 7475  eric)):.    retu
-00002160: 726e 206e 702e 7265 7368 6170 6528 782c  rn np.reshape(x,
-00002170: 2073 6861 7065 290a 2020 656c 7365 3a0a   shape).  else:.
-00002180: 2020 2020 7265 7475 726e 206a 6e70 2e72      return jnp.r
-00002190: 6573 6861 7065 2878 2c20 7368 6170 6529  eshape(x, shape)
-000021a0: 0a0a 0a64 6566 205f 7072 6f6d 6f74 655f  ...def _promote_
-000021b0: 7368 6170 6573 282a 6172 6773 2c20 7368  shapes(*args, sh
-000021c0: 6170 653d 2829 293a 0a20 2023 2061 6461  ape=()):.  # ada
-000021d0: 7074 6564 2066 726f 6d20 6c61 782e 6c61  pted from lax.la
-000021e0: 785f 6e75 6d70 790a 2020 6966 206c 656e  x_numpy.  if len
-000021f0: 2861 7267 7329 203c 2032 2061 6e64 206e  (args) < 2 and n
-00002200: 6f74 2073 6861 7065 3a0a 2020 2020 7265  ot shape:.    re
-00002210: 7475 726e 2061 7267 730a 2020 656c 7365  turn args.  else
-00002220: 3a0a 2020 2020 7368 6170 6573 203d 205b  :.    shapes = [
-00002230: 6a6e 702e 7368 6170 6528 6172 6729 2066  jnp.shape(arg) f
-00002240: 6f72 2061 7267 2069 6e20 6172 6773 5d0a  or arg in args].
-00002250: 2020 2020 6e75 6d5f 6469 6d73 203d 206c      num_dims = l
-00002260: 656e 286c 6178 2e62 726f 6164 6361 7374  en(lax.broadcast
-00002270: 5f73 6861 7065 7328 7368 6170 652c 202a  _shapes(shape, *
-00002280: 7368 6170 6573 2929 0a20 2020 2072 6574  shapes)).    ret
-00002290: 7572 6e20 5b0a 2020 2020 2020 5f72 6573  urn [.      _res
-000022a0: 6861 7065 2861 7267 2c20 2831 2c29 202a  hape(arg, (1,) *
-000022b0: 2028 6e75 6d5f 6469 6d73 202d 206c 656e   (num_dims - len
-000022c0: 2873 2929 202b 2073 2920 6966 206c 656e  (s)) + s) if len
-000022d0: 2873 2920 3c20 6e75 6d5f 6469 6d73 2065  (s) < num_dims e
-000022e0: 6c73 6520 6172 670a 2020 2020 2020 666f  lse arg.      fo
-000022f0: 7220 6172 672c 2073 2069 6e20 7a69 7028  r arg, s in zip(
-00002300: 6172 6773 2c20 7368 6170 6573 290a 2020  args, shapes).  
-00002310: 2020 5d0a 0a0a 4070 6172 7469 616c 286a    ]...@partial(j
-00002320: 6974 2c20 7374 6174 6963 5f61 7267 6e75  it, static_argnu
-00002330: 6d73 3d28 332c 2034 2929 0a64 6566 205f  ms=(3, 4)).def _
-00002340: 6d75 6c74 696e 6f6d 6961 6c28 6b65 792c  multinomial(key,
-00002350: 2070 2c20 6e2c 206e 5f6d 6178 2c20 7368   p, n, n_max, sh
-00002360: 6170 653d 2829 293a 0a20 2069 6620 6a6e  ape=()):.  if jn
-00002370: 702e 7368 6170 6528 6e29 2021 3d20 6a6e  p.shape(n) != jn
-00002380: 702e 7368 6170 6528 7029 5b3a 2d31 5d3a  p.shape(p)[:-1]:
-00002390: 0a20 2020 2062 726f 6164 6361 7374 5f73  .    broadcast_s
-000023a0: 6861 7065 203d 206c 6178 2e62 726f 6164  hape = lax.broad
-000023b0: 6361 7374 5f73 6861 7065 7328 6a6e 702e  cast_shapes(jnp.
-000023c0: 7368 6170 6528 6e29 2c20 6a6e 702e 7368  shape(n), jnp.sh
-000023d0: 6170 6528 7029 5b3a 2d31 5d29 0a20 2020  ape(p)[:-1]).   
-000023e0: 206e 203d 206a 6e70 2e62 726f 6164 6361   n = jnp.broadca
-000023f0: 7374 5f74 6f28 6e2c 2062 726f 6164 6361  st_to(n, broadca
-00002400: 7374 5f73 6861 7065 290a 2020 2020 7020  st_shape).    p 
-00002410: 3d20 6a6e 702e 6272 6f61 6463 6173 745f  = jnp.broadcast_
-00002420: 746f 2870 2c20 6272 6f61 6463 6173 745f  to(p, broadcast_
-00002430: 7368 6170 6520 2b20 6a6e 702e 7368 6170  shape + jnp.shap
-00002440: 6528 7029 5b2d 313a 5d29 0a20 2073 6861  e(p)[-1:]).  sha
-00002450: 7065 203d 2073 6861 7065 206f 7220 702e  pe = shape or p.
-00002460: 7368 6170 655b 3a2d 315d 0a20 2069 6620  shape[:-1].  if 
-00002470: 6e5f 6d61 7820 3d3d 2030 3a0a 2020 2020  n_max == 0:.    
-00002480: 7265 7475 726e 206a 6e70 2e7a 6572 6f73  return jnp.zeros
-00002490: 2873 6861 7065 202b 2070 2e73 6861 7065  (shape + p.shape
-000024a0: 5b2d 313a 5d2c 2064 7479 7065 3d6a 6e70  [-1:], dtype=jnp
-000024b0: 2e72 6573 756c 745f 7479 7065 2869 6e74  .result_type(int
-000024c0: 2929 0a20 2023 2067 6574 2069 6e64 6963  )).  # get indic
-000024d0: 6573 2066 726f 6d20 6361 7465 676f 7269  es from categori
-000024e0: 6361 6c20 6469 7374 7269 6275 7469 6f6e  cal distribution
-000024f0: 2074 6865 6e20 6761 7468 6572 2074 6865   then gather the
-00002500: 2072 6573 756c 740a 2020 696e 6469 6365   result.  indice
-00002510: 7320 3d20 5f63 6174 6567 6f72 6963 616c  s = _categorical
-00002520: 286b 6579 2c20 702c 2028 6e5f 6d61 782c  (key, p, (n_max,
-00002530: 2920 2b20 7368 6170 6529 0a20 2023 206d  ) + shape).  # m
-00002540: 6173 6b20 6f75 7420 7661 6c75 6573 2077  ask out values w
-00002550: 6865 6e20 636f 756e 7473 2069 7320 6865  hen counts is he
-00002560: 7465 726f 6765 6e65 6f75 730a 2020 6966  terogeneous.  if
-00002570: 206a 6e70 2e6e 6469 6d28 6e29 203e 2030   jnp.ndim(n) > 0
-00002580: 3a0a 2020 2020 6d61 736b 203d 205f 7072  :.    mask = _pr
-00002590: 6f6d 6f74 655f 7368 6170 6573 286a 6e70  omote_shapes(jnp
-000025a0: 2e61 7261 6e67 6528 6e5f 6d61 7829 203c  .arange(n_max) <
-000025b0: 206a 6e70 2e65 7870 616e 645f 6469 6d73   jnp.expand_dims
-000025c0: 286e 2c20 2d31 292c 2073 6861 7065 3d73  (n, -1), shape=s
-000025d0: 6861 7065 202b 2028 6e5f 6d61 782c 2929  hape + (n_max,))
-000025e0: 5b30 5d0a 2020 2020 6d61 736b 203d 206a  [0].    mask = j
-000025f0: 6e70 2e6d 6f76 6561 7869 7328 6d61 736b  np.moveaxis(mask
-00002600: 2c20 2d31 2c20 3029 2e61 7374 7970 6528  , -1, 0).astype(
-00002610: 696e 6469 6365 732e 6474 7970 6529 0a20  indices.dtype). 
-00002620: 2020 2065 7863 6573 7320 3d20 6a6e 702e     excess = jnp.
-00002630: 636f 6e63 6174 656e 6174 6528 5b6a 6e70  concatenate([jnp
-00002640: 2e65 7870 616e 645f 6469 6d73 286e 5f6d  .expand_dims(n_m
-00002650: 6178 202d 206e 2c20 2d31 292c 0a20 2020  ax - n, -1),.   
-00002660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002670: 2020 2020 2020 2020 2020 206a 6e70 2e7a             jnp.z
-00002680: 6572 6f73 286a 6e70 2e73 6861 7065 286e  eros(jnp.shape(n
-00002690: 2920 2b20 2870 2e73 6861 7065 5b2d 315d  ) + (p.shape[-1]
-000026a0: 202d 2031 2c29 295d 2c0a 2020 2020 2020   - 1,))],.      
-000026b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000026c0: 2020 2020 2020 202d 3129 0a20 2065 6c73         -1).  els
-000026d0: 653a 0a20 2020 206d 6173 6b20 3d20 310a  e:.    mask = 1.
-000026e0: 2020 2020 6578 6365 7373 203d 2030 0a20      excess = 0. 
-000026f0: 2023 204e 423a 2077 6520 7472 616e 7370   # NB: we transp
-00002700: 6f73 6520 746f 206d 6f76 6520 6261 7463  ose to move batc
-00002710: 6820 7368 6170 6520 746f 2074 6865 2066  h shape to the f
-00002720: 726f 6e74 0a20 2069 6e64 6963 6573 5f32  ront.  indices_2
-00002730: 4420 3d20 286a 6e70 2e72 6573 6861 7065  D = (jnp.reshape
-00002740: 2869 6e64 6963 6573 202a 206d 6173 6b2c  (indices * mask,
-00002750: 2028 6e5f 6d61 782c 202d 3129 2929 2e54   (n_max, -1))).T
-00002760: 0a20 2073 616d 706c 6573 5f32 4420 3d20  .  samples_2D = 
-00002770: 766d 6170 285f 7363 6174 7465 725f 6164  vmap(_scatter_ad
-00002780: 645f 6f6e 6529 286a 6e70 2e7a 6572 6f73  d_one)(jnp.zeros
-00002790: 2828 696e 6469 6365 735f 3244 2e73 6861  ((indices_2D.sha
-000027a0: 7065 5b30 5d2c 2070 2e73 6861 7065 5b2d  pe[0], p.shape[-
-000027b0: 315d 292c 2064 7479 7065 3d69 6e64 6963  1]), dtype=indic
-000027c0: 6573 2e64 7479 7065 292c 0a20 2020 2020  es.dtype),.     
-000027d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000027e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000027f0: 206a 6e70 2e65 7870 616e 645f 6469 6d73   jnp.expand_dims
-00002800: 2869 6e64 6963 6573 5f32 442c 2061 7869  (indices_2D, axi
-00002810: 733d 2d31 292c 0a20 2020 2020 2020 2020  s=-1),.         
-00002820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002830: 2020 2020 2020 2020 2020 2020 206a 6e70               jnp
-00002840: 2e6f 6e65 7328 696e 6469 6365 735f 3244  .ones(indices_2D
-00002850: 2e73 6861 7065 2c20 6474 7970 653d 696e  .shape, dtype=in
-00002860: 6469 6365 732e 6474 7970 6529 290a 2020  dices.dtype)).  
-00002870: 7265 7475 726e 206a 6e70 2e72 6573 6861  return jnp.resha
-00002880: 7065 2873 616d 706c 6573 5f32 442c 2073  pe(samples_2D, s
-00002890: 6861 7065 202b 2070 2e73 6861 7065 5b2d  hape + p.shape[-
-000028a0: 313a 5d29 202d 2065 7863 6573 730a 0a0a  1:]) - excess...
-000028b0: 4070 6172 7469 616c 286a 6974 2c20 7374  @partial(jit, st
-000028c0: 6174 6963 5f61 7267 6e75 6d73 3d28 322c  atic_argnums=(2,
-000028d0: 2033 2929 0a64 6566 205f 766f 6e5f 6d69   3)).def _von_mi
-000028e0: 7365 735f 6365 6e74 6572 6564 286b 6579  ses_centered(key
-000028f0: 2c20 636f 6e63 656e 7472 6174 696f 6e2c  , concentration,
-00002900: 2073 6861 7065 2c20 6474 7970 653d 6a6e   shape, dtype=jn
-00002910: 702e 666c 6f61 7436 3429 3a0a 2020 2222  p.float64):.  ""
-00002920: 2243 6f6d 7075 7465 2063 656e 7465 7265  "Compute centere
-00002930: 6420 766f 6e20 4d69 7365 7320 7361 6d70  d von Mises samp
-00002940: 6c65 7320 7573 696e 6720 7265 6a65 6374  les using reject
-00002950: 696f 6e20 7361 6d70 6c69 6e67 2066 726f  ion sampling fro
-00002960: 6d20 5b31 5d5f 2077 6974 6820 7772 6170  m [1]_ with wrap
-00002970: 7065 6420 4361 7563 6879 2070 726f 706f  ped Cauchy propo
-00002980: 7361 6c2e 0a0a 2020 5265 7475 726e 730a  sal...  Returns.
-00002990: 2020 2d2d 2d2d 2d2d 2d0a 2020 6f75 743a    -------.  out:
-000029a0: 2061 7272 6179 5f6c 696b 650a 2020 2020   array_like.    
-000029b0: 2063 656e 7465 7265 6420 7361 6d70 6c65   centered sample
-000029c0: 7320 6672 6f6d 2076 6f6e 204d 6973 6573  s from von Mises
-000029d0: 0a0a 2020 5265 6665 7265 6e63 6573 0a20  ..  References. 
-000029e0: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2e2e   ----------.  ..
-000029f0: 205b 315d 204c 7563 2044 6576 726f 7965   [1] Luc Devroye
-00002a00: 2022 4e6f 6e2d 556e 6966 6f72 6d20 5261   "Non-Uniform Ra
-00002a10: 6e64 6f6d 2056 6172 6961 7465 2047 656e  ndom Variate Gen
-00002a20: 6572 6174 696f 6e22 2c20 5370 7269 6e67  eration", Spring
-00002a30: 6572 2d56 6572 6c61 672c 2031 3938 363b  er-Verlag, 1986;
-00002a40: 0a20 2020 2020 2020 2020 4368 6170 7465  .         Chapte
-00002a50: 7220 392c 2070 2e20 3437 332d 3437 362e  r 9, p. 473-476.
-00002a60: 2068 7474 703a 2f2f 7777 772e 6e72 626f   http://www.nrbo
-00002a70: 6f6b 2e63 6f6d 2f64 6576 726f 7965 2f44  ok.com/devroye/D
-00002a80: 6576 726f 7965 5f66 696c 6573 2f63 6861  evroye_files/cha
-00002a90: 7074 6572 5f6e 696e 652e 7064 660a 0a20  pter_nine.pdf.. 
-00002aa0: 2022 2222 0a20 2073 6861 7065 203d 2073   """.  shape = s
-00002ab0: 6861 7065 206f 7220 6a6e 702e 7368 6170  hape or jnp.shap
-00002ac0: 6528 636f 6e63 656e 7472 6174 696f 6e29  e(concentration)
-00002ad0: 0a20 2064 7479 7065 203d 206a 6e70 2e72  .  dtype = jnp.r
-00002ae0: 6573 756c 745f 7479 7065 2864 7479 7065  esult_type(dtype
-00002af0: 290a 2020 636f 6e63 656e 7472 6174 696f  ).  concentratio
-00002b00: 6e20 3d20 6c61 782e 636f 6e76 6572 745f  n = lax.convert_
-00002b10: 656c 656d 656e 745f 7479 7065 2863 6f6e  element_type(con
-00002b20: 6365 6e74 7261 7469 6f6e 2c20 6474 7970  centration, dtyp
-00002b30: 6529 0a20 2063 6f6e 6365 6e74 7261 7469  e).  concentrati
-00002b40: 6f6e 203d 206a 6e70 2e62 726f 6164 6361  on = jnp.broadca
-00002b50: 7374 5f74 6f28 636f 6e63 656e 7472 6174  st_to(concentrat
-00002b60: 696f 6e2c 2073 6861 7065 290a 0a20 2073  ion, shape)..  s
-00002b70: 5f63 7574 6f66 665f 6d61 7020 3d20 7b0a  _cutoff_map = {.
-00002b80: 2020 2020 6a6e 702e 6474 7970 6528 6a6e      jnp.dtype(jn
-00002b90: 702e 666c 6f61 7431 3629 3a20 312e 3865  p.float16): 1.8e
-00002ba0: 2d31 2c0a 2020 2020 6a6e 702e 6474 7970  -1,.    jnp.dtyp
-00002bb0: 6528 6a6e 702e 666c 6f61 7433 3229 3a20  e(jnp.float32): 
-00002bc0: 3265 2d32 2c0a 2020 2020 6a6e 702e 6474  2e-2,.    jnp.dt
-00002bd0: 7970 6528 6a6e 702e 666c 6f61 7436 3429  ype(jnp.float64)
-00002be0: 3a20 312e 3265 2d34 2c0a 2020 7d0a 2020  : 1.2e-4,.  }.  
-00002bf0: 735f 6375 746f 6666 203d 2073 5f63 7574  s_cutoff = s_cut
-00002c00: 6f66 665f 6d61 702e 6765 7428 6474 7970  off_map.get(dtyp
-00002c10: 6529 0a0a 2020 7220 3d20 312e 3020 2b20  e)..  r = 1.0 + 
-00002c20: 6a6e 702e 7371 7274 2831 2e30 202b 2034  jnp.sqrt(1.0 + 4
-00002c30: 2e30 202a 2063 6f6e 6365 6e74 7261 7469  .0 * concentrati
-00002c40: 6f6e 202a 2a20 3229 0a20 2072 686f 203d  on ** 2).  rho =
-00002c50: 2028 7220 2d20 6a6e 702e 7371 7274 2832   (r - jnp.sqrt(2
-00002c60: 2e30 202a 2072 2929 202f 2028 322e 3020  .0 * r)) / (2.0 
-00002c70: 2a20 636f 6e63 656e 7472 6174 696f 6e29  * concentration)
-00002c80: 0a20 2073 5f65 7861 6374 203d 2028 312e  .  s_exact = (1.
-00002c90: 3020 2b20 7268 6f20 2a2a 2032 2920 2f20  0 + rho ** 2) / 
-00002ca0: 2832 2e30 202a 2072 686f 290a 0a20 2073  (2.0 * rho)..  s
-00002cb0: 5f61 7070 726f 7869 6d61 7465 203d 2031  _approximate = 1
-00002cc0: 2e30 202f 2063 6f6e 6365 6e74 7261 7469  .0 / concentrati
-00002cd0: 6f6e 0a0a 2020 7320 3d20 6a6e 702e 7768  on..  s = jnp.wh
-00002ce0: 6572 6528 636f 6e63 656e 7472 6174 696f  ere(concentratio
-00002cf0: 6e20 3e20 735f 6375 746f 6666 2c20 735f  n > s_cutoff, s_
-00002d00: 6578 6163 742c 2073 5f61 7070 726f 7869  exact, s_approxi
-00002d10: 6d61 7465 290a 0a20 2064 6566 2063 6f6e  mate)..  def con
-00002d20: 645f 666e 282a 6172 6773 293a 0a20 2020  d_fn(*args):.   
-00002d30: 2022 2222 6368 6563 6b20 6966 2061 6c6c   """check if all
-00002d40: 2061 7265 2064 6f6e 6520 6f72 2072 6561   are done or rea
-00002d50: 6368 6564 206d 6178 206e 756d 6265 7220  ched max number 
-00002d60: 6f66 2069 7465 7261 7469 6f6e 7322 2222  of iterations"""
-00002d70: 0a20 2020 2069 2c20 5f2c 2064 6f6e 652c  .    i, _, done,
-00002d80: 205f 2c20 5f20 3d20 6172 6773 5b30 5d0a   _, _ = args[0].
-00002d90: 2020 2020 7265 7475 726e 206a 6e70 2e62      return jnp.b
-00002da0: 6974 7769 7365 5f61 6e64 2869 203c 2031  itwise_and(i < 1
-00002db0: 3030 2c20 6a6e 702e 6c6f 6769 6361 6c5f  00, jnp.logical_
-00002dc0: 6e6f 7428 6a6e 702e 616c 6c28 646f 6e65  not(jnp.all(done
-00002dd0: 2929 290a 0a20 2064 6566 2062 6f64 795f  )))..  def body_
-00002de0: 666e 282a 6172 6773 293a 0a20 2020 2069  fn(*args):.    i
-00002df0: 2c20 6b65 792c 2064 6f6e 652c 205f 2c20  , key, done, _, 
-00002e00: 7720 3d20 6172 6773 5b30 5d0a 2020 2020  w = args[0].    
-00002e10: 756e 695f 756b 6579 2c20 756e 695f 766b  uni_ukey, uni_vk
-00002e20: 6579 2c20 6b65 7920 3d20 6a72 2e73 706c  ey, key = jr.spl
-00002e30: 6974 286b 6579 2c20 3329 0a20 2020 2075  it(key, 3).    u
-00002e40: 203d 206a 722e 756e 6966 6f72 6d28 0a20   = jr.uniform(. 
-00002e50: 2020 2020 206b 6579 3d75 6e69 5f75 6b65       key=uni_uke
-00002e60: 792c 0a20 2020 2020 2073 6861 7065 3d73  y,.      shape=s
-00002e70: 6861 7065 2c0a 2020 2020 2020 6474 7970  hape,.      dtyp
-00002e80: 653d 636f 6e63 656e 7472 6174 696f 6e2e  e=concentration.
-00002e90: 6474 7970 652c 0a20 2020 2020 206d 696e  dtype,.      min
-00002ea0: 7661 6c3d 2d31 2e30 2c0a 2020 2020 2020  val=-1.0,.      
-00002eb0: 6d61 7876 616c 3d31 2e30 2c0a 2020 2020  maxval=1.0,.    
-00002ec0: 290a 2020 2020 7a20 3d20 6a6e 702e 636f  ).    z = jnp.co
-00002ed0: 7328 6a6e 702e 7069 202a 2075 290a 2020  s(jnp.pi * u).  
-00002ee0: 2020 7720 3d20 6a6e 702e 7768 6572 6528    w = jnp.where(
-00002ef0: 646f 6e65 2c20 772c 2028 312e 3020 2b20  done, w, (1.0 + 
-00002f00: 7320 2a20 7a29 202f 2028 7320 2b20 7a29  s * z) / (s + z)
-00002f10: 2920 2023 2055 7064 6174 6520 7768 6572  )  # Update wher
-00002f20: 6520 6e6f 7420 646f 6e65 0a20 2020 2079  e not done.    y
-00002f30: 203d 2063 6f6e 6365 6e74 7261 7469 6f6e   = concentration
-00002f40: 202a 2028 7320 2d20 7729 0a20 2020 2076   * (s - w).    v
-00002f50: 203d 206a 722e 756e 6966 6f72 6d28 6b65   = jr.uniform(ke
-00002f60: 793d 756e 695f 766b 6579 2c20 7368 6170  y=uni_vkey, shap
-00002f70: 653d 7368 6170 652c 2064 7479 7065 3d63  e=shape, dtype=c
-00002f80: 6f6e 6365 6e74 7261 7469 6f6e 2e64 7479  oncentration.dty
-00002f90: 7065 290a 2020 2020 6163 6365 7074 203d  pe).    accept =
-00002fa0: 2028 7920 2a20 2832 2e30 202d 2079 2920   (y * (2.0 - y) 
-00002fb0: 3e3d 2076 2920 7c20 286a 6e70 2e6c 6f67  >= v) | (jnp.log
-00002fc0: 2879 202f 2076 2920 2b20 312e 3020 3e3d  (y / v) + 1.0 >=
-00002fd0: 2079 290a 2020 2020 7265 7475 726e 2069   y).    return i
-00002fe0: 202b 2031 2c20 6b65 792c 2061 6363 6570   + 1, key, accep
-00002ff0: 7420 7c20 646f 6e65 2c20 752c 2077 0a0a  t | done, u, w..
-00003000: 2020 696e 6974 5f64 6f6e 6520 3d20 6a6e    init_done = jn
-00003010: 702e 7a65 726f 7328 7368 6170 652c 2064  p.zeros(shape, d
-00003020: 7479 7065 3d62 6f6f 6c29 0a20 2069 6e69  type=bool).  ini
-00003030: 745f 7520 3d20 6a6e 702e 7a65 726f 7328  t_u = jnp.zeros(
-00003040: 7368 6170 6529 0a20 2069 6e69 745f 7720  shape).  init_w 
-00003050: 3d20 6a6e 702e 7a65 726f 7328 7368 6170  = jnp.zeros(shap
-00003060: 6529 0a0a 2020 5f2c 205f 2c20 646f 6e65  e)..  _, _, done
-00003070: 2c20 752c 2077 203d 206c 6178 2e77 6869  , u, w = lax.whi
-00003080: 6c65 5f6c 6f6f 7028 0a20 2020 2063 6f6e  le_loop(.    con
-00003090: 645f 6675 6e3d 636f 6e64 5f66 6e2c 0a20  d_fun=cond_fn,. 
-000030a0: 2020 2062 6f64 795f 6675 6e3d 626f 6479     body_fun=body
-000030b0: 5f66 6e2c 0a20 2020 2069 6e69 745f 7661  _fn,.    init_va
-000030c0: 6c3d 286a 6e70 2e61 7272 6179 2830 292c  l=(jnp.array(0),
-000030d0: 206b 6579 2c20 696e 6974 5f64 6f6e 652c   key, init_done,
-000030e0: 2069 6e69 745f 752c 2069 6e69 745f 7729   init_u, init_w)
-000030f0: 2c0a 2020 290a 0a20 2072 6574 7572 6e20  ,.  )..  return 
-00003100: 6a6e 702e 7369 676e 2875 2920 2a20 6a6e  jnp.sign(u) * jn
-00003110: 702e 6172 6363 6f73 2877 290a 0a0a 6465  p.arccos(w)...de
-00003120: 6620 5f6c 6f63 5f73 6361 6c65 286c 6f63  f _loc_scale(loc
-00003130: 2c20 7363 616c 652c 2076 616c 7565 293a  , scale, value):
-00003140: 0a20 2069 6620 6c6f 6320 6973 204e 6f6e  .  if loc is Non
-00003150: 653a 0a20 2020 2069 6620 7363 616c 6520  e:.    if scale 
-00003160: 6973 204e 6f6e 653a 0a20 2020 2020 2072  is None:.      r
-00003170: 6574 7572 6e20 7661 6c75 650a 2020 2020  eturn value.    
-00003180: 656c 7365 3a0a 2020 2020 2020 7265 7475  else:.      retu
-00003190: 726e 2076 616c 7565 202a 2073 6361 6c65  rn value * scale
-000031a0: 0a20 2065 6c73 653a 0a20 2020 2069 6620  .  else:.    if 
-000031b0: 7363 616c 6520 6973 204e 6f6e 653a 0a20  scale is None:. 
-000031c0: 2020 2020 2072 6574 7572 6e20 7661 6c75       return valu
-000031d0: 6520 2b20 6c6f 630a 2020 2020 656c 7365  e + loc.    else
-000031e0: 3a0a 2020 2020 2020 7265 7475 726e 2076  :.      return v
-000031f0: 616c 7565 202a 2073 6361 6c65 202b 206c  alue * scale + l
-00003200: 6f63 0a0a 0a64 6566 205f 6368 6563 6b5f  oc...def _check_
-00003210: 7079 5f73 6571 2873 6571 293a 0a20 2072  py_seq(seq):.  r
-00003220: 6574 7572 6e20 6a6e 702e 6173 6172 7261  eturn jnp.asarra
-00003230: 7928 7365 7129 2069 6620 6973 696e 7374  y(seq) if isinst
-00003240: 616e 6365 2873 6571 2c20 2874 7570 6c65  ance(seq, (tuple
-00003250: 2c20 6c69 7374 2929 2065 6c73 6520 7365  , list)) else se
-00003260: 710a 0a0a 636c 6173 7320 5261 6e64 6f6d  q...class Random
-00003270: 5374 6174 6528 5661 7269 6162 6c65 293a  State(Variable):
-00003280: 0a20 2022 2222 5261 6e64 6f6d 5374 6174  .  """RandomStat
-00003290: 6520 7468 6174 2074 7261 636b 2074 6865  e that track the
-000032a0: 2072 616e 646f 6d20 6765 6e65 7261 746f   random generato
-000032b0: 7220 7374 6174 652e 2022 2222 0a20 205f  r state. """.  _
-000032c0: 5f73 6c6f 7473 5f5f 203d 2028 290a 0a20  _slots__ = ().. 
-000032d0: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
-000032e0: 6c66 2c0a 2020 2020 2020 2020 2020 2020  lf,.            
-000032f0: 2020 2073 6565 645f 6f72 5f6b 6579 3a20     seed_or_key: 
-00003300: 4f70 7469 6f6e 616c 5b55 6e69 6f6e 5b69  Optional[Union[i
-00003310: 6e74 2c20 4172 7261 792c 206a 6178 2e41  nt, Array, jax.A
-00003320: 7272 6179 2c20 6e70 2e6e 6461 7272 6179  rray, np.ndarray
-00003330: 5d5d 203d 204e 6f6e 652c 0a20 2020 2020  ]] = None,.     
-00003340: 2020 2020 2020 2020 2020 7365 6564 3a20            seed: 
-00003350: 4f70 7469 6f6e 616c 5b69 6e74 5d20 3d20  Optional[int] = 
-00003360: 4e6f 6e65 293a 0a20 2020 2022 2222 5261  None):.    """Ra
-00003370: 6e64 6f6d 5374 6174 6520 636f 6e73 7472  ndomState constr
-00003380: 7563 746f 722e 0a0a 2020 2020 5061 7261  uctor...    Para
-00003390: 6d65 7465 7273 0a20 2020 202d 2d2d 2d2d  meters.    -----
-000033a0: 2d2d 2d2d 2d0a 2020 2020 7365 6564 5f6f  -----.    seed_o
-000033b0: 725f 6b65 793a 2069 6e74 2c20 4172 7261  r_key: int, Arra
-000033c0: 792c 206f 7074 696f 6e61 6c0a 2020 2020  y, optional.    
-000033d0: 2020 4974 2063 616e 2062 6520 616e 2069    It can be an i
-000033e0: 6e74 6567 6572 2066 6f72 2069 6e69 7469  nteger for initi
-000033f0: 616c 2073 6565 6420 6f66 2074 6865 2072  al seed of the r
-00003400: 616e 646f 6d20 6e75 6d62 6572 2067 656e  andom number gen
-00003410: 6572 6174 6f72 2c0a 2020 2020 2020 6f72  erator,.      or
-00003420: 2069 7420 6361 6e20 6265 2061 204a 4158   it can be a JAX
-00003430: 2773 2050 524e 4b65 792c 2077 6869 6368  's PRNKey, which
-00003440: 2069 7320 616e 2061 7272 6179 2077 6974   is an array wit
-00003450: 6820 7477 6f20 656c 656d 656e 7473 2061  h two elements a
-00003460: 6e64 2060 7569 6e74 3332 6020 6474 7970  nd `uint32` dtyp
-00003470: 652e 0a0a 2020 2020 2020 2e2e 2076 6572  e...      .. ver
-00003480: 7369 6f6e 6164 6465 643a 3a20 322e 322e  sionadded:: 2.2.
-00003490: 332e 340a 0a20 2020 2073 6565 6420 3a20  3.4..    seed : 
-000034a0: 696e 742c 2041 7272 6179 5479 7065 2c20  int, ArrayType, 
-000034b0: 6f70 7469 6f6e 616c 0a20 2020 2020 2053  optional.      S
-000034c0: 616d 6520 6173 2060 7365 6564 5f6f 725f  ame as `seed_or_
-000034d0: 6b65 7960 2e0a 0a20 2020 2020 202e 2e20  key`...      .. 
-000034e0: 6465 7072 6563 6174 6564 3a3a 2032 2e32  deprecated:: 2.2
-000034f0: 2e33 2e34 0a20 2020 2020 2020 2020 5769  .3.4.         Wi
-00003500: 6c6c 2062 6520 7265 6d6f 7665 6420 7369  ll be removed si
-00003510: 6e63 6520 7665 7273 696f 6e20 322e 342e  nce version 2.4.
-00003520: 0a20 2020 2022 2222 0a20 2020 2069 6620  .    """.    if 
-00003530: 7365 6564 2069 7320 6e6f 7420 4e6f 6e65  seed is not None
-00003540: 3a0a 2020 2020 2020 6966 2073 6565 645f  :.      if seed_
-00003550: 6f72 5f6b 6579 2069 7320 6e6f 7420 4e6f  or_key is not No
-00003560: 6e65 3a0a 2020 2020 2020 2020 7261 6973  ne:.        rais
-00003570: 6520 5661 6c75 6545 7272 6f72 2827 506c  e ValueError('Pl
-00003580: 6561 7365 2073 6574 2022 7365 6564 5f6f  ease set "seed_o
-00003590: 725f 6b65 7922 206f 7220 2273 6565 6422  r_key" or "seed"
-000035a0: 2c20 6e6f 7420 626f 7468 2e27 290a 2020  , not both.').  
-000035b0: 2020 2020 7365 6564 5f6f 725f 6b65 7920      seed_or_key 
-000035c0: 3d20 7365 6564 0a20 2020 2020 2077 6172  = seed.      war
-000035d0: 6e69 6e67 732e 7761 726e 2827 506c 6561  nings.warn('Plea
-000035e0: 7365 2075 7365 2060 7365 6564 5f6f 725f  se use `seed_or_
-000035f0: 6b65 7960 2069 6e73 7465 6164 2e20 270a  key` instead. '.
-00003600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003610: 2020 2020 2773 6565 6420 7769 6c6c 2062      'seed will b
-00003620: 6520 7265 6d6f 7665 6420 7369 6e63 6520  e removed since 
-00003630: 322e 342e 3027 2c20 5573 6572 5761 726e  2.4.0', UserWarn
-00003640: 696e 6729 0a0a 2020 2020 6966 2073 6565  ing)..    if see
-00003650: 645f 6f72 5f6b 6579 2069 7320 4e6f 6e65  d_or_key is None
-00003660: 3a0a 2020 2020 2020 7365 6564 5f6f 725f  :.      seed_or_
-00003670: 6b65 7920 3d20 6e70 2e72 616e 646f 6d2e  key = np.random.
-00003680: 7261 6e64 696e 7428 302c 2031 3030 3030  randint(0, 10000
-00003690: 302c 2032 2c20 6474 7970 653d 6e70 2e75  0, 2, dtype=np.u
-000036a0: 696e 7433 3229 0a20 2020 2069 6620 6973  int32).    if is
-000036b0: 696e 7374 616e 6365 2873 6565 645f 6f72  instance(seed_or
-000036c0: 5f6b 6579 2c20 696e 7429 3a0a 2020 2020  _key, int):.    
-000036d0: 2020 6b65 7920 3d20 6a72 2e50 524e 474b    key = jr.PRNGK
-000036e0: 6579 2873 6565 645f 6f72 5f6b 6579 290a  ey(seed_or_key).
-000036f0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00003700: 6966 206c 656e 2873 6565 645f 6f72 5f6b  if len(seed_or_k
-00003710: 6579 2920 213d 2032 2061 6e64 2073 6565  ey) != 2 and see
-00003720: 645f 6f72 5f6b 6579 2e64 7479 7065 2021  d_or_key.dtype !
-00003730: 3d20 6e70 2e75 696e 7433 323a 0a20 2020  = np.uint32:.   
-00003740: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-00003750: 4572 726f 7228 276b 6579 206d 7573 7420  Error('key must 
-00003760: 6265 2061 6e20 6172 7261 7920 7769 7468  be an array with
-00003770: 2064 7479 7065 2075 696e 7433 322e 2027   dtype uint32. '
-00003780: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003790: 2020 2020 2020 2020 2020 6627 4275 7420            f'But 
-000037a0: 7765 2067 6f74 207b 7365 6564 5f6f 725f  we got {seed_or_
-000037b0: 6b65 797d 2729 0a20 2020 2020 206b 6579  key}').      key
-000037c0: 203d 2073 6565 645f 6f72 5f6b 6579 0a20   = seed_or_key. 
-000037d0: 2020 2073 7570 6572 2852 616e 646f 6d53     super(RandomS
-000037e0: 7461 7465 2c20 7365 6c66 292e 5f5f 696e  tate, self).__in
-000037f0: 6974 5f5f 286b 6579 290a 0a20 2064 6566  it__(key)..  def
-00003800: 205f 5f72 6570 725f 5f28 7365 6c66 2920   __repr__(self) 
-00003810: 2d3e 2073 7472 3a0a 2020 2020 7072 696e  -> str:.    prin
-00003820: 745f 636f 6465 203d 2072 6570 7228 7365  t_code = repr(se
-00003830: 6c66 2e76 616c 7565 290a 2020 2020 6920  lf.value).    i 
-00003840: 3d20 7072 696e 745f 636f 6465 2e69 6e64  = print_code.ind
-00003850: 6578 2827 2827 290a 2020 2020 6e61 6d65  ex('(').    name
-00003860: 203d 2073 656c 662e 5f5f 636c 6173 735f   = self.__class_
-00003870: 5f2e 5f5f 6e61 6d65 5f5f 0a20 2020 2072  _.__name__.    r
-00003880: 6574 7572 6e20 6627 7b6e 616d 657d 286b  eturn f'{name}(k
-00003890: 6579 3d7b 7072 696e 745f 636f 6465 5b69  ey={print_code[i
-000038a0: 3a5d 7d29 270a 0a20 2023 202d 2d2d 2d2d  :]})'..  # -----
-000038b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2023  -------------- #
-000038c0: 0a20 2023 2073 6565 6420 616e 6420 7261  .  # seed and ra
-000038d0: 6e64 6f6d 206b 6579 2023 0a20 2023 202d  ndom key #.  # -
-000038e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000038f0: 2d2d 2023 0a0a 2020 6465 6620 636c 6f6e  -- #..  def clon
-00003900: 6528 7365 6c66 293a 0a20 2020 2072 6574  e(self):.    ret
-00003910: 7572 6e20 7479 7065 2873 656c 6629 2873  urn type(self)(s
-00003920: 656c 662e 7370 6c69 745f 6b65 7928 2929  elf.split_key())
-00003930: 0a0a 2020 6465 6620 7365 6564 2873 656c  ..  def seed(sel
-00003940: 662c 2073 6565 645f 6f72 5f6b 6579 3d4e  f, seed_or_key=N
-00003950: 6f6e 652c 2073 6565 643d 4e6f 6e65 293a  one, seed=None):
-00003960: 0a20 2020 2022 2222 5365 7473 2061 206e  .    """Sets a n
-00003970: 6577 2072 616e 646f 6d20 7365 6564 2e0a  ew random seed..
-00003980: 0a20 2020 2050 6172 616d 6574 6572 730a  .    Parameters.
-00003990: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20      ----------. 
-000039a0: 2020 2073 6565 645f 6f72 5f6b 6579 3a20     seed_or_key: 
-000039b0: 696e 742c 2041 7272 6179 5479 7065 2c20  int, ArrayType, 
-000039c0: 6f70 7469 6f6e 616c 0a20 2020 2020 2049  optional.      I
-000039d0: 7420 6361 6e20 6265 2061 6e20 696e 7465  t can be an inte
-000039e0: 6765 7220 666f 7220 696e 6974 6961 6c20  ger for initial 
-000039f0: 7365 6564 206f 6620 7468 6520 7261 6e64  seed of the rand
-00003a00: 6f6d 206e 756d 6265 7220 6765 6e65 7261  om number genera
-00003a10: 746f 722c 0a20 2020 2020 206f 7220 6974  tor,.      or it
-00003a20: 2063 616e 2062 6520 6120 4a41 5827 7320   can be a JAX's 
-00003a30: 5052 4e4b 6579 2c20 7768 6963 6820 6973  PRNKey, which is
-00003a40: 2061 6e20 6172 7261 7920 7769 7468 2074   an array with t
-00003a50: 776f 2065 6c65 6d65 6e74 7320 616e 6420  wo elements and 
-00003a60: 6075 696e 7433 3260 2064 7479 7065 2e0a  `uint32` dtype..
-00003a70: 0a20 2020 2020 202e 2e20 7665 7273 696f  .      .. versio
-00003a80: 6e61 6464 6564 3a3a 2032 2e32 2e33 2e34  nadded:: 2.2.3.4
-00003a90: 0a0a 2020 2020 7365 6564 203a 2069 6e74  ..    seed : int
-00003aa0: 2c20 4172 7261 7954 7970 652c 206f 7074  , ArrayType, opt
-00003ab0: 696f 6e61 6c0a 2020 2020 2020 5361 6d65  ional.      Same
-00003ac0: 2061 7320 6073 6565 645f 6f72 5f6b 6579   as `seed_or_key
-00003ad0: 602e 0a0a 2020 2020 2020 2e2e 2064 6570  `...      .. dep
-00003ae0: 7265 6361 7465 643a 3a20 322e 322e 332e  recated:: 2.2.3.
-00003af0: 340a 2020 2020 2020 2020 2057 696c 6c20  4.         Will 
-00003b00: 6265 2072 656d 6f76 6564 2073 696e 6365  be removed since
-00003b10: 2076 6572 7369 6f6e 2032 2e34 2e0a 2020   version 2.4..  
-00003b20: 2020 2222 220a 2020 2020 6966 2073 6565    """.    if see
-00003b30: 6420 6973 206e 6f74 204e 6f6e 653a 0a20  d is not None:. 
-00003b40: 2020 2020 2069 6620 7365 6564 5f6f 725f       if seed_or_
-00003b50: 6b65 7920 6973 206e 6f74 204e 6f6e 653a  key is not None:
-00003b60: 0a20 2020 2020 2020 2072 6169 7365 2056  .        raise V
-00003b70: 616c 7565 4572 726f 7228 2750 6c65 6173  alueError('Pleas
-00003b80: 6520 7365 7420 2273 6565 645f 6f72 5f6b  e set "seed_or_k
-00003b90: 6579 2220 6f72 2022 7365 6564 222c 206e  ey" or "seed", n
-00003ba0: 6f74 2062 6f74 682e 2729 0a20 2020 2020  ot both.').     
-00003bb0: 2073 6565 645f 6f72 5f6b 6579 203d 2073   seed_or_key = s
-00003bc0: 6565 640a 2020 2020 2020 7761 726e 696e  eed.      warnin
-00003bd0: 6773 2e77 6172 6e28 2750 6c65 6173 6520  gs.warn('Please 
-00003be0: 7573 6520 7365 6564 5f6f 725f 6b65 7920  use seed_or_key 
-00003bf0: 696e 7374 6561 642e 2027 0a20 2020 2020  instead. '.     
-00003c00: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00003c10: 7365 6564 2077 696c 6c20 6265 2072 656d  seed will be rem
-00003c20: 6f76 6564 2073 696e 6365 2032 2e34 2e30  oved since 2.4.0
-00003c30: 272c 2055 7365 7257 6172 6e69 6e67 290a  ', UserWarning).
-00003c40: 0a20 2020 2069 6620 7365 6564 5f6f 725f  .    if seed_or_
-00003c50: 6b65 7920 6973 204e 6f6e 653a 0a20 2020  key is None:.   
-00003c60: 2020 2073 6565 645f 6f72 5f6b 6579 203d     seed_or_key =
-00003c70: 206e 702e 7261 6e64 6f6d 2e72 616e 6469   np.random.randi
-00003c80: 6e74 2830 2c20 3130 3030 3030 2c20 322c  nt(0, 100000, 2,
-00003c90: 2064 7479 7065 3d6e 702e 7569 6e74 3332   dtype=np.uint32
-00003ca0: 290a 2020 2020 6966 2069 7369 6e73 7461  ).    if isinsta
-00003cb0: 6e63 6528 7365 6564 5f6f 725f 6b65 792c  nce(seed_or_key,
-00003cc0: 2069 6e74 293a 0a20 2020 2020 206b 6579   int):.      key
-00003cd0: 203d 206a 722e 5052 4e47 4b65 7928 7365   = jr.PRNGKey(se
-00003ce0: 6564 5f6f 725f 6b65 7929 0a20 2020 2065  ed_or_key).    e
-00003cf0: 6c73 653a 0a20 2020 2020 2069 6620 6c65  lse:.      if le
-00003d00: 6e28 7365 6564 5f6f 725f 6b65 7929 2021  n(seed_or_key) !
-00003d10: 3d20 3220 616e 6420 7365 6564 5f6f 725f  = 2 and seed_or_
-00003d20: 6b65 792e 6474 7970 6520 213d 206e 702e  key.dtype != np.
-00003d30: 7569 6e74 3332 3a0a 2020 2020 2020 2020  uint32:.        
-00003d40: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-00003d50: 2827 6b65 7920 6d75 7374 2062 6520 616e  ('key must be an
-00003d60: 2061 7272 6179 2077 6974 6820 6474 7970   array with dtyp
-00003d70: 6520 7569 6e74 3332 2e20 270a 2020 2020  e uint32. '.    
-00003d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003d90: 2020 2020 2066 2742 7574 2077 6520 676f       f'But we go
-00003da0: 7420 7b73 6565 645f 6f72 5f6b 6579 7d27  t {seed_or_key}'
-00003db0: 290a 2020 2020 2020 6b65 7920 3d20 7365  ).      key = se
-00003dc0: 6564 5f6f 725f 6b65 790a 2020 2020 7365  ed_or_key.    se
-00003dd0: 6c66 2e5f 7661 6c75 6520 3d20 6b65 790a  lf._value = key.
-00003de0: 0a20 2064 6566 2073 706c 6974 5f6b 6579  .  def split_key
-00003df0: 2873 656c 6629 3a0a 2020 2020 2222 2243  (self):.    """C
-00003e00: 7265 6174 6520 6120 6e65 7720 7365 6564  reate a new seed
-00003e10: 2066 726f 6d20 7468 6520 6375 7272 656e   from the curren
-00003e20: 7420 7365 6564 2e0a 2020 2020 2222 220a  t seed..    """.
-00003e30: 2020 2020 6966 206e 6f74 2069 7369 6e73      if not isins
-00003e40: 7461 6e63 6528 7365 6c66 2e76 616c 7565  tance(self.value
-00003e50: 2c20 6a6e 702e 6e64 6172 7261 7929 3a0a  , jnp.ndarray):.
-00003e60: 2020 2020 2020 7365 6c66 2e5f 7661 6c75        self._valu
-00003e70: 6520 3d20 6a6e 702e 6173 6172 7261 7928  e = jnp.asarray(
-00003e80: 7365 6c66 2e76 616c 7565 290a 2020 2020  self.value).    
-00003e90: 6b65 7973 203d 206a 722e 7370 6c69 7428  keys = jr.split(
-00003ea0: 7365 6c66 2e76 616c 7565 2c20 6e75 6d3d  self.value, num=
-00003eb0: 3229 0a20 2020 2073 656c 662e 5f76 616c  2).    self._val
-00003ec0: 7565 203d 206b 6579 735b 305d 0a20 2020  ue = keys[0].   
-00003ed0: 2072 6574 7572 6e20 6b65 7973 5b31 5d0a   return keys[1].
-00003ee0: 0a20 2064 6566 2073 706c 6974 5f6b 6579  .  def split_key
-00003ef0: 7328 7365 6c66 2c20 6e29 3a0a 2020 2020  s(self, n):.    
-00003f00: 2222 2243 7265 6174 6520 6d75 6c74 6970  """Create multip
-00003f10: 6c65 2073 6565 6473 2066 726f 6d20 7468  le seeds from th
-00003f20: 6520 6375 7272 656e 7420 7365 6564 2e20  e current seed. 
-00003f30: 5468 6973 2069 7320 7573 6564 0a20 2020  This is used.   
-00003f40: 2069 6e74 6572 6e61 6c6c 7920 6279 2060   internally by `
-00003f50: 706d 6170 6020 616e 6420 6076 6d61 7060  pmap` and `vmap`
-00003f60: 2074 6f20 656e 7375 7265 2074 6861 7420   to ensure that 
-00003f70: 7261 6e64 6f6d 206e 756d 6265 7273 0a20  random numbers. 
-00003f80: 2020 2061 7265 2064 6966 6665 7265 6e74     are different
-00003f90: 2069 6e20 7061 7261 6c6c 656c 2074 6872   in parallel thr
-00003fa0: 6561 6473 2e0a 0a20 2020 2050 6172 616d  eads...    Param
-00003fb0: 6574 6572 730a 2020 2020 2d2d 2d2d 2d2d  eters.    ------
-00003fc0: 2d2d 2d2d 0a20 2020 206e 203a 2069 6e74  ----.    n : int
-00003fd0: 0a20 2020 2020 2054 6865 206e 756d 6265  .      The numbe
-00003fe0: 7220 6f66 2073 6565 6473 2074 6f20 6765  r of seeds to ge
-00003ff0: 6e65 7261 7465 2e0a 2020 2020 2222 220a  nerate..    """.
-00004000: 2020 2020 6b65 7973 203d 206a 722e 7370      keys = jr.sp
-00004010: 6c69 7428 7365 6c66 2e76 616c 7565 2c20  lit(self.value, 
-00004020: 6e20 2b20 3129 0a20 2020 2073 656c 662e  n + 1).    self.
-00004030: 5f76 616c 7565 203d 206b 6579 735b 305d  _value = keys[0]
-00004040: 0a20 2020 2072 6574 7572 6e20 6b65 7973  .    return keys
-00004050: 5b31 3a5d 0a0a 2020 2320 2d2d 2d2d 2d2d  [1:]..  # ------
-00004060: 2d2d 2d2d 2d2d 2d2d 2d2d 2023 0a20 2023  ---------- #.  #
-00004070: 2072 616e 646f 6d20 6675 6e63 7469 6f6e   random function
-00004080: 7320 230a 2020 2320 2d2d 2d2d 2d2d 2d2d  s #.  # --------
-00004090: 2d2d 2d2d 2d2d 2d2d 2023 0a0a 2020 6465  -------- #..  de
-000040a0: 6620 7261 6e64 2873 656c 662c 202a 646e  f rand(self, *dn
-000040b0: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2020  , key=None):.   
-000040c0: 206b 6579 203d 2073 656c 662e 7370 6c69   key = self.spli
-000040d0: 745f 6b65 7928 2920 6966 206b 6579 2069  t_key() if key i
-000040e0: 7320 4e6f 6e65 2065 6c73 6520 5f66 6f72  s None else _for
-000040f0: 6d61 6c69 7a65 5f6b 6579 286b 6579 290a  malize_key(key).
-00004100: 2020 2020 7220 3d20 6a72 2e75 6e69 666f      r = jr.unifo
-00004110: 726d 286b 6579 2c20 7368 6170 653d 646e  rm(key, shape=dn
-00004120: 2c20 6d69 6e76 616c 3d30 2e2c 206d 6178  , minval=0., max
-00004130: 7661 6c3d 312e 290a 2020 2020 7265 7475  val=1.).    retu
-00004140: 726e 205f 7265 7475 726e 2872 290a 0a20  rn _return(r).. 
-00004150: 2064 6566 2072 616e 6469 6e74 2873 656c   def randint(sel
-00004160: 662c 206c 6f77 2c20 6869 6768 3d4e 6f6e  f, low, high=Non
-00004170: 652c 2073 697a 653d 4e6f 6e65 2c20 6474  e, size=None, dt
-00004180: 7970 653d 4e6f 6e65 2c20 6b65 793d 4e6f  ype=None, key=No
-00004190: 6e65 293a 0a20 2020 2064 7479 7065 203d  ne):.    dtype =
-000041a0: 2067 6574 5f69 6e74 2829 2069 6620 6474   get_int() if dt
-000041b0: 7970 6520 6973 204e 6f6e 6520 656c 7365  ype is None else
-000041c0: 2064 7479 7065 0a20 2020 206c 6f77 203d   dtype.    low =
-000041d0: 205f 6173 5f6a 6178 5f61 7272 6179 286c   _as_jax_array(l
-000041e0: 6f77 290a 2020 2020 6869 6768 203d 205f  ow).    high = _
-000041f0: 6173 5f6a 6178 5f61 7272 6179 2868 6967  as_jax_array(hig
-00004200: 6829 0a20 2020 2069 6620 6869 6768 2069  h).    if high i
-00004210: 7320 4e6f 6e65 3a0a 2020 2020 2020 6869  s None:.      hi
-00004220: 6768 203d 206c 6f77 0a20 2020 2020 206c  gh = low.      l
-00004230: 6f77 203d 2030 0a20 2020 2068 6967 6820  ow = 0.    high 
-00004240: 3d20 5f63 6865 636b 5f70 795f 7365 7128  = _check_py_seq(
-00004250: 6869 6768 290a 2020 2020 6c6f 7720 3d20  high).    low = 
-00004260: 5f63 6865 636b 5f70 795f 7365 7128 6c6f  _check_py_seq(lo
-00004270: 7729 0a20 2020 2069 6620 7369 7a65 2069  w).    if size i
-00004280: 7320 4e6f 6e65 3a0a 2020 2020 2020 7369  s None:.      si
-00004290: 7a65 203d 206c 6178 2e62 726f 6164 6361  ze = lax.broadca
-000042a0: 7374 5f73 6861 7065 7328 6a6e 702e 7368  st_shapes(jnp.sh
-000042b0: 6170 6528 6c6f 7729 2c0a 2020 2020 2020  ape(low),.      
-000042c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000042d0: 2020 2020 2020 2020 2020 2020 6a6e 702e              jnp.
-000042e0: 7368 6170 6528 6869 6768 2929 0a20 2020  shape(high)).   
-000042f0: 206b 6579 203d 2073 656c 662e 7370 6c69   key = self.spli
-00004300: 745f 6b65 7928 2920 6966 206b 6579 2069  t_key() if key i
-00004310: 7320 4e6f 6e65 2065 6c73 6520 5f66 6f72  s None else _for
-00004320: 6d61 6c69 7a65 5f6b 6579 286b 6579 290a  malize_key(key).
-00004330: 2020 2020 7220 3d20 6a72 2e72 616e 6469      r = jr.randi
-00004340: 6e74 286b 6579 2c0a 2020 2020 2020 2020  nt(key,.        
-00004350: 2020 2020 2020 2020 2020 2073 6861 7065             shape
-00004360: 3d5f 7369 7a65 3273 6861 7065 2873 697a  =_size2shape(siz
-00004370: 6529 2c0a 2020 2020 2020 2020 2020 2020  e),.            
-00004380: 2020 2020 2020 206d 696e 7661 6c3d 6c6f         minval=lo
-00004390: 772c 206d 6178 7661 6c3d 6869 6768 2c20  w, maxval=high, 
-000043a0: 6474 7970 653d 6474 7970 6529 0a20 2020  dtype=dtype).   
-000043b0: 2072 6574 7572 6e20 5f72 6574 7572 6e28   return _return(
-000043c0: 7229 0a0a 2020 6465 6620 7261 6e64 6f6d  r)..  def random
-000043d0: 5f69 6e74 6567 6572 7328 7365 6c66 2c20  _integers(self, 
-000043e0: 6c6f 772c 2068 6967 683d 4e6f 6e65 2c20  low, high=None, 
-000043f0: 7369 7a65 3d4e 6f6e 652c 206b 6579 3d4e  size=None, key=N
-00004400: 6f6e 6529 3a0a 2020 2020 6c6f 7720 3d20  one):.    low = 
-00004410: 5f61 735f 6a61 785f 6172 7261 7928 6c6f  _as_jax_array(lo
-00004420: 7729 0a20 2020 2068 6967 6820 3d20 5f61  w).    high = _a
-00004430: 735f 6a61 785f 6172 7261 7928 6869 6768  s_jax_array(high
-00004440: 290a 2020 2020 6c6f 7720 3d20 5f63 6865  ).    low = _che
-00004450: 636b 5f70 795f 7365 7128 6c6f 7729 0a20  ck_py_seq(low). 
-00004460: 2020 2068 6967 6820 3d20 5f63 6865 636b     high = _check
-00004470: 5f70 795f 7365 7128 6869 6768 290a 2020  _py_seq(high).  
-00004480: 2020 6966 2068 6967 6820 6973 204e 6f6e    if high is Non
-00004490: 653a 0a20 2020 2020 2068 6967 6820 3d20  e:.      high = 
-000044a0: 6c6f 770a 2020 2020 2020 6c6f 7720 3d20  low.      low = 
-000044b0: 310a 2020 2020 6869 6768 202b 3d20 310a  1.    high += 1.
-000044c0: 2020 2020 6966 2073 697a 6520 6973 204e      if size is N
-000044d0: 6f6e 653a 0a20 2020 2020 2073 697a 6520  one:.      size 
-000044e0: 3d20 6c61 782e 6272 6f61 6463 6173 745f  = lax.broadcast_
-000044f0: 7368 6170 6573 286a 6e70 2e73 6861 7065  shapes(jnp.shape
-00004500: 286c 6f77 292c 206a 6e70 2e73 6861 7065  (low), jnp.shape
-00004510: 2868 6967 6829 290a 2020 2020 6b65 7920  (high)).    key 
-00004520: 3d20 7365 6c66 2e73 706c 6974 5f6b 6579  = self.split_key
-00004530: 2829 2069 6620 6b65 7920 6973 204e 6f6e  () if key is Non
-00004540: 6520 656c 7365 205f 666f 726d 616c 697a  e else _formaliz
-00004550: 655f 6b65 7928 6b65 7929 0a20 2020 2072  e_key(key).    r
-00004560: 203d 206a 722e 7261 6e64 696e 7428 6b65   = jr.randint(ke
-00004570: 792c 0a20 2020 2020 2020 2020 2020 2020  y,.             
-00004580: 2020 2020 2020 7368 6170 653d 5f73 697a        shape=_siz
-00004590: 6532 7368 6170 6528 7369 7a65 292c 0a20  e2shape(size),. 
-000045a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000045b0: 2020 6d69 6e76 616c 3d6c 6f77 2c0a 2020    minval=low,.  
-000045c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000045d0: 206d 6178 7661 6c3d 6869 6768 290a 2020   maxval=high).  
-000045e0: 2020 7265 7475 726e 205f 7265 7475 726e    return _return
-000045f0: 2872 290a 0a20 2064 6566 2072 616e 646e  (r)..  def randn
-00004600: 2873 656c 662c 202a 646e 2c20 6b65 793d  (self, *dn, key=
-00004610: 4e6f 6e65 293a 0a20 2020 206b 6579 203d  None):.    key =
-00004620: 2073 656c 662e 7370 6c69 745f 6b65 7928   self.split_key(
-00004630: 2920 6966 206b 6579 2069 7320 4e6f 6e65  ) if key is None
-00004640: 2065 6c73 6520 5f66 6f72 6d61 6c69 7a65   else _formalize
-00004650: 5f6b 6579 286b 6579 290a 2020 2020 7220  _key(key).    r 
-00004660: 3d20 6a72 2e6e 6f72 6d61 6c28 6b65 792c  = jr.normal(key,
-00004670: 2073 6861 7065 3d64 6e29 0a20 2020 2072   shape=dn).    r
-00004680: 6574 7572 6e20 5f72 6574 7572 6e28 7229  eturn _return(r)
-00004690: 0a0a 2020 6465 6620 7261 6e64 6f6d 2873  ..  def random(s
-000046a0: 656c 662c 2073 697a 653d 4e6f 6e65 2c20  elf, size=None, 
-000046b0: 6b65 793d 4e6f 6e65 293a 0a20 2020 206b  key=None):.    k
-000046c0: 6579 203d 2073 656c 662e 7370 6c69 745f  ey = self.split_
-000046d0: 6b65 7928 2920 6966 206b 6579 2069 7320  key() if key is 
-000046e0: 4e6f 6e65 2065 6c73 6520 5f66 6f72 6d61  None else _forma
-000046f0: 6c69 7a65 5f6b 6579 286b 6579 290a 2020  lize_key(key).  
-00004700: 2020 7220 3d20 6a72 2e75 6e69 666f 726d    r = jr.uniform
-00004710: 286b 6579 2c20 7368 6170 653d 5f73 697a  (key, shape=_siz
-00004720: 6532 7368 6170 6528 7369 7a65 292c 206d  e2shape(size), m
-00004730: 696e 7661 6c3d 302e 2c20 6d61 7876 616c  inval=0., maxval
-00004740: 3d31 2e29 0a20 2020 2072 6574 7572 6e20  =1.).    return 
-00004750: 5f72 6574 7572 6e28 7229 0a0a 2020 6465  _return(r)..  de
-00004760: 6620 7261 6e64 6f6d 5f73 616d 706c 6528  f random_sample(
-00004770: 7365 6c66 2c20 7369 7a65 3d4e 6f6e 652c  self, size=None,
-00004780: 206b 6579 3d4e 6f6e 6529 3a0a 2020 2020   key=None):.    
-00004790: 7220 3d20 7365 6c66 2e72 616e 646f 6d28  r = self.random(
-000047a0: 7369 7a65 3d73 697a 652c 206b 6579 3d6b  size=size, key=k
-000047b0: 6579 290a 2020 2020 7265 7475 726e 205f  ey).    return _
-000047c0: 7265 7475 726e 2872 290a 0a20 2064 6566  return(r)..  def
-000047d0: 2072 616e 6628 7365 6c66 2c20 7369 7a65   ranf(self, size
-000047e0: 3d4e 6f6e 652c 206b 6579 3d4e 6f6e 6529  =None, key=None)
-000047f0: 3a0a 2020 2020 7220 3d20 7365 6c66 2e72  :.    r = self.r
-00004800: 616e 646f 6d28 7369 7a65 3d73 697a 652c  andom(size=size,
-00004810: 206b 6579 3d6b 6579 290a 2020 2020 7265   key=key).    re
-00004820: 7475 726e 205f 7265 7475 726e 2872 290a  turn _return(r).
-00004830: 0a20 2064 6566 2073 616d 706c 6528 7365  .  def sample(se
-00004840: 6c66 2c20 7369 7a65 3d4e 6f6e 652c 206b  lf, size=None, k
-00004850: 6579 3d4e 6f6e 6529 3a0a 2020 2020 7220  ey=None):.    r 
-00004860: 3d20 7365 6c66 2e72 616e 646f 6d28 7369  = self.random(si
-00004870: 7a65 3d73 697a 652c 206b 6579 3d6b 6579  ze=size, key=key
-00004880: 290a 2020 2020 7265 7475 726e 205f 7265  ).    return _re
-00004890: 7475 726e 2872 290a 0a20 2064 6566 2063  turn(r)..  def c
-000048a0: 686f 6963 6528 7365 6c66 2c20 612c 2073  hoice(self, a, s
-000048b0: 697a 653d 4e6f 6e65 2c20 7265 706c 6163  ize=None, replac
-000048c0: 653d 5472 7565 2c20 703d 4e6f 6e65 2c20  e=True, p=None, 
-000048d0: 6b65 793d 4e6f 6e65 293a 0a20 2020 2061  key=None):.    a
-000048e0: 203d 205f 6173 5f6a 6178 5f61 7272 6179   = _as_jax_array
-000048f0: 2861 290a 2020 2020 7020 3d20 5f61 735f  (a).    p = _as_
-00004900: 6a61 785f 6172 7261 7928 7029 0a20 2020  jax_array(p).   
-00004910: 2061 203d 205f 6368 6563 6b5f 7079 5f73   a = _check_py_s
-00004920: 6571 2861 290a 2020 2020 7020 3d20 5f63  eq(a).    p = _c
-00004930: 6865 636b 5f70 795f 7365 7128 7029 0a20  heck_py_seq(p). 
-00004940: 2020 206b 6579 203d 2073 656c 662e 7370     key = self.sp
-00004950: 6c69 745f 6b65 7928 2920 6966 206b 6579  lit_key() if key
-00004960: 2069 7320 4e6f 6e65 2065 6c73 6520 5f66   is None else _f
-00004970: 6f72 6d61 6c69 7a65 5f6b 6579 286b 6579  ormalize_key(key
-00004980: 290a 2020 2020 7220 3d20 6a72 2e63 686f  ).    r = jr.cho
-00004990: 6963 6528 6b65 792c 2061 3d61 2c20 7368  ice(key, a=a, sh
-000049a0: 6170 653d 5f73 697a 6532 7368 6170 6528  ape=_size2shape(
-000049b0: 7369 7a65 292c 2072 6570 6c61 6365 3d72  size), replace=r
-000049c0: 6570 6c61 6365 2c20 703d 7029 0a20 2020  eplace, p=p).   
-000049d0: 2072 6574 7572 6e20 5f72 6574 7572 6e28   return _return(
-000049e0: 7229 0a0a 2020 6465 6620 7065 726d 7574  r)..  def permut
-000049f0: 6174 696f 6e28 7365 6c66 2c20 782c 2061  ation(self, x, a
-00004a00: 7869 733a 2069 6e74 203d 2030 2c20 696e  xis: int = 0, in
-00004a10: 6465 7065 6e64 656e 743a 2062 6f6f 6c20  dependent: bool 
-00004a20: 3d20 4661 6c73 652c 206b 6579 3d4e 6f6e  = False, key=Non
-00004a30: 6529 3a0a 2020 2020 7820 3d20 782e 7661  e):.    x = x.va
-00004a40: 6c75 6520 6966 2069 7369 6e73 7461 6e63  lue if isinstanc
-00004a50: 6528 782c 2041 7272 6179 2920 656c 7365  e(x, Array) else
-00004a60: 2078 0a20 2020 2078 203d 205f 6368 6563   x.    x = _chec
-00004a70: 6b5f 7079 5f73 6571 2878 290a 2020 2020  k_py_seq(x).    
-00004a80: 6b65 7920 3d20 7365 6c66 2e73 706c 6974  key = self.split
-00004a90: 5f6b 6579 2829 2069 6620 6b65 7920 6973  _key() if key is
-00004aa0: 204e 6f6e 6520 656c 7365 205f 666f 726d   None else _form
-00004ab0: 616c 697a 655f 6b65 7928 6b65 7929 0a20  alize_key(key). 
-00004ac0: 2020 2072 203d 206a 722e 7065 726d 7574     r = jr.permut
-00004ad0: 6174 696f 6e28 6b65 792c 2078 2c20 6178  ation(key, x, ax
-00004ae0: 6973 3d61 7869 732c 2069 6e64 6570 656e  is=axis, indepen
-00004af0: 6465 6e74 3d69 6e64 6570 656e 6465 6e74  dent=independent
-00004b00: 290a 2020 2020 7265 7475 726e 205f 7265  ).    return _re
-00004b10: 7475 726e 2872 290a 0a20 2064 6566 2073  turn(r)..  def s
-00004b20: 6875 6666 6c65 2873 656c 662c 2078 2c20  huffle(self, x, 
-00004b30: 6178 6973 3d30 2c20 6b65 793d 4e6f 6e65  axis=0, key=None
-00004b40: 293a 0a20 2020 2069 6620 6e6f 7420 6973  ):.    if not is
-00004b50: 696e 7374 616e 6365 2878 2c20 4172 7261  instance(x, Arra
-00004b60: 7929 3a0a 2020 2020 2020 7261 6973 6520  y):.      raise 
-00004b70: 5479 7065 4572 726f 7228 2754 6869 7320  TypeError('This 
-00004b80: 6e75 6d70 7920 6f70 6572 6174 6f72 206e  numpy operator n
-00004b90: 6565 6473 2069 6e2d 706c 6163 6520 7570  eeds in-place up
-00004ba0: 6461 7469 6e67 2c20 7468 6572 6566 6f72  dating, therefor
-00004bb0: 6520 270a 2020 2020 2020 2020 2020 2020  e '.            
-00004bc0: 2020 2020 2020 2020 2020 2769 6e70 7574            'input
-00004bd0: 7320 7368 6f75 6c64 2062 6520 6272 6169  s should be brai
-00004be0: 6e70 7920 4172 7261 792e 2729 0a20 2020  npy Array.').   
-00004bf0: 206b 6579 203d 2073 656c 662e 7370 6c69   key = self.spli
-00004c00: 745f 6b65 7928 2920 6966 206b 6579 2069  t_key() if key i
-00004c10: 7320 4e6f 6e65 2065 6c73 6520 5f66 6f72  s None else _for
-00004c20: 6d61 6c69 7a65 5f6b 6579 286b 6579 290a  malize_key(key).
-00004c30: 2020 2020 782e 7661 6c75 6520 3d20 6a72      x.value = jr
-00004c40: 2e70 6572 6d75 7461 7469 6f6e 286b 6579  .permutation(key
-00004c50: 2c20 782e 7661 6c75 652c 2061 7869 733d  , x.value, axis=
-00004c60: 6178 6973 290a 0a20 2064 6566 2062 6574  axis)..  def bet
-00004c70: 6128 7365 6c66 2c20 612c 2062 2c20 7369  a(self, a, b, si
-00004c80: 7a65 3d4e 6f6e 652c 206b 6579 3d4e 6f6e  ze=None, key=Non
-00004c90: 6529 3a0a 2020 2020 6120 3d20 612e 7661  e):.    a = a.va
-00004ca0: 6c75 6520 6966 2069 7369 6e73 7461 6e63  lue if isinstanc
-00004cb0: 6528 612c 2041 7272 6179 2920 656c 7365  e(a, Array) else
-00004cc0: 2061 0a20 2020 2062 203d 2062 2e76 616c   a.    b = b.val
-00004cd0: 7565 2069 6620 6973 696e 7374 616e 6365  ue if isinstance
-00004ce0: 2862 2c20 4172 7261 7929 2065 6c73 6520  (b, Array) else 
-00004cf0: 620a 2020 2020 6120 3d20 5f63 6865 636b  b.    a = _check
-00004d00: 5f70 795f 7365 7128 6129 0a20 2020 2062  _py_seq(a).    b
-00004d10: 203d 205f 6368 6563 6b5f 7079 5f73 6571   = _check_py_seq
-00004d20: 2862 290a 2020 2020 6966 2073 697a 6520  (b).    if size 
-00004d30: 6973 204e 6f6e 653a 0a20 2020 2020 2073  is None:.      s
-00004d40: 697a 6520 3d20 6c61 782e 6272 6f61 6463  ize = lax.broadc
-00004d50: 6173 745f 7368 6170 6573 286a 6e70 2e73  ast_shapes(jnp.s
-00004d60: 6861 7065 2861 292c 206a 6e70 2e73 6861  hape(a), jnp.sha
-00004d70: 7065 2862 2929 0a20 2020 206b 6579 203d  pe(b)).    key =
-00004d80: 2073 656c 662e 7370 6c69 745f 6b65 7928   self.split_key(
-00004d90: 2920 6966 206b 6579 2069 7320 4e6f 6e65  ) if key is None
-00004da0: 2065 6c73 6520 5f66 6f72 6d61 6c69 7a65   else _formalize
-00004db0: 5f6b 6579 286b 6579 290a 2020 2020 7220  _key(key).    r 
-00004dc0: 3d20 6a72 2e62 6574 6128 6b65 792c 2061  = jr.beta(key, a
-00004dd0: 3d61 2c20 623d 622c 2073 6861 7065 3d5f  =a, b=b, shape=_
-00004de0: 7369 7a65 3273 6861 7065 2873 697a 6529  size2shape(size)
-00004df0: 290a 2020 2020 7265 7475 726e 205f 7265  ).    return _re
-00004e00: 7475 726e 2872 290a 0a20 2064 6566 2065  turn(r)..  def e
-00004e10: 7870 6f6e 656e 7469 616c 2873 656c 662c  xponential(self,
-00004e20: 2073 6361 6c65 3d4e 6f6e 652c 2073 697a   scale=None, siz
-00004e30: 653d 4e6f 6e65 2c20 6b65 793d 4e6f 6e65  e=None, key=None
-00004e40: 293a 0a20 2020 2073 6361 6c65 203d 205f  ):.    scale = _
-00004e50: 6173 5f6a 6178 5f61 7272 6179 2873 6361  as_jax_array(sca
-00004e60: 6c65 290a 2020 2020 7363 616c 6520 3d20  le).    scale = 
-00004e70: 5f63 6865 636b 5f70 795f 7365 7128 7363  _check_py_seq(sc
-00004e80: 616c 6529 0a20 2020 2069 6620 7369 7a65  ale).    if size
-00004e90: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
-00004ea0: 7369 7a65 203d 206a 6e70 2e73 6861 7065  size = jnp.shape
-00004eb0: 2873 6361 6c65 290a 2020 2020 6b65 7920  (scale).    key 
-00004ec0: 3d20 7365 6c66 2e73 706c 6974 5f6b 6579  = self.split_key
-00004ed0: 2829 2069 6620 6b65 7920 6973 204e 6f6e  () if key is Non
-00004ee0: 6520 656c 7365 205f 666f 726d 616c 697a  e else _formaliz
-00004ef0: 655f 6b65 7928 6b65 7929 0a20 2020 2072  e_key(key).    r
-00004f00: 203d 206a 722e 6578 706f 6e65 6e74 6961   = jr.exponentia
-00004f10: 6c28 6b65 792c 2073 6861 7065 3d5f 7369  l(key, shape=_si
-00004f20: 7a65 3273 6861 7065 2873 697a 6529 290a  ze2shape(size)).
-00004f30: 2020 2020 6966 2073 6361 6c65 2069 7320      if scale is 
-00004f40: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-00004f50: 7220 3d20 7220 2f20 7363 616c 650a 2020  r = r / scale.  
-00004f60: 2020 7265 7475 726e 205f 7265 7475 726e    return _return
-00004f70: 2872 290a 0a20 2064 6566 2067 616d 6d61  (r)..  def gamma
-00004f80: 2873 656c 662c 2073 6861 7065 2c20 7363  (self, shape, sc
-00004f90: 616c 653d 4e6f 6e65 2c20 7369 7a65 3d4e  ale=None, size=N
-00004fa0: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
-00004fb0: 2020 2020 7368 6170 6520 3d20 5f61 735f      shape = _as_
-00004fc0: 6a61 785f 6172 7261 7928 7368 6170 6529  jax_array(shape)
-00004fd0: 0a20 2020 2073 6361 6c65 203d 205f 6173  .    scale = _as
-00004fe0: 5f6a 6178 5f61 7272 6179 2873 6361 6c65  _jax_array(scale
-00004ff0: 290a 2020 2020 7368 6170 6520 3d20 5f63  ).    shape = _c
-00005000: 6865 636b 5f70 795f 7365 7128 7368 6170  heck_py_seq(shap
-00005010: 6529 0a20 2020 2073 6361 6c65 203d 205f  e).    scale = _
-00005020: 6368 6563 6b5f 7079 5f73 6571 2873 6361  check_py_seq(sca
-00005030: 6c65 290a 2020 2020 6966 2073 697a 6520  le).    if size 
-00005040: 6973 204e 6f6e 653a 0a20 2020 2020 2073  is None:.      s
-00005050: 697a 6520 3d20 6c61 782e 6272 6f61 6463  ize = lax.broadc
-00005060: 6173 745f 7368 6170 6573 286a 6e70 2e73  ast_shapes(jnp.s
-00005070: 6861 7065 2873 6861 7065 292c 206a 6e70  hape(shape), jnp
-00005080: 2e73 6861 7065 2873 6361 6c65 2929 0a20  .shape(scale)). 
-00005090: 2020 206b 6579 203d 2073 656c 662e 7370     key = self.sp
-000050a0: 6c69 745f 6b65 7928 2920 6966 206b 6579  lit_key() if key
-000050b0: 2069 7320 4e6f 6e65 2065 6c73 6520 5f66   is None else _f
-000050c0: 6f72 6d61 6c69 7a65 5f6b 6579 286b 6579  ormalize_key(key
-000050d0: 290a 2020 2020 7220 3d20 6a72 2e67 616d  ).    r = jr.gam
-000050e0: 6d61 286b 6579 2c20 613d 7368 6170 652c  ma(key, a=shape,
-000050f0: 2073 6861 7065 3d5f 7369 7a65 3273 6861   shape=_size2sha
-00005100: 7065 2873 697a 6529 290a 2020 2020 6966  pe(size)).    if
-00005110: 2073 6361 6c65 2069 7320 6e6f 7420 4e6f   scale is not No
-00005120: 6e65 3a0a 2020 2020 2020 7220 3d20 7220  ne:.      r = r 
-00005130: 2a20 7363 616c 650a 2020 2020 7265 7475  * scale.    retu
-00005140: 726e 205f 7265 7475 726e 2872 290a 0a20  rn _return(r).. 
-00005150: 2064 6566 2067 756d 6265 6c28 7365 6c66   def gumbel(self
-00005160: 2c20 6c6f 633d 4e6f 6e65 2c20 7363 616c  , loc=None, scal
-00005170: 653d 4e6f 6e65 2c20 7369 7a65 3d4e 6f6e  e=None, size=Non
-00005180: 652c 206b 6579 3d4e 6f6e 6529 3a0a 2020  e, key=None):.  
-00005190: 2020 6c6f 6320 3d20 5f61 735f 6a61 785f    loc = _as_jax_
-000051a0: 6172 7261 7928 6c6f 6329 0a20 2020 2073  array(loc).    s
-000051b0: 6361 6c65 203d 205f 6173 5f6a 6178 5f61  cale = _as_jax_a
-000051c0: 7272 6179 2873 6361 6c65 290a 2020 2020  rray(scale).    
-000051d0: 6c6f 6320 3d20 5f63 6865 636b 5f70 795f  loc = _check_py_
-000051e0: 7365 7128 6c6f 6329 0a20 2020 2073 6361  seq(loc).    sca
-000051f0: 6c65 203d 205f 6368 6563 6b5f 7079 5f73  le = _check_py_s
-00005200: 6571 2873 6361 6c65 290a 2020 2020 6966  eq(scale).    if
-00005210: 2073 697a 6520 6973 204e 6f6e 653a 0a20   size is None:. 
-00005220: 2020 2020 2073 697a 6520 3d20 6c61 782e       size = lax.
-00005230: 6272 6f61 6463 6173 745f 7368 6170 6573  broadcast_shapes
-00005240: 286a 6e70 2e73 6861 7065 286c 6f63 292c  (jnp.shape(loc),
-00005250: 206a 6e70 2e73 6861 7065 2873 6361 6c65   jnp.shape(scale
-00005260: 2929 0a20 2020 206b 6579 203d 2073 656c  )).    key = sel
-00005270: 662e 7370 6c69 745f 6b65 7928 2920 6966  f.split_key() if
-00005280: 206b 6579 2069 7320 4e6f 6e65 2065 6c73   key is None els
-00005290: 6520 5f66 6f72 6d61 6c69 7a65 5f6b 6579  e _formalize_key
-000052a0: 286b 6579 290a 2020 2020 7220 3d20 5f6c  (key).    r = _l
-000052b0: 6f63 5f73 6361 6c65 286c 6f63 2c20 7363  oc_scale(loc, sc
-000052c0: 616c 652c 206a 722e 6775 6d62 656c 286b  ale, jr.gumbel(k
-000052d0: 6579 2c20 7368 6170 653d 5f73 697a 6532  ey, shape=_size2
-000052e0: 7368 6170 6528 7369 7a65 2929 290a 2020  shape(size))).  
-000052f0: 2020 7265 7475 726e 205f 7265 7475 726e    return _return
-00005300: 2872 290a 0a20 2064 6566 206c 6170 6c61  (r)..  def lapla
-00005310: 6365 2873 656c 662c 206c 6f63 3d4e 6f6e  ce(self, loc=Non
-00005320: 652c 2073 6361 6c65 3d4e 6f6e 652c 2073  e, scale=None, s
-00005330: 697a 653d 4e6f 6e65 2c20 6b65 793d 4e6f  ize=None, key=No
-00005340: 6e65 293a 0a20 2020 206c 6f63 203d 205f  ne):.    loc = _
-00005350: 6173 5f6a 6178 5f61 7272 6179 286c 6f63  as_jax_array(loc
-00005360: 290a 2020 2020 7363 616c 6520 3d20 5f61  ).    scale = _a
-00005370: 735f 6a61 785f 6172 7261 7928 7363 616c  s_jax_array(scal
-00005380: 6529 0a20 2020 206c 6f63 203d 205f 6368  e).    loc = _ch
-00005390: 6563 6b5f 7079 5f73 6571 286c 6f63 290a  eck_py_seq(loc).
-000053a0: 2020 2020 7363 616c 6520 3d20 5f63 6865      scale = _che
-000053b0: 636b 5f70 795f 7365 7128 7363 616c 6529  ck_py_seq(scale)
-000053c0: 0a20 2020 2069 6620 7369 7a65 2069 7320  .    if size is 
-000053d0: 4e6f 6e65 3a0a 2020 2020 2020 7369 7a65  None:.      size
-000053e0: 203d 206c 6178 2e62 726f 6164 6361 7374   = lax.broadcast
-000053f0: 5f73 6861 7065 7328 6a6e 702e 7368 6170  _shapes(jnp.shap
-00005400: 6528 6c6f 6329 2c20 6a6e 702e 7368 6170  e(loc), jnp.shap
-00005410: 6528 7363 616c 6529 290a 2020 2020 6b65  e(scale)).    ke
-00005420: 7920 3d20 7365 6c66 2e73 706c 6974 5f6b  y = self.split_k
-00005430: 6579 2829 2069 6620 6b65 7920 6973 204e  ey() if key is N
-00005440: 6f6e 6520 656c 7365 205f 666f 726d 616c  one else _formal
-00005450: 697a 655f 6b65 7928 6b65 7929 0a20 2020  ize_key(key).   
-00005460: 2072 203d 205f 6c6f 635f 7363 616c 6528   r = _loc_scale(
-00005470: 6c6f 632c 2073 6361 6c65 2c20 6a72 2e6c  loc, scale, jr.l
-00005480: 6170 6c61 6365 286b 6579 2c20 7368 6170  aplace(key, shap
-00005490: 653d 5f73 697a 6532 7368 6170 6528 7369  e=_size2shape(si
-000054a0: 7a65 2929 290a 2020 2020 7265 7475 726e  ze))).    return
-000054b0: 205f 7265 7475 726e 2872 290a 0a20 2064   _return(r)..  d
-000054c0: 6566 206c 6f67 6973 7469 6328 7365 6c66  ef logistic(self
-000054d0: 2c20 6c6f 633d 4e6f 6e65 2c20 7363 616c  , loc=None, scal
-000054e0: 653d 4e6f 6e65 2c20 7369 7a65 3d4e 6f6e  e=None, size=Non
-000054f0: 652c 206b 6579 3d4e 6f6e 6529 3a0a 2020  e, key=None):.  
-00005500: 2020 6c6f 6320 3d20 5f61 735f 6a61 785f    loc = _as_jax_
-00005510: 6172 7261 7928 6c6f 6329 0a20 2020 2073  array(loc).    s
-00005520: 6361 6c65 203d 205f 6173 5f6a 6178 5f61  cale = _as_jax_a
-00005530: 7272 6179 2873 6361 6c65 290a 2020 2020  rray(scale).    
-00005540: 6c6f 6320 3d20 5f63 6865 636b 5f70 795f  loc = _check_py_
-00005550: 7365 7128 6c6f 6329 0a20 2020 2073 6361  seq(loc).    sca
-00005560: 6c65 203d 205f 6368 6563 6b5f 7079 5f73  le = _check_py_s
-00005570: 6571 2873 6361 6c65 290a 2020 2020 6966  eq(scale).    if
-00005580: 2073 697a 6520 6973 204e 6f6e 653a 0a20   size is None:. 
-00005590: 2020 2020 2073 697a 6520 3d20 6c61 782e       size = lax.
-000055a0: 6272 6f61 6463 6173 745f 7368 6170 6573  broadcast_shapes
-000055b0: 286a 6e70 2e73 6861 7065 286c 6f63 292c  (jnp.shape(loc),
-000055c0: 206a 6e70 2e73 6861 7065 2873 6361 6c65   jnp.shape(scale
-000055d0: 2929 0a20 2020 206b 6579 203d 2073 656c  )).    key = sel
-000055e0: 662e 7370 6c69 745f 6b65 7928 2920 6966  f.split_key() if
-000055f0: 206b 6579 2069 7320 4e6f 6e65 2065 6c73   key is None els
-00005600: 6520 5f66 6f72 6d61 6c69 7a65 5f6b 6579  e _formalize_key
-00005610: 286b 6579 290a 2020 2020 7220 3d20 5f6c  (key).    r = _l
-00005620: 6f63 5f73 6361 6c65 286c 6f63 2c20 7363  oc_scale(loc, sc
-00005630: 616c 652c 206a 722e 6c6f 6769 7374 6963  ale, jr.logistic
-00005640: 286b 6579 2c20 7368 6170 653d 5f73 697a  (key, shape=_siz
-00005650: 6532 7368 6170 6528 7369 7a65 2929 290a  e2shape(size))).
-00005660: 2020 2020 7265 7475 726e 205f 7265 7475      return _retu
-00005670: 726e 2872 290a 0a20 2064 6566 206e 6f72  rn(r)..  def nor
-00005680: 6d61 6c28 7365 6c66 2c20 6c6f 633d 4e6f  mal(self, loc=No
-00005690: 6e65 2c20 7363 616c 653d 4e6f 6e65 2c20  ne, scale=None, 
-000056a0: 7369 7a65 3d4e 6f6e 652c 206b 6579 3d4e  size=None, key=N
-000056b0: 6f6e 6529 3a0a 2020 2020 6c6f 6320 3d20  one):.    loc = 
-000056c0: 5f61 735f 6a61 785f 6172 7261 7928 6c6f  _as_jax_array(lo
-000056d0: 6329 0a20 2020 2073 6361 6c65 203d 205f  c).    scale = _
-000056e0: 6173 5f6a 6178 5f61 7272 6179 2873 6361  as_jax_array(sca
-000056f0: 6c65 290a 2020 2020 6c6f 6320 3d20 5f63  le).    loc = _c
-00005700: 6865 636b 5f70 795f 7365 7128 6c6f 6329  heck_py_seq(loc)
-00005710: 0a20 2020 2073 6361 6c65 203d 205f 6368  .    scale = _ch
-00005720: 6563 6b5f 7079 5f73 6571 2873 6361 6c65  eck_py_seq(scale
-00005730: 290a 2020 2020 6966 2073 697a 6520 6973  ).    if size is
-00005740: 204e 6f6e 653a 0a20 2020 2020 2073 697a   None:.      siz
-00005750: 6520 3d20 6c61 782e 6272 6f61 6463 6173  e = lax.broadcas
-00005760: 745f 7368 6170 6573 286a 6e70 2e73 6861  t_shapes(jnp.sha
-00005770: 7065 2873 6361 6c65 292c 206a 6e70 2e73  pe(scale), jnp.s
-00005780: 6861 7065 286c 6f63 2929 0a20 2020 206b  hape(loc)).    k
-00005790: 6579 203d 2073 656c 662e 7370 6c69 745f  ey = self.split_
-000057a0: 6b65 7928 2920 6966 206b 6579 2069 7320  key() if key is 
-000057b0: 4e6f 6e65 2065 6c73 6520 5f66 6f72 6d61  None else _forma
-000057c0: 6c69 7a65 5f6b 6579 286b 6579 290a 2020  lize_key(key).  
-000057d0: 2020 7220 3d20 5f6c 6f63 5f73 6361 6c65    r = _loc_scale
-000057e0: 286c 6f63 2c20 7363 616c 652c 206a 722e  (loc, scale, jr.
-000057f0: 6e6f 726d 616c 286b 6579 2c20 7368 6170  normal(key, shap
-00005800: 653d 5f73 697a 6532 7368 6170 6528 7369  e=_size2shape(si
-00005810: 7a65 2929 290a 2020 2020 7265 7475 726e  ze))).    return
-00005820: 205f 7265 7475 726e 2872 290a 0a20 2064   _return(r)..  d
-00005830: 6566 2070 6172 6574 6f28 7365 6c66 2c20  ef pareto(self, 
-00005840: 612c 2073 697a 653d 4e6f 6e65 2c20 6b65  a, size=None, ke
-00005850: 793d 4e6f 6e65 293a 0a20 2020 2061 203d  y=None):.    a =
-00005860: 205f 6173 5f6a 6178 5f61 7272 6179 2861   _as_jax_array(a
-00005870: 290a 2020 2020 6120 3d20 5f63 6865 636b  ).    a = _check
-00005880: 5f70 795f 7365 7128 6129 0a20 2020 2069  _py_seq(a).    i
-00005890: 6620 7369 7a65 2069 7320 4e6f 6e65 3a0a  f size is None:.
-000058a0: 2020 2020 2020 7369 7a65 203d 206a 6e70        size = jnp
-000058b0: 2e73 6861 7065 2861 290a 2020 2020 6b65  .shape(a).    ke
-000058c0: 7920 3d20 7365 6c66 2e73 706c 6974 5f6b  y = self.split_k
-000058d0: 6579 2829 2069 6620 6b65 7920 6973 204e  ey() if key is N
-000058e0: 6f6e 6520 656c 7365 205f 666f 726d 616c  one else _formal
-000058f0: 697a 655f 6b65 7928 6b65 7929 0a20 2020  ize_key(key).   
-00005900: 2072 203d 206a 722e 7061 7265 746f 286b   r = jr.pareto(k
-00005910: 6579 2c20 623d 612c 2073 6861 7065 3d5f  ey, b=a, shape=_
-00005920: 7369 7a65 3273 6861 7065 2873 697a 6529  size2shape(size)
-00005930: 290a 2020 2020 7265 7475 726e 205f 7265  ).    return _re
-00005940: 7475 726e 2872 290a 0a20 2064 6566 2070  turn(r)..  def p
-00005950: 6f69 7373 6f6e 2873 656c 662c 206c 616d  oisson(self, lam
-00005960: 3d31 2e30 2c20 7369 7a65 3d4e 6f6e 652c  =1.0, size=None,
-00005970: 206b 6579 3d4e 6f6e 6529 3a0a 2020 2020   key=None):.    
-00005980: 6c61 6d20 3d20 5f63 6865 636b 5f70 795f  lam = _check_py_
-00005990: 7365 7128 5f61 735f 6a61 785f 6172 7261  seq(_as_jax_arra
-000059a0: 7928 6c61 6d29 290a 2020 2020 6966 2073  y(lam)).    if s
-000059b0: 697a 6520 6973 204e 6f6e 653a 0a20 2020  ize is None:.   
-000059c0: 2020 2073 697a 6520 3d20 6a6e 702e 7368     size = jnp.sh
-000059d0: 6170 6528 6c61 6d29 0a20 2020 206b 6579  ape(lam).    key
-000059e0: 203d 2073 656c 662e 7370 6c69 745f 6b65   = self.split_ke
-000059f0: 7928 2920 6966 206b 6579 2069 7320 4e6f  y() if key is No
-00005a00: 6e65 2065 6c73 6520 5f66 6f72 6d61 6c69  ne else _formali
-00005a10: 7a65 5f6b 6579 286b 6579 290a 2020 2020  ze_key(key).    
-00005a20: 7220 3d20 6a72 2e70 6f69 7373 6f6e 286b  r = jr.poisson(k
-00005a30: 6579 2c20 6c61 6d3d 6c61 6d2c 2073 6861  ey, lam=lam, sha
-00005a40: 7065 3d5f 7369 7a65 3273 6861 7065 2873  pe=_size2shape(s
-00005a50: 697a 6529 290a 2020 2020 7265 7475 726e  ize)).    return
-00005a60: 205f 7265 7475 726e 2872 290a 0a20 2064   _return(r)..  d
-00005a70: 6566 2073 7461 6e64 6172 645f 6361 7563  ef standard_cauc
-00005a80: 6879 2873 656c 662c 2073 697a 653d 4e6f  hy(self, size=No
-00005a90: 6e65 2c20 6b65 793d 4e6f 6e65 293a 0a20  ne, key=None):. 
-00005aa0: 2020 206b 6579 203d 2073 656c 662e 7370     key = self.sp
-00005ab0: 6c69 745f 6b65 7928 2920 6966 206b 6579  lit_key() if key
-00005ac0: 2069 7320 4e6f 6e65 2065 6c73 6520 5f66   is None else _f
-00005ad0: 6f72 6d61 6c69 7a65 5f6b 6579 286b 6579  ormalize_key(key
-00005ae0: 290a 2020 2020 7220 3d20 6a72 2e63 6175  ).    r = jr.cau
-00005af0: 6368 7928 6b65 792c 2073 6861 7065 3d5f  chy(key, shape=_
-00005b00: 7369 7a65 3273 6861 7065 2873 697a 6529  size2shape(size)
-00005b10: 290a 2020 2020 7265 7475 726e 205f 7265  ).    return _re
-00005b20: 7475 726e 2872 290a 0a20 2064 6566 2073  turn(r)..  def s
-00005b30: 7461 6e64 6172 645f 6578 706f 6e65 6e74  tandard_exponent
-00005b40: 6961 6c28 7365 6c66 2c20 7369 7a65 3d4e  ial(self, size=N
-00005b50: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
-00005b60: 2020 2020 6b65 7920 3d20 7365 6c66 2e73      key = self.s
-00005b70: 706c 6974 5f6b 6579 2829 2069 6620 6b65  plit_key() if ke
-00005b80: 7920 6973 204e 6f6e 6520 656c 7365 205f  y is None else _
-00005b90: 666f 726d 616c 697a 655f 6b65 7928 6b65  formalize_key(ke
-00005ba0: 7929 0a20 2020 2072 203d 206a 722e 6578  y).    r = jr.ex
-00005bb0: 706f 6e65 6e74 6961 6c28 6b65 792c 2073  ponential(key, s
-00005bc0: 6861 7065 3d5f 7369 7a65 3273 6861 7065  hape=_size2shape
-00005bd0: 2873 697a 6529 290a 2020 2020 7265 7475  (size)).    retu
-00005be0: 726e 205f 7265 7475 726e 2872 290a 0a20  rn _return(r).. 
-00005bf0: 2064 6566 2073 7461 6e64 6172 645f 6761   def standard_ga
-00005c00: 6d6d 6128 7365 6c66 2c20 7368 6170 652c  mma(self, shape,
-00005c10: 2073 697a 653d 4e6f 6e65 2c20 6b65 793d   size=None, key=
-00005c20: 4e6f 6e65 293a 0a20 2020 2073 6861 7065  None):.    shape
-00005c30: 203d 205f 6173 5f6a 6178 5f61 7272 6179   = _as_jax_array
-00005c40: 2873 6861 7065 290a 2020 2020 7368 6170  (shape).    shap
-00005c50: 6520 3d20 5f63 6865 636b 5f70 795f 7365  e = _check_py_se
-00005c60: 7128 7368 6170 6529 0a20 2020 2069 6620  q(shape).    if 
-00005c70: 7369 7a65 2069 7320 4e6f 6e65 3a0a 2020  size is None:.  
-00005c80: 2020 2020 7369 7a65 203d 206a 6e70 2e73      size = jnp.s
-00005c90: 6861 7065 2873 6861 7065 290a 2020 2020  hape(shape).    
-00005ca0: 6b65 7920 3d20 7365 6c66 2e73 706c 6974  key = self.split
-00005cb0: 5f6b 6579 2829 2069 6620 6b65 7920 6973  _key() if key is
-00005cc0: 204e 6f6e 6520 656c 7365 205f 666f 726d   None else _form
-00005cd0: 616c 697a 655f 6b65 7928 6b65 7929 0a20  alize_key(key). 
-00005ce0: 2020 2072 203d 206a 722e 6761 6d6d 6128     r = jr.gamma(
-00005cf0: 6b65 792c 2061 3d73 6861 7065 2c20 7368  key, a=shape, sh
-00005d00: 6170 653d 5f73 697a 6532 7368 6170 6528  ape=_size2shape(
-00005d10: 7369 7a65 2929 0a20 2020 2072 6574 7572  size)).    retur
-00005d20: 6e20 5f72 6574 7572 6e28 7229 0a0a 2020  n _return(r)..  
-00005d30: 6465 6620 7374 616e 6461 7264 5f6e 6f72  def standard_nor
-00005d40: 6d61 6c28 7365 6c66 2c20 7369 7a65 3d4e  mal(self, size=N
-00005d50: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
-00005d60: 2020 2020 6b65 7920 3d20 7365 6c66 2e73      key = self.s
-00005d70: 706c 6974 5f6b 6579 2829 2069 6620 6b65  plit_key() if ke
-00005d80: 7920 6973 204e 6f6e 6520 656c 7365 205f  y is None else _
-00005d90: 666f 726d 616c 697a 655f 6b65 7928 6b65  formalize_key(ke
-00005da0: 7929 0a20 2020 2072 203d 206a 722e 6e6f  y).    r = jr.no
-00005db0: 726d 616c 286b 6579 2c20 7368 6170 653d  rmal(key, shape=
-00005dc0: 5f73 697a 6532 7368 6170 6528 7369 7a65  _size2shape(size
-00005dd0: 2929 0a20 2020 2072 6574 7572 6e20 5f72  )).    return _r
-00005de0: 6574 7572 6e28 7229 0a0a 2020 6465 6620  eturn(r)..  def 
-00005df0: 7374 616e 6461 7264 5f74 2873 656c 662c  standard_t(self,
-00005e00: 2064 662c 2073 697a 653d 4e6f 6e65 2c20   df, size=None, 
-00005e10: 6b65 793d 4e6f 6e65 293a 0a20 2020 2064  key=None):.    d
-00005e20: 6620 3d20 5f61 735f 6a61 785f 6172 7261  f = _as_jax_arra
-00005e30: 7928 6466 290a 2020 2020 6466 203d 205f  y(df).    df = _
-00005e40: 6368 6563 6b5f 7079 5f73 6571 2864 6629  check_py_seq(df)
-00005e50: 0a20 2020 2069 6620 7369 7a65 2069 7320  .    if size is 
-00005e60: 4e6f 6e65 3a0a 2020 2020 2020 7369 7a65  None:.      size
-00005e70: 203d 206a 6e70 2e73 6861 7065 2873 697a   = jnp.shape(siz
-00005e80: 6529 0a20 2020 206b 6579 203d 2073 656c  e).    key = sel
-00005e90: 662e 7370 6c69 745f 6b65 7928 2920 6966  f.split_key() if
-00005ea0: 206b 6579 2069 7320 4e6f 6e65 2065 6c73   key is None els
-00005eb0: 6520 5f66 6f72 6d61 6c69 7a65 5f6b 6579  e _formalize_key
-00005ec0: 286b 6579 290a 2020 2020 7220 3d20 6a72  (key).    r = jr
-00005ed0: 2e74 286b 6579 2c20 6466 3d64 662c 2073  .t(key, df=df, s
-00005ee0: 6861 7065 3d5f 7369 7a65 3273 6861 7065  hape=_size2shape
-00005ef0: 2873 697a 6529 290a 2020 2020 7265 7475  (size)).    retu
-00005f00: 726e 205f 7265 7475 726e 2872 290a 0a20  rn _return(r).. 
-00005f10: 2064 6566 2075 6e69 666f 726d 2873 656c   def uniform(sel
-00005f20: 662c 206c 6f77 3d30 2e30 2c20 6869 6768  f, low=0.0, high
-00005f30: 3d31 2e30 2c20 7369 7a65 3d4e 6f6e 652c  =1.0, size=None,
-00005f40: 206b 6579 3d4e 6f6e 6529 3a0a 2020 2020   key=None):.    
-00005f50: 6c6f 7720 3d20 5f61 735f 6a61 785f 6172  low = _as_jax_ar
-00005f60: 7261 7928 6c6f 7729 0a20 2020 2068 6967  ray(low).    hig
-00005f70: 6820 3d20 5f61 735f 6a61 785f 6172 7261  h = _as_jax_arra
-00005f80: 7928 6869 6768 290a 2020 2020 6c6f 7720  y(high).    low 
-00005f90: 3d20 5f63 6865 636b 5f70 795f 7365 7128  = _check_py_seq(
-00005fa0: 6c6f 7729 0a20 2020 2068 6967 6820 3d20  low).    high = 
-00005fb0: 5f63 6865 636b 5f70 795f 7365 7128 6869  _check_py_seq(hi
-00005fc0: 6768 290a 2020 2020 6966 2073 697a 6520  gh).    if size 
-00005fd0: 6973 204e 6f6e 653a 0a20 2020 2020 2073  is None:.      s
-00005fe0: 697a 6520 3d20 6c61 782e 6272 6f61 6463  ize = lax.broadc
-00005ff0: 6173 745f 7368 6170 6573 286a 6e70 2e73  ast_shapes(jnp.s
-00006000: 6861 7065 286c 6f77 292c 206a 6e70 2e73  hape(low), jnp.s
-00006010: 6861 7065 2868 6967 6829 290a 2020 2020  hape(high)).    
-00006020: 6b65 7920 3d20 7365 6c66 2e73 706c 6974  key = self.split
-00006030: 5f6b 6579 2829 2069 6620 6b65 7920 6973  _key() if key is
-00006040: 204e 6f6e 6520 656c 7365 205f 666f 726d   None else _form
-00006050: 616c 697a 655f 6b65 7928 6b65 7929 0a20  alize_key(key). 
-00006060: 2020 2072 203d 206a 722e 756e 6966 6f72     r = jr.unifor
-00006070: 6d28 6b65 792c 2073 6861 7065 3d5f 7369  m(key, shape=_si
-00006080: 7a65 3273 6861 7065 2873 697a 6529 2c20  ze2shape(size), 
-00006090: 6d69 6e76 616c 3d6c 6f77 2c20 6d61 7876  minval=low, maxv
-000060a0: 616c 3d68 6967 6829 0a20 2020 2072 6574  al=high).    ret
-000060b0: 7572 6e20 5f72 6574 7572 6e28 7229 0a0a  urn _return(r)..
-000060c0: 2020 6465 6620 7472 756e 6361 7465 645f    def truncated_
-000060d0: 6e6f 726d 616c 2873 656c 662c 206c 6f77  normal(self, low
-000060e0: 6572 2c20 7570 7065 722c 2073 697a 653d  er, upper, size=
-000060f0: 4e6f 6e65 2c20 7363 616c 653d 4e6f 6e65  None, scale=None
-00006100: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2020  , key=None):.   
-00006110: 206c 6f77 6572 203d 205f 6173 5f6a 6178   lower = _as_jax
-00006120: 5f61 7272 6179 286c 6f77 6572 290a 2020  _array(lower).  
-00006130: 2020 6c6f 7765 7220 3d20 5f63 6865 636b    lower = _check
-00006140: 5f70 795f 7365 7128 6c6f 7765 7229 0a20  _py_seq(lower). 
-00006150: 2020 2075 7070 6572 203d 205f 6173 5f6a     upper = _as_j
-00006160: 6178 5f61 7272 6179 2875 7070 6572 290a  ax_array(upper).
-00006170: 2020 2020 7570 7065 7220 3d20 5f63 6865      upper = _che
-00006180: 636b 5f70 795f 7365 7128 7570 7065 7229  ck_py_seq(upper)
-00006190: 0a20 2020 2073 6361 6c65 203d 205f 6173  .    scale = _as
-000061a0: 5f6a 6178 5f61 7272 6179 2873 6361 6c65  _jax_array(scale
-000061b0: 290a 2020 2020 7363 616c 6520 3d20 5f63  ).    scale = _c
-000061c0: 6865 636b 5f70 795f 7365 7128 7363 616c  heck_py_seq(scal
-000061d0: 6529 0a20 2020 2069 6620 7369 7a65 2069  e).    if size i
-000061e0: 7320 4e6f 6e65 3a0a 2020 2020 2020 7369  s None:.      si
-000061f0: 7a65 203d 206c 6178 2e62 726f 6164 6361  ze = lax.broadca
-00006200: 7374 5f73 6861 7065 7328 6a6e 702e 7368  st_shapes(jnp.sh
-00006210: 6170 6528 6c6f 7765 7229 2c0a 2020 2020  ape(lower),.    
-00006220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006230: 2020 2020 2020 2020 2020 2020 2020 6a6e                jn
-00006240: 702e 7368 6170 6528 7570 7065 7229 2c0a  p.shape(upper),.
-00006250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006270: 2020 6a6e 702e 7368 6170 6528 7363 616c    jnp.shape(scal
-00006280: 6529 290a 2020 2020 6b65 7920 3d20 7365  e)).    key = se
+00000100: 722c 2063 6f72 652c 2064 7479 7065 730a  r, core, dtypes.
+00000110: 6672 6f6d 206a 6178 2e65 7870 6572 696d  from jax.experim
+00000120: 656e 7461 6c2e 686f 7374 5f63 616c 6c62  ental.host_callb
+00000130: 6163 6b20 696d 706f 7274 2063 616c 6c0a  ack import call.
+00000140: 6672 6f6d 206a 6178 2e74 7265 655f 7574  from jax.tree_ut
+00000150: 696c 2069 6d70 6f72 7420 7265 6769 7374  il import regist
+00000160: 6572 5f70 7974 7265 655f 6e6f 6465 5f63  er_pytree_node_c
+00000170: 6c61 7373 0a0a 6672 6f6d 2062 7261 696e  lass..from brain
+00000180: 7079 2e63 6865 636b 2069 6d70 6f72 7420  py.check import 
+00000190: 6a69 745f 6572 726f 725f 6368 6563 6b69  jit_error_checki
+000001a0: 6e67 0a66 726f 6d20 2e63 6f6d 7061 745f  ng.from .compat_
+000001b0: 6e75 6d70 7920 696d 706f 7274 2073 6861  numpy import sha
+000001c0: 7065 0a66 726f 6d20 2e65 6e76 6972 6f6e  pe.from .environ
+000001d0: 6d65 6e74 2069 6d70 6f72 7420 6765 745f  ment import get_
+000001e0: 696e 740a 6672 6f6d 202e 6e64 6172 7261  int.from .ndarra
+000001f0: 7920 696d 706f 7274 2041 7272 6179 2c20  y import Array, 
+00000200: 5f72 6574 7572 6e0a 6672 6f6d 202e 6f62  _return.from .ob
+00000210: 6a65 6374 5f74 7261 6e73 666f 726d 2e76  ject_transform.v
+00000220: 6172 6961 626c 6573 2069 6d70 6f72 7420  ariables import 
+00000230: 5661 7269 6162 6c65 0a0a 5f5f 616c 6c5f  Variable..__all_
+00000240: 5f20 3d20 5b0a 2020 2752 616e 646f 6d53  _ = [.  'RandomS
+00000250: 7461 7465 272c 2027 4765 6e65 7261 746f  tate', 'Generato
+00000260: 7227 2c20 2744 4546 4155 4c54 272c 0a0a  r', 'DEFAULT',..
+00000270: 2020 2773 6565 6427 2c20 2764 6566 6175    'seed', 'defau
+00000280: 6c74 5f72 6e67 272c 2027 7370 6c69 745f  lt_rng', 'split_
+00000290: 6b65 7927 2c0a 0a20 2023 206e 756d 7079  key',..  # numpy
+000002a0: 2063 6f6d 7061 7469 6269 6c69 7479 0a20   compatibility. 
+000002b0: 2027 7261 6e64 272c 2027 7261 6e64 696e   'rand', 'randin
+000002c0: 7427 2c20 2772 616e 646f 6d5f 696e 7465  t', 'random_inte
+000002d0: 6765 7273 272c 2027 7261 6e64 6e27 2c20  gers', 'randn', 
+000002e0: 2772 616e 646f 6d27 2c0a 2020 2772 616e  'random',.  'ran
+000002f0: 646f 6d5f 7361 6d70 6c65 272c 2027 7261  dom_sample', 'ra
+00000300: 6e66 272c 2027 7361 6d70 6c65 272c 2027  nf', 'sample', '
+00000310: 6368 6f69 6365 272c 2027 7065 726d 7574  choice', 'permut
+00000320: 6174 696f 6e27 2c20 2773 6875 6666 6c65  ation', 'shuffle
+00000330: 272c 2027 6265 7461 272c 0a20 2027 6578  ', 'beta',.  'ex
+00000340: 706f 6e65 6e74 6961 6c27 2c20 2767 616d  ponential', 'gam
+00000350: 6d61 272c 2027 6775 6d62 656c 272c 2027  ma', 'gumbel', '
+00000360: 6c61 706c 6163 6527 2c20 276c 6f67 6973  laplace', 'logis
+00000370: 7469 6327 2c20 276e 6f72 6d61 6c27 2c20  tic', 'normal', 
+00000380: 2770 6172 6574 6f27 2c0a 2020 2770 6f69  'pareto',.  'poi
+00000390: 7373 6f6e 272c 2027 7374 616e 6461 7264  sson', 'standard
+000003a0: 5f63 6175 6368 7927 2c20 2773 7461 6e64  _cauchy', 'stand
+000003b0: 6172 645f 6578 706f 6e65 6e74 6961 6c27  ard_exponential'
+000003c0: 2c20 2773 7461 6e64 6172 645f 6761 6d6d  , 'standard_gamm
+000003d0: 6127 2c0a 2020 2773 7461 6e64 6172 645f  a',.  'standard_
+000003e0: 6e6f 726d 616c 272c 2027 7374 616e 6461  normal', 'standa
+000003f0: 7264 5f74 272c 2027 756e 6966 6f72 6d27  rd_t', 'uniform'
+00000400: 2c20 2774 7275 6e63 6174 6564 5f6e 6f72  , 'truncated_nor
+00000410: 6d61 6c27 2c20 2762 6572 6e6f 756c 6c69  mal', 'bernoulli
+00000420: 272c 0a20 2027 6c6f 676e 6f72 6d61 6c27  ',.  'lognormal'
+00000430: 2c20 2762 696e 6f6d 6961 6c27 2c20 2763  , 'binomial', 'c
+00000440: 6869 7371 7561 7265 272c 2027 6469 7269  hisquare', 'diri
+00000450: 6368 6c65 7427 2c20 2767 656f 6d65 7472  chlet', 'geometr
+00000460: 6963 272c 2027 6627 2c0a 2020 2768 7970  ic', 'f',.  'hyp
+00000470: 6572 6765 6f6d 6574 7269 6327 2c20 276c  ergeometric', 'l
+00000480: 6f67 7365 7269 6573 272c 2027 6d75 6c74  ogseries', 'mult
+00000490: 696e 6f6d 6961 6c27 2c20 276d 756c 7469  inomial', 'multi
+000004a0: 7661 7269 6174 655f 6e6f 726d 616c 272c  variate_normal',
+000004b0: 0a20 2027 6e65 6761 7469 7665 5f62 696e  .  'negative_bin
+000004c0: 6f6d 6961 6c27 2c20 276e 6f6e 6365 6e74  omial', 'noncent
+000004d0: 7261 6c5f 6368 6973 7175 6172 6527 2c20  ral_chisquare', 
+000004e0: 276e 6f6e 6365 6e74 7261 6c5f 6627 2c20  'noncentral_f', 
+000004f0: 2770 6f77 6572 272c 0a20 2027 7261 796c  'power',.  'rayl
+00000500: 6569 6768 272c 2027 7472 6961 6e67 756c  eigh', 'triangul
+00000510: 6172 272c 2027 766f 6e6d 6973 6573 272c  ar', 'vonmises',
+00000520: 2027 7761 6c64 272c 2027 7765 6962 756c   'wald', 'weibul
+00000530: 6c27 2c20 2777 6569 6275 6c6c 5f6d 696e  l', 'weibull_min
+00000540: 272c 0a20 2027 7a69 7066 272c 2027 6d61  ',.  'zipf', 'ma
+00000550: 7877 656c 6c27 2c20 2774 272c 2027 6f72  xwell', 't', 'or
+00000560: 7468 6f67 6f6e 616c 272c 2027 6c6f 6767  thogonal', 'logg
+00000570: 616d 6d61 272c 2027 6361 7465 676f 7269  amma', 'categori
+00000580: 6361 6c27 2c0a 0a20 2023 2070 7974 6f72  cal',..  # pytor
+00000590: 6368 2063 6f6d 7061 7469 6269 6c69 7479  ch compatibility
+000005a0: 0a20 2027 7261 6e64 5f6c 696b 6527 2c20  .  'rand_like', 
+000005b0: 2772 616e 6469 6e74 5f6c 696b 6527 2c20  'randint_like', 
+000005c0: 2772 616e 646e 5f6c 696b 6527 2c0a 5d0a  'randn_like',.].
+000005d0: 0a0a 6465 6620 5f66 6f72 6d61 6c69 7a65  ..def _formalize
+000005e0: 5f6b 6579 286b 6579 293a 0a20 2069 6620  _key(key):.  if 
+000005f0: 6973 696e 7374 616e 6365 286b 6579 2c20  isinstance(key, 
+00000600: 696e 7429 3a0a 2020 2020 7265 7475 726e  int):.    return
+00000610: 206a 722e 5052 4e47 4b65 7928 6b65 7929   jr.PRNGKey(key)
+00000620: 0a20 2065 6c69 6620 6973 696e 7374 616e  .  elif isinstan
+00000630: 6365 286b 6579 2c20 2841 7272 6179 2c20  ce(key, (Array, 
+00000640: 6a6e 702e 6e64 6172 7261 792c 206e 702e  jnp.ndarray, np.
+00000650: 6e64 6172 7261 7929 293a 0a20 2020 2069  ndarray)):.    i
+00000660: 6620 6b65 792e 6474 7970 6520 213d 206a  f key.dtype != j
+00000670: 6e70 2e75 696e 7433 323a 0a20 2020 2020  np.uint32:.     
+00000680: 2072 6169 7365 2054 7970 6545 7272 6f72   raise TypeError
+00000690: 2827 6b65 7920 6d75 7374 2062 6520 6120  ('key must be a 
+000006a0: 696e 7420 6f72 2061 6e20 6172 7261 7920  int or an array 
+000006b0: 7769 7468 2074 776f 2075 696e 7433 322e  with two uint32.
+000006c0: 2729 0a20 2020 2069 6620 6b65 792e 7369  ').    if key.si
+000006d0: 7a65 2021 3d20 323a 0a20 2020 2020 2072  ze != 2:.      r
+000006e0: 6169 7365 2054 7970 6545 7272 6f72 2827  aise TypeError('
+000006f0: 6b65 7920 6d75 7374 2062 6520 6120 696e  key must be a in
+00000700: 7420 6f72 2061 6e20 6172 7261 7920 7769  t or an array wi
+00000710: 7468 2074 776f 2075 696e 7433 322e 2729  th two uint32.')
+00000720: 0a20 2020 2072 6574 7572 6e20 6a6e 702e  .    return jnp.
+00000730: 6173 6172 7261 7928 6b65 7929 0a20 2065  asarray(key).  e
+00000740: 6c73 653a 0a20 2020 2072 6169 7365 2054  lse:.    raise T
+00000750: 7970 6545 7272 6f72 2827 6b65 7920 6d75  ypeError('key mu
+00000760: 7374 2062 6520 6120 696e 7420 6f72 2061  st be a int or a
+00000770: 6e20 6172 7261 7920 7769 7468 2074 776f  n array with two
+00000780: 2075 696e 7433 322e 2729 0a0a 0a64 6566   uint32.')...def
+00000790: 205f 7369 7a65 3273 6861 7065 2873 697a   _size2shape(siz
+000007a0: 6529 3a0a 2020 6966 2073 697a 6520 6973  e):.  if size is
+000007b0: 204e 6f6e 653a 0a20 2020 2072 6574 7572   None:.    retur
+000007c0: 6e20 2829 0a20 2065 6c69 6620 6973 696e  n ().  elif isin
+000007d0: 7374 616e 6365 2873 697a 652c 2069 6e74  stance(size, int
+000007e0: 293a 0a20 2020 2072 6574 7572 6e20 2873  ):.    return (s
+000007f0: 697a 652c 290a 2020 656c 6966 2069 7369  ize,).  elif isi
+00000800: 6e73 7461 6e63 6528 7369 7a65 2c20 2874  nstance(size, (t
+00000810: 7570 6c65 2c20 6c69 7374 2929 3a0a 2020  uple, list)):.  
+00000820: 2020 7265 7475 726e 2074 7570 6c65 2873    return tuple(s
+00000830: 697a 6529 0a20 2065 6c73 653a 0a20 2020  ize).  else:.   
+00000840: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
+00000850: 7228 6627 4d75 7374 2062 6520 6120 6c69  r(f'Must be a li
+00000860: 7374 2f74 7570 6c65 206f 6620 696e 742c  st/tuple of int,
+00000870: 2062 7574 2067 6f74 207b 7369 7a65 7d27   but got {size}'
+00000880: 290a 0a0a 6465 6620 5f63 6865 636b 5f73  )...def _check_s
+00000890: 6861 7065 286e 616d 652c 2073 6861 7065  hape(name, shape
+000008a0: 2c20 2a70 6172 616d 5f73 6861 7065 7329  , *param_shapes)
+000008b0: 3a0a 2020 7368 6170 6520 3d20 636f 7265  :.  shape = core
+000008c0: 2e61 735f 6e61 6d65 645f 7368 6170 6528  .as_named_shape(
+000008d0: 7368 6170 6529 0a20 2069 6620 7061 7261  shape).  if para
+000008e0: 6d5f 7368 6170 6573 3a0a 2020 2020 7368  m_shapes:.    sh
+000008f0: 6170 655f 203d 206c 6178 2e62 726f 6164  ape_ = lax.broad
+00000900: 6361 7374 5f73 6861 7065 7328 7368 6170  cast_shapes(shap
+00000910: 652e 706f 7369 7469 6f6e 616c 2c20 2a70  e.positional, *p
+00000920: 6172 616d 5f73 6861 7065 7329 0a20 2020  aram_shapes).   
+00000930: 2069 6620 7368 6170 652e 706f 7369 7469   if shape.positi
+00000940: 6f6e 616c 2021 3d20 7368 6170 655f 3a0a  onal != shape_:.
+00000950: 2020 2020 2020 6d73 6720 3d20 2822 7b7d        msg = ("{}
+00000960: 2070 6172 616d 6574 6572 2073 6861 7065   parameter shape
+00000970: 7320 6d75 7374 2062 6520 6272 6f61 6463  s must be broadc
+00000980: 6173 742d 636f 6d70 6174 6962 6c65 2077  ast-compatible w
+00000990: 6974 6820 7368 6170 6520 220a 2020 2020  ith shape ".    
+000009a0: 2020 2020 2020 2020 2022 6172 6775 6d65           "argume
+000009b0: 6e74 2c20 616e 6420 7468 6520 7265 7375  nt, and the resu
+000009c0: 6c74 206f 6620 6272 6f61 6463 6173 7469  lt of broadcasti
+000009d0: 6e67 2074 6865 2073 6861 7065 7320 6d75  ng the shapes mu
+000009e0: 7374 2065 7175 616c 2022 0a20 2020 2020  st equal ".     
+000009f0: 2020 2020 2020 2020 2274 6865 2073 6861          "the sha
+00000a00: 7065 2061 7267 756d 656e 742c 2062 7574  pe argument, but
+00000a10: 2067 6f74 2072 6573 756c 7420 7b7d 2066   got result {} f
+00000a20: 6f72 2073 6861 7065 2061 7267 756d 656e  or shape argumen
+00000a30: 7420 7b7d 2e22 290a 2020 2020 2020 7261  t {}.").      ra
+00000a40: 6973 6520 5661 6c75 6545 7272 6f72 286d  ise ValueError(m
+00000a50: 7367 2e66 6f72 6d61 7428 6e61 6d65 2c20  sg.format(name, 
+00000a60: 7368 6170 655f 2c20 7368 6170 6529 290a  shape_, shape)).
+00000a70: 0a0a 6465 6620 5f61 735f 6a61 785f 6172  ..def _as_jax_ar
+00000a80: 7261 7928 6129 3a0a 2020 7265 7475 726e  ray(a):.  return
+00000a90: 2061 2e76 616c 7565 2069 6620 6973 696e   a.value if isin
+00000aa0: 7374 616e 6365 2861 2c20 4172 7261 7929  stance(a, Array)
+00000ab0: 2065 6c73 6520 610a 0a0a 6465 6620 5f69   else a...def _i
+00000ac0: 735f 7079 7468 6f6e 5f73 6361 6c61 7228  s_python_scalar(
+00000ad0: 7829 3a0a 2020 6966 2068 6173 6174 7472  x):.  if hasattr
+00000ae0: 2878 2c20 2761 7661 6c27 293a 0a20 2020  (x, 'aval'):.   
+00000af0: 2072 6574 7572 6e20 782e 6176 616c 2e77   return x.aval.w
+00000b00: 6561 6b5f 7479 7065 0a20 2065 6c69 6620  eak_type.  elif 
+00000b10: 6e70 2e6e 6469 6d28 7829 203d 3d20 303a  np.ndim(x) == 0:
+00000b20: 0a20 2020 2072 6574 7572 6e20 5472 7565  .    return True
+00000b30: 0a20 2065 6c69 6620 6973 696e 7374 616e  .  elif isinstan
+00000b40: 6365 2878 2c20 2862 6f6f 6c2c 2069 6e74  ce(x, (bool, int
+00000b50: 2c20 666c 6f61 742c 2063 6f6d 706c 6578  , float, complex
+00000b60: 2929 3a0a 2020 2020 7265 7475 726e 2054  )):.    return T
+00000b70: 7275 650a 2020 656c 7365 3a0a 2020 2020  rue.  else:.    
+00000b80: 7265 7475 726e 2046 616c 7365 0a0a 0a70  return False...p
+00000b90: 7974 686f 6e5f 7363 616c 6172 5f64 7479  ython_scalar_dty
+00000ba0: 7065 7320 3d20 7b0a 2020 626f 6f6c 3a20  pes = {.  bool: 
+00000bb0: 6e70 2e64 7479 7065 2827 626f 6f6c 2729  np.dtype('bool')
+00000bc0: 2c0a 2020 696e 743a 206e 702e 6474 7970  ,.  int: np.dtyp
+00000bd0: 6528 2769 6e74 3634 2729 2c0a 2020 666c  e('int64'),.  fl
+00000be0: 6f61 743a 206e 702e 6474 7970 6528 2766  oat: np.dtype('f
+00000bf0: 6c6f 6174 3634 2729 2c0a 2020 636f 6d70  loat64'),.  comp
+00000c00: 6c65 783a 206e 702e 6474 7970 6528 2763  lex: np.dtype('c
+00000c10: 6f6d 706c 6578 3132 3827 292c 0a7d 0a0a  omplex128'),.}..
+00000c20: 0a64 6566 205f 6474 7970 6528 782c 202a  .def _dtype(x, *
+00000c30: 2c20 6361 6e6f 6e69 6361 6c69 7a65 3a20  , canonicalize: 
+00000c40: 626f 6f6c 203d 2046 616c 7365 293a 0a20  bool = False):. 
+00000c50: 2022 2222 5265 7475 726e 2074 6865 2064   """Return the d
+00000c60: 7479 7065 206f 626a 6563 7420 666f 7220  type object for 
+00000c70: 6120 7661 6c75 6520 6f72 2074 7970 652c  a value or type,
+00000c80: 206f 7074 696f 6e61 6c6c 7920 6361 6e6f   optionally cano
+00000c90: 6e69 6361 6c69 7a65 6420 6261 7365 6420  nicalized based 
+00000ca0: 6f6e 2058 3634 206d 6f64 652e 2222 220a  on X64 mode.""".
+00000cb0: 2020 6966 2078 2069 7320 4e6f 6e65 3a0a    if x is None:.
+00000cc0: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
+00000cd0: 7272 6f72 2866 2249 6e76 616c 6964 2061  rror(f"Invalid a
+00000ce0: 7267 756d 656e 7420 746f 2064 7479 7065  rgument to dtype
+00000cf0: 3a20 7b78 7d2e 2229 0a20 2065 6c69 6620  : {x}.").  elif 
+00000d00: 6973 696e 7374 616e 6365 2878 2c20 7479  isinstance(x, ty
+00000d10: 7065 2920 616e 6420 7820 696e 2070 7974  pe) and x in pyt
+00000d20: 686f 6e5f 7363 616c 6172 5f64 7479 7065  hon_scalar_dtype
+00000d30: 733a 0a20 2020 2064 7420 3d20 7079 7468  s:.    dt = pyth
+00000d40: 6f6e 5f73 6361 6c61 725f 6474 7970 6573  on_scalar_dtypes
+00000d50: 5b78 5d0a 2020 656c 6966 2074 7970 6528  [x].  elif type(
+00000d60: 7829 2069 6e20 7079 7468 6f6e 5f73 6361  x) in python_sca
+00000d70: 6c61 725f 6474 7970 6573 3a0a 2020 2020  lar_dtypes:.    
+00000d80: 6474 203d 2070 7974 686f 6e5f 7363 616c  dt = python_scal
+00000d90: 6172 5f64 7479 7065 735b 7479 7065 2878  ar_dtypes[type(x
+00000da0: 295d 0a20 2065 6c69 6620 6a61 782e 636f  )].  elif jax.co
+00000db0: 7265 2e69 735f 6f70 6171 7565 5f64 7479  re.is_opaque_dty
+00000dc0: 7065 2867 6574 6174 7472 2878 2c20 2764  pe(getattr(x, 'd
+00000dd0: 7479 7065 272c 204e 6f6e 6529 293a 0a20  type', None)):. 
+00000de0: 2020 2064 7420 3d20 782e 6474 7970 650a     dt = x.dtype.
+00000df0: 2020 656c 7365 3a0a 2020 2020 6474 203d    else:.    dt =
+00000e00: 206e 702e 7265 7375 6c74 5f74 7970 6528   np.result_type(
+00000e10: 7829 0a20 2072 6574 7572 6e20 6474 7970  x).  return dtyp
+00000e20: 6573 2e63 616e 6f6e 6963 616c 697a 655f  es.canonicalize_
+00000e30: 6474 7970 6528 6474 2920 6966 2063 616e  dtype(dt) if can
+00000e40: 6f6e 6963 616c 697a 6520 656c 7365 2064  onicalize else d
+00000e50: 740a 0a0a 6465 6620 5f63 6f6e 7374 2865  t...def _const(e
+00000e60: 7861 6d70 6c65 2c20 7661 6c29 3a0a 2020  xample, val):.  
+00000e70: 6966 205f 6973 5f70 7974 686f 6e5f 7363  if _is_python_sc
+00000e80: 616c 6172 2865 7861 6d70 6c65 293a 0a20  alar(example):. 
+00000e90: 2020 2064 7479 7065 203d 2064 7479 7065     dtype = dtype
+00000ea0: 732e 6361 6e6f 6e69 6361 6c69 7a65 5f64  s.canonicalize_d
+00000eb0: 7479 7065 2874 7970 6528 6578 616d 706c  type(type(exampl
+00000ec0: 6529 290a 2020 2020 7661 6c20 3d20 6474  e)).    val = dt
+00000ed0: 7970 6573 2e73 6361 6c61 725f 7479 7065  ypes.scalar_type
+00000ee0: 5f6f 6628 6578 616d 706c 6529 2876 616c  _of(example)(val
+00000ef0: 290a 2020 2020 7265 7475 726e 2076 616c  ).    return val
+00000f00: 2069 6620 6474 7970 6520 3d3d 205f 6474   if dtype == _dt
+00000f10: 7970 6528 7661 6c2c 2063 616e 6f6e 6963  ype(val, canonic
+00000f20: 616c 697a 653d 5472 7565 2920 656c 7365  alize=True) else
+00000f30: 206e 702e 6172 7261 7928 7661 6c2c 2064   np.array(val, d
+00000f40: 7479 7065 290a 2020 656c 7365 3a0a 2020  type).  else:.  
+00000f50: 2020 6474 7970 6520 3d20 6474 7970 6573    dtype = dtypes
+00000f60: 2e63 616e 6f6e 6963 616c 697a 655f 6474  .canonicalize_dt
+00000f70: 7970 6528 6578 616d 706c 652e 6474 7970  ype(example.dtyp
+00000f80: 6529 0a20 2072 6574 7572 6e20 6e70 2e61  e).  return np.a
+00000f90: 7272 6179 2876 616c 2c20 6474 7970 6529  rray(val, dtype)
+00000fa0: 0a0a 0a5f 7472 5f70 6172 616d 7320 3d20  ..._tr_params = 
+00000fb0: 6e61 6d65 6474 7570 6c65 280a 2020 2274  namedtuple(.  "t
+00000fc0: 725f 7061 7261 6d73 222c 205b 2263 222c  r_params", ["c",
+00000fd0: 2022 6222 2c20 2261 222c 2022 616c 7068   "b", "a", "alph
+00000fe0: 6122 2c20 2275 5f72 222c 2022 765f 7222  a", "u_r", "v_r"
+00000ff0: 2c20 226d 222c 2022 6c6f 675f 7022 2c20  , "m", "log_p", 
+00001000: 226c 6f67 315f 7022 2c20 226c 6f67 5f68  "log1_p", "log_h
+00001010: 225d 0a29 0a0a 0a64 6566 205f 6765 745f  "].)...def _get_
+00001020: 7472 5f70 6172 616d 7328 6e2c 2070 293a  tr_params(n, p):
+00001030: 0a20 2023 2053 6565 2054 6162 6c65 2031  .  # See Table 1
+00001040: 2e20 4164 6469 7469 6f6e 616c 6c79 2c20  . Additionally, 
+00001050: 7765 2070 7265 2d63 6f6d 7075 7465 206c  we pre-compute l
+00001060: 6f67 2870 292c 206c 6f67 3128 2d70 2920  og(p), log1(-p) 
+00001070: 616e 6420 7468 650a 2020 2320 636f 6e73  and the.  # cons
+00001080: 7461 6e74 2074 6572 6d73 2c20 7468 6174  tant terms, that
+00001090: 2064 6570 656e 6420 6f6e 6c79 206f 6e20   depend only on 
+000010a0: 286e 2c20 702c 206d 2920 696e 206c 6f67  (n, p, m) in log
+000010b0: 2866 286b 2929 2028 626f 7474 6f6d 206f  (f(k)) (bottom o
+000010c0: 6620 7061 6765 2035 292e 0a20 206d 7520  f page 5)..  mu 
+000010d0: 3d20 6e20 2a20 700a 2020 7370 7120 3d20  = n * p.  spq = 
+000010e0: 6a6e 702e 7371 7274 286d 7520 2a20 2831  jnp.sqrt(mu * (1
+000010f0: 202d 2070 2929 0a20 2063 203d 206d 7520   - p)).  c = mu 
+00001100: 2b20 302e 350a 2020 6220 3d20 312e 3135  + 0.5.  b = 1.15
+00001110: 202b 2032 2e35 3320 2a20 7370 710a 2020   + 2.53 * spq.  
+00001120: 6120 3d20 2d30 2e30 3837 3320 2b20 302e  a = -0.0873 + 0.
+00001130: 3032 3438 202a 2062 202b 2030 2e30 3120  0248 * b + 0.01 
+00001140: 2a20 700a 2020 616c 7068 6120 3d20 2832  * p.  alpha = (2
+00001150: 2e38 3320 2b20 352e 3120 2f20 6229 202a  .83 + 5.1 / b) *
+00001160: 2073 7071 0a20 2075 5f72 203d 2030 2e34   spq.  u_r = 0.4
+00001170: 330a 2020 765f 7220 3d20 302e 3932 202d  3.  v_r = 0.92 -
+00001180: 2034 2e32 202f 2062 0a20 206d 203d 206a   4.2 / b.  m = j
+00001190: 6e70 2e66 6c6f 6f72 2828 6e20 2b20 3129  np.floor((n + 1)
+000011a0: 202a 2070 292e 6173 7479 7065 286e 2e64   * p).astype(n.d
+000011b0: 7479 7065 290a 2020 6c6f 675f 7020 3d20  type).  log_p = 
+000011c0: 6a6e 702e 6c6f 6728 7029 0a20 206c 6f67  jnp.log(p).  log
+000011d0: 315f 7020 3d20 6a6e 702e 6c6f 6731 7028  1_p = jnp.log1p(
+000011e0: 2d70 290a 2020 6c6f 675f 6820 3d20 2828  -p).  log_h = ((
+000011f0: 6d20 2b20 302e 3529 202a 2028 6a6e 702e  m + 0.5) * (jnp.
+00001200: 6c6f 6728 286d 202b 2031 2e30 2920 2f20  log((m + 1.0) / 
+00001210: 286e 202d 206d 202b 2031 2e30 2929 202b  (n - m + 1.0)) +
+00001220: 206c 6f67 315f 7020 2d20 6c6f 675f 7029   log1_p - log_p)
+00001230: 202b 0a20 2020 2020 2020 2020 2020 5f73   +.           _s
+00001240: 7469 726c 696e 675f 6170 7072 6f78 5f74  tirling_approx_t
+00001250: 6169 6c28 6d29 202b 205f 7374 6972 6c69  ail(m) + _stirli
+00001260: 6e67 5f61 7070 726f 785f 7461 696c 286e  ng_approx_tail(n
+00001270: 202d 206d 2929 0a20 2072 6574 7572 6e20   - m)).  return 
+00001280: 5f74 725f 7061 7261 6d73 2863 2c20 622c  _tr_params(c, b,
+00001290: 2061 2c20 616c 7068 612c 2075 5f72 2c20   a, alpha, u_r, 
+000012a0: 765f 722c 206d 2c20 6c6f 675f 702c 206c  v_r, m, log_p, l
+000012b0: 6f67 315f 702c 206c 6f67 5f68 290a 0a0a  og1_p, log_h)...
+000012c0: 6465 6620 5f73 7469 726c 696e 675f 6170  def _stirling_ap
+000012d0: 7072 6f78 5f74 6169 6c28 6b29 3a0a 2020  prox_tail(k):.  
+000012e0: 7072 6563 6f6d 7075 7465 6420 3d20 6a6e  precomputed = jn
+000012f0: 702e 6172 7261 7928 5b30 2e30 3831 3036  p.array([0.08106
+00001300: 3134 3636 3739 3533 3237 3236 2c0a 2020  146679532726,.  
+00001310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001320: 2020 2020 2020 2020 2030 2e30 3431 3334           0.04134
+00001330: 3036 3935 3935 3534 3039 3239 2c0a 2020  069595540929,.  
+00001340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001350: 2020 2020 2020 2020 2030 2e30 3237 3637           0.02767
+00001360: 3739 3235 3638 3439 3938 3334 2c0a 2020  792568499834,.  
+00001370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001380: 2020 2020 2020 2020 2030 2e30 3230 3739           0.02079
+00001390: 3036 3732 3130 3337 3635 3039 2c0a 2020  067210376509,.  
+000013a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000013b0: 2020 2020 2020 2020 2030 2e30 3136 3634           0.01664
+000013c0: 3436 3931 3138 3938 3231 3139 2c0a 2020  469118982119,.  
+000013d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000013e0: 2020 2020 2020 2020 2030 2e30 3133 3837           0.01387
+000013f0: 3631 3238 3832 3330 3730 3735 2c0a 2020  612882307075,.  
+00001400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001410: 2020 2020 2020 2020 2030 2e30 3131 3839           0.01189
+00001420: 3637 3039 3934 3538 3931 3737 2c0a 2020  670994589177,.  
+00001430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001440: 2020 2020 2020 2020 2030 2e30 3130 3431           0.01041
+00001450: 3132 3635 3236 3139 3732 3039 2c0a 2020  126526197209,.  
+00001460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001470: 2020 2020 2020 2020 2030 2e30 3039 3235           0.00925
+00001480: 3534 3632 3138 3237 3132 3733 332c 0a20  5462182712733,. 
+00001490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000014a0: 2020 2020 2020 2020 2020 302e 3030 3833            0.0083
+000014b0: 3330 3536 3334 3333 3336 3238 3731 2c20  30563433362871, 
+000014c0: 5d29 0a20 206b 7031 203d 206b 202b 2031  ]).  kp1 = k + 1
+000014d0: 0a20 206b 7031 7371 203d 2028 6b20 2b20  .  kp1sq = (k + 
+000014e0: 3129 202a 2a20 320a 2020 7265 7475 726e  1) ** 2.  return
+000014f0: 206a 6e70 2e77 6865 7265 286b 203c 2031   jnp.where(k < 1
+00001500: 302c 0a20 2020 2020 2020 2020 2020 2020  0,.             
+00001510: 2020 2020 2020 7072 6563 6f6d 7075 7465        precompute
+00001520: 645b 6b5d 2c0a 2020 2020 2020 2020 2020  d[k],.          
+00001530: 2020 2020 2020 2020 2028 312e 3020 2f20           (1.0 / 
+00001540: 3132 202d 2028 312e 3020 2f20 3336 3020  12 - (1.0 / 360 
+00001550: 2d20 2831 2e30 202f 2031 3236 3029 202f  - (1.0 / 1260) /
+00001560: 206b 7031 7371 2920 2f20 6b70 3173 7129   kp1sq) / kp1sq)
+00001570: 202f 206b 7031 290a 0a0a 6465 6620 5f62   / kp1)...def _b
+00001580: 696e 6f6d 6961 6c5f 6274 7273 286b 6579  inomial_btrs(key
+00001590: 2c20 702c 206e 293a 0a20 2022 2222 0a20  , p, n):.  """. 
+000015a0: 2042 6173 6564 206f 6e20 7468 6520 7472   Based on the tr
+000015b0: 616e 7366 6f72 6d65 6420 7265 6a65 6374  ansformed reject
+000015c0: 696f 6e20 7361 6d70 6c69 6e67 2061 6c67  ion sampling alg
+000015d0: 6f72 6974 686d 2028 4254 5253 2920 6672  orithm (BTRS) fr
+000015e0: 6f6d 2074 6865 0a20 2066 6f6c 6c6f 7769  om the.  followi
+000015f0: 6e67 2072 6566 6572 656e 6365 3a0a 0a20  ng reference:.. 
+00001600: 2048 6f72 6d61 6e6e 2c20 2254 6865 2047   Hormann, "The G
+00001610: 656e 6572 6174 696f 6e20 6f66 2042 696e  eneration of Bin
+00001620: 6f6e 6d69 616c 2052 616e 646f 6d20 5661  onmial Random Va
+00001630: 7269 6174 6573 220a 2020 2868 7474 7073  riates".  (https
+00001640: 3a2f 2f63 6f72 652e 6163 2e75 6b2f 646f  ://core.ac.uk/do
+00001650: 776e 6c6f 6164 2f70 6466 2f31 3130 3037  wnload/pdf/11007
+00001660: 3235 342e 7064 6629 0a20 2022 2222 0a0a  254.pdf).  """..
+00001670: 2020 6465 6620 5f62 7472 735f 626f 6479    def _btrs_body
+00001680: 5f66 6e28 7661 6c29 3a0a 2020 2020 5f2c  _fn(val):.    _,
+00001690: 206b 6579 2c20 5f2c 205f 203d 2076 616c   key, _, _ = val
+000016a0: 0a20 2020 206b 6579 2c20 6b65 795f 752c  .    key, key_u,
+000016b0: 206b 6579 5f76 203d 206a 722e 7370 6c69   key_v = jr.spli
+000016c0: 7428 6b65 792c 2033 290a 2020 2020 7520  t(key, 3).    u 
+000016d0: 3d20 6a72 2e75 6e69 666f 726d 286b 6579  = jr.uniform(key
+000016e0: 5f75 290a 2020 2020 7620 3d20 6a72 2e75  _u).    v = jr.u
+000016f0: 6e69 666f 726d 286b 6579 5f76 290a 2020  niform(key_v).  
+00001700: 2020 7520 3d20 7520 2d20 302e 350a 2020    u = u - 0.5.  
+00001710: 2020 6b20 3d20 6a6e 702e 666c 6f6f 7228    k = jnp.floor(
+00001720: 0a20 2020 2020 2028 3220 2a20 7472 5f70  .      (2 * tr_p
+00001730: 6172 616d 732e 6120 2f20 2830 2e35 202d  arams.a / (0.5 -
+00001740: 206a 6e70 2e61 6273 2875 2929 202b 2074   jnp.abs(u)) + t
+00001750: 725f 7061 7261 6d73 2e62 2920 2a20 7520  r_params.b) * u 
+00001760: 2b20 7472 5f70 6172 616d 732e 630a 2020  + tr_params.c.  
+00001770: 2020 292e 6173 7479 7065 286e 2e64 7479    ).astype(n.dty
+00001780: 7065 290a 2020 2020 7265 7475 726e 206b  pe).    return k
+00001790: 2c20 6b65 792c 2075 2c20 760a 0a20 2064  , key, u, v..  d
+000017a0: 6566 205f 6274 7273 5f63 6f6e 645f 666e  ef _btrs_cond_fn
+000017b0: 2876 616c 293a 0a20 2020 2064 6566 2061  (val):.    def a
+000017c0: 6363 6570 745f 666e 286b 2c20 752c 2076  ccept_fn(k, u, v
+000017d0: 293a 0a20 2020 2020 2023 2053 6565 2061  ):.      # See a
+000017e0: 6363 6570 7461 6e63 6520 636f 6e64 6974  cceptance condit
+000017f0: 696f 6e20 696e 2053 7465 7020 332e 2028  ion in Step 3. (
+00001800: 5061 6765 2033 2920 6f66 2054 5253 2061  Page 3) of TRS a
+00001810: 6c67 6f72 6974 686d 0a20 2020 2020 2023  lgorithm.      #
+00001820: 2076 203c 3d20 6628 6b29 202a 2067 5f67   v <= f(k) * g_g
+00001830: 7261 6428 7529 202f 2061 6c70 6861 0a0a  rad(u) / alpha..
+00001840: 2020 2020 2020 6d20 3d20 7472 5f70 6172        m = tr_par
+00001850: 616d 732e 6d0a 2020 2020 2020 6c6f 675f  ams.m.      log_
+00001860: 7020 3d20 7472 5f70 6172 616d 732e 6c6f  p = tr_params.lo
+00001870: 675f 700a 2020 2020 2020 6c6f 6731 5f70  g_p.      log1_p
+00001880: 203d 2074 725f 7061 7261 6d73 2e6c 6f67   = tr_params.log
+00001890: 315f 700a 2020 2020 2020 2320 5365 653a  1_p.      # See:
+000018a0: 2066 6f72 6d75 6c61 2066 6f72 206c 6f67   formula for log
+000018b0: 2866 286b 2929 2061 7420 626f 7474 6f6d  (f(k)) at bottom
+000018c0: 206f 6620 5061 6765 2035 2e0a 2020 2020   of Page 5..    
+000018d0: 2020 6c6f 675f 6620 3d20 280a 2020 2020    log_f = (.    
+000018e0: 2020 2020 2020 286e 202b 2031 2e30 2920        (n + 1.0) 
+000018f0: 2a20 6a6e 702e 6c6f 6728 286e 202d 206d  * jnp.log((n - m
+00001900: 202b 2031 2e30 2920 2f20 286e 202d 206b   + 1.0) / (n - k
+00001910: 202b 2031 2e30 2929 0a20 2020 2020 2020   + 1.0)).       
+00001920: 2020 202b 2028 6b20 2b20 302e 3529 202a     + (k + 0.5) *
+00001930: 2028 6a6e 702e 6c6f 6728 286e 202d 206b   (jnp.log((n - k
+00001940: 202b 2031 2e30 2920 2f20 286b 202b 2031   + 1.0) / (k + 1
+00001950: 2e30 2929 202b 206c 6f67 5f70 202d 206c  .0)) + log_p - l
+00001960: 6f67 315f 7029 0a20 2020 2020 2020 2020  og1_p).         
+00001970: 202b 2028 5f73 7469 726c 696e 675f 6170   + (_stirling_ap
+00001980: 7072 6f78 5f74 6169 6c28 6b29 202d 205f  prox_tail(k) - _
+00001990: 7374 6972 6c69 6e67 5f61 7070 726f 785f  stirling_approx_
+000019a0: 7461 696c 286e 202d 206b 2929 0a20 2020  tail(n - k)).   
+000019b0: 2020 2020 2020 202b 2074 725f 7061 7261         + tr_para
+000019c0: 6d73 2e6c 6f67 5f68 0a20 2020 2020 2029  ms.log_h.      )
+000019d0: 0a20 2020 2020 2067 203d 2028 7472 5f70  .      g = (tr_p
+000019e0: 6172 616d 732e 6120 2f20 2830 2e35 202d  arams.a / (0.5 -
+000019f0: 206a 6e70 2e61 6273 2875 2929 202a 2a20   jnp.abs(u)) ** 
+00001a00: 3229 202b 2074 725f 7061 7261 6d73 2e62  2) + tr_params.b
+00001a10: 0a20 2020 2020 2072 6574 7572 6e20 6a6e  .      return jn
+00001a20: 702e 6c6f 6728 2876 202a 2074 725f 7061  p.log((v * tr_pa
+00001a30: 7261 6d73 2e61 6c70 6861 2920 2f20 6729  rams.alpha) / g)
+00001a40: 203c 3d20 6c6f 675f 660a 0a20 2020 206b   <= log_f..    k
+00001a50: 2c20 6b65 792c 2075 2c20 7620 3d20 7661  , key, u, v = va
+00001a60: 6c0a 2020 2020 6561 726c 795f 6163 6365  l.    early_acce
+00001a70: 7074 203d 2028 6a6e 702e 6162 7328 7529  pt = (jnp.abs(u)
+00001a80: 203c 3d20 7472 5f70 6172 616d 732e 755f   <= tr_params.u_
+00001a90: 7229 2026 2028 7620 3c3d 2074 725f 7061  r) & (v <= tr_pa
+00001aa0: 7261 6d73 2e76 5f72 290a 2020 2020 6561  rams.v_r).    ea
+00001ab0: 726c 795f 7265 6a65 6374 203d 2028 6b20  rly_reject = (k 
+00001ac0: 3c20 3029 207c 2028 6b20 3e20 6e29 0a20  < 0) | (k > n). 
+00001ad0: 2020 2072 6574 7572 6e20 6c61 782e 636f     return lax.co
+00001ae0: 6e64 280a 2020 2020 2020 6561 726c 795f  nd(.      early_
+00001af0: 6163 6365 7074 207c 2065 6172 6c79 5f72  accept | early_r
+00001b00: 656a 6563 742c 0a20 2020 2020 2028 292c  eject,.      (),
+00001b10: 0a20 2020 2020 206c 616d 6264 6120 5f3a  .      lambda _:
+00001b20: 207e 6561 726c 795f 6163 6365 7074 2c0a   ~early_accept,.
+00001b30: 2020 2020 2020 286b 2c20 752c 2076 292c        (k, u, v),
+00001b40: 0a20 2020 2020 206c 616d 6264 6120 783a  .      lambda x:
+00001b50: 207e 6163 6365 7074 5f66 6e28 2a78 292c   ~accept_fn(*x),
+00001b60: 0a20 2020 2029 0a0a 2020 7472 5f70 6172  .    )..  tr_par
+00001b70: 616d 7320 3d20 5f67 6574 5f74 725f 7061  ams = _get_tr_pa
+00001b80: 7261 6d73 286e 2c20 7029 0a20 2072 6574  rams(n, p).  ret
+00001b90: 203d 206c 6178 2e77 6869 6c65 5f6c 6f6f   = lax.while_loo
+00001ba0: 7028 0a20 2020 205f 6274 7273 5f63 6f6e  p(.    _btrs_con
+00001bb0: 645f 666e 2c20 5f62 7472 735f 626f 6479  d_fn, _btrs_body
+00001bc0: 5f66 6e2c 2028 2d31 2c20 6b65 792c 2031  _fn, (-1, key, 1
+00001bd0: 2e30 2c20 312e 3029 0a20 2029 2020 2320  .0, 1.0).  )  # 
+00001be0: 7573 6520 6b3d 2d31 2069 6e69 7469 616c  use k=-1 initial
+00001bf0: 6c79 2073 6f20 7468 6174 2063 6f6e 645f  ly so that cond_
+00001c00: 666e 2072 6574 7572 6e73 2054 7275 650a  fn returns True.
+00001c10: 2020 7265 7475 726e 2072 6574 5b30 5d0a    return ret[0].
+00001c20: 0a0a 6465 6620 5f62 696e 6f6d 6961 6c5f  ..def _binomial_
+00001c30: 696e 7665 7273 696f 6e28 6b65 792c 2070  inversion(key, p
+00001c40: 2c20 6e29 3a0a 2020 6465 6620 5f62 696e  , n):.  def _bin
+00001c50: 6f6d 5f69 6e76 5f62 6f64 795f 666e 2876  om_inv_body_fn(v
+00001c60: 616c 293a 0a20 2020 2069 2c20 6b65 792c  al):.    i, key,
+00001c70: 2067 656f 6d5f 6163 6320 3d20 7661 6c0a   geom_acc = val.
+00001c80: 2020 2020 6b65 792c 206b 6579 5f75 203d      key, key_u =
+00001c90: 206a 722e 7370 6c69 7428 6b65 7929 0a20   jr.split(key). 
+00001ca0: 2020 2075 203d 206a 722e 756e 6966 6f72     u = jr.unifor
+00001cb0: 6d28 6b65 795f 7529 0a20 2020 2067 656f  m(key_u).    geo
+00001cc0: 6d20 3d20 6a6e 702e 666c 6f6f 7228 6a6e  m = jnp.floor(jn
+00001cd0: 702e 6c6f 6731 7028 2d75 2920 2f20 6c6f  p.log1p(-u) / lo
+00001ce0: 6731 5f70 2920 2b20 310a 2020 2020 6765  g1_p) + 1.    ge
+00001cf0: 6f6d 5f61 6363 203d 2067 656f 6d5f 6163  om_acc = geom_ac
+00001d00: 6320 2b20 6765 6f6d 0a20 2020 2072 6574  c + geom.    ret
+00001d10: 7572 6e20 6920 2b20 312c 206b 6579 2c20  urn i + 1, key, 
+00001d20: 6765 6f6d 5f61 6363 0a0a 2020 6465 6620  geom_acc..  def 
+00001d30: 5f62 696e 6f6d 5f69 6e76 5f63 6f6e 645f  _binom_inv_cond_
+00001d40: 666e 2876 616c 293a 0a20 2020 2069 2c20  fn(val):.    i, 
+00001d50: 5f2c 2067 656f 6d5f 6163 6320 3d20 7661  _, geom_acc = va
+00001d60: 6c0a 2020 2020 7265 7475 726e 2067 656f  l.    return geo
+00001d70: 6d5f 6163 6320 3c3d 206e 0a0a 2020 6c6f  m_acc <= n..  lo
+00001d80: 6731 5f70 203d 206a 6e70 2e6c 6f67 3170  g1_p = jnp.log1p
+00001d90: 282d 7029 0a20 2072 6574 203d 206c 6178  (-p).  ret = lax
+00001da0: 2e77 6869 6c65 5f6c 6f6f 7028 5f62 696e  .while_loop(_bin
+00001db0: 6f6d 5f69 6e76 5f63 6f6e 645f 666e 2c20  om_inv_cond_fn, 
+00001dc0: 5f62 696e 6f6d 5f69 6e76 5f62 6f64 795f  _binom_inv_body_
+00001dd0: 666e 2c20 282d 312c 206b 6579 2c20 302e  fn, (-1, key, 0.
+00001de0: 3029 290a 2020 7265 7475 726e 2072 6574  0)).  return ret
+00001df0: 5b30 5d0a 0a0a 6465 6620 5f62 696e 6f6d  [0]...def _binom
+00001e00: 6961 6c5f 6469 7370 6174 6368 286b 6579  ial_dispatch(key
+00001e10: 2c20 702c 206e 293a 0a20 2064 6566 2064  , p, n):.  def d
+00001e20: 6973 7061 7463 6828 6b65 792c 2070 2c20  ispatch(key, p, 
+00001e30: 6e29 3a0a 2020 2020 6973 5f6c 655f 6d69  n):.    is_le_mi
+00001e40: 6420 3d20 7020 3c3d 2030 2e35 0a20 2020  d = p <= 0.5.   
+00001e50: 2070 7120 3d20 6a6e 702e 7768 6572 6528   pq = jnp.where(
+00001e60: 6973 5f6c 655f 6d69 642c 2070 2c20 3120  is_le_mid, p, 1 
+00001e70: 2d20 7029 0a20 2020 206d 7520 3d20 6e20  - p).    mu = n 
+00001e80: 2a20 7071 0a20 2020 206b 203d 206c 6178  * pq.    k = lax
+00001e90: 2e63 6f6e 6428 0a20 2020 2020 206d 7520  .cond(.      mu 
+00001ea0: 3c20 3130 2c0a 2020 2020 2020 286b 6579  < 10,.      (key
+00001eb0: 2c20 7071 2c20 6e29 2c0a 2020 2020 2020  , pq, n),.      
+00001ec0: 6c61 6d62 6461 2078 3a20 5f62 696e 6f6d  lambda x: _binom
+00001ed0: 6961 6c5f 696e 7665 7273 696f 6e28 2a78  ial_inversion(*x
+00001ee0: 292c 0a20 2020 2020 2028 6b65 792c 2070  ),.      (key, p
+00001ef0: 712c 206e 292c 0a20 2020 2020 206c 616d  q, n),.      lam
+00001f00: 6264 6120 783a 205f 6269 6e6f 6d69 616c  bda x: _binomial
+00001f10: 5f62 7472 7328 2a78 292c 0a20 2020 2029  _btrs(*x),.    )
+00001f20: 0a20 2020 2072 6574 7572 6e20 6a6e 702e  .    return jnp.
+00001f30: 7768 6572 6528 6973 5f6c 655f 6d69 642c  where(is_le_mid,
+00001f40: 206b 2c20 6e20 2d20 6b29 0a0a 2020 2320   k, n - k)..  # 
+00001f50: 5265 7475 726e 2030 2066 6f72 206e 616e  Return 0 for nan
+00001f60: 2060 7060 206f 7220 6e65 6761 7469 7665   `p` or negative
+00001f70: 2060 6e60 2c20 7369 6e63 6520 6e61 6e20   `n`, since nan 
+00001f80: 7661 6c75 6573 2061 7265 206e 6f74 2061  values are not a
+00001f90: 6c6c 6f77 6564 2066 6f72 2069 6e74 6567  llowed for integ
+00001fa0: 6572 2074 7970 6573 0a20 2063 6f6e 6430  er types.  cond0
+00001fb0: 203d 206a 6e70 2e69 7366 696e 6974 6528   = jnp.isfinite(
+00001fc0: 7029 2026 2028 6e20 3e20 3029 2026 2028  p) & (n > 0) & (
+00001fd0: 7020 3e20 3029 0a20 2072 6574 7572 6e20  p > 0).  return 
+00001fe0: 6c61 782e 636f 6e64 280a 2020 2020 636f  lax.cond(.    co
+00001ff0: 6e64 3020 2620 2870 203c 2031 292c 0a20  nd0 & (p < 1),. 
+00002000: 2020 2028 6b65 792c 2070 2c20 6e29 2c0a     (key, p, n),.
+00002010: 2020 2020 6c61 6d62 6461 2078 3a20 6469      lambda x: di
+00002020: 7370 6174 6368 282a 7829 2c0a 2020 2020  spatch(*x),.    
+00002030: 2829 2c0a 2020 2020 6c61 6d62 6461 205f  (),.    lambda _
+00002040: 3a20 6a6e 702e 7768 6572 6528 636f 6e64  : jnp.where(cond
+00002050: 302c 206e 2c20 3029 2c0a 2020 290a 0a0a  0, n, 0),.  )...
+00002060: 4070 6172 7469 616c 286a 6974 2c20 7374  @partial(jit, st
+00002070: 6174 6963 5f61 7267 6e75 6d73 3d28 332c  atic_argnums=(3,
+00002080: 2929 0a64 6566 205f 6269 6e6f 6d69 616c  )).def _binomial
+00002090: 286b 6579 2c20 702c 206e 2c20 7368 6170  (key, p, n, shap
+000020a0: 6529 3a0a 2020 7368 6170 6520 3d20 7368  e):.  shape = sh
+000020b0: 6170 6520 6f72 206c 6178 2e62 726f 6164  ape or lax.broad
+000020c0: 6361 7374 5f73 6861 7065 7328 6a6e 702e  cast_shapes(jnp.
+000020d0: 7368 6170 6528 7029 2c20 6a6e 702e 7368  shape(p), jnp.sh
+000020e0: 6170 6528 6e29 290a 2020 2320 7265 7368  ape(n)).  # resh
+000020f0: 6170 6520 746f 206d 6170 206f 7665 7220  ape to map over 
+00002100: 6178 6973 2030 0a20 2070 203d 206a 6e70  axis 0.  p = jnp
+00002110: 2e72 6573 6861 7065 286a 6e70 2e62 726f  .reshape(jnp.bro
+00002120: 6164 6361 7374 5f74 6f28 702c 2073 6861  adcast_to(p, sha
+00002130: 7065 292c 202d 3129 0a20 206e 203d 206a  pe), -1).  n = j
+00002140: 6e70 2e72 6573 6861 7065 286a 6e70 2e62  np.reshape(jnp.b
+00002150: 726f 6164 6361 7374 5f74 6f28 6e2c 2073  roadcast_to(n, s
+00002160: 6861 7065 292c 202d 3129 0a20 206b 6579  hape), -1).  key
+00002170: 203d 206a 722e 7370 6c69 7428 6b65 792c   = jr.split(key,
+00002180: 206a 6e70 2e73 697a 6528 7029 290a 2020   jnp.size(p)).  
+00002190: 6966 206a 6178 2e64 6566 6175 6c74 5f62  if jax.default_b
+000021a0: 6163 6b65 6e64 2829 203d 3d20 2263 7075  ackend() == "cpu
+000021b0: 223a 0a20 2020 2072 6574 203d 206c 6178  ":.    ret = lax
+000021c0: 2e6d 6170 286c 616d 6264 6120 783a 205f  .map(lambda x: _
+000021d0: 6269 6e6f 6d69 616c 5f64 6973 7061 7463  binomial_dispatc
+000021e0: 6828 2a78 292c 2028 6b65 792c 2070 2c20  h(*x), (key, p, 
+000021f0: 6e29 290a 2020 656c 7365 3a0a 2020 2020  n)).  else:.    
+00002200: 7265 7420 3d20 766d 6170 286c 616d 6264  ret = vmap(lambd
+00002210: 6120 2a78 3a20 5f62 696e 6f6d 6961 6c5f  a *x: _binomial_
+00002220: 6469 7370 6174 6368 282a 7829 2928 6b65  dispatch(*x))(ke
+00002230: 792c 2070 2c20 6e29 0a20 2072 6574 7572  y, p, n).  retur
+00002240: 6e20 6a6e 702e 7265 7368 6170 6528 7265  n jnp.reshape(re
+00002250: 742c 2073 6861 7065 290a 0a0a 4070 6172  t, shape)...@par
+00002260: 7469 616c 286a 6974 2c20 7374 6174 6963  tial(jit, static
+00002270: 5f61 7267 6e75 6d73 3d28 322c 2929 0a64  _argnums=(2,)).d
+00002280: 6566 205f 6361 7465 676f 7269 6361 6c28  ef _categorical(
+00002290: 6b65 792c 2070 2c20 7368 6170 6529 3a0a  key, p, shape):.
+000022a0: 2020 2320 7468 6973 2069 6d70 6c65 6d65    # this impleme
+000022b0: 6e74 6174 696f 6e20 6973 2066 6173 7420  ntation is fast 
+000022c0: 7768 656e 2065 7665 6e74 2073 6861 7065  when event shape
+000022d0: 2069 7320 736d 616c 6c2c 2061 6e64 2073   is small, and s
+000022e0: 6c6f 7720 6f74 6865 7277 6973 650a 2020  low otherwise.  
+000022f0: 2320 5265 663a 2068 7474 7073 3a2f 2f73  # Ref: https://s
+00002300: 7461 636b 6f76 6572 666c 6f77 2e63 6f6d  tackoverflow.com
+00002310: 2f61 2f33 3431 3930 3033 350a 2020 7368  /a/34190035.  sh
+00002320: 6170 6520 3d20 7368 6170 6520 6f72 2070  ape = shape or p
+00002330: 2e73 6861 7065 5b3a 2d31 5d0a 2020 7320  .shape[:-1].  s 
+00002340: 3d20 6a6e 702e 6375 6d73 756d 2870 2c20  = jnp.cumsum(p, 
+00002350: 6178 6973 3d2d 3129 0a20 2072 203d 206a  axis=-1).  r = j
+00002360: 722e 756e 6966 6f72 6d28 6b65 792c 2073  r.uniform(key, s
+00002370: 6861 7065 3d73 6861 7065 202b 2028 312c  hape=shape + (1,
+00002380: 2929 0a20 2072 6574 7572 6e20 6a6e 702e  )).  return jnp.
+00002390: 7375 6d28 7320 3c20 722c 2061 7869 733d  sum(s < r, axis=
+000023a0: 2d31 290a 0a0a 6465 6620 5f73 6361 7474  -1)...def _scatt
+000023b0: 6572 5f61 6464 5f6f 6e65 286f 7065 7261  er_add_one(opera
+000023c0: 6e64 2c20 696e 6469 6365 732c 2075 7064  nd, indices, upd
+000023d0: 6174 6573 293a 0a20 2072 6574 7572 6e20  ates):.  return 
+000023e0: 6c61 782e 7363 6174 7465 725f 6164 6428  lax.scatter_add(
+000023f0: 0a20 2020 206f 7065 7261 6e64 2c0a 2020  .    operand,.  
+00002400: 2020 696e 6469 6365 732c 0a20 2020 2075    indices,.    u
+00002410: 7064 6174 6573 2c0a 2020 2020 6c61 782e  pdates,.    lax.
+00002420: 5363 6174 7465 7244 696d 656e 7369 6f6e  ScatterDimension
+00002430: 4e75 6d62 6572 7328 0a20 2020 2020 2075  Numbers(.      u
+00002440: 7064 6174 655f 7769 6e64 6f77 5f64 696d  pdate_window_dim
+00002450: 733d 2829 2c0a 2020 2020 2020 696e 7365  s=(),.      inse
+00002460: 7274 6564 5f77 696e 646f 775f 6469 6d73  rted_window_dims
+00002470: 3d28 302c 292c 0a20 2020 2020 2073 6361  =(0,),.      sca
+00002480: 7474 6572 5f64 696d 735f 746f 5f6f 7065  tter_dims_to_ope
+00002490: 7261 6e64 5f64 696d 733d 2830 2c29 2c0a  rand_dims=(0,),.
+000024a0: 2020 2020 292c 0a20 2029 0a0a 0a64 6566      ),.  )...def
+000024b0: 205f 7265 7368 6170 6528 782c 2073 6861   _reshape(x, sha
+000024c0: 7065 293a 0a20 2069 6620 6973 696e 7374  pe):.  if isinst
+000024d0: 616e 6365 2878 2c20 2869 6e74 2c20 666c  ance(x, (int, fl
+000024e0: 6f61 742c 206e 702e 6e64 6172 7261 792c  oat, np.ndarray,
+000024f0: 206e 702e 6765 6e65 7269 6329 293a 0a20   np.generic)):. 
+00002500: 2020 2072 6574 7572 6e20 6e70 2e72 6573     return np.res
+00002510: 6861 7065 2878 2c20 7368 6170 6529 0a20  hape(x, shape). 
+00002520: 2065 6c73 653a 0a20 2020 2072 6574 7572   else:.    retur
+00002530: 6e20 6a6e 702e 7265 7368 6170 6528 782c  n jnp.reshape(x,
+00002540: 2073 6861 7065 290a 0a0a 6465 6620 5f70   shape)...def _p
+00002550: 726f 6d6f 7465 5f73 6861 7065 7328 2a61  romote_shapes(*a
+00002560: 7267 732c 2073 6861 7065 3d28 2929 3a0a  rgs, shape=()):.
+00002570: 2020 2320 6164 6170 7465 6420 6672 6f6d    # adapted from
+00002580: 206c 6178 2e6c 6178 5f6e 756d 7079 0a20   lax.lax_numpy. 
+00002590: 2069 6620 6c65 6e28 6172 6773 2920 3c20   if len(args) < 
+000025a0: 3220 616e 6420 6e6f 7420 7368 6170 653a  2 and not shape:
+000025b0: 0a20 2020 2072 6574 7572 6e20 6172 6773  .    return args
+000025c0: 0a20 2065 6c73 653a 0a20 2020 2073 6861  .  else:.    sha
+000025d0: 7065 7320 3d20 5b6a 6e70 2e73 6861 7065  pes = [jnp.shape
+000025e0: 2861 7267 2920 666f 7220 6172 6720 696e  (arg) for arg in
+000025f0: 2061 7267 735d 0a20 2020 206e 756d 5f64   args].    num_d
+00002600: 696d 7320 3d20 6c65 6e28 6c61 782e 6272  ims = len(lax.br
+00002610: 6f61 6463 6173 745f 7368 6170 6573 2873  oadcast_shapes(s
+00002620: 6861 7065 2c20 2a73 6861 7065 7329 290a  hape, *shapes)).
+00002630: 2020 2020 7265 7475 726e 205b 0a20 2020      return [.   
+00002640: 2020 205f 7265 7368 6170 6528 6172 672c     _reshape(arg,
+00002650: 2028 312c 2920 2a20 286e 756d 5f64 696d   (1,) * (num_dim
+00002660: 7320 2d20 6c65 6e28 7329 2920 2b20 7329  s - len(s)) + s)
+00002670: 2069 6620 6c65 6e28 7329 203c 206e 756d   if len(s) < num
+00002680: 5f64 696d 7320 656c 7365 2061 7267 0a20  _dims else arg. 
+00002690: 2020 2020 2066 6f72 2061 7267 2c20 7320       for arg, s 
+000026a0: 696e 207a 6970 2861 7267 732c 2073 6861  in zip(args, sha
+000026b0: 7065 7329 0a20 2020 205d 0a0a 0a40 7061  pes).    ]...@pa
+000026c0: 7274 6961 6c28 6a69 742c 2073 7461 7469  rtial(jit, stati
+000026d0: 635f 6172 676e 756d 733d 2833 2c20 3429  c_argnums=(3, 4)
+000026e0: 290a 6465 6620 5f6d 756c 7469 6e6f 6d69  ).def _multinomi
+000026f0: 616c 286b 6579 2c20 702c 206e 2c20 6e5f  al(key, p, n, n_
+00002700: 6d61 782c 2073 6861 7065 3d28 2929 3a0a  max, shape=()):.
+00002710: 2020 6966 206a 6e70 2e73 6861 7065 286e    if jnp.shape(n
+00002720: 2920 213d 206a 6e70 2e73 6861 7065 2870  ) != jnp.shape(p
+00002730: 295b 3a2d 315d 3a0a 2020 2020 6272 6f61  )[:-1]:.    broa
+00002740: 6463 6173 745f 7368 6170 6520 3d20 6c61  dcast_shape = la
+00002750: 782e 6272 6f61 6463 6173 745f 7368 6170  x.broadcast_shap
+00002760: 6573 286a 6e70 2e73 6861 7065 286e 292c  es(jnp.shape(n),
+00002770: 206a 6e70 2e73 6861 7065 2870 295b 3a2d   jnp.shape(p)[:-
+00002780: 315d 290a 2020 2020 6e20 3d20 6a6e 702e  1]).    n = jnp.
+00002790: 6272 6f61 6463 6173 745f 746f 286e 2c20  broadcast_to(n, 
+000027a0: 6272 6f61 6463 6173 745f 7368 6170 6529  broadcast_shape)
+000027b0: 0a20 2020 2070 203d 206a 6e70 2e62 726f  .    p = jnp.bro
+000027c0: 6164 6361 7374 5f74 6f28 702c 2062 726f  adcast_to(p, bro
+000027d0: 6164 6361 7374 5f73 6861 7065 202b 206a  adcast_shape + j
+000027e0: 6e70 2e73 6861 7065 2870 295b 2d31 3a5d  np.shape(p)[-1:]
+000027f0: 290a 2020 7368 6170 6520 3d20 7368 6170  ).  shape = shap
+00002800: 6520 6f72 2070 2e73 6861 7065 5b3a 2d31  e or p.shape[:-1
+00002810: 5d0a 2020 6966 206e 5f6d 6178 203d 3d20  ].  if n_max == 
+00002820: 303a 0a20 2020 2072 6574 7572 6e20 6a6e  0:.    return jn
+00002830: 702e 7a65 726f 7328 7368 6170 6520 2b20  p.zeros(shape + 
+00002840: 702e 7368 6170 655b 2d31 3a5d 2c20 6474  p.shape[-1:], dt
+00002850: 7970 653d 6a6e 702e 7265 7375 6c74 5f74  ype=jnp.result_t
+00002860: 7970 6528 696e 7429 290a 2020 2320 6765  ype(int)).  # ge
+00002870: 7420 696e 6469 6365 7320 6672 6f6d 2063  t indices from c
+00002880: 6174 6567 6f72 6963 616c 2064 6973 7472  ategorical distr
+00002890: 6962 7574 696f 6e20 7468 656e 2067 6174  ibution then gat
+000028a0: 6865 7220 7468 6520 7265 7375 6c74 0a20  her the result. 
+000028b0: 2069 6e64 6963 6573 203d 205f 6361 7465   indices = _cate
+000028c0: 676f 7269 6361 6c28 6b65 792c 2070 2c20  gorical(key, p, 
+000028d0: 286e 5f6d 6178 2c29 202b 2073 6861 7065  (n_max,) + shape
+000028e0: 290a 2020 2320 6d61 736b 206f 7574 2076  ).  # mask out v
+000028f0: 616c 7565 7320 7768 656e 2063 6f75 6e74  alues when count
+00002900: 7320 6973 2068 6574 6572 6f67 656e 656f  s is heterogeneo
+00002910: 7573 0a20 2069 6620 6a6e 702e 6e64 696d  us.  if jnp.ndim
+00002920: 286e 2920 3e20 303a 0a20 2020 206d 6173  (n) > 0:.    mas
+00002930: 6b20 3d20 5f70 726f 6d6f 7465 5f73 6861  k = _promote_sha
+00002940: 7065 7328 6a6e 702e 6172 616e 6765 286e  pes(jnp.arange(n
+00002950: 5f6d 6178 2920 3c20 6a6e 702e 6578 7061  _max) < jnp.expa
+00002960: 6e64 5f64 696d 7328 6e2c 202d 3129 2c20  nd_dims(n, -1), 
+00002970: 7368 6170 653d 7368 6170 6520 2b20 286e  shape=shape + (n
+00002980: 5f6d 6178 2c29 295b 305d 0a20 2020 206d  _max,))[0].    m
+00002990: 6173 6b20 3d20 6a6e 702e 6d6f 7665 6178  ask = jnp.moveax
+000029a0: 6973 286d 6173 6b2c 202d 312c 2030 292e  is(mask, -1, 0).
+000029b0: 6173 7479 7065 2869 6e64 6963 6573 2e64  astype(indices.d
+000029c0: 7479 7065 290a 2020 2020 6578 6365 7373  type).    excess
+000029d0: 203d 206a 6e70 2e63 6f6e 6361 7465 6e61   = jnp.concatena
+000029e0: 7465 285b 6a6e 702e 6578 7061 6e64 5f64  te([jnp.expand_d
+000029f0: 696d 7328 6e5f 6d61 7820 2d20 6e2c 202d  ims(n_max - n, -
+00002a00: 3129 2c0a 2020 2020 2020 2020 2020 2020  1),.            
+00002a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002a20: 2020 6a6e 702e 7a65 726f 7328 6a6e 702e    jnp.zeros(jnp.
+00002a30: 7368 6170 6528 6e29 202b 2028 702e 7368  shape(n) + (p.sh
+00002a40: 6170 655b 2d31 5d20 2d20 312c 2929 5d2c  ape[-1] - 1,))],
+00002a50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002a60: 2020 2020 2020 2020 2020 2020 2020 2d31                -1
+00002a70: 290a 2020 656c 7365 3a0a 2020 2020 6d61  ).  else:.    ma
+00002a80: 736b 203d 2031 0a20 2020 2065 7863 6573  sk = 1.    exces
+00002a90: 7320 3d20 300a 2020 2320 4e42 3a20 7765  s = 0.  # NB: we
+00002aa0: 2074 7261 6e73 706f 7365 2074 6f20 6d6f   transpose to mo
+00002ab0: 7665 2062 6174 6368 2073 6861 7065 2074  ve batch shape t
+00002ac0: 6f20 7468 6520 6672 6f6e 740a 2020 696e  o the front.  in
+00002ad0: 6469 6365 735f 3244 203d 2028 6a6e 702e  dices_2D = (jnp.
+00002ae0: 7265 7368 6170 6528 696e 6469 6365 7320  reshape(indices 
+00002af0: 2a20 6d61 736b 2c20 286e 5f6d 6178 2c20  * mask, (n_max, 
+00002b00: 2d31 2929 292e 540a 2020 7361 6d70 6c65  -1))).T.  sample
+00002b10: 735f 3244 203d 2076 6d61 7028 5f73 6361  s_2D = vmap(_sca
+00002b20: 7474 6572 5f61 6464 5f6f 6e65 2928 6a6e  tter_add_one)(jn
+00002b30: 702e 7a65 726f 7328 2869 6e64 6963 6573  p.zeros((indices
+00002b40: 5f32 442e 7368 6170 655b 305d 2c20 702e  _2D.shape[0], p.
+00002b50: 7368 6170 655b 2d31 5d29 2c20 6474 7970  shape[-1]), dtyp
+00002b60: 653d 696e 6469 6365 732e 6474 7970 6529  e=indices.dtype)
+00002b70: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00002b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002b90: 2020 2020 2020 2020 6a6e 702e 6578 7061          jnp.expa
+00002ba0: 6e64 5f64 696d 7328 696e 6469 6365 735f  nd_dims(indices_
+00002bb0: 3244 2c20 6178 6973 3d2d 3129 2c0a 2020  2D, axis=-1),.  
+00002bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002be0: 2020 2020 6a6e 702e 6f6e 6573 2869 6e64      jnp.ones(ind
+00002bf0: 6963 6573 5f32 442e 7368 6170 652c 2064  ices_2D.shape, d
+00002c00: 7479 7065 3d69 6e64 6963 6573 2e64 7479  type=indices.dty
+00002c10: 7065 2929 0a20 2072 6574 7572 6e20 6a6e  pe)).  return jn
+00002c20: 702e 7265 7368 6170 6528 7361 6d70 6c65  p.reshape(sample
+00002c30: 735f 3244 2c20 7368 6170 6520 2b20 702e  s_2D, shape + p.
+00002c40: 7368 6170 655b 2d31 3a5d 2920 2d20 6578  shape[-1:]) - ex
+00002c50: 6365 7373 0a0a 0a40 7061 7274 6961 6c28  cess...@partial(
+00002c60: 6a69 742c 2073 7461 7469 635f 6172 676e  jit, static_argn
+00002c70: 756d 733d 2832 2c20 3329 290a 6465 6620  ums=(2, 3)).def 
+00002c80: 5f76 6f6e 5f6d 6973 6573 5f63 656e 7465  _von_mises_cente
+00002c90: 7265 6428 6b65 792c 2063 6f6e 6365 6e74  red(key, concent
+00002ca0: 7261 7469 6f6e 2c20 7368 6170 652c 2064  ration, shape, d
+00002cb0: 7479 7065 3d6a 6e70 2e66 6c6f 6174 3634  type=jnp.float64
+00002cc0: 293a 0a20 2022 2222 436f 6d70 7574 6520  ):.  """Compute 
+00002cd0: 6365 6e74 6572 6564 2076 6f6e 204d 6973  centered von Mis
+00002ce0: 6573 2073 616d 706c 6573 2075 7369 6e67  es samples using
+00002cf0: 2072 656a 6563 7469 6f6e 2073 616d 706c   rejection sampl
+00002d00: 696e 6720 6672 6f6d 205b 315d 5f20 7769  ing from [1]_ wi
+00002d10: 7468 2077 7261 7070 6564 2043 6175 6368  th wrapped Cauch
+00002d20: 7920 7072 6f70 6f73 616c 2e0a 0a20 2052  y proposal...  R
+00002d30: 6574 7572 6e73 0a20 202d 2d2d 2d2d 2d2d  eturns.  -------
+00002d40: 0a20 206f 7574 3a20 6172 7261 795f 6c69  .  out: array_li
+00002d50: 6b65 0a20 2020 2020 6365 6e74 6572 6564  ke.     centered
+00002d60: 2073 616d 706c 6573 2066 726f 6d20 766f   samples from vo
+00002d70: 6e20 4d69 7365 730a 0a20 2052 6566 6572  n Mises..  Refer
+00002d80: 656e 6365 730a 2020 2d2d 2d2d 2d2d 2d2d  ences.  --------
+00002d90: 2d2d 0a20 202e 2e20 5b31 5d20 4c75 6320  --.  .. [1] Luc 
+00002da0: 4465 7672 6f79 6520 224e 6f6e 2d55 6e69  Devroye "Non-Uni
+00002db0: 666f 726d 2052 616e 646f 6d20 5661 7269  form Random Vari
+00002dc0: 6174 6520 4765 6e65 7261 7469 6f6e 222c  ate Generation",
+00002dd0: 2053 7072 696e 6765 722d 5665 726c 6167   Springer-Verlag
+00002de0: 2c20 3139 3836 3b0a 2020 2020 2020 2020  , 1986;.        
+00002df0: 2043 6861 7074 6572 2039 2c20 702e 2034   Chapter 9, p. 4
+00002e00: 3733 2d34 3736 2e20 6874 7470 3a2f 2f77  73-476. http://w
+00002e10: 7777 2e6e 7262 6f6f 6b2e 636f 6d2f 6465  ww.nrbook.com/de
+00002e20: 7672 6f79 652f 4465 7672 6f79 655f 6669  vroye/Devroye_fi
+00002e30: 6c65 732f 6368 6170 7465 725f 6e69 6e65  les/chapter_nine
+00002e40: 2e70 6466 0a0a 2020 2222 220a 2020 7368  .pdf..  """.  sh
+00002e50: 6170 6520 3d20 7368 6170 6520 6f72 206a  ape = shape or j
+00002e60: 6e70 2e73 6861 7065 2863 6f6e 6365 6e74  np.shape(concent
+00002e70: 7261 7469 6f6e 290a 2020 6474 7970 6520  ration).  dtype 
+00002e80: 3d20 6a6e 702e 7265 7375 6c74 5f74 7970  = jnp.result_typ
+00002e90: 6528 6474 7970 6529 0a20 2063 6f6e 6365  e(dtype).  conce
+00002ea0: 6e74 7261 7469 6f6e 203d 206c 6178 2e63  ntration = lax.c
+00002eb0: 6f6e 7665 7274 5f65 6c65 6d65 6e74 5f74  onvert_element_t
+00002ec0: 7970 6528 636f 6e63 656e 7472 6174 696f  ype(concentratio
+00002ed0: 6e2c 2064 7479 7065 290a 2020 636f 6e63  n, dtype).  conc
+00002ee0: 656e 7472 6174 696f 6e20 3d20 6a6e 702e  entration = jnp.
+00002ef0: 6272 6f61 6463 6173 745f 746f 2863 6f6e  broadcast_to(con
+00002f00: 6365 6e74 7261 7469 6f6e 2c20 7368 6170  centration, shap
+00002f10: 6529 0a0a 2020 735f 6375 746f 6666 5f6d  e)..  s_cutoff_m
+00002f20: 6170 203d 207b 0a20 2020 206a 6e70 2e64  ap = {.    jnp.d
+00002f30: 7479 7065 286a 6e70 2e66 6c6f 6174 3136  type(jnp.float16
+00002f40: 293a 2031 2e38 652d 312c 0a20 2020 206a  ): 1.8e-1,.    j
+00002f50: 6e70 2e64 7479 7065 286a 6e70 2e66 6c6f  np.dtype(jnp.flo
+00002f60: 6174 3332 293a 2032 652d 322c 0a20 2020  at32): 2e-2,.   
+00002f70: 206a 6e70 2e64 7479 7065 286a 6e70 2e66   jnp.dtype(jnp.f
+00002f80: 6c6f 6174 3634 293a 2031 2e32 652d 342c  loat64): 1.2e-4,
+00002f90: 0a20 207d 0a20 2073 5f63 7574 6f66 6620  .  }.  s_cutoff 
+00002fa0: 3d20 735f 6375 746f 6666 5f6d 6170 2e67  = s_cutoff_map.g
+00002fb0: 6574 2864 7479 7065 290a 0a20 2072 203d  et(dtype)..  r =
+00002fc0: 2031 2e30 202b 206a 6e70 2e73 7172 7428   1.0 + jnp.sqrt(
+00002fd0: 312e 3020 2b20 342e 3020 2a20 636f 6e63  1.0 + 4.0 * conc
+00002fe0: 656e 7472 6174 696f 6e20 2a2a 2032 290a  entration ** 2).
+00002ff0: 2020 7268 6f20 3d20 2872 202d 206a 6e70    rho = (r - jnp
+00003000: 2e73 7172 7428 322e 3020 2a20 7229 2920  .sqrt(2.0 * r)) 
+00003010: 2f20 2832 2e30 202a 2063 6f6e 6365 6e74  / (2.0 * concent
+00003020: 7261 7469 6f6e 290a 2020 735f 6578 6163  ration).  s_exac
+00003030: 7420 3d20 2831 2e30 202b 2072 686f 202a  t = (1.0 + rho *
+00003040: 2a20 3229 202f 2028 322e 3020 2a20 7268  * 2) / (2.0 * rh
+00003050: 6f29 0a0a 2020 735f 6170 7072 6f78 696d  o)..  s_approxim
+00003060: 6174 6520 3d20 312e 3020 2f20 636f 6e63  ate = 1.0 / conc
+00003070: 656e 7472 6174 696f 6e0a 0a20 2073 203d  entration..  s =
+00003080: 206a 6e70 2e77 6865 7265 2863 6f6e 6365   jnp.where(conce
+00003090: 6e74 7261 7469 6f6e 203e 2073 5f63 7574  ntration > s_cut
+000030a0: 6f66 662c 2073 5f65 7861 6374 2c20 735f  off, s_exact, s_
+000030b0: 6170 7072 6f78 696d 6174 6529 0a0a 2020  approximate)..  
+000030c0: 6465 6620 636f 6e64 5f66 6e28 2a61 7267  def cond_fn(*arg
+000030d0: 7329 3a0a 2020 2020 2222 2263 6865 636b  s):.    """check
+000030e0: 2069 6620 616c 6c20 6172 6520 646f 6e65   if all are done
+000030f0: 206f 7220 7265 6163 6865 6420 6d61 7820   or reached max 
+00003100: 6e75 6d62 6572 206f 6620 6974 6572 6174  number of iterat
+00003110: 696f 6e73 2222 220a 2020 2020 692c 205f  ions""".    i, _
+00003120: 2c20 646f 6e65 2c20 5f2c 205f 203d 2061  , done, _, _ = a
+00003130: 7267 735b 305d 0a20 2020 2072 6574 7572  rgs[0].    retur
+00003140: 6e20 6a6e 702e 6269 7477 6973 655f 616e  n jnp.bitwise_an
+00003150: 6428 6920 3c20 3130 302c 206a 6e70 2e6c  d(i < 100, jnp.l
+00003160: 6f67 6963 616c 5f6e 6f74 286a 6e70 2e61  ogical_not(jnp.a
+00003170: 6c6c 2864 6f6e 6529 2929 0a0a 2020 6465  ll(done)))..  de
+00003180: 6620 626f 6479 5f66 6e28 2a61 7267 7329  f body_fn(*args)
+00003190: 3a0a 2020 2020 692c 206b 6579 2c20 646f  :.    i, key, do
+000031a0: 6e65 2c20 5f2c 2077 203d 2061 7267 735b  ne, _, w = args[
+000031b0: 305d 0a20 2020 2075 6e69 5f75 6b65 792c  0].    uni_ukey,
+000031c0: 2075 6e69 5f76 6b65 792c 206b 6579 203d   uni_vkey, key =
+000031d0: 206a 722e 7370 6c69 7428 6b65 792c 2033   jr.split(key, 3
+000031e0: 290a 2020 2020 7520 3d20 6a72 2e75 6e69  ).    u = jr.uni
+000031f0: 666f 726d 280a 2020 2020 2020 6b65 793d  form(.      key=
+00003200: 756e 695f 756b 6579 2c0a 2020 2020 2020  uni_ukey,.      
+00003210: 7368 6170 653d 7368 6170 652c 0a20 2020  shape=shape,.   
+00003220: 2020 2064 7479 7065 3d63 6f6e 6365 6e74     dtype=concent
+00003230: 7261 7469 6f6e 2e64 7479 7065 2c0a 2020  ration.dtype,.  
+00003240: 2020 2020 6d69 6e76 616c 3d2d 312e 302c      minval=-1.0,
+00003250: 0a20 2020 2020 206d 6178 7661 6c3d 312e  .      maxval=1.
+00003260: 302c 0a20 2020 2029 0a20 2020 207a 203d  0,.    ).    z =
+00003270: 206a 6e70 2e63 6f73 286a 6e70 2e70 6920   jnp.cos(jnp.pi 
+00003280: 2a20 7529 0a20 2020 2077 203d 206a 6e70  * u).    w = jnp
+00003290: 2e77 6865 7265 2864 6f6e 652c 2077 2c20  .where(done, w, 
+000032a0: 2831 2e30 202b 2073 202a 207a 2920 2f20  (1.0 + s * z) / 
+000032b0: 2873 202b 207a 2929 2020 2320 5570 6461  (s + z))  # Upda
+000032c0: 7465 2077 6865 7265 206e 6f74 2064 6f6e  te where not don
+000032d0: 650a 2020 2020 7920 3d20 636f 6e63 656e  e.    y = concen
+000032e0: 7472 6174 696f 6e20 2a20 2873 202d 2077  tration * (s - w
+000032f0: 290a 2020 2020 7620 3d20 6a72 2e75 6e69  ).    v = jr.uni
+00003300: 666f 726d 286b 6579 3d75 6e69 5f76 6b65  form(key=uni_vke
+00003310: 792c 2073 6861 7065 3d73 6861 7065 2c20  y, shape=shape, 
+00003320: 6474 7970 653d 636f 6e63 656e 7472 6174  dtype=concentrat
+00003330: 696f 6e2e 6474 7970 6529 0a20 2020 2061  ion.dtype).    a
+00003340: 6363 6570 7420 3d20 2879 202a 2028 322e  ccept = (y * (2.
+00003350: 3020 2d20 7929 203e 3d20 7629 207c 2028  0 - y) >= v) | (
+00003360: 6a6e 702e 6c6f 6728 7920 2f20 7629 202b  jnp.log(y / v) +
+00003370: 2031 2e30 203e 3d20 7929 0a20 2020 2072   1.0 >= y).    r
+00003380: 6574 7572 6e20 6920 2b20 312c 206b 6579  eturn i + 1, key
+00003390: 2c20 6163 6365 7074 207c 2064 6f6e 652c  , accept | done,
+000033a0: 2075 2c20 770a 0a20 2069 6e69 745f 646f   u, w..  init_do
+000033b0: 6e65 203d 206a 6e70 2e7a 6572 6f73 2873  ne = jnp.zeros(s
+000033c0: 6861 7065 2c20 6474 7970 653d 626f 6f6c  hape, dtype=bool
+000033d0: 290a 2020 696e 6974 5f75 203d 206a 6e70  ).  init_u = jnp
+000033e0: 2e7a 6572 6f73 2873 6861 7065 290a 2020  .zeros(shape).  
+000033f0: 696e 6974 5f77 203d 206a 6e70 2e7a 6572  init_w = jnp.zer
+00003400: 6f73 2873 6861 7065 290a 0a20 205f 2c20  os(shape)..  _, 
+00003410: 5f2c 2064 6f6e 652c 2075 2c20 7720 3d20  _, done, u, w = 
+00003420: 6c61 782e 7768 696c 655f 6c6f 6f70 280a  lax.while_loop(.
+00003430: 2020 2020 636f 6e64 5f66 756e 3d63 6f6e      cond_fun=con
+00003440: 645f 666e 2c0a 2020 2020 626f 6479 5f66  d_fn,.    body_f
+00003450: 756e 3d62 6f64 795f 666e 2c0a 2020 2020  un=body_fn,.    
+00003460: 696e 6974 5f76 616c 3d28 6a6e 702e 6172  init_val=(jnp.ar
+00003470: 7261 7928 3029 2c20 6b65 792c 2069 6e69  ray(0), key, ini
+00003480: 745f 646f 6e65 2c20 696e 6974 5f75 2c20  t_done, init_u, 
+00003490: 696e 6974 5f77 292c 0a20 2029 0a0a 2020  init_w),.  )..  
+000034a0: 7265 7475 726e 206a 6e70 2e73 6967 6e28  return jnp.sign(
+000034b0: 7529 202a 206a 6e70 2e61 7263 636f 7328  u) * jnp.arccos(
+000034c0: 7729 0a0a 0a64 6566 205f 6c6f 635f 7363  w)...def _loc_sc
+000034d0: 616c 6528 6c6f 632c 2073 6361 6c65 2c20  ale(loc, scale, 
+000034e0: 7661 6c75 6529 3a0a 2020 6966 206c 6f63  value):.  if loc
+000034f0: 2069 7320 4e6f 6e65 3a0a 2020 2020 6966   is None:.    if
+00003500: 2073 6361 6c65 2069 7320 4e6f 6e65 3a0a   scale is None:.
+00003510: 2020 2020 2020 7265 7475 726e 2076 616c        return val
+00003520: 7565 0a20 2020 2065 6c73 653a 0a20 2020  ue.    else:.   
+00003530: 2020 2072 6574 7572 6e20 7661 6c75 6520     return value 
+00003540: 2a20 7363 616c 650a 2020 656c 7365 3a0a  * scale.  else:.
+00003550: 2020 2020 6966 2073 6361 6c65 2069 7320      if scale is 
+00003560: 4e6f 6e65 3a0a 2020 2020 2020 7265 7475  None:.      retu
+00003570: 726e 2076 616c 7565 202b 206c 6f63 0a20  rn value + loc. 
+00003580: 2020 2065 6c73 653a 0a20 2020 2020 2072     else:.      r
+00003590: 6574 7572 6e20 7661 6c75 6520 2a20 7363  eturn value * sc
+000035a0: 616c 6520 2b20 6c6f 630a 0a0a 6465 6620  ale + loc...def 
+000035b0: 5f63 6865 636b 5f70 795f 7365 7128 7365  _check_py_seq(se
+000035c0: 7129 3a0a 2020 7265 7475 726e 206a 6e70  q):.  return jnp
+000035d0: 2e61 7361 7272 6179 2873 6571 2920 6966  .asarray(seq) if
+000035e0: 2069 7369 6e73 7461 6e63 6528 7365 712c   isinstance(seq,
+000035f0: 2028 7475 706c 652c 206c 6973 7429 2920   (tuple, list)) 
+00003600: 656c 7365 2073 6571 0a0a 0a40 7265 6769  else seq...@regi
+00003610: 7374 6572 5f70 7974 7265 655f 6e6f 6465  ster_pytree_node
+00003620: 5f63 6c61 7373 0a63 6c61 7373 2052 616e  _class.class Ran
+00003630: 646f 6d53 7461 7465 2856 6172 6961 626c  domState(Variabl
+00003640: 6529 3a0a 2020 2222 2252 616e 646f 6d53  e):.  """RandomS
+00003650: 7461 7465 2074 6861 7420 7472 6163 6b20  tate that track 
+00003660: 7468 6520 7261 6e64 6f6d 2067 656e 6572  the random gener
+00003670: 6174 6f72 2073 7461 7465 2e20 2222 220a  ator state. """.
+00003680: 2020 5f5f 736c 6f74 735f 5f20 3d20 2829    __slots__ = ()
+00003690: 0a0a 2020 6465 6620 5f5f 696e 6974 5f5f  ..  def __init__
+000036a0: 280a 2020 2020 2020 7365 6c66 2c0a 2020  (.      self,.  
+000036b0: 2020 2020 7365 6564 5f6f 725f 6b65 793a      seed_or_key:
+000036c0: 204f 7074 696f 6e61 6c5b 556e 696f 6e5b   Optional[Union[
+000036d0: 696e 742c 2041 7272 6179 2c20 6a61 782e  int, Array, jax.
+000036e0: 4172 7261 792c 206e 702e 6e64 6172 7261  Array, np.ndarra
+000036f0: 795d 5d20 3d20 4e6f 6e65 2c0a 2020 2020  y]] = None,.    
+00003700: 2020 7365 6564 3a20 4f70 7469 6f6e 616c    seed: Optional
+00003710: 5b69 6e74 5d20 3d20 4e6f 6e65 2c0a 2020  [int] = None,.  
+00003720: 2020 2020 5f72 6561 6479 5f74 6f5f 7472      _ready_to_tr
+00003730: 6163 653a 2062 6f6f 6c20 3d20 5472 7565  ace: bool = True
+00003740: 2c0a 2020 293a 0a20 2020 2022 2222 5261  ,.  ):.    """Ra
+00003750: 6e64 6f6d 5374 6174 6520 636f 6e73 7472  ndomState constr
+00003760: 7563 746f 722e 0a0a 2020 2020 5061 7261  uctor...    Para
+00003770: 6d65 7465 7273 0a20 2020 202d 2d2d 2d2d  meters.    -----
+00003780: 2d2d 2d2d 2d0a 2020 2020 7365 6564 5f6f  -----.    seed_o
+00003790: 725f 6b65 793a 2069 6e74 2c20 4172 7261  r_key: int, Arra
+000037a0: 792c 206f 7074 696f 6e61 6c0a 2020 2020  y, optional.    
+000037b0: 2020 4974 2063 616e 2062 6520 616e 2069    It can be an i
+000037c0: 6e74 6567 6572 2066 6f72 2069 6e69 7469  nteger for initi
+000037d0: 616c 2073 6565 6420 6f66 2074 6865 2072  al seed of the r
+000037e0: 616e 646f 6d20 6e75 6d62 6572 2067 656e  andom number gen
+000037f0: 6572 6174 6f72 2c0a 2020 2020 2020 6f72  erator,.      or
+00003800: 2069 7420 6361 6e20 6265 2061 204a 4158   it can be a JAX
+00003810: 2773 2050 524e 4b65 792c 2077 6869 6368  's PRNKey, which
+00003820: 2069 7320 616e 2061 7272 6179 2077 6974   is an array wit
+00003830: 6820 7477 6f20 656c 656d 656e 7473 2061  h two elements a
+00003840: 6e64 2060 7569 6e74 3332 6020 6474 7970  nd `uint32` dtyp
+00003850: 652e 0a0a 2020 2020 2020 2e2e 2076 6572  e...      .. ver
+00003860: 7369 6f6e 6164 6465 643a 3a20 322e 322e  sionadded:: 2.2.
+00003870: 332e 340a 0a20 2020 2073 6565 6420 3a20  3.4..    seed : 
+00003880: 696e 742c 2041 7272 6179 5479 7065 2c20  int, ArrayType, 
+00003890: 6f70 7469 6f6e 616c 0a20 2020 2020 2053  optional.      S
+000038a0: 616d 6520 6173 2060 7365 6564 5f6f 725f  ame as `seed_or_
+000038b0: 6b65 7960 2e0a 0a20 2020 2020 202e 2e20  key`...      .. 
+000038c0: 6465 7072 6563 6174 6564 3a3a 2032 2e32  deprecated:: 2.2
+000038d0: 2e33 2e34 0a20 2020 2020 2020 2020 5769  .3.4.         Wi
+000038e0: 6c6c 2062 6520 7265 6d6f 7665 6420 7369  ll be removed si
+000038f0: 6e63 6520 7665 7273 696f 6e20 322e 342e  nce version 2.4.
+00003900: 0a20 2020 2022 2222 0a20 2020 2069 6620  .    """.    if 
+00003910: 7365 6564 2069 7320 6e6f 7420 4e6f 6e65  seed is not None
+00003920: 3a0a 2020 2020 2020 6966 2073 6565 645f  :.      if seed_
+00003930: 6f72 5f6b 6579 2069 7320 6e6f 7420 4e6f  or_key is not No
+00003940: 6e65 3a0a 2020 2020 2020 2020 7261 6973  ne:.        rais
+00003950: 6520 5661 6c75 6545 7272 6f72 2827 506c  e ValueError('Pl
+00003960: 6561 7365 2073 6574 2022 7365 6564 5f6f  ease set "seed_o
+00003970: 725f 6b65 7922 206f 7220 2273 6565 6422  r_key" or "seed"
+00003980: 2c20 6e6f 7420 626f 7468 2e27 290a 2020  , not both.').  
+00003990: 2020 2020 7365 6564 5f6f 725f 6b65 7920      seed_or_key 
+000039a0: 3d20 7365 6564 0a20 2020 2020 2077 6172  = seed.      war
+000039b0: 6e69 6e67 732e 7761 726e 2827 506c 6561  nings.warn('Plea
+000039c0: 7365 2075 7365 2060 7365 6564 5f6f 725f  se use `seed_or_
+000039d0: 6b65 7960 2069 6e73 7465 6164 2e20 270a  key` instead. '.
+000039e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000039f0: 2020 2020 2773 6565 6420 7769 6c6c 2062      'seed will b
+00003a00: 6520 7265 6d6f 7665 6420 7369 6e63 6520  e removed since 
+00003a10: 322e 342e 3027 2c20 5573 6572 5761 726e  2.4.0', UserWarn
+00003a20: 696e 6729 0a0a 2020 2020 6966 2073 6565  ing)..    if see
+00003a30: 645f 6f72 5f6b 6579 2069 7320 4e6f 6e65  d_or_key is None
+00003a40: 3a0a 2020 2020 2020 7365 6564 5f6f 725f  :.      seed_or_
+00003a50: 6b65 7920 3d20 6e70 2e72 616e 646f 6d2e  key = np.random.
+00003a60: 7261 6e64 696e 7428 302c 2031 3030 3030  randint(0, 10000
+00003a70: 302c 2032 2c20 6474 7970 653d 6e70 2e75  0, 2, dtype=np.u
+00003a80: 696e 7433 3229 0a20 2020 2069 6620 6973  int32).    if is
+00003a90: 696e 7374 616e 6365 2873 6565 645f 6f72  instance(seed_or
+00003aa0: 5f6b 6579 2c20 696e 7429 3a0a 2020 2020  _key, int):.    
+00003ab0: 2020 6b65 7920 3d20 6a72 2e50 524e 474b    key = jr.PRNGK
+00003ac0: 6579 2873 6565 645f 6f72 5f6b 6579 290a  ey(seed_or_key).
+00003ad0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00003ae0: 6966 206c 656e 2873 6565 645f 6f72 5f6b  if len(seed_or_k
+00003af0: 6579 2920 213d 2032 2061 6e64 2073 6565  ey) != 2 and see
+00003b00: 645f 6f72 5f6b 6579 2e64 7479 7065 2021  d_or_key.dtype !
+00003b10: 3d20 6e70 2e75 696e 7433 323a 0a20 2020  = np.uint32:.   
+00003b20: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00003b30: 4572 726f 7228 276b 6579 206d 7573 7420  Error('key must 
+00003b40: 6265 2061 6e20 6172 7261 7920 7769 7468  be an array with
+00003b50: 2064 7479 7065 2075 696e 7433 322e 2027   dtype uint32. '
+00003b60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003b70: 2020 2020 2020 2020 2020 6627 4275 7420            f'But 
+00003b80: 7765 2067 6f74 207b 7365 6564 5f6f 725f  we got {seed_or_
+00003b90: 6b65 797d 2729 0a20 2020 2020 206b 6579  key}').      key
+00003ba0: 203d 2073 6565 645f 6f72 5f6b 6579 0a20   = seed_or_key. 
+00003bb0: 2020 2073 7570 6572 2852 616e 646f 6d53     super(RandomS
+00003bc0: 7461 7465 2c20 7365 6c66 292e 5f5f 696e  tate, self).__in
+00003bd0: 6974 5f5f 286b 6579 2c20 5f72 6561 6479  it__(key, _ready
+00003be0: 5f74 6f5f 7472 6163 653d 5f72 6561 6479  _to_trace=_ready
+00003bf0: 5f74 6f5f 7472 6163 6529 0a0a 2020 6465  _to_trace)..  de
+00003c00: 6620 5f5f 7265 7072 5f5f 2873 656c 6629  f __repr__(self)
+00003c10: 202d 3e20 7374 723a 0a20 2020 2070 7269   -> str:.    pri
+00003c20: 6e74 5f63 6f64 6520 3d20 7265 7072 2873  nt_code = repr(s
+00003c30: 656c 662e 7661 6c75 6529 0a20 2020 2069  elf.value).    i
+00003c40: 203d 2070 7269 6e74 5f63 6f64 652e 696e   = print_code.in
+00003c50: 6465 7828 2728 2729 0a20 2020 206e 616d  dex('(').    nam
+00003c60: 6520 3d20 7365 6c66 2e5f 5f63 6c61 7373  e = self.__class
+00003c70: 5f5f 2e5f 5f6e 616d 655f 5f0a 2020 2020  __.__name__.    
+00003c80: 7265 7475 726e 2066 277b 6e61 6d65 7d28  return f'{name}(
+00003c90: 6b65 793d 7b70 7269 6e74 5f63 6f64 655b  key={print_code[
+00003ca0: 693a 5d7d 2927 0a0a 2020 2320 2d2d 2d2d  i:]})'..  # ----
+00003cb0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d20  --------------- 
+00003cc0: 230a 2020 2320 7365 6564 2061 6e64 2072  #.  # seed and r
+00003cd0: 616e 646f 6d20 6b65 7920 230a 2020 2320  andom key #.  # 
+00003ce0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00003cf0: 2d2d 2d20 230a 0a20 2064 6566 2063 6c6f  --- #..  def clo
+00003d00: 6e65 2873 656c 6629 3a0a 2020 2020 7265  ne(self):.    re
+00003d10: 7475 726e 2074 7970 6528 7365 6c66 2928  turn type(self)(
+00003d20: 7365 6c66 2e73 706c 6974 5f6b 6579 2829  self.split_key()
+00003d30: 290a 0a20 2064 6566 2073 6565 6428 7365  )..  def seed(se
+00003d40: 6c66 2c20 7365 6564 5f6f 725f 6b65 793d  lf, seed_or_key=
+00003d50: 4e6f 6e65 2c20 7365 6564 3d4e 6f6e 6529  None, seed=None)
+00003d60: 3a0a 2020 2020 2222 2253 6574 7320 6120  :.    """Sets a 
+00003d70: 6e65 7720 7261 6e64 6f6d 2073 6565 642e  new random seed.
+00003d80: 0a0a 2020 2020 5061 7261 6d65 7465 7273  ..    Parameters
+00003d90: 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a  .    ----------.
+00003da0: 2020 2020 7365 6564 5f6f 725f 6b65 793a      seed_or_key:
+00003db0: 2069 6e74 2c20 4172 7261 7954 7970 652c   int, ArrayType,
+00003dc0: 206f 7074 696f 6e61 6c0a 2020 2020 2020   optional.      
+00003dd0: 4974 2063 616e 2062 6520 616e 2069 6e74  It can be an int
+00003de0: 6567 6572 2066 6f72 2069 6e69 7469 616c  eger for initial
+00003df0: 2073 6565 6420 6f66 2074 6865 2072 616e   seed of the ran
+00003e00: 646f 6d20 6e75 6d62 6572 2067 656e 6572  dom number gener
+00003e10: 6174 6f72 2c0a 2020 2020 2020 6f72 2069  ator,.      or i
+00003e20: 7420 6361 6e20 6265 2061 204a 4158 2773  t can be a JAX's
+00003e30: 2050 524e 4b65 792c 2077 6869 6368 2069   PRNKey, which i
+00003e40: 7320 616e 2061 7272 6179 2077 6974 6820  s an array with 
+00003e50: 7477 6f20 656c 656d 656e 7473 2061 6e64  two elements and
+00003e60: 2060 7569 6e74 3332 6020 6474 7970 652e   `uint32` dtype.
+00003e70: 0a0a 2020 2020 2020 2e2e 2076 6572 7369  ..      .. versi
+00003e80: 6f6e 6164 6465 643a 3a20 322e 322e 332e  onadded:: 2.2.3.
+00003e90: 340a 0a20 2020 2073 6565 6420 3a20 696e  4..    seed : in
+00003ea0: 742c 2041 7272 6179 5479 7065 2c20 6f70  t, ArrayType, op
+00003eb0: 7469 6f6e 616c 0a20 2020 2020 2053 616d  tional.      Sam
+00003ec0: 6520 6173 2060 7365 6564 5f6f 725f 6b65  e as `seed_or_ke
+00003ed0: 7960 2e0a 0a20 2020 2020 202e 2e20 6465  y`...      .. de
+00003ee0: 7072 6563 6174 6564 3a3a 2032 2e32 2e33  precated:: 2.2.3
+00003ef0: 2e34 0a20 2020 2020 2020 2020 5769 6c6c  .4.         Will
+00003f00: 2062 6520 7265 6d6f 7665 6420 7369 6e63   be removed sinc
+00003f10: 6520 7665 7273 696f 6e20 322e 342e 0a20  e version 2.4.. 
+00003f20: 2020 2022 2222 0a20 2020 2069 6620 7365     """.    if se
+00003f30: 6564 2069 7320 6e6f 7420 4e6f 6e65 3a0a  ed is not None:.
+00003f40: 2020 2020 2020 6966 2073 6565 645f 6f72        if seed_or
+00003f50: 5f6b 6579 2069 7320 6e6f 7420 4e6f 6e65  _key is not None
+00003f60: 3a0a 2020 2020 2020 2020 7261 6973 6520  :.        raise 
+00003f70: 5661 6c75 6545 7272 6f72 2827 506c 6561  ValueError('Plea
+00003f80: 7365 2073 6574 2022 7365 6564 5f6f 725f  se set "seed_or_
+00003f90: 6b65 7922 206f 7220 2273 6565 6422 2c20  key" or "seed", 
+00003fa0: 6e6f 7420 626f 7468 2e27 290a 2020 2020  not both.').    
+00003fb0: 2020 7365 6564 5f6f 725f 6b65 7920 3d20    seed_or_key = 
+00003fc0: 7365 6564 0a20 2020 2020 2077 6172 6e69  seed.      warni
+00003fd0: 6e67 732e 7761 726e 2827 506c 6561 7365  ngs.warn('Please
+00003fe0: 2075 7365 2073 6565 645f 6f72 5f6b 6579   use seed_or_key
+00003ff0: 2069 6e73 7465 6164 2e20 270a 2020 2020   instead. '.    
+00004000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004010: 2773 6565 6420 7769 6c6c 2062 6520 7265  'seed will be re
+00004020: 6d6f 7665 6420 7369 6e63 6520 322e 342e  moved since 2.4.
+00004030: 3027 2c20 5573 6572 5761 726e 696e 6729  0', UserWarning)
+00004040: 0a0a 2020 2020 6966 2073 6565 645f 6f72  ..    if seed_or
+00004050: 5f6b 6579 2069 7320 4e6f 6e65 3a0a 2020  _key is None:.  
+00004060: 2020 2020 7365 6564 5f6f 725f 6b65 7920      seed_or_key 
+00004070: 3d20 6e70 2e72 616e 646f 6d2e 7261 6e64  = np.random.rand
+00004080: 696e 7428 302c 2031 3030 3030 302c 2032  int(0, 100000, 2
+00004090: 2c20 6474 7970 653d 6e70 2e75 696e 7433  , dtype=np.uint3
+000040a0: 3229 0a20 2020 2069 6620 6973 696e 7374  2).    if isinst
+000040b0: 616e 6365 2873 6565 645f 6f72 5f6b 6579  ance(seed_or_key
+000040c0: 2c20 696e 7429 3a0a 2020 2020 2020 6b65  , int):.      ke
+000040d0: 7920 3d20 6a72 2e50 524e 474b 6579 2873  y = jr.PRNGKey(s
+000040e0: 6565 645f 6f72 5f6b 6579 290a 2020 2020  eed_or_key).    
+000040f0: 656c 7365 3a0a 2020 2020 2020 6966 206c  else:.      if l
+00004100: 656e 2873 6565 645f 6f72 5f6b 6579 2920  en(seed_or_key) 
+00004110: 213d 2032 2061 6e64 2073 6565 645f 6f72  != 2 and seed_or
+00004120: 5f6b 6579 2e64 7479 7065 2021 3d20 6e70  _key.dtype != np
+00004130: 2e75 696e 7433 323a 0a20 2020 2020 2020  .uint32:.       
+00004140: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
+00004150: 7228 276b 6579 206d 7573 7420 6265 2061  r('key must be a
+00004160: 6e20 6172 7261 7920 7769 7468 2064 7479  n array with dty
+00004170: 7065 2075 696e 7433 322e 2027 0a20 2020  pe uint32. '.   
+00004180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004190: 2020 2020 2020 6627 4275 7420 7765 2067        f'But we g
+000041a0: 6f74 207b 7365 6564 5f6f 725f 6b65 797d  ot {seed_or_key}
+000041b0: 2729 0a20 2020 2020 206b 6579 203d 2073  ').      key = s
+000041c0: 6565 645f 6f72 5f6b 6579 0a20 2020 2073  eed_or_key.    s
+000041d0: 656c 662e 5f76 616c 7565 203d 206b 6579  elf._value = key
+000041e0: 0a0a 2020 6465 6620 7370 6c69 745f 6b65  ..  def split_ke
+000041f0: 7928 7365 6c66 293a 0a20 2020 2022 2222  y(self):.    """
+00004200: 4372 6561 7465 2061 206e 6577 2073 6565  Create a new see
+00004210: 6420 6672 6f6d 2074 6865 2063 7572 7265  d from the curre
+00004220: 6e74 2073 6565 642e 0a20 2020 2022 2222  nt seed..    """
+00004230: 0a20 2020 2069 6620 6e6f 7420 6973 696e  .    if not isin
+00004240: 7374 616e 6365 2873 656c 662e 7661 6c75  stance(self.valu
+00004250: 652c 206a 6e70 2e6e 6461 7272 6179 293a  e, jnp.ndarray):
+00004260: 0a20 2020 2020 2073 656c 662e 5f76 616c  .      self._val
+00004270: 7565 203d 206a 6e70 2e61 7361 7272 6179  ue = jnp.asarray
+00004280: 2873 656c 662e 7661 6c75 6529 0a20 2020  (self.value).   
+00004290: 206b 6579 7320 3d20 6a72 2e73 706c 6974   keys = jr.split
+000042a0: 2873 656c 662e 7661 6c75 652c 206e 756d  (self.value, num
+000042b0: 3d32 290a 2020 2020 7365 6c66 2e5f 7661  =2).    self._va
+000042c0: 6c75 6520 3d20 6b65 7973 5b30 5d0a 2020  lue = keys[0].  
+000042d0: 2020 7265 7475 726e 206b 6579 735b 315d    return keys[1]
+000042e0: 0a0a 2020 6465 6620 7370 6c69 745f 6b65  ..  def split_ke
+000042f0: 7973 2873 656c 662c 206e 293a 0a20 2020  ys(self, n):.   
+00004300: 2022 2222 4372 6561 7465 206d 756c 7469   """Create multi
+00004310: 706c 6520 7365 6564 7320 6672 6f6d 2074  ple seeds from t
+00004320: 6865 2063 7572 7265 6e74 2073 6565 642e  he current seed.
+00004330: 2054 6869 7320 6973 2075 7365 640a 2020   This is used.  
+00004340: 2020 696e 7465 726e 616c 6c79 2062 7920    internally by 
+00004350: 6070 6d61 7060 2061 6e64 2060 766d 6170  `pmap` and `vmap
+00004360: 6020 746f 2065 6e73 7572 6520 7468 6174  ` to ensure that
+00004370: 2072 616e 646f 6d20 6e75 6d62 6572 730a   random numbers.
+00004380: 2020 2020 6172 6520 6469 6666 6572 656e      are differen
+00004390: 7420 696e 2070 6172 616c 6c65 6c20 7468  t in parallel th
+000043a0: 7265 6164 732e 0a0a 2020 2020 5061 7261  reads...    Para
+000043b0: 6d65 7465 7273 0a20 2020 202d 2d2d 2d2d  meters.    -----
+000043c0: 2d2d 2d2d 2d0a 2020 2020 6e20 3a20 696e  -----.    n : in
+000043d0: 740a 2020 2020 2020 5468 6520 6e75 6d62  t.      The numb
+000043e0: 6572 206f 6620 7365 6564 7320 746f 2067  er of seeds to g
+000043f0: 656e 6572 6174 652e 0a20 2020 2022 2222  enerate..    """
+00004400: 0a20 2020 206b 6579 7320 3d20 6a72 2e73  .    keys = jr.s
+00004410: 706c 6974 2873 656c 662e 7661 6c75 652c  plit(self.value,
+00004420: 206e 202b 2031 290a 2020 2020 7365 6c66   n + 1).    self
+00004430: 2e5f 7661 6c75 6520 3d20 6b65 7973 5b30  ._value = keys[0
+00004440: 5d0a 2020 2020 7265 7475 726e 206b 6579  ].    return key
+00004450: 735b 313a 5d0a 0a20 2023 202d 2d2d 2d2d  s[1:]..  # -----
+00004460: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 230a 2020  ----------- #.  
+00004470: 2320 7261 6e64 6f6d 2066 756e 6374 696f  # random functio
+00004480: 6e73 2023 0a20 2023 202d 2d2d 2d2d 2d2d  ns #.  # -------
+00004490: 2d2d 2d2d 2d2d 2d2d 2d20 230a 0a20 2064  --------- #..  d
+000044a0: 6566 2072 616e 6428 7365 6c66 2c20 2a64  ef rand(self, *d
+000044b0: 6e2c 206b 6579 3d4e 6f6e 6529 3a0a 2020  n, key=None):.  
+000044c0: 2020 6b65 7920 3d20 7365 6c66 2e73 706c    key = self.spl
+000044d0: 6974 5f6b 6579 2829 2069 6620 6b65 7920  it_key() if key 
+000044e0: 6973 204e 6f6e 6520 656c 7365 205f 666f  is None else _fo
+000044f0: 726d 616c 697a 655f 6b65 7928 6b65 7929  rmalize_key(key)
+00004500: 0a20 2020 2072 203d 206a 722e 756e 6966  .    r = jr.unif
+00004510: 6f72 6d28 6b65 792c 2073 6861 7065 3d64  orm(key, shape=d
+00004520: 6e2c 206d 696e 7661 6c3d 302e 2c20 6d61  n, minval=0., ma
+00004530: 7876 616c 3d31 2e29 0a20 2020 2072 6574  xval=1.).    ret
+00004540: 7572 6e20 5f72 6574 7572 6e28 7229 0a0a  urn _return(r)..
+00004550: 2020 6465 6620 7261 6e64 696e 7428 7365    def randint(se
+00004560: 6c66 2c20 6c6f 772c 2068 6967 683d 4e6f  lf, low, high=No
+00004570: 6e65 2c20 7369 7a65 3d4e 6f6e 652c 2064  ne, size=None, d
+00004580: 7479 7065 3d4e 6f6e 652c 206b 6579 3d4e  type=None, key=N
+00004590: 6f6e 6529 3a0a 2020 2020 6474 7970 6520  one):.    dtype 
+000045a0: 3d20 6765 745f 696e 7428 2920 6966 2064  = get_int() if d
+000045b0: 7479 7065 2069 7320 4e6f 6e65 2065 6c73  type is None els
+000045c0: 6520 6474 7970 650a 2020 2020 6c6f 7720  e dtype.    low 
+000045d0: 3d20 5f61 735f 6a61 785f 6172 7261 7928  = _as_jax_array(
+000045e0: 6c6f 7729 0a20 2020 2068 6967 6820 3d20  low).    high = 
+000045f0: 5f61 735f 6a61 785f 6172 7261 7928 6869  _as_jax_array(hi
+00004600: 6768 290a 2020 2020 6966 2068 6967 6820  gh).    if high 
+00004610: 6973 204e 6f6e 653a 0a20 2020 2020 2068  is None:.      h
+00004620: 6967 6820 3d20 6c6f 770a 2020 2020 2020  igh = low.      
+00004630: 6c6f 7720 3d20 300a 2020 2020 6869 6768  low = 0.    high
+00004640: 203d 205f 6368 6563 6b5f 7079 5f73 6571   = _check_py_seq
+00004650: 2868 6967 6829 0a20 2020 206c 6f77 203d  (high).    low =
+00004660: 205f 6368 6563 6b5f 7079 5f73 6571 286c   _check_py_seq(l
+00004670: 6f77 290a 2020 2020 6966 2073 697a 6520  ow).    if size 
+00004680: 6973 204e 6f6e 653a 0a20 2020 2020 2073  is None:.      s
+00004690: 697a 6520 3d20 6c61 782e 6272 6f61 6463  ize = lax.broadc
+000046a0: 6173 745f 7368 6170 6573 286a 6e70 2e73  ast_shapes(jnp.s
+000046b0: 6861 7065 286c 6f77 292c 0a20 2020 2020  hape(low),.     
+000046c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000046d0: 2020 2020 2020 2020 2020 2020 206a 6e70               jnp
+000046e0: 2e73 6861 7065 2868 6967 6829 290a 2020  .shape(high)).  
+000046f0: 2020 6b65 7920 3d20 7365 6c66 2e73 706c    key = self.spl
+00004700: 6974 5f6b 6579 2829 2069 6620 6b65 7920  it_key() if key 
+00004710: 6973 204e 6f6e 6520 656c 7365 205f 666f  is None else _fo
+00004720: 726d 616c 697a 655f 6b65 7928 6b65 7929  rmalize_key(key)
+00004730: 0a20 2020 2072 203d 206a 722e 7261 6e64  .    r = jr.rand
+00004740: 696e 7428 6b65 792c 0a20 2020 2020 2020  int(key,.       
+00004750: 2020 2020 2020 2020 2020 2020 7368 6170              shap
+00004760: 653d 5f73 697a 6532 7368 6170 6528 7369  e=_size2shape(si
+00004770: 7a65 292c 0a20 2020 2020 2020 2020 2020  ze),.           
+00004780: 2020 2020 2020 2020 6d69 6e76 616c 3d6c          minval=l
+00004790: 6f77 2c20 6d61 7876 616c 3d68 6967 682c  ow, maxval=high,
+000047a0: 2064 7479 7065 3d64 7479 7065 290a 2020   dtype=dtype).  
+000047b0: 2020 7265 7475 726e 205f 7265 7475 726e    return _return
+000047c0: 2872 290a 0a20 2064 6566 2072 616e 646f  (r)..  def rando
+000047d0: 6d5f 696e 7465 6765 7273 2873 656c 662c  m_integers(self,
+000047e0: 206c 6f77 2c20 6869 6768 3d4e 6f6e 652c   low, high=None,
+000047f0: 2073 697a 653d 4e6f 6e65 2c20 6b65 793d   size=None, key=
+00004800: 4e6f 6e65 293a 0a20 2020 206c 6f77 203d  None):.    low =
+00004810: 205f 6173 5f6a 6178 5f61 7272 6179 286c   _as_jax_array(l
+00004820: 6f77 290a 2020 2020 6869 6768 203d 205f  ow).    high = _
+00004830: 6173 5f6a 6178 5f61 7272 6179 2868 6967  as_jax_array(hig
+00004840: 6829 0a20 2020 206c 6f77 203d 205f 6368  h).    low = _ch
+00004850: 6563 6b5f 7079 5f73 6571 286c 6f77 290a  eck_py_seq(low).
+00004860: 2020 2020 6869 6768 203d 205f 6368 6563      high = _chec
+00004870: 6b5f 7079 5f73 6571 2868 6967 6829 0a20  k_py_seq(high). 
+00004880: 2020 2069 6620 6869 6768 2069 7320 4e6f     if high is No
+00004890: 6e65 3a0a 2020 2020 2020 6869 6768 203d  ne:.      high =
+000048a0: 206c 6f77 0a20 2020 2020 206c 6f77 203d   low.      low =
+000048b0: 2031 0a20 2020 2068 6967 6820 2b3d 2031   1.    high += 1
+000048c0: 0a20 2020 2069 6620 7369 7a65 2069 7320  .    if size is 
+000048d0: 4e6f 6e65 3a0a 2020 2020 2020 7369 7a65  None:.      size
+000048e0: 203d 206c 6178 2e62 726f 6164 6361 7374   = lax.broadcast
+000048f0: 5f73 6861 7065 7328 6a6e 702e 7368 6170  _shapes(jnp.shap
+00004900: 6528 6c6f 7729 2c20 6a6e 702e 7368 6170  e(low), jnp.shap
+00004910: 6528 6869 6768 2929 0a20 2020 206b 6579  e(high)).    key
+00004920: 203d 2073 656c 662e 7370 6c69 745f 6b65   = self.split_ke
+00004930: 7928 2920 6966 206b 6579 2069 7320 4e6f  y() if key is No
+00004940: 6e65 2065 6c73 6520 5f66 6f72 6d61 6c69  ne else _formali
+00004950: 7a65 5f6b 6579 286b 6579 290a 2020 2020  ze_key(key).    
+00004960: 7220 3d20 6a72 2e72 616e 6469 6e74 286b  r = jr.randint(k
+00004970: 6579 2c0a 2020 2020 2020 2020 2020 2020  ey,.            
+00004980: 2020 2020 2020 2073 6861 7065 3d5f 7369         shape=_si
+00004990: 7a65 3273 6861 7065 2873 697a 6529 2c0a  ze2shape(size),.
+000049a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000049b0: 2020 206d 696e 7661 6c3d 6c6f 772c 0a20     minval=low,. 
+000049c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000049d0: 2020 6d61 7876 616c 3d68 6967 6829 0a20    maxval=high). 
+000049e0: 2020 2072 6574 7572 6e20 5f72 6574 7572     return _retur
+000049f0: 6e28 7229 0a0a 2020 6465 6620 7261 6e64  n(r)..  def rand
+00004a00: 6e28 7365 6c66 2c20 2a64 6e2c 206b 6579  n(self, *dn, key
+00004a10: 3d4e 6f6e 6529 3a0a 2020 2020 6b65 7920  =None):.    key 
+00004a20: 3d20 7365 6c66 2e73 706c 6974 5f6b 6579  = self.split_key
+00004a30: 2829 2069 6620 6b65 7920 6973 204e 6f6e  () if key is Non
+00004a40: 6520 656c 7365 205f 666f 726d 616c 697a  e else _formaliz
+00004a50: 655f 6b65 7928 6b65 7929 0a20 2020 2072  e_key(key).    r
+00004a60: 203d 206a 722e 6e6f 726d 616c 286b 6579   = jr.normal(key
+00004a70: 2c20 7368 6170 653d 646e 290a 2020 2020  , shape=dn).    
+00004a80: 7265 7475 726e 205f 7265 7475 726e 2872  return _return(r
+00004a90: 290a 0a20 2064 6566 2072 616e 646f 6d28  )..  def random(
+00004aa0: 7365 6c66 2c20 7369 7a65 3d4e 6f6e 652c  self, size=None,
+00004ab0: 206b 6579 3d4e 6f6e 6529 3a0a 2020 2020   key=None):.    
+00004ac0: 6b65 7920 3d20 7365 6c66 2e73 706c 6974  key = self.split
+00004ad0: 5f6b 6579 2829 2069 6620 6b65 7920 6973  _key() if key is
+00004ae0: 204e 6f6e 6520 656c 7365 205f 666f 726d   None else _form
+00004af0: 616c 697a 655f 6b65 7928 6b65 7929 0a20  alize_key(key). 
+00004b00: 2020 2072 203d 206a 722e 756e 6966 6f72     r = jr.unifor
+00004b10: 6d28 6b65 792c 2073 6861 7065 3d5f 7369  m(key, shape=_si
+00004b20: 7a65 3273 6861 7065 2873 697a 6529 2c20  ze2shape(size), 
+00004b30: 6d69 6e76 616c 3d30 2e2c 206d 6178 7661  minval=0., maxva
+00004b40: 6c3d 312e 290a 2020 2020 7265 7475 726e  l=1.).    return
+00004b50: 205f 7265 7475 726e 2872 290a 0a20 2064   _return(r)..  d
+00004b60: 6566 2072 616e 646f 6d5f 7361 6d70 6c65  ef random_sample
+00004b70: 2873 656c 662c 2073 697a 653d 4e6f 6e65  (self, size=None
+00004b80: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2020  , key=None):.   
+00004b90: 2072 203d 2073 656c 662e 7261 6e64 6f6d   r = self.random
+00004ba0: 2873 697a 653d 7369 7a65 2c20 6b65 793d  (size=size, key=
+00004bb0: 6b65 7929 0a20 2020 2072 6574 7572 6e20  key).    return 
+00004bc0: 5f72 6574 7572 6e28 7229 0a0a 2020 6465  _return(r)..  de
+00004bd0: 6620 7261 6e66 2873 656c 662c 2073 697a  f ranf(self, siz
+00004be0: 653d 4e6f 6e65 2c20 6b65 793d 4e6f 6e65  e=None, key=None
+00004bf0: 293a 0a20 2020 2072 203d 2073 656c 662e  ):.    r = self.
+00004c00: 7261 6e64 6f6d 2873 697a 653d 7369 7a65  random(size=size
+00004c10: 2c20 6b65 793d 6b65 7929 0a20 2020 2072  , key=key).    r
+00004c20: 6574 7572 6e20 5f72 6574 7572 6e28 7229  eturn _return(r)
+00004c30: 0a0a 2020 6465 6620 7361 6d70 6c65 2873  ..  def sample(s
+00004c40: 656c 662c 2073 697a 653d 4e6f 6e65 2c20  elf, size=None, 
+00004c50: 6b65 793d 4e6f 6e65 293a 0a20 2020 2072  key=None):.    r
+00004c60: 203d 2073 656c 662e 7261 6e64 6f6d 2873   = self.random(s
+00004c70: 697a 653d 7369 7a65 2c20 6b65 793d 6b65  ize=size, key=ke
+00004c80: 7929 0a20 2020 2072 6574 7572 6e20 5f72  y).    return _r
+00004c90: 6574 7572 6e28 7229 0a0a 2020 6465 6620  eturn(r)..  def 
+00004ca0: 6368 6f69 6365 2873 656c 662c 2061 2c20  choice(self, a, 
+00004cb0: 7369 7a65 3d4e 6f6e 652c 2072 6570 6c61  size=None, repla
+00004cc0: 6365 3d54 7275 652c 2070 3d4e 6f6e 652c  ce=True, p=None,
+00004cd0: 206b 6579 3d4e 6f6e 6529 3a0a 2020 2020   key=None):.    
+00004ce0: 6120 3d20 5f61 735f 6a61 785f 6172 7261  a = _as_jax_arra
+00004cf0: 7928 6129 0a20 2020 2070 203d 205f 6173  y(a).    p = _as
+00004d00: 5f6a 6178 5f61 7272 6179 2870 290a 2020  _jax_array(p).  
+00004d10: 2020 6120 3d20 5f63 6865 636b 5f70 795f    a = _check_py_
+00004d20: 7365 7128 6129 0a20 2020 2070 203d 205f  seq(a).    p = _
+00004d30: 6368 6563 6b5f 7079 5f73 6571 2870 290a  check_py_seq(p).
+00004d40: 2020 2020 6b65 7920 3d20 7365 6c66 2e73      key = self.s
+00004d50: 706c 6974 5f6b 6579 2829 2069 6620 6b65  plit_key() if ke
+00004d60: 7920 6973 204e 6f6e 6520 656c 7365 205f  y is None else _
+00004d70: 666f 726d 616c 697a 655f 6b65 7928 6b65  formalize_key(ke
+00004d80: 7929 0a20 2020 2072 203d 206a 722e 6368  y).    r = jr.ch
+00004d90: 6f69 6365 286b 6579 2c20 613d 612c 2073  oice(key, a=a, s
+00004da0: 6861 7065 3d5f 7369 7a65 3273 6861 7065  hape=_size2shape
+00004db0: 2873 697a 6529 2c20 7265 706c 6163 653d  (size), replace=
+00004dc0: 7265 706c 6163 652c 2070 3d70 290a 2020  replace, p=p).  
+00004dd0: 2020 7265 7475 726e 205f 7265 7475 726e    return _return
+00004de0: 2872 290a 0a20 2064 6566 2070 6572 6d75  (r)..  def permu
+00004df0: 7461 7469 6f6e 2873 656c 662c 2078 2c20  tation(self, x, 
+00004e00: 6178 6973 3a20 696e 7420 3d20 302c 2069  axis: int = 0, i
+00004e10: 6e64 6570 656e 6465 6e74 3a20 626f 6f6c  ndependent: bool
+00004e20: 203d 2046 616c 7365 2c20 6b65 793d 4e6f   = False, key=No
+00004e30: 6e65 293a 0a20 2020 2078 203d 2078 2e76  ne):.    x = x.v
+00004e40: 616c 7565 2069 6620 6973 696e 7374 616e  alue if isinstan
+00004e50: 6365 2878 2c20 4172 7261 7929 2065 6c73  ce(x, Array) els
+00004e60: 6520 780a 2020 2020 7820 3d20 5f63 6865  e x.    x = _che
+00004e70: 636b 5f70 795f 7365 7128 7829 0a20 2020  ck_py_seq(x).   
+00004e80: 206b 6579 203d 2073 656c 662e 7370 6c69   key = self.spli
+00004e90: 745f 6b65 7928 2920 6966 206b 6579 2069  t_key() if key i
+00004ea0: 7320 4e6f 6e65 2065 6c73 6520 5f66 6f72  s None else _for
+00004eb0: 6d61 6c69 7a65 5f6b 6579 286b 6579 290a  malize_key(key).
+00004ec0: 2020 2020 7220 3d20 6a72 2e70 6572 6d75      r = jr.permu
+00004ed0: 7461 7469 6f6e 286b 6579 2c20 782c 2061  tation(key, x, a
+00004ee0: 7869 733d 6178 6973 2c20 696e 6465 7065  xis=axis, indepe
+00004ef0: 6e64 656e 743d 696e 6465 7065 6e64 656e  ndent=independen
+00004f00: 7429 0a20 2020 2072 6574 7572 6e20 5f72  t).    return _r
+00004f10: 6574 7572 6e28 7229 0a0a 2020 6465 6620  eturn(r)..  def 
+00004f20: 7368 7566 666c 6528 7365 6c66 2c20 782c  shuffle(self, x,
+00004f30: 2061 7869 733d 302c 206b 6579 3d4e 6f6e   axis=0, key=Non
+00004f40: 6529 3a0a 2020 2020 6966 206e 6f74 2069  e):.    if not i
+00004f50: 7369 6e73 7461 6e63 6528 782c 2041 7272  sinstance(x, Arr
+00004f60: 6179 293a 0a20 2020 2020 2072 6169 7365  ay):.      raise
+00004f70: 2054 7970 6545 7272 6f72 2827 5468 6973   TypeError('This
+00004f80: 206e 756d 7079 206f 7065 7261 746f 7220   numpy operator 
+00004f90: 6e65 6564 7320 696e 2d70 6c61 6365 2075  needs in-place u
+00004fa0: 7064 6174 696e 672c 2074 6865 7265 666f  pdating, therefo
+00004fb0: 7265 2027 0a20 2020 2020 2020 2020 2020  re '.           
+00004fc0: 2020 2020 2020 2020 2020 2027 696e 7075             'inpu
+00004fd0: 7473 2073 686f 756c 6420 6265 2062 7261  ts should be bra
+00004fe0: 696e 7079 2041 7272 6179 2e27 290a 2020  inpy Array.').  
+00004ff0: 2020 6b65 7920 3d20 7365 6c66 2e73 706c    key = self.spl
+00005000: 6974 5f6b 6579 2829 2069 6620 6b65 7920  it_key() if key 
+00005010: 6973 204e 6f6e 6520 656c 7365 205f 666f  is None else _fo
+00005020: 726d 616c 697a 655f 6b65 7928 6b65 7929  rmalize_key(key)
+00005030: 0a20 2020 2078 2e76 616c 7565 203d 206a  .    x.value = j
+00005040: 722e 7065 726d 7574 6174 696f 6e28 6b65  r.permutation(ke
+00005050: 792c 2078 2e76 616c 7565 2c20 6178 6973  y, x.value, axis
+00005060: 3d61 7869 7329 0a0a 2020 6465 6620 6265  =axis)..  def be
+00005070: 7461 2873 656c 662c 2061 2c20 622c 2073  ta(self, a, b, s
+00005080: 697a 653d 4e6f 6e65 2c20 6b65 793d 4e6f  ize=None, key=No
+00005090: 6e65 293a 0a20 2020 2061 203d 2061 2e76  ne):.    a = a.v
+000050a0: 616c 7565 2069 6620 6973 696e 7374 616e  alue if isinstan
+000050b0: 6365 2861 2c20 4172 7261 7929 2065 6c73  ce(a, Array) els
+000050c0: 6520 610a 2020 2020 6220 3d20 622e 7661  e a.    b = b.va
+000050d0: 6c75 6520 6966 2069 7369 6e73 7461 6e63  lue if isinstanc
+000050e0: 6528 622c 2041 7272 6179 2920 656c 7365  e(b, Array) else
+000050f0: 2062 0a20 2020 2061 203d 205f 6368 6563   b.    a = _chec
+00005100: 6b5f 7079 5f73 6571 2861 290a 2020 2020  k_py_seq(a).    
+00005110: 6220 3d20 5f63 6865 636b 5f70 795f 7365  b = _check_py_se
+00005120: 7128 6229 0a20 2020 2069 6620 7369 7a65  q(b).    if size
+00005130: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+00005140: 7369 7a65 203d 206c 6178 2e62 726f 6164  size = lax.broad
+00005150: 6361 7374 5f73 6861 7065 7328 6a6e 702e  cast_shapes(jnp.
+00005160: 7368 6170 6528 6129 2c20 6a6e 702e 7368  shape(a), jnp.sh
+00005170: 6170 6528 6229 290a 2020 2020 6b65 7920  ape(b)).    key 
+00005180: 3d20 7365 6c66 2e73 706c 6974 5f6b 6579  = self.split_key
+00005190: 2829 2069 6620 6b65 7920 6973 204e 6f6e  () if key is Non
+000051a0: 6520 656c 7365 205f 666f 726d 616c 697a  e else _formaliz
+000051b0: 655f 6b65 7928 6b65 7929 0a20 2020 2072  e_key(key).    r
+000051c0: 203d 206a 722e 6265 7461 286b 6579 2c20   = jr.beta(key, 
+000051d0: 613d 612c 2062 3d62 2c20 7368 6170 653d  a=a, b=b, shape=
+000051e0: 5f73 697a 6532 7368 6170 6528 7369 7a65  _size2shape(size
+000051f0: 2929 0a20 2020 2072 6574 7572 6e20 5f72  )).    return _r
+00005200: 6574 7572 6e28 7229 0a0a 2020 6465 6620  eturn(r)..  def 
+00005210: 6578 706f 6e65 6e74 6961 6c28 7365 6c66  exponential(self
+00005220: 2c20 7363 616c 653d 4e6f 6e65 2c20 7369  , scale=None, si
+00005230: 7a65 3d4e 6f6e 652c 206b 6579 3d4e 6f6e  ze=None, key=Non
+00005240: 6529 3a0a 2020 2020 7363 616c 6520 3d20  e):.    scale = 
+00005250: 5f61 735f 6a61 785f 6172 7261 7928 7363  _as_jax_array(sc
+00005260: 616c 6529 0a20 2020 2073 6361 6c65 203d  ale).    scale =
+00005270: 205f 6368 6563 6b5f 7079 5f73 6571 2873   _check_py_seq(s
+00005280: 6361 6c65 290a 2020 2020 6966 2073 697a  cale).    if siz
+00005290: 6520 6973 204e 6f6e 653a 0a20 2020 2020  e is None:.     
+000052a0: 2073 697a 6520 3d20 6a6e 702e 7368 6170   size = jnp.shap
+000052b0: 6528 7363 616c 6529 0a20 2020 206b 6579  e(scale).    key
+000052c0: 203d 2073 656c 662e 7370 6c69 745f 6b65   = self.split_ke
+000052d0: 7928 2920 6966 206b 6579 2069 7320 4e6f  y() if key is No
+000052e0: 6e65 2065 6c73 6520 5f66 6f72 6d61 6c69  ne else _formali
+000052f0: 7a65 5f6b 6579 286b 6579 290a 2020 2020  ze_key(key).    
+00005300: 7220 3d20 6a72 2e65 7870 6f6e 656e 7469  r = jr.exponenti
+00005310: 616c 286b 6579 2c20 7368 6170 653d 5f73  al(key, shape=_s
+00005320: 697a 6532 7368 6170 6528 7369 7a65 2929  ize2shape(size))
+00005330: 0a20 2020 2069 6620 7363 616c 6520 6973  .    if scale is
+00005340: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+00005350: 2072 203d 2072 202f 2073 6361 6c65 0a20   r = r / scale. 
+00005360: 2020 2072 6574 7572 6e20 5f72 6574 7572     return _retur
+00005370: 6e28 7229 0a0a 2020 6465 6620 6761 6d6d  n(r)..  def gamm
+00005380: 6128 7365 6c66 2c20 7368 6170 652c 2073  a(self, shape, s
+00005390: 6361 6c65 3d4e 6f6e 652c 2073 697a 653d  cale=None, size=
+000053a0: 4e6f 6e65 2c20 6b65 793d 4e6f 6e65 293a  None, key=None):
+000053b0: 0a20 2020 2073 6861 7065 203d 205f 6173  .    shape = _as
+000053c0: 5f6a 6178 5f61 7272 6179 2873 6861 7065  _jax_array(shape
+000053d0: 290a 2020 2020 7363 616c 6520 3d20 5f61  ).    scale = _a
+000053e0: 735f 6a61 785f 6172 7261 7928 7363 616c  s_jax_array(scal
+000053f0: 6529 0a20 2020 2073 6861 7065 203d 205f  e).    shape = _
+00005400: 6368 6563 6b5f 7079 5f73 6571 2873 6861  check_py_seq(sha
+00005410: 7065 290a 2020 2020 7363 616c 6520 3d20  pe).    scale = 
+00005420: 5f63 6865 636b 5f70 795f 7365 7128 7363  _check_py_seq(sc
+00005430: 616c 6529 0a20 2020 2069 6620 7369 7a65  ale).    if size
+00005440: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+00005450: 7369 7a65 203d 206c 6178 2e62 726f 6164  size = lax.broad
+00005460: 6361 7374 5f73 6861 7065 7328 6a6e 702e  cast_shapes(jnp.
+00005470: 7368 6170 6528 7368 6170 6529 2c20 6a6e  shape(shape), jn
+00005480: 702e 7368 6170 6528 7363 616c 6529 290a  p.shape(scale)).
+00005490: 2020 2020 6b65 7920 3d20 7365 6c66 2e73      key = self.s
+000054a0: 706c 6974 5f6b 6579 2829 2069 6620 6b65  plit_key() if ke
+000054b0: 7920 6973 204e 6f6e 6520 656c 7365 205f  y is None else _
+000054c0: 666f 726d 616c 697a 655f 6b65 7928 6b65  formalize_key(ke
+000054d0: 7929 0a20 2020 2072 203d 206a 722e 6761  y).    r = jr.ga
+000054e0: 6d6d 6128 6b65 792c 2061 3d73 6861 7065  mma(key, a=shape
+000054f0: 2c20 7368 6170 653d 5f73 697a 6532 7368  , shape=_size2sh
+00005500: 6170 6528 7369 7a65 2929 0a20 2020 2069  ape(size)).    i
+00005510: 6620 7363 616c 6520 6973 206e 6f74 204e  f scale is not N
+00005520: 6f6e 653a 0a20 2020 2020 2072 203d 2072  one:.      r = r
+00005530: 202a 2073 6361 6c65 0a20 2020 2072 6574   * scale.    ret
+00005540: 7572 6e20 5f72 6574 7572 6e28 7229 0a0a  urn _return(r)..
+00005550: 2020 6465 6620 6775 6d62 656c 2873 656c    def gumbel(sel
+00005560: 662c 206c 6f63 3d4e 6f6e 652c 2073 6361  f, loc=None, sca
+00005570: 6c65 3d4e 6f6e 652c 2073 697a 653d 4e6f  le=None, size=No
+00005580: 6e65 2c20 6b65 793d 4e6f 6e65 293a 0a20  ne, key=None):. 
+00005590: 2020 206c 6f63 203d 205f 6173 5f6a 6178     loc = _as_jax
+000055a0: 5f61 7272 6179 286c 6f63 290a 2020 2020  _array(loc).    
+000055b0: 7363 616c 6520 3d20 5f61 735f 6a61 785f  scale = _as_jax_
+000055c0: 6172 7261 7928 7363 616c 6529 0a20 2020  array(scale).   
+000055d0: 206c 6f63 203d 205f 6368 6563 6b5f 7079   loc = _check_py
+000055e0: 5f73 6571 286c 6f63 290a 2020 2020 7363  _seq(loc).    sc
+000055f0: 616c 6520 3d20 5f63 6865 636b 5f70 795f  ale = _check_py_
+00005600: 7365 7128 7363 616c 6529 0a20 2020 2069  seq(scale).    i
+00005610: 6620 7369 7a65 2069 7320 4e6f 6e65 3a0a  f size is None:.
+00005620: 2020 2020 2020 7369 7a65 203d 206c 6178        size = lax
+00005630: 2e62 726f 6164 6361 7374 5f73 6861 7065  .broadcast_shape
+00005640: 7328 6a6e 702e 7368 6170 6528 6c6f 6329  s(jnp.shape(loc)
+00005650: 2c20 6a6e 702e 7368 6170 6528 7363 616c  , jnp.shape(scal
+00005660: 6529 290a 2020 2020 6b65 7920 3d20 7365  e)).    key = se
+00005670: 6c66 2e73 706c 6974 5f6b 6579 2829 2069  lf.split_key() i
+00005680: 6620 6b65 7920 6973 204e 6f6e 6520 656c  f key is None el
+00005690: 7365 205f 666f 726d 616c 697a 655f 6b65  se _formalize_ke
+000056a0: 7928 6b65 7929 0a20 2020 2072 203d 205f  y(key).    r = _
+000056b0: 6c6f 635f 7363 616c 6528 6c6f 632c 2073  loc_scale(loc, s
+000056c0: 6361 6c65 2c20 6a72 2e67 756d 6265 6c28  cale, jr.gumbel(
+000056d0: 6b65 792c 2073 6861 7065 3d5f 7369 7a65  key, shape=_size
+000056e0: 3273 6861 7065 2873 697a 6529 2929 0a20  2shape(size))). 
+000056f0: 2020 2072 6574 7572 6e20 5f72 6574 7572     return _retur
+00005700: 6e28 7229 0a0a 2020 6465 6620 6c61 706c  n(r)..  def lapl
+00005710: 6163 6528 7365 6c66 2c20 6c6f 633d 4e6f  ace(self, loc=No
+00005720: 6e65 2c20 7363 616c 653d 4e6f 6e65 2c20  ne, scale=None, 
+00005730: 7369 7a65 3d4e 6f6e 652c 206b 6579 3d4e  size=None, key=N
+00005740: 6f6e 6529 3a0a 2020 2020 6c6f 6320 3d20  one):.    loc = 
+00005750: 5f61 735f 6a61 785f 6172 7261 7928 6c6f  _as_jax_array(lo
+00005760: 6329 0a20 2020 2073 6361 6c65 203d 205f  c).    scale = _
+00005770: 6173 5f6a 6178 5f61 7272 6179 2873 6361  as_jax_array(sca
+00005780: 6c65 290a 2020 2020 6c6f 6320 3d20 5f63  le).    loc = _c
+00005790: 6865 636b 5f70 795f 7365 7128 6c6f 6329  heck_py_seq(loc)
+000057a0: 0a20 2020 2073 6361 6c65 203d 205f 6368  .    scale = _ch
+000057b0: 6563 6b5f 7079 5f73 6571 2873 6361 6c65  eck_py_seq(scale
+000057c0: 290a 2020 2020 6966 2073 697a 6520 6973  ).    if size is
+000057d0: 204e 6f6e 653a 0a20 2020 2020 2073 697a   None:.      siz
+000057e0: 6520 3d20 6c61 782e 6272 6f61 6463 6173  e = lax.broadcas
+000057f0: 745f 7368 6170 6573 286a 6e70 2e73 6861  t_shapes(jnp.sha
+00005800: 7065 286c 6f63 292c 206a 6e70 2e73 6861  pe(loc), jnp.sha
+00005810: 7065 2873 6361 6c65 2929 0a20 2020 206b  pe(scale)).    k
+00005820: 6579 203d 2073 656c 662e 7370 6c69 745f  ey = self.split_
+00005830: 6b65 7928 2920 6966 206b 6579 2069 7320  key() if key is 
+00005840: 4e6f 6e65 2065 6c73 6520 5f66 6f72 6d61  None else _forma
+00005850: 6c69 7a65 5f6b 6579 286b 6579 290a 2020  lize_key(key).  
+00005860: 2020 7220 3d20 5f6c 6f63 5f73 6361 6c65    r = _loc_scale
+00005870: 286c 6f63 2c20 7363 616c 652c 206a 722e  (loc, scale, jr.
+00005880: 6c61 706c 6163 6528 6b65 792c 2073 6861  laplace(key, sha
+00005890: 7065 3d5f 7369 7a65 3273 6861 7065 2873  pe=_size2shape(s
+000058a0: 697a 6529 2929 0a20 2020 2072 6574 7572  ize))).    retur
+000058b0: 6e20 5f72 6574 7572 6e28 7229 0a0a 2020  n _return(r)..  
+000058c0: 6465 6620 6c6f 6769 7374 6963 2873 656c  def logistic(sel
+000058d0: 662c 206c 6f63 3d4e 6f6e 652c 2073 6361  f, loc=None, sca
+000058e0: 6c65 3d4e 6f6e 652c 2073 697a 653d 4e6f  le=None, size=No
+000058f0: 6e65 2c20 6b65 793d 4e6f 6e65 293a 0a20  ne, key=None):. 
+00005900: 2020 206c 6f63 203d 205f 6173 5f6a 6178     loc = _as_jax
+00005910: 5f61 7272 6179 286c 6f63 290a 2020 2020  _array(loc).    
+00005920: 7363 616c 6520 3d20 5f61 735f 6a61 785f  scale = _as_jax_
+00005930: 6172 7261 7928 7363 616c 6529 0a20 2020  array(scale).   
+00005940: 206c 6f63 203d 205f 6368 6563 6b5f 7079   loc = _check_py
+00005950: 5f73 6571 286c 6f63 290a 2020 2020 7363  _seq(loc).    sc
+00005960: 616c 6520 3d20 5f63 6865 636b 5f70 795f  ale = _check_py_
+00005970: 7365 7128 7363 616c 6529 0a20 2020 2069  seq(scale).    i
+00005980: 6620 7369 7a65 2069 7320 4e6f 6e65 3a0a  f size is None:.
+00005990: 2020 2020 2020 7369 7a65 203d 206c 6178        size = lax
+000059a0: 2e62 726f 6164 6361 7374 5f73 6861 7065  .broadcast_shape
+000059b0: 7328 6a6e 702e 7368 6170 6528 6c6f 6329  s(jnp.shape(loc)
+000059c0: 2c20 6a6e 702e 7368 6170 6528 7363 616c  , jnp.shape(scal
+000059d0: 6529 290a 2020 2020 6b65 7920 3d20 7365  e)).    key = se
+000059e0: 6c66 2e73 706c 6974 5f6b 6579 2829 2069  lf.split_key() i
+000059f0: 6620 6b65 7920 6973 204e 6f6e 6520 656c  f key is None el
+00005a00: 7365 205f 666f 726d 616c 697a 655f 6b65  se _formalize_ke
+00005a10: 7928 6b65 7929 0a20 2020 2072 203d 205f  y(key).    r = _
+00005a20: 6c6f 635f 7363 616c 6528 6c6f 632c 2073  loc_scale(loc, s
+00005a30: 6361 6c65 2c20 6a72 2e6c 6f67 6973 7469  cale, jr.logisti
+00005a40: 6328 6b65 792c 2073 6861 7065 3d5f 7369  c(key, shape=_si
+00005a50: 7a65 3273 6861 7065 2873 697a 6529 2929  ze2shape(size)))
+00005a60: 0a20 2020 2072 6574 7572 6e20 5f72 6574  .    return _ret
+00005a70: 7572 6e28 7229 0a0a 2020 6465 6620 6e6f  urn(r)..  def no
+00005a80: 726d 616c 2873 656c 662c 206c 6f63 3d4e  rmal(self, loc=N
+00005a90: 6f6e 652c 2073 6361 6c65 3d4e 6f6e 652c  one, scale=None,
+00005aa0: 2073 697a 653d 4e6f 6e65 2c20 6b65 793d   size=None, key=
+00005ab0: 4e6f 6e65 293a 0a20 2020 206c 6f63 203d  None):.    loc =
+00005ac0: 205f 6173 5f6a 6178 5f61 7272 6179 286c   _as_jax_array(l
+00005ad0: 6f63 290a 2020 2020 7363 616c 6520 3d20  oc).    scale = 
+00005ae0: 5f61 735f 6a61 785f 6172 7261 7928 7363  _as_jax_array(sc
+00005af0: 616c 6529 0a20 2020 206c 6f63 203d 205f  ale).    loc = _
+00005b00: 6368 6563 6b5f 7079 5f73 6571 286c 6f63  check_py_seq(loc
+00005b10: 290a 2020 2020 7363 616c 6520 3d20 5f63  ).    scale = _c
+00005b20: 6865 636b 5f70 795f 7365 7128 7363 616c  heck_py_seq(scal
+00005b30: 6529 0a20 2020 2069 6620 7369 7a65 2069  e).    if size i
+00005b40: 7320 4e6f 6e65 3a0a 2020 2020 2020 7369  s None:.      si
+00005b50: 7a65 203d 206c 6178 2e62 726f 6164 6361  ze = lax.broadca
+00005b60: 7374 5f73 6861 7065 7328 6a6e 702e 7368  st_shapes(jnp.sh
+00005b70: 6170 6528 7363 616c 6529 2c20 6a6e 702e  ape(scale), jnp.
+00005b80: 7368 6170 6528 6c6f 6329 290a 2020 2020  shape(loc)).    
+00005b90: 6b65 7920 3d20 7365 6c66 2e73 706c 6974  key = self.split
+00005ba0: 5f6b 6579 2829 2069 6620 6b65 7920 6973  _key() if key is
+00005bb0: 204e 6f6e 6520 656c 7365 205f 666f 726d   None else _form
+00005bc0: 616c 697a 655f 6b65 7928 6b65 7929 0a20  alize_key(key). 
+00005bd0: 2020 2072 203d 205f 6c6f 635f 7363 616c     r = _loc_scal
+00005be0: 6528 6c6f 632c 2073 6361 6c65 2c20 6a72  e(loc, scale, jr
+00005bf0: 2e6e 6f72 6d61 6c28 6b65 792c 2073 6861  .normal(key, sha
+00005c00: 7065 3d5f 7369 7a65 3273 6861 7065 2873  pe=_size2shape(s
+00005c10: 697a 6529 2929 0a20 2020 2072 6574 7572  ize))).    retur
+00005c20: 6e20 5f72 6574 7572 6e28 7229 0a0a 2020  n _return(r)..  
+00005c30: 6465 6620 7061 7265 746f 2873 656c 662c  def pareto(self,
+00005c40: 2061 2c20 7369 7a65 3d4e 6f6e 652c 206b   a, size=None, k
+00005c50: 6579 3d4e 6f6e 6529 3a0a 2020 2020 6120  ey=None):.    a 
+00005c60: 3d20 5f61 735f 6a61 785f 6172 7261 7928  = _as_jax_array(
+00005c70: 6129 0a20 2020 2061 203d 205f 6368 6563  a).    a = _chec
+00005c80: 6b5f 7079 5f73 6571 2861 290a 2020 2020  k_py_seq(a).    
+00005c90: 6966 2073 697a 6520 6973 204e 6f6e 653a  if size is None:
+00005ca0: 0a20 2020 2020 2073 697a 6520 3d20 6a6e  .      size = jn
+00005cb0: 702e 7368 6170 6528 6129 0a20 2020 206b  p.shape(a).    k
+00005cc0: 6579 203d 2073 656c 662e 7370 6c69 745f  ey = self.split_
+00005cd0: 6b65 7928 2920 6966 206b 6579 2069 7320  key() if key is 
+00005ce0: 4e6f 6e65 2065 6c73 6520 5f66 6f72 6d61  None else _forma
+00005cf0: 6c69 7a65 5f6b 6579 286b 6579 290a 2020  lize_key(key).  
+00005d00: 2020 7220 3d20 6a72 2e70 6172 6574 6f28    r = jr.pareto(
+00005d10: 6b65 792c 2062 3d61 2c20 7368 6170 653d  key, b=a, shape=
+00005d20: 5f73 697a 6532 7368 6170 6528 7369 7a65  _size2shape(size
+00005d30: 2929 0a20 2020 2072 6574 7572 6e20 5f72  )).    return _r
+00005d40: 6574 7572 6e28 7229 0a0a 2020 6465 6620  eturn(r)..  def 
+00005d50: 706f 6973 736f 6e28 7365 6c66 2c20 6c61  poisson(self, la
+00005d60: 6d3d 312e 302c 2073 697a 653d 4e6f 6e65  m=1.0, size=None
+00005d70: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2020  , key=None):.   
+00005d80: 206c 616d 203d 205f 6368 6563 6b5f 7079   lam = _check_py
+00005d90: 5f73 6571 285f 6173 5f6a 6178 5f61 7272  _seq(_as_jax_arr
+00005da0: 6179 286c 616d 2929 0a20 2020 2069 6620  ay(lam)).    if 
+00005db0: 7369 7a65 2069 7320 4e6f 6e65 3a0a 2020  size is None:.  
+00005dc0: 2020 2020 7369 7a65 203d 206a 6e70 2e73      size = jnp.s
+00005dd0: 6861 7065 286c 616d 290a 2020 2020 6b65  hape(lam).    ke
+00005de0: 7920 3d20 7365 6c66 2e73 706c 6974 5f6b  y = self.split_k
+00005df0: 6579 2829 2069 6620 6b65 7920 6973 204e  ey() if key is N
+00005e00: 6f6e 6520 656c 7365 205f 666f 726d 616c  one else _formal
+00005e10: 697a 655f 6b65 7928 6b65 7929 0a20 2020  ize_key(key).   
+00005e20: 2072 203d 206a 722e 706f 6973 736f 6e28   r = jr.poisson(
+00005e30: 6b65 792c 206c 616d 3d6c 616d 2c20 7368  key, lam=lam, sh
+00005e40: 6170 653d 5f73 697a 6532 7368 6170 6528  ape=_size2shape(
+00005e50: 7369 7a65 2929 0a20 2020 2072 6574 7572  size)).    retur
+00005e60: 6e20 5f72 6574 7572 6e28 7229 0a0a 2020  n _return(r)..  
+00005e70: 6465 6620 7374 616e 6461 7264 5f63 6175  def standard_cau
+00005e80: 6368 7928 7365 6c66 2c20 7369 7a65 3d4e  chy(self, size=N
+00005e90: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
+00005ea0: 2020 2020 6b65 7920 3d20 7365 6c66 2e73      key = self.s
+00005eb0: 706c 6974 5f6b 6579 2829 2069 6620 6b65  plit_key() if ke
+00005ec0: 7920 6973 204e 6f6e 6520 656c 7365 205f  y is None else _
+00005ed0: 666f 726d 616c 697a 655f 6b65 7928 6b65  formalize_key(ke
+00005ee0: 7929 0a20 2020 2072 203d 206a 722e 6361  y).    r = jr.ca
+00005ef0: 7563 6879 286b 6579 2c20 7368 6170 653d  uchy(key, shape=
+00005f00: 5f73 697a 6532 7368 6170 6528 7369 7a65  _size2shape(size
+00005f10: 2929 0a20 2020 2072 6574 7572 6e20 5f72  )).    return _r
+00005f20: 6574 7572 6e28 7229 0a0a 2020 6465 6620  eturn(r)..  def 
+00005f30: 7374 616e 6461 7264 5f65 7870 6f6e 656e  standard_exponen
+00005f40: 7469 616c 2873 656c 662c 2073 697a 653d  tial(self, size=
+00005f50: 4e6f 6e65 2c20 6b65 793d 4e6f 6e65 293a  None, key=None):
+00005f60: 0a20 2020 206b 6579 203d 2073 656c 662e  .    key = self.
+00005f70: 7370 6c69 745f 6b65 7928 2920 6966 206b  split_key() if k
+00005f80: 6579 2069 7320 4e6f 6e65 2065 6c73 6520  ey is None else 
+00005f90: 5f66 6f72 6d61 6c69 7a65 5f6b 6579 286b  _formalize_key(k
+00005fa0: 6579 290a 2020 2020 7220 3d20 6a72 2e65  ey).    r = jr.e
+00005fb0: 7870 6f6e 656e 7469 616c 286b 6579 2c20  xponential(key, 
+00005fc0: 7368 6170 653d 5f73 697a 6532 7368 6170  shape=_size2shap
+00005fd0: 6528 7369 7a65 2929 0a20 2020 2072 6574  e(size)).    ret
+00005fe0: 7572 6e20 5f72 6574 7572 6e28 7229 0a0a  urn _return(r)..
+00005ff0: 2020 6465 6620 7374 616e 6461 7264 5f67    def standard_g
+00006000: 616d 6d61 2873 656c 662c 2073 6861 7065  amma(self, shape
+00006010: 2c20 7369 7a65 3d4e 6f6e 652c 206b 6579  , size=None, key
+00006020: 3d4e 6f6e 6529 3a0a 2020 2020 7368 6170  =None):.    shap
+00006030: 6520 3d20 5f61 735f 6a61 785f 6172 7261  e = _as_jax_arra
+00006040: 7928 7368 6170 6529 0a20 2020 2073 6861  y(shape).    sha
+00006050: 7065 203d 205f 6368 6563 6b5f 7079 5f73  pe = _check_py_s
+00006060: 6571 2873 6861 7065 290a 2020 2020 6966  eq(shape).    if
+00006070: 2073 697a 6520 6973 204e 6f6e 653a 0a20   size is None:. 
+00006080: 2020 2020 2073 697a 6520 3d20 6a6e 702e       size = jnp.
+00006090: 7368 6170 6528 7368 6170 6529 0a20 2020  shape(shape).   
+000060a0: 206b 6579 203d 2073 656c 662e 7370 6c69   key = self.spli
+000060b0: 745f 6b65 7928 2920 6966 206b 6579 2069  t_key() if key i
+000060c0: 7320 4e6f 6e65 2065 6c73 6520 5f66 6f72  s None else _for
+000060d0: 6d61 6c69 7a65 5f6b 6579 286b 6579 290a  malize_key(key).
+000060e0: 2020 2020 7220 3d20 6a72 2e67 616d 6d61      r = jr.gamma
+000060f0: 286b 6579 2c20 613d 7368 6170 652c 2073  (key, a=shape, s
+00006100: 6861 7065 3d5f 7369 7a65 3273 6861 7065  hape=_size2shape
+00006110: 2873 697a 6529 290a 2020 2020 7265 7475  (size)).    retu
+00006120: 726e 205f 7265 7475 726e 2872 290a 0a20  rn _return(r).. 
+00006130: 2064 6566 2073 7461 6e64 6172 645f 6e6f   def standard_no
+00006140: 726d 616c 2873 656c 662c 2073 697a 653d  rmal(self, size=
+00006150: 4e6f 6e65 2c20 6b65 793d 4e6f 6e65 293a  None, key=None):
+00006160: 0a20 2020 206b 6579 203d 2073 656c 662e  .    key = self.
+00006170: 7370 6c69 745f 6b65 7928 2920 6966 206b  split_key() if k
+00006180: 6579 2069 7320 4e6f 6e65 2065 6c73 6520  ey is None else 
+00006190: 5f66 6f72 6d61 6c69 7a65 5f6b 6579 286b  _formalize_key(k
+000061a0: 6579 290a 2020 2020 7220 3d20 6a72 2e6e  ey).    r = jr.n
+000061b0: 6f72 6d61 6c28 6b65 792c 2073 6861 7065  ormal(key, shape
+000061c0: 3d5f 7369 7a65 3273 6861 7065 2873 697a  =_size2shape(siz
+000061d0: 6529 290a 2020 2020 7265 7475 726e 205f  e)).    return _
+000061e0: 7265 7475 726e 2872 290a 0a20 2064 6566  return(r)..  def
+000061f0: 2073 7461 6e64 6172 645f 7428 7365 6c66   standard_t(self
+00006200: 2c20 6466 2c20 7369 7a65 3d4e 6f6e 652c  , df, size=None,
+00006210: 206b 6579 3d4e 6f6e 6529 3a0a 2020 2020   key=None):.    
+00006220: 6466 203d 205f 6173 5f6a 6178 5f61 7272  df = _as_jax_arr
+00006230: 6179 2864 6629 0a20 2020 2064 6620 3d20  ay(df).    df = 
+00006240: 5f63 6865 636b 5f70 795f 7365 7128 6466  _check_py_seq(df
+00006250: 290a 2020 2020 6966 2073 697a 6520 6973  ).    if size is
+00006260: 204e 6f6e 653a 0a20 2020 2020 2073 697a   None:.      siz
+00006270: 6520 3d20 6a6e 702e 7368 6170 6528 7369  e = jnp.shape(si
+00006280: 7a65 290a 2020 2020 6b65 7920 3d20 7365  ze).    key = se
 00006290: 6c66 2e73 706c 6974 5f6b 6579 2829 2069  lf.split_key() i
 000062a0: 6620 6b65 7920 6973 204e 6f6e 6520 656c  f key is None el
 000062b0: 7365 205f 666f 726d 616c 697a 655f 6b65  se _formalize_ke
-000062c0: 7928 6b65 7929 0a20 2020 2072 616e 6473  y(key).    rands
-000062d0: 203d 206a 722e 7472 756e 6361 7465 645f   = jr.truncated_
-000062e0: 6e6f 726d 616c 286b 6579 2c0a 2020 2020  normal(key,.    
-000062f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006300: 2020 2020 2020 2020 2020 2020 6c6f 7765              lowe
-00006310: 723d 6c6f 7765 722c 0a20 2020 2020 2020  r=lower,.       
-00006320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006330: 2020 2020 2020 2020 2075 7070 6572 3d75           upper=u
-00006340: 7070 6572 2c0a 2020 2020 2020 2020 2020  pper,.          
-00006350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006360: 2020 2020 2020 7368 6170 653d 5f73 697a        shape=_siz
-00006370: 6532 7368 6170 6528 7369 7a65 2929 0a20  e2shape(size)). 
-00006380: 2020 2069 6620 7363 616c 6520 6973 206e     if scale is n
-00006390: 6f74 204e 6f6e 653a 0a20 2020 2020 2072  ot None:.      r
-000063a0: 616e 6473 203d 2072 616e 6473 202a 2073  ands = rands * s
-000063b0: 6361 6c65 0a20 2020 2072 6574 7572 6e20  cale.    return 
-000063c0: 5f72 6574 7572 6e28 7261 6e64 7329 0a0a  _return(rands)..
-000063d0: 2020 6465 6620 5f63 6865 636b 5f70 2873    def _check_p(s
-000063e0: 656c 662c 2070 293a 0a20 2020 2072 6169  elf, p):.    rai
-000063f0: 7365 2056 616c 7565 4572 726f 7228 6627  se ValueError(f'
-00006400: 5061 7261 6d65 7465 7220 7020 7368 6f75  Parameter p shou
-00006410: 6c64 2062 6520 7769 7468 696e 205b 302c  ld be within [0,
-00006420: 2031 5d2c 2062 7574 2077 6520 676f 7420   1], but we got 
-00006430: 7b70 7d27 290a 0a20 2064 6566 2062 6572  {p}')..  def ber
-00006440: 6e6f 756c 6c69 2873 656c 662c 2070 2c20  noulli(self, p, 
-00006450: 7369 7a65 3d4e 6f6e 652c 206b 6579 3d4e  size=None, key=N
-00006460: 6f6e 6529 3a0a 2020 2020 7020 3d20 5f63  one):.    p = _c
-00006470: 6865 636b 5f70 795f 7365 7128 5f61 735f  heck_py_seq(_as_
-00006480: 6a61 785f 6172 7261 7928 7029 290a 2020  jax_array(p)).  
-00006490: 2020 6a69 745f 6572 726f 725f 6368 6563    jit_error_chec
-000064a0: 6b69 6e67 286a 6e70 2e61 6e79 286a 6e70  king(jnp.any(jnp
-000064b0: 2e6c 6f67 6963 616c 5f61 6e64 2870 203c  .logical_and(p <
-000064c0: 2030 2c20 7020 3e20 3129 292c 2073 656c   0, p > 1)), sel
-000064d0: 662e 5f63 6865 636b 5f70 2c20 7029 0a20  f._check_p, p). 
-000064e0: 2020 2069 6620 7369 7a65 2069 7320 4e6f     if size is No
-000064f0: 6e65 3a0a 2020 2020 2020 7369 7a65 203d  ne:.      size =
-00006500: 206a 6e70 2e73 6861 7065 2870 290a 2020   jnp.shape(p).  
-00006510: 2020 6b65 7920 3d20 7365 6c66 2e73 706c    key = self.spl
-00006520: 6974 5f6b 6579 2829 2069 6620 6b65 7920  it_key() if key 
-00006530: 6973 204e 6f6e 6520 656c 7365 205f 666f  is None else _fo
-00006540: 726d 616c 697a 655f 6b65 7928 6b65 7929  rmalize_key(key)
-00006550: 0a20 2020 2072 203d 206a 722e 6265 726e  .    r = jr.bern
-00006560: 6f75 6c6c 6928 6b65 792c 2070 3d70 2c20  oulli(key, p=p, 
-00006570: 7368 6170 653d 5f73 697a 6532 7368 6170  shape=_size2shap
-00006580: 6528 7369 7a65 2929 0a20 2020 2072 6574  e(size)).    ret
-00006590: 7572 6e20 5f72 6574 7572 6e28 7229 0a0a  urn _return(r)..
-000065a0: 2020 6465 6620 6c6f 676e 6f72 6d61 6c28    def lognormal(
-000065b0: 7365 6c66 2c20 6d65 616e 3d4e 6f6e 652c  self, mean=None,
-000065c0: 2073 6967 6d61 3d4e 6f6e 652c 2073 697a   sigma=None, siz
-000065d0: 653d 4e6f 6e65 2c20 6b65 793d 4e6f 6e65  e=None, key=None
-000065e0: 293a 0a20 2020 206d 6561 6e20 3d20 5f63  ):.    mean = _c
-000065f0: 6865 636b 5f70 795f 7365 7128 5f61 735f  heck_py_seq(_as_
-00006600: 6a61 785f 6172 7261 7928 6d65 616e 2929  jax_array(mean))
-00006610: 0a20 2020 2073 6967 6d61 203d 205f 6368  .    sigma = _ch
-00006620: 6563 6b5f 7079 5f73 6571 285f 6173 5f6a  eck_py_seq(_as_j
-00006630: 6178 5f61 7272 6179 2873 6967 6d61 2929  ax_array(sigma))
-00006640: 0a20 2020 2069 6620 7369 7a65 2069 7320  .    if size is 
-00006650: 4e6f 6e65 3a0a 2020 2020 2020 7369 7a65  None:.      size
-00006660: 203d 206a 6e70 2e62 726f 6164 6361 7374   = jnp.broadcast
-00006670: 5f73 6861 7065 7328 6a6e 702e 7368 6170  _shapes(jnp.shap
-00006680: 6528 6d65 616e 292c 0a20 2020 2020 2020  e(mean),.       
-00006690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000066a0: 2020 2020 2020 2020 2020 206a 6e70 2e73             jnp.s
-000066b0: 6861 7065 2873 6967 6d61 2929 0a20 2020  hape(sigma)).   
-000066c0: 206b 6579 203d 2073 656c 662e 7370 6c69   key = self.spli
-000066d0: 745f 6b65 7928 2920 6966 206b 6579 2069  t_key() if key i
-000066e0: 7320 4e6f 6e65 2065 6c73 6520 5f66 6f72  s None else _for
-000066f0: 6d61 6c69 7a65 5f6b 6579 286b 6579 290a  malize_key(key).
-00006700: 2020 2020 7361 6d70 6c65 7320 3d20 6a72      samples = jr
-00006710: 2e6e 6f72 6d61 6c28 6b65 792c 2073 6861  .normal(key, sha
-00006720: 7065 3d5f 7369 7a65 3273 6861 7065 2873  pe=_size2shape(s
-00006730: 697a 6529 290a 2020 2020 7361 6d70 6c65  ize)).    sample
-00006740: 7320 3d20 5f6c 6f63 5f73 6361 6c65 286d  s = _loc_scale(m
-00006750: 6561 6e2c 2073 6967 6d61 2c20 7361 6d70  ean, sigma, samp
-00006760: 6c65 7329 0a20 2020 2073 616d 706c 6573  les).    samples
-00006770: 203d 206a 6e70 2e65 7870 2873 616d 706c   = jnp.exp(sampl
-00006780: 6573 290a 2020 2020 7265 7475 726e 205f  es).    return _
-00006790: 7265 7475 726e 2873 616d 706c 6573 290a  return(samples).
-000067a0: 0a20 2064 6566 2062 696e 6f6d 6961 6c28  .  def binomial(
-000067b0: 7365 6c66 2c20 6e2c 2070 2c20 7369 7a65  self, n, p, size
-000067c0: 3d4e 6f6e 652c 206b 6579 3d4e 6f6e 6529  =None, key=None)
-000067d0: 3a0a 2020 2020 6e20 3d20 5f63 6865 636b  :.    n = _check
-000067e0: 5f70 795f 7365 7128 6e2e 7661 6c75 6520  _py_seq(n.value 
-000067f0: 6966 2069 7369 6e73 7461 6e63 6528 6e2c  if isinstance(n,
-00006800: 2041 7272 6179 2920 656c 7365 206e 290a   Array) else n).
-00006810: 2020 2020 7020 3d20 5f63 6865 636b 5f70      p = _check_p
-00006820: 795f 7365 7128 702e 7661 6c75 6520 6966  y_seq(p.value if
-00006830: 2069 7369 6e73 7461 6e63 6528 702c 2041   isinstance(p, A
-00006840: 7272 6179 2920 656c 7365 2070 290a 2020  rray) else p).  
-00006850: 2020 6a69 745f 6572 726f 725f 6368 6563    jit_error_chec
-00006860: 6b69 6e67 286a 6e70 2e61 6e79 286a 6e70  king(jnp.any(jnp
-00006870: 2e6c 6f67 6963 616c 5f61 6e64 2870 203c  .logical_and(p <
-00006880: 2030 2c20 7020 3e20 3129 292c 2073 656c   0, p > 1)), sel
-00006890: 662e 5f63 6865 636b 5f70 2c20 7029 0a20  f._check_p, p). 
-000068a0: 2020 2069 6620 7369 7a65 2069 7320 4e6f     if size is No
-000068b0: 6e65 3a0a 2020 2020 2020 7369 7a65 203d  ne:.      size =
-000068c0: 206a 6e70 2e62 726f 6164 6361 7374 5f73   jnp.broadcast_s
-000068d0: 6861 7065 7328 6a6e 702e 7368 6170 6528  hapes(jnp.shape(
-000068e0: 6e29 2c20 6a6e 702e 7368 6170 6528 7029  n), jnp.shape(p)
-000068f0: 290a 2020 2020 6b65 7920 3d20 7365 6c66  ).    key = self
-00006900: 2e73 706c 6974 5f6b 6579 2829 2069 6620  .split_key() if 
-00006910: 6b65 7920 6973 204e 6f6e 6520 656c 7365  key is None else
-00006920: 205f 666f 726d 616c 697a 655f 6b65 7928   _formalize_key(
-00006930: 6b65 7929 0a20 2020 2072 203d 205f 6269  key).    r = _bi
-00006940: 6e6f 6d69 616c 286b 6579 2c20 702c 206e  nomial(key, p, n
-00006950: 2c20 7368 6170 653d 5f73 697a 6532 7368  , shape=_size2sh
-00006960: 6170 6528 7369 7a65 2929 0a20 2020 2072  ape(size)).    r
-00006970: 6574 7572 6e20 5f72 6574 7572 6e28 7229  eturn _return(r)
-00006980: 0a0a 2020 6465 6620 6368 6973 7175 6172  ..  def chisquar
-00006990: 6528 7365 6c66 2c20 6466 2c20 7369 7a65  e(self, df, size
-000069a0: 3d4e 6f6e 652c 206b 6579 3d4e 6f6e 6529  =None, key=None)
-000069b0: 3a0a 2020 2020 6466 203d 205f 6368 6563  :.    df = _chec
-000069c0: 6b5f 7079 5f73 6571 285f 6173 5f6a 6178  k_py_seq(_as_jax
-000069d0: 5f61 7272 6179 2864 6629 290a 2020 2020  _array(df)).    
-000069e0: 6b65 7920 3d20 7365 6c66 2e73 706c 6974  key = self.split
-000069f0: 5f6b 6579 2829 2069 6620 6b65 7920 6973  _key() if key is
-00006a00: 204e 6f6e 6520 656c 7365 205f 666f 726d   None else _form
-00006a10: 616c 697a 655f 6b65 7928 6b65 7929 0a20  alize_key(key). 
-00006a20: 2020 2069 6620 7369 7a65 2069 7320 4e6f     if size is No
-00006a30: 6e65 3a0a 2020 2020 2020 6966 206a 6e70  ne:.      if jnp
-00006a40: 2e6e 6469 6d28 6466 2920 3d3d 2030 3a0a  .ndim(df) == 0:.
-00006a50: 2020 2020 2020 2020 6469 7374 203d 206a          dist = j
-00006a60: 722e 6e6f 726d 616c 286b 6579 2c20 2864  r.normal(key, (d
-00006a70: 662c 2929 202a 2a20 320a 2020 2020 2020  f,)) ** 2.      
-00006a80: 2020 6469 7374 203d 2064 6973 742e 7375    dist = dist.su
-00006a90: 6d28 290a 2020 2020 2020 656c 7365 3a0a  m().      else:.
-00006aa0: 2020 2020 2020 2020 7261 6973 6520 4e6f          raise No
-00006ab0: 7449 6d70 6c65 6d65 6e74 6564 4572 726f  tImplementedErro
-00006ac0: 7228 2744 6f20 6e6f 7420 7375 7070 6f72  r('Do not suppor
-00006ad0: 7420 6e6f 6e2d 7363 616c 6520 2264 6622  t non-scale "df"
-00006ae0: 2077 6865 6e20 2273 697a 6522 2069 7320   when "size" is 
-00006af0: 4e6f 6e65 2729 0a20 2020 2065 6c73 653a  None').    else:
-00006b00: 0a20 2020 2020 2064 6973 7420 3d20 6a72  .      dist = jr
-00006b10: 2e6e 6f72 6d61 6c28 6b65 792c 2028 6466  .normal(key, (df
-00006b20: 2c29 202b 205f 7369 7a65 3273 6861 7065  ,) + _size2shape
-00006b30: 2873 697a 6529 2920 2a2a 2032 0a20 2020  (size)) ** 2.   
-00006b40: 2020 2064 6973 7420 3d20 6469 7374 2e73     dist = dist.s
-00006b50: 756d 2861 7869 733d 3029 0a20 2020 2072  um(axis=0).    r
-00006b60: 6574 7572 6e20 5f72 6574 7572 6e28 6469  eturn _return(di
-00006b70: 7374 290a 0a20 2064 6566 2064 6972 6963  st)..  def diric
-00006b80: 686c 6574 2873 656c 662c 2061 6c70 6861  hlet(self, alpha
-00006b90: 2c20 7369 7a65 3d4e 6f6e 652c 206b 6579  , size=None, key
-00006ba0: 3d4e 6f6e 6529 3a0a 2020 2020 6b65 7920  =None):.    key 
-00006bb0: 3d20 7365 6c66 2e73 706c 6974 5f6b 6579  = self.split_key
-00006bc0: 2829 2069 6620 6b65 7920 6973 204e 6f6e  () if key is Non
-00006bd0: 6520 656c 7365 205f 666f 726d 616c 697a  e else _formaliz
-00006be0: 655f 6b65 7928 6b65 7929 0a20 2020 2061  e_key(key).    a
-00006bf0: 6c70 6861 203d 205f 6368 6563 6b5f 7079  lpha = _check_py
-00006c00: 5f73 6571 285f 6173 5f6a 6178 5f61 7272  _seq(_as_jax_arr
-00006c10: 6179 2861 6c70 6861 2929 0a20 2020 2072  ay(alpha)).    r
-00006c20: 203d 206a 722e 6469 7269 6368 6c65 7428   = jr.dirichlet(
-00006c30: 6b65 792c 2061 6c70 6861 3d61 6c70 6861  key, alpha=alpha
-00006c40: 2c20 7368 6170 653d 5f73 697a 6532 7368  , shape=_size2sh
-00006c50: 6170 6528 7369 7a65 2929 0a20 2020 2072  ape(size)).    r
-00006c60: 6574 7572 6e20 5f72 6574 7572 6e28 7229  eturn _return(r)
-00006c70: 0a0a 2020 6465 6620 6765 6f6d 6574 7269  ..  def geometri
-00006c80: 6328 7365 6c66 2c20 702c 2073 697a 653d  c(self, p, size=
-00006c90: 4e6f 6e65 2c20 6b65 793d 4e6f 6e65 293a  None, key=None):
-00006ca0: 0a20 2020 2070 203d 205f 6173 5f6a 6178  .    p = _as_jax
-00006cb0: 5f61 7272 6179 2870 290a 2020 2020 7020  _array(p).    p 
-00006cc0: 3d20 5f63 6865 636b 5f70 795f 7365 7128  = _check_py_seq(
-00006cd0: 7029 0a20 2020 2069 6620 7369 7a65 2069  p).    if size i
-00006ce0: 7320 4e6f 6e65 3a0a 2020 2020 2020 7369  s None:.      si
-00006cf0: 7a65 203d 206a 6e70 2e73 6861 7065 2870  ze = jnp.shape(p
-00006d00: 290a 2020 2020 6b65 7920 3d20 7365 6c66  ).    key = self
-00006d10: 2e73 706c 6974 5f6b 6579 2829 2069 6620  .split_key() if 
-00006d20: 6b65 7920 6973 204e 6f6e 6520 656c 7365  key is None else
-00006d30: 205f 666f 726d 616c 697a 655f 6b65 7928   _formalize_key(
-00006d40: 6b65 7929 0a20 2020 2075 203d 206a 722e  key).    u = jr.
-00006d50: 756e 6966 6f72 6d28 6b65 792c 2073 697a  uniform(key, siz
-00006d60: 6529 0a20 2020 2072 203d 206a 6e70 2e66  e).    r = jnp.f
-00006d70: 6c6f 6f72 286a 6e70 2e6c 6f67 3170 282d  loor(jnp.log1p(-
-00006d80: 7529 202f 206a 6e70 2e6c 6f67 3170 282d  u) / jnp.log1p(-
-00006d90: 7029 290a 2020 2020 7265 7475 726e 205f  p)).    return _
-00006da0: 7265 7475 726e 2872 290a 0a20 2064 6566  return(r)..  def
-00006db0: 205f 6368 6563 6b5f 7032 2873 656c 662c   _check_p2(self,
-00006dc0: 2070 293a 0a20 2020 2072 6169 7365 2056   p):.    raise V
-00006dd0: 616c 7565 4572 726f 7228 6627 5765 2072  alueError(f'We r
-00006de0: 6571 7569 7265 2060 7375 6d28 7076 616c  equire `sum(pval
-00006df0: 735b 3a2d 315d 2920 3c3d 2031 602e 2042  s[:-1]) <= 1`. B
-00006e00: 7574 2077 6520 676f 7420 7b70 7d27 290a  ut we got {p}').
-00006e10: 0a20 2064 6566 206d 756c 7469 6e6f 6d69  .  def multinomi
-00006e20: 616c 2873 656c 662c 206e 2c20 7076 616c  al(self, n, pval
-00006e30: 732c 2073 697a 653d 4e6f 6e65 2c20 6b65  s, size=None, ke
-00006e40: 793d 4e6f 6e65 293a 0a20 2020 206b 6579  y=None):.    key
-00006e50: 203d 2073 656c 662e 7370 6c69 745f 6b65   = self.split_ke
-00006e60: 7928 2920 6966 206b 6579 2069 7320 4e6f  y() if key is No
-00006e70: 6e65 2065 6c73 6520 5f66 6f72 6d61 6c69  ne else _formali
-00006e80: 7a65 5f6b 6579 286b 6579 290a 2020 2020  ze_key(key).    
-00006e90: 6e20 3d20 5f63 6865 636b 5f70 795f 7365  n = _check_py_se
-00006ea0: 7128 5f61 735f 6a61 785f 6172 7261 7928  q(_as_jax_array(
-00006eb0: 6e29 290a 2020 2020 7076 616c 7320 3d20  n)).    pvals = 
-00006ec0: 5f63 6865 636b 5f70 795f 7365 7128 5f61  _check_py_seq(_a
-00006ed0: 735f 6a61 785f 6172 7261 7928 7076 616c  s_jax_array(pval
-00006ee0: 7329 290a 2020 2020 6a69 745f 6572 726f  s)).    jit_erro
-00006ef0: 725f 6368 6563 6b69 6e67 286a 6e70 2e73  r_checking(jnp.s
-00006f00: 756d 2870 7661 6c73 5b3a 2d31 5d29 203e  um(pvals[:-1]) >
-00006f10: 2031 2e2c 2073 656c 662e 5f63 6865 636b   1., self._check
-00006f20: 5f70 322c 2070 7661 6c73 290a 2020 2020  _p2, pvals).    
-00006f30: 6966 2069 7369 6e73 7461 6e63 6528 6e2c  if isinstance(n,
-00006f40: 206a 6178 2e63 6f72 652e 5472 6163 6572   jax.core.Tracer
-00006f50: 293a 0a20 2020 2020 2072 6169 7365 2056  ):.      raise V
-00006f60: 616c 7565 4572 726f 7228 2254 6865 2074  alueError("The t
-00006f70: 6f74 616c 2063 6f75 6e74 2070 6172 616d  otal count param
-00006f80: 6574 6572 2060 6e60 2073 686f 756c 6420  eter `n` should 
-00006f90: 6e6f 7420 6265 2061 206a 6178 2061 6273  not be a jax abs
-00006fa0: 7472 6163 7420 6172 7261 792e 2229 0a20  tract array."). 
-00006fb0: 2020 2073 697a 6520 3d20 5f73 697a 6532     size = _size2
-00006fc0: 7368 6170 6528 7369 7a65 290a 2020 2020  shape(size).    
-00006fd0: 6e5f 6d61 7820 3d20 696e 7428 6e70 2e6d  n_max = int(np.m
-00006fe0: 6178 286a 6178 2e64 6576 6963 655f 6765  ax(jax.device_ge
-00006ff0: 7428 6e29 2929 0a20 2020 2062 6174 6368  t(n))).    batch
-00007000: 5f73 6861 7065 203d 206c 6178 2e62 726f  _shape = lax.bro
-00007010: 6164 6361 7374 5f73 6861 7065 7328 6a6e  adcast_shapes(jn
-00007020: 702e 7368 6170 6528 7076 616c 7329 5b3a  p.shape(pvals)[:
-00007030: 2d31 5d2c 206a 6e70 2e73 6861 7065 286e  -1], jnp.shape(n
-00007040: 2929 0a20 2020 2072 203d 205f 6d75 6c74  )).    r = _mult
-00007050: 696e 6f6d 6961 6c28 6b65 792c 2070 7661  inomial(key, pva
-00007060: 6c73 2c20 6e2c 206e 5f6d 6178 2c20 6261  ls, n, n_max, ba
-00007070: 7463 685f 7368 6170 6520 2b20 7369 7a65  tch_shape + size
-00007080: 290a 2020 2020 7265 7475 726e 205f 7265  ).    return _re
-00007090: 7475 726e 2872 290a 0a20 2064 6566 206d  turn(r)..  def m
-000070a0: 756c 7469 7661 7269 6174 655f 6e6f 726d  ultivariate_norm
-000070b0: 616c 2873 656c 662c 206d 6561 6e2c 2063  al(self, mean, c
-000070c0: 6f76 2c20 7369 7a65 3d4e 6f6e 652c 206d  ov, size=None, m
-000070d0: 6574 686f 643a 2073 7472 203d 2027 6368  ethod: str = 'ch
-000070e0: 6f6c 6573 6b79 272c 206b 6579 3d4e 6f6e  olesky', key=Non
-000070f0: 6529 3a0a 2020 2020 6966 206d 6574 686f  e):.    if metho
-00007100: 6420 6e6f 7420 696e 207b 2773 7664 272c  d not in {'svd',
-00007110: 2027 6569 6768 272c 2027 6368 6f6c 6573   'eigh', 'choles
-00007120: 6b79 277d 3a0a 2020 2020 2020 7261 6973  ky'}:.      rais
-00007130: 6520 5661 6c75 6545 7272 6f72 2822 6d65  e ValueError("me
-00007140: 7468 6f64 206d 7573 7420 6265 206f 6e65  thod must be one
-00007150: 206f 6620 7b27 7376 6427 2c20 2765 6967   of {'svd', 'eig
-00007160: 6827 2c20 2763 686f 6c65 736b 7927 7d22  h', 'cholesky'}"
-00007170: 290a 2020 2020 6d65 616e 203d 205f 6368  ).    mean = _ch
-00007180: 6563 6b5f 7079 5f73 6571 285f 6173 5f6a  eck_py_seq(_as_j
-00007190: 6178 5f61 7272 6179 286d 6561 6e29 290a  ax_array(mean)).
-000071a0: 2020 2020 636f 7620 3d20 5f63 6865 636b      cov = _check
-000071b0: 5f70 795f 7365 7128 5f61 735f 6a61 785f  _py_seq(_as_jax_
-000071c0: 6172 7261 7928 636f 7629 290a 2020 2020  array(cov)).    
-000071d0: 6b65 7920 3d20 7365 6c66 2e73 706c 6974  key = self.split
-000071e0: 5f6b 6579 2829 2069 6620 6b65 7920 6973  _key() if key is
-000071f0: 204e 6f6e 6520 656c 7365 205f 666f 726d   None else _form
-00007200: 616c 697a 655f 6b65 7928 6b65 7929 0a0a  alize_key(key)..
-00007210: 2020 2020 6966 206e 6f74 206a 6e70 2e6e      if not jnp.n
-00007220: 6469 6d28 6d65 616e 2920 3e3d 2031 3a0a  dim(mean) >= 1:.
-00007230: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-00007240: 6545 7272 6f72 2866 226d 756c 7469 7661  eError(f"multiva
-00007250: 7269 6174 655f 6e6f 726d 616c 2072 6571  riate_normal req
-00007260: 7569 7265 7320 6d65 616e 2e6e 6469 6d20  uires mean.ndim 
-00007270: 3e3d 2031 2c20 676f 7420 6d65 616e 2e6e  >= 1, got mean.n
-00007280: 6469 6d20 3d3d 207b 6a6e 702e 6e64 696d  dim == {jnp.ndim
-00007290: 286d 6561 6e29 7d22 290a 2020 2020 6966  (mean)}").    if
-000072a0: 206e 6f74 206a 6e70 2e6e 6469 6d28 636f   not jnp.ndim(co
-000072b0: 7629 203e 3d20 323a 0a20 2020 2020 2072  v) >= 2:.      r
-000072c0: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-000072d0: 6622 6d75 6c74 6976 6172 6961 7465 5f6e  f"multivariate_n
-000072e0: 6f72 6d61 6c20 7265 7175 6972 6573 2063  ormal requires c
-000072f0: 6f76 2e6e 6469 6d20 3e3d 2032 2c20 676f  ov.ndim >= 2, go
-00007300: 7420 636f 762e 6e64 696d 203d 3d20 7b6a  t cov.ndim == {j
-00007310: 6e70 2e6e 6469 6d28 636f 7629 7d22 290a  np.ndim(cov)}").
-00007320: 2020 2020 6e20 3d20 6d65 616e 2e73 6861      n = mean.sha
-00007330: 7065 5b2d 315d 0a20 2020 2069 6620 6a6e  pe[-1].    if jn
-00007340: 702e 7368 6170 6528 636f 7629 5b2d 323a  p.shape(cov)[-2:
-00007350: 5d20 213d 2028 6e2c 206e 293a 0a20 2020  ] != (n, n):.   
-00007360: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-00007370: 726f 7228 6622 6d75 6c74 6976 6172 6961  ror(f"multivaria
-00007380: 7465 5f6e 6f72 6d61 6c20 7265 7175 6972  te_normal requir
-00007390: 6573 2063 6f76 2e73 6861 7065 203d 3d20  es cov.shape == 
-000073a0: 282e 2e2e 2c20 6e2c 206e 2920 666f 7220  (..., n, n) for 
-000073b0: 6e3d 7b6e 7d2c 2022 0a20 2020 2020 2020  n={n}, ".       
-000073c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000073d0: 6622 6275 7420 676f 7420 636f 762e 7368  f"but got cov.sh
-000073e0: 6170 6520 3d3d 207b 6a6e 702e 7368 6170  ape == {jnp.shap
-000073f0: 6528 636f 7629 7d2e 2229 0a20 2020 2069  e(cov)}.").    i
-00007400: 6620 7369 7a65 2069 7320 4e6f 6e65 3a0a  f size is None:.
-00007410: 2020 2020 2020 7369 7a65 203d 206c 6178        size = lax
-00007420: 2e62 726f 6164 6361 7374 5f73 6861 7065  .broadcast_shape
-00007430: 7328 6d65 616e 2e73 6861 7065 5b3a 2d31  s(mean.shape[:-1
-00007440: 5d2c 2063 6f76 2e73 6861 7065 5b3a 2d32  ], cov.shape[:-2
-00007450: 5d29 0a20 2020 2065 6c73 653a 0a20 2020  ]).    else:.   
-00007460: 2020 2073 697a 6520 3d20 5f73 697a 6532     size = _size2
-00007470: 7368 6170 6528 7369 7a65 290a 2020 2020  shape(size).    
-00007480: 2020 5f63 6865 636b 5f73 6861 7065 2822    _check_shape("
-00007490: 6e6f 726d 616c 222c 2073 697a 652c 206d  normal", size, m
-000074a0: 6561 6e2e 7368 6170 655b 3a2d 315d 2c20  ean.shape[:-1], 
-000074b0: 636f 762e 7368 6170 655b 3a2d 325d 290a  cov.shape[:-2]).
-000074c0: 0a20 2020 2069 6620 6d65 7468 6f64 203d  .    if method =
-000074d0: 3d20 2773 7664 273a 0a20 2020 2020 2028  = 'svd':.      (
-000074e0: 752c 2073 2c20 5f29 203d 206a 6e70 2e6c  u, s, _) = jnp.l
-000074f0: 696e 616c 672e 7376 6428 636f 7629 0a20  inalg.svd(cov). 
-00007500: 2020 2020 2066 6163 746f 7220 3d20 7520       factor = u 
-00007510: 2a20 6a6e 702e 7371 7274 2873 5b2e 2e2e  * jnp.sqrt(s[...
-00007520: 2c20 4e6f 6e65 2c20 3a5d 290a 2020 2020  , None, :]).    
-00007530: 656c 6966 206d 6574 686f 6420 3d3d 2027  elif method == '
-00007540: 6569 6768 273a 0a20 2020 2020 2028 772c  eigh':.      (w,
-00007550: 2076 2920 3d20 6a6e 702e 6c69 6e61 6c67   v) = jnp.linalg
-00007560: 2e65 6967 6828 636f 7629 0a20 2020 2020  .eigh(cov).     
-00007570: 2066 6163 746f 7220 3d20 7620 2a20 6a6e   factor = v * jn
-00007580: 702e 7371 7274 2877 5b2e 2e2e 2c20 4e6f  p.sqrt(w[..., No
-00007590: 6e65 2c20 3a5d 290a 2020 2020 656c 7365  ne, :]).    else
-000075a0: 3a20 2023 2027 6368 6f6c 6573 6b79 270a  :  # 'cholesky'.
-000075b0: 2020 2020 2020 6661 6374 6f72 203d 206a        factor = j
-000075c0: 6e70 2e6c 696e 616c 672e 6368 6f6c 6573  np.linalg.choles
-000075d0: 6b79 2863 6f76 290a 2020 2020 6e6f 726d  ky(cov).    norm
-000075e0: 616c 5f73 616d 706c 6573 203d 206a 722e  al_samples = jr.
-000075f0: 6e6f 726d 616c 286b 6579 2c20 7369 7a65  normal(key, size
-00007600: 202b 206d 6561 6e2e 7368 6170 655b 2d31   + mean.shape[-1
-00007610: 3a5d 290a 2020 2020 7220 3d20 6d65 616e  :]).    r = mean
-00007620: 202b 206a 6e70 2e65 696e 7375 6d28 272e   + jnp.einsum('.
-00007630: 2e2e 696a 2c2e 2e2e 6a2d 3e2e 2e2e 6927  ..ij,...j->...i'
-00007640: 2c20 6661 6374 6f72 2c20 6e6f 726d 616c  , factor, normal
-00007650: 5f73 616d 706c 6573 290a 2020 2020 7265  _samples).    re
-00007660: 7475 726e 205f 7265 7475 726e 2872 290a  turn _return(r).
-00007670: 0a20 2064 6566 2072 6179 6c65 6967 6828  .  def rayleigh(
-00007680: 7365 6c66 2c20 7363 616c 653d 312e 302c  self, scale=1.0,
-00007690: 2073 697a 653d 4e6f 6e65 2c20 6b65 793d   size=None, key=
-000076a0: 4e6f 6e65 293a 0a20 2020 2073 6361 6c65  None):.    scale
-000076b0: 203d 205f 6368 6563 6b5f 7079 5f73 6571   = _check_py_seq
-000076c0: 285f 6173 5f6a 6178 5f61 7272 6179 2873  (_as_jax_array(s
-000076d0: 6361 6c65 2929 0a20 2020 2069 6620 7369  cale)).    if si
-000076e0: 7a65 2069 7320 4e6f 6e65 3a0a 2020 2020  ze is None:.    
-000076f0: 2020 7369 7a65 203d 206a 6e70 2e73 6861    size = jnp.sha
-00007700: 7065 2873 6361 6c65 290a 2020 2020 6b65  pe(scale).    ke
-00007710: 7920 3d20 7365 6c66 2e73 706c 6974 5f6b  y = self.split_k
-00007720: 6579 2829 2069 6620 6b65 7920 6973 204e  ey() if key is N
-00007730: 6f6e 6520 656c 7365 205f 666f 726d 616c  one else _formal
-00007740: 697a 655f 6b65 7928 6b65 7929 0a20 2020  ize_key(key).   
-00007750: 2078 203d 206a 6e70 2e73 7172 7428 2d32   x = jnp.sqrt(-2
-00007760: 2e20 2a20 6a6e 702e 6c6f 6728 6a72 2e75  . * jnp.log(jr.u
-00007770: 6e69 666f 726d 286b 6579 2c20 7368 6170  niform(key, shap
-00007780: 653d 5f73 697a 6532 7368 6170 6528 7369  e=_size2shape(si
-00007790: 7a65 292c 206d 696e 7661 6c3d 302c 206d  ze), minval=0, m
-000077a0: 6178 7661 6c3d 3129 2929 0a20 2020 2072  axval=1))).    r
-000077b0: 203d 2078 202a 2073 6361 6c65 0a20 2020   = x * scale.   
-000077c0: 2072 6574 7572 6e20 5f72 6574 7572 6e28   return _return(
-000077d0: 7229 0a0a 2020 6465 6620 7472 6961 6e67  r)..  def triang
-000077e0: 756c 6172 2873 656c 662c 2073 697a 653d  ular(self, size=
-000077f0: 4e6f 6e65 2c20 6b65 793d 4e6f 6e65 293a  None, key=None):
-00007800: 0a20 2020 206b 6579 203d 2073 656c 662e  .    key = self.
-00007810: 7370 6c69 745f 6b65 7928 2920 6966 206b  split_key() if k
-00007820: 6579 2069 7320 4e6f 6e65 2065 6c73 6520  ey is None else 
-00007830: 5f66 6f72 6d61 6c69 7a65 5f6b 6579 286b  _formalize_key(k
-00007840: 6579 290a 2020 2020 6265 726e 6f75 6c6c  ey).    bernoull
-00007850: 695f 7361 6d70 6c65 7320 3d20 6a72 2e62  i_samples = jr.b
-00007860: 6572 6e6f 756c 6c69 286b 6579 2c20 703d  ernoulli(key, p=
-00007870: 302e 352c 2073 6861 7065 3d5f 7369 7a65  0.5, shape=_size
-00007880: 3273 6861 7065 2873 697a 6529 290a 2020  2shape(size)).  
-00007890: 2020 7220 3d20 3220 2a20 6265 726e 6f75    r = 2 * bernou
-000078a0: 6c6c 695f 7361 6d70 6c65 7320 2d20 310a  lli_samples - 1.
-000078b0: 2020 2020 7265 7475 726e 205f 7265 7475      return _retu
-000078c0: 726e 2872 290a 0a20 2064 6566 2076 6f6e  rn(r)..  def von
-000078d0: 6d69 7365 7328 7365 6c66 2c20 6d75 2c20  mises(self, mu, 
-000078e0: 6b61 7070 612c 2073 697a 653d 4e6f 6e65  kappa, size=None
-000078f0: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2020  , key=None):.   
-00007900: 206b 6579 203d 2073 656c 662e 7370 6c69   key = self.spli
-00007910: 745f 6b65 7928 2920 6966 206b 6579 2069  t_key() if key i
-00007920: 7320 4e6f 6e65 2065 6c73 6520 5f66 6f72  s None else _for
-00007930: 6d61 6c69 7a65 5f6b 6579 286b 6579 290a  malize_key(key).
-00007940: 2020 2020 6d75 203d 205f 6368 6563 6b5f      mu = _check_
-00007950: 7079 5f73 6571 285f 6173 5f6a 6178 5f61  py_seq(_as_jax_a
-00007960: 7272 6179 286d 7529 290a 2020 2020 6b61  rray(mu)).    ka
-00007970: 7070 6120 3d20 5f63 6865 636b 5f70 795f  ppa = _check_py_
-00007980: 7365 7128 5f61 735f 6a61 785f 6172 7261  seq(_as_jax_arra
-00007990: 7928 6b61 7070 6129 290a 2020 2020 6966  y(kappa)).    if
-000079a0: 2073 697a 6520 6973 204e 6f6e 653a 0a20   size is None:. 
-000079b0: 2020 2020 2073 697a 6520 3d20 6c61 782e       size = lax.
-000079c0: 6272 6f61 6463 6173 745f 7368 6170 6573  broadcast_shapes
-000079d0: 286a 6e70 2e73 6861 7065 286d 7529 2c20  (jnp.shape(mu), 
-000079e0: 6a6e 702e 7368 6170 6528 6b61 7070 6129  jnp.shape(kappa)
-000079f0: 290a 2020 2020 7369 7a65 203d 205f 7369  ).    size = _si
-00007a00: 7a65 3273 6861 7065 2873 697a 6529 0a20  ze2shape(size). 
-00007a10: 2020 2073 616d 706c 6573 203d 205f 766f     samples = _vo
-00007a20: 6e5f 6d69 7365 735f 6365 6e74 6572 6564  n_mises_centered
-00007a30: 286b 6579 2c20 6b61 7070 612c 2073 697a  (key, kappa, siz
-00007a40: 6529 0a20 2020 2073 616d 706c 6573 203d  e).    samples =
-00007a50: 2073 616d 706c 6573 202b 206d 750a 2020   samples + mu.  
-00007a60: 2020 7361 6d70 6c65 7320 3d20 2873 616d    samples = (sam
-00007a70: 706c 6573 202b 206a 6e70 2e70 6929 2025  ples + jnp.pi) %
-00007a80: 2028 322e 3020 2a20 6a6e 702e 7069 2920   (2.0 * jnp.pi) 
-00007a90: 2d20 6a6e 702e 7069 0a20 2020 2072 6574  - jnp.pi.    ret
-00007aa0: 7572 6e20 5f72 6574 7572 6e28 7361 6d70  urn _return(samp
-00007ab0: 6c65 7329 0a0a 2020 6465 6620 7765 6962  les)..  def weib
-00007ac0: 756c 6c28 7365 6c66 2c20 612c 2073 697a  ull(self, a, siz
-00007ad0: 653d 4e6f 6e65 2c20 6b65 793d 4e6f 6e65  e=None, key=None
-00007ae0: 293a 0a20 2020 206b 6579 203d 2073 656c  ):.    key = sel
-00007af0: 662e 7370 6c69 745f 6b65 7928 2920 6966  f.split_key() if
-00007b00: 206b 6579 2069 7320 4e6f 6e65 2065 6c73   key is None els
-00007b10: 6520 5f66 6f72 6d61 6c69 7a65 5f6b 6579  e _formalize_key
-00007b20: 286b 6579 290a 2020 2020 6120 3d20 5f63  (key).    a = _c
-00007b30: 6865 636b 5f70 795f 7365 7128 5f61 735f  heck_py_seq(_as_
-00007b40: 6a61 785f 6172 7261 7928 6129 290a 2020  jax_array(a)).  
-00007b50: 2020 6966 2073 697a 6520 6973 204e 6f6e    if size is Non
-00007b60: 653a 0a20 2020 2020 2073 697a 6520 3d20  e:.      size = 
-00007b70: 6a6e 702e 7368 6170 6528 6129 0a20 2020  jnp.shape(a).   
-00007b80: 2065 6c73 653a 0a20 2020 2020 2069 6620   else:.      if 
-00007b90: 6a6e 702e 7369 7a65 2861 2920 3e20 313a  jnp.size(a) > 1:
-00007ba0: 0a20 2020 2020 2020 2072 6169 7365 2056  .        raise V
-00007bb0: 616c 7565 4572 726f 7228 6627 2261 2220  alueError(f'"a" 
-00007bc0: 7368 6f75 6c64 2062 6520 6120 7363 616c  should be a scal
-00007bd0: 6172 2077 6865 6e20 2273 697a 6522 2069  ar when "size" i
-00007be0: 7320 7072 6f76 6964 6564 2e20 4275 7420  s provided. But 
-00007bf0: 7765 2067 6f74 207b 617d 2729 0a20 2020  we got {a}').   
-00007c00: 2073 697a 6520 3d20 5f73 697a 6532 7368   size = _size2sh
-00007c10: 6170 6528 7369 7a65 290a 2020 2020 7261  ape(size).    ra
-00007c20: 6e64 6f6d 5f75 6e69 666f 726d 203d 206a  ndom_uniform = j
-00007c30: 722e 756e 6966 6f72 6d28 6b65 793d 6b65  r.uniform(key=ke
-00007c40: 792c 2073 6861 7065 3d73 697a 652c 206d  y, shape=size, m
-00007c50: 696e 7661 6c3d 302c 206d 6178 7661 6c3d  inval=0, maxval=
-00007c60: 3129 0a20 2020 2072 203d 206a 6e70 2e70  1).    r = jnp.p
-00007c70: 6f77 6572 282d 6a6e 702e 6c6f 6731 7028  ower(-jnp.log1p(
-00007c80: 2d72 616e 646f 6d5f 756e 6966 6f72 6d29  -random_uniform)
-00007c90: 2c20 312e 3020 2f20 6129 0a20 2020 2072  , 1.0 / a).    r
-00007ca0: 6574 7572 6e20 5f72 6574 7572 6e28 7229  eturn _return(r)
-00007cb0: 0a0a 2020 6465 6620 7765 6962 756c 6c5f  ..  def weibull_
-00007cc0: 6d69 6e28 7365 6c66 2c20 612c 2073 6361  min(self, a, sca
-00007cd0: 6c65 3d4e 6f6e 652c 2073 697a 653d 4e6f  le=None, size=No
-00007ce0: 6e65 2c20 6b65 793d 4e6f 6e65 293a 0a20  ne, key=None):. 
-00007cf0: 2020 2022 2222 5361 6d70 6c65 2066 726f     """Sample fro
-00007d00: 6d20 6120 5765 6962 756c 6c20 6d69 6e69  m a Weibull mini
-00007d10: 6d75 6d20 6469 7374 7269 6275 7469 6f6e  mum distribution
-00007d20: 2e0a 0a20 2020 2050 6172 616d 6574 6572  ...    Parameter
-00007d30: 730a 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d  s.    ----------
-00007d40: 0a20 2020 2061 3a20 666c 6f61 742c 2061  .    a: float, a
-00007d50: 7272 6179 5f6c 696b 650a 2020 2020 2020  rray_like.      
-00007d60: 5468 6520 636f 6e63 656e 7472 6174 696f  The concentratio
-00007d70: 6e20 7061 7261 6d65 7465 7220 6f66 2074  n parameter of t
-00007d80: 6865 2064 6973 7472 6962 7574 696f 6e2e  he distribution.
-00007d90: 0a20 2020 2073 6361 6c65 3a20 666c 6f61  .    scale: floa
-00007da0: 742c 2061 7272 6179 5f6c 696b 650a 2020  t, array_like.  
-00007db0: 2020 2020 5468 6520 7363 616c 6520 7061      The scale pa
-00007dc0: 7261 6d65 7465 7220 6f66 2074 6865 2064  rameter of the d
-00007dd0: 6973 7472 6962 7574 696f 6e2e 0a20 2020  istribution..   
-00007de0: 2073 697a 653a 206f 7074 696f 6e61 6c2c   size: optional,
-00007df0: 2069 6e74 2c20 7475 706c 6520 6f66 2069   int, tuple of i
-00007e00: 6e74 0a20 2020 2020 2054 6865 2073 6861  nt.      The sha
-00007e10: 7065 2061 6464 6564 2074 6f20 7468 6520  pe added to the 
-00007e20: 7061 7261 6d65 7465 7273 206c 6f63 2061  parameters loc a
-00007e30: 6e64 2073 6361 6c65 2062 726f 6164 6361  nd scale broadca
-00007e40: 7374 6162 6c65 2073 6861 7065 2e0a 0a20  stable shape... 
-00007e50: 2020 2052 6574 7572 6e73 0a20 2020 202d     Returns.    -
-00007e60: 2d2d 2d2d 2d2d 0a20 2020 206f 7574 3a20  ------.    out: 
-00007e70: 6172 7261 795f 6c69 6b65 0a20 2020 2020  array_like.     
-00007e80: 2054 6865 2073 616d 706c 696e 6720 7265   The sampling re
-00007e90: 7375 6c74 732e 0a20 2020 2022 2222 0a20  sults..    """. 
-00007ea0: 2020 206b 6579 203d 2073 656c 662e 7370     key = self.sp
-00007eb0: 6c69 745f 6b65 7928 2920 6966 206b 6579  lit_key() if key
-00007ec0: 2069 7320 4e6f 6e65 2065 6c73 6520 5f66   is None else _f
-00007ed0: 6f72 6d61 6c69 7a65 5f6b 6579 286b 6579  ormalize_key(key
-00007ee0: 290a 2020 2020 6120 3d20 5f63 6865 636b  ).    a = _check
-00007ef0: 5f70 795f 7365 7128 5f61 735f 6a61 785f  _py_seq(_as_jax_
-00007f00: 6172 7261 7928 6129 290a 2020 2020 7363  array(a)).    sc
-00007f10: 616c 6520 3d20 5f63 6865 636b 5f70 795f  ale = _check_py_
-00007f20: 7365 7128 5f61 735f 6a61 785f 6172 7261  seq(_as_jax_arra
-00007f30: 7928 7363 616c 6529 290a 2020 2020 6966  y(scale)).    if
-00007f40: 2073 697a 6520 6973 204e 6f6e 653a 0a20   size is None:. 
-00007f50: 2020 2020 2073 697a 6520 3d20 6a6e 702e       size = jnp.
-00007f60: 6272 6f61 6463 6173 745f 7368 6170 6573  broadcast_shapes
-00007f70: 286a 6e70 2e73 6861 7065 2861 292c 206a  (jnp.shape(a), j
-00007f80: 6e70 2e73 6861 7065 2873 6361 6c65 2929  np.shape(scale))
-00007f90: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
-00007fa0: 2069 6620 6a6e 702e 7369 7a65 2861 2920   if jnp.size(a) 
-00007fb0: 3e20 313a 0a20 2020 2020 2020 2072 6169  > 1:.        rai
-00007fc0: 7365 2056 616c 7565 4572 726f 7228 6627  se ValueError(f'
-00007fd0: 2261 2220 7368 6f75 6c64 2062 6520 6120  "a" should be a 
-00007fe0: 7363 616c 6172 2077 6865 6e20 2273 697a  scalar when "siz
-00007ff0: 6522 2069 7320 7072 6f76 6964 6564 2e20  e" is provided. 
-00008000: 4275 7420 7765 2067 6f74 207b 617d 2729  But we got {a}')
-00008010: 0a20 2020 2073 697a 6520 3d20 5f73 697a  .    size = _siz
-00008020: 6532 7368 6170 6528 7369 7a65 290a 2020  e2shape(size).  
-00008030: 2020 7261 6e64 6f6d 5f75 6e69 666f 726d    random_uniform
-00008040: 203d 206a 722e 756e 6966 6f72 6d28 6b65   = jr.uniform(ke
-00008050: 793d 6b65 792c 2073 6861 7065 3d73 697a  y=key, shape=siz
-00008060: 652c 206d 696e 7661 6c3d 302c 206d 6178  e, minval=0, max
-00008070: 7661 6c3d 3129 0a20 2020 2072 203d 206a  val=1).    r = j
-00008080: 6e70 2e70 6f77 6572 282d 6a6e 702e 6c6f  np.power(-jnp.lo
-00008090: 6731 7028 2d72 616e 646f 6d5f 756e 6966  g1p(-random_unif
-000080a0: 6f72 6d29 2c20 312e 3020 2f20 6129 0a20  orm), 1.0 / a). 
-000080b0: 2020 2069 6620 7363 616c 6520 6973 206e     if scale is n
-000080c0: 6f74 204e 6f6e 653a 0a20 2020 2020 2072  ot None:.      r
-000080d0: 202f 3d20 7363 616c 650a 2020 2020 7265   /= scale.    re
-000080e0: 7475 726e 205f 7265 7475 726e 2872 290a  turn _return(r).
-000080f0: 0a20 2064 6566 206d 6178 7765 6c6c 2873  .  def maxwell(s
-00008100: 656c 662c 2073 697a 653d 4e6f 6e65 2c20  elf, size=None, 
-00008110: 6b65 793d 4e6f 6e65 293a 0a20 2020 206b  key=None):.    k
-00008120: 6579 203d 2073 656c 662e 7370 6c69 745f  ey = self.split_
-00008130: 6b65 7928 2920 6966 206b 6579 2069 7320  key() if key is 
-00008140: 4e6f 6e65 2065 6c73 6520 5f66 6f72 6d61  None else _forma
-00008150: 6c69 7a65 5f6b 6579 286b 6579 290a 2020  lize_key(key).  
-00008160: 2020 7368 6170 6520 3d20 636f 7265 2e63    shape = core.c
-00008170: 616e 6f6e 6963 616c 697a 655f 7368 6170  anonicalize_shap
-00008180: 6528 5f73 697a 6532 7368 6170 6528 7369  e(_size2shape(si
-00008190: 7a65 2929 202b 2028 332c 290a 2020 2020  ze)) + (3,).    
-000081a0: 6e6f 726d 5f72 7673 203d 206a 722e 6e6f  norm_rvs = jr.no
-000081b0: 726d 616c 286b 6579 3d6b 6579 2c20 7368  rmal(key=key, sh
-000081c0: 6170 653d 7368 6170 6529 0a20 2020 2072  ape=shape).    r
-000081d0: 203d 206a 6e70 2e6c 696e 616c 672e 6e6f   = jnp.linalg.no
-000081e0: 726d 286e 6f72 6d5f 7276 732c 2061 7869  rm(norm_rvs, axi
-000081f0: 733d 2d31 290a 2020 2020 7265 7475 726e  s=-1).    return
-00008200: 205f 7265 7475 726e 2872 290a 0a20 2064   _return(r)..  d
-00008210: 6566 206e 6567 6174 6976 655f 6269 6e6f  ef negative_bino
-00008220: 6d69 616c 2873 656c 662c 206e 2c20 702c  mial(self, n, p,
-00008230: 2073 697a 653d 4e6f 6e65 2c20 6b65 793d   size=None, key=
-00008240: 4e6f 6e65 293a 0a20 2020 206e 203d 205f  None):.    n = _
-00008250: 6368 6563 6b5f 7079 5f73 6571 285f 6173  check_py_seq(_as
-00008260: 5f6a 6178 5f61 7272 6179 286e 2929 0a20  _jax_array(n)). 
-00008270: 2020 2070 203d 205f 6368 6563 6b5f 7079     p = _check_py
-00008280: 5f73 6571 285f 6173 5f6a 6178 5f61 7272  _seq(_as_jax_arr
-00008290: 6179 2870 2929 0a20 2020 2069 6620 7369  ay(p)).    if si
-000082a0: 7a65 2069 7320 4e6f 6e65 3a0a 2020 2020  ze is None:.    
-000082b0: 2020 7369 7a65 203d 206c 6178 2e62 726f    size = lax.bro
-000082c0: 6164 6361 7374 5f73 6861 7065 7328 6a6e  adcast_shapes(jn
-000082d0: 702e 7368 6170 6528 6e29 2c20 6a6e 702e  p.shape(n), jnp.
-000082e0: 7368 6170 6528 7029 290a 2020 2020 7369  shape(p)).    si
-000082f0: 7a65 203d 205f 7369 7a65 3273 6861 7065  ze = _size2shape
-00008300: 2873 697a 6529 0a20 2020 206c 6f67 6974  (size).    logit
-00008310: 7320 3d20 6a6e 702e 6c6f 6728 7029 202d  s = jnp.log(p) -
-00008320: 206a 6e70 2e6c 6f67 3170 282d 7029 0a20   jnp.log1p(-p). 
-00008330: 2020 2069 6620 6b65 7920 6973 204e 6f6e     if key is Non
-00008340: 653a 0a20 2020 2020 206b 6579 7320 3d20  e:.      keys = 
-00008350: 7365 6c66 2e73 706c 6974 5f6b 6579 7328  self.split_keys(
-00008360: 3229 0a20 2020 2065 6c73 653a 0a20 2020  2).    else:.   
-00008370: 2020 206b 6579 7320 3d20 6a72 2e73 706c     keys = jr.spl
-00008380: 6974 285f 666f 726d 616c 697a 655f 6b65  it(_formalize_ke
-00008390: 7928 6b65 7929 2c20 3229 0a20 2020 2072  y(key), 2).    r
-000083a0: 6174 6520 3d20 7365 6c66 2e67 616d 6d61  ate = self.gamma
-000083b0: 2873 6861 7065 3d6e 2c20 7363 616c 653d  (shape=n, scale=
-000083c0: 6a6e 702e 6578 7028 2d6c 6f67 6974 7329  jnp.exp(-logits)
-000083d0: 2c20 7369 7a65 3d73 697a 652c 206b 6579  , size=size, key
-000083e0: 3d6b 6579 735b 305d 290a 2020 2020 7220  =keys[0]).    r 
-000083f0: 3d20 7365 6c66 2e70 6f69 7373 6f6e 286c  = self.poisson(l
-00008400: 616d 3d72 6174 652c 206b 6579 3d6b 6579  am=rate, key=key
-00008410: 735b 315d 290a 2020 2020 7265 7475 726e  s[1]).    return
-00008420: 205f 7265 7475 726e 2872 290a 0a20 2064   _return(r)..  d
-00008430: 6566 2077 616c 6428 7365 6c66 2c20 6d65  ef wald(self, me
-00008440: 616e 2c20 7363 616c 652c 2073 697a 653d  an, scale, size=
-00008450: 4e6f 6e65 2c20 6b65 793d 4e6f 6e65 293a  None, key=None):
-00008460: 0a20 2020 206b 6579 203d 2073 656c 662e  .    key = self.
-00008470: 7370 6c69 745f 6b65 7928 2920 6966 206b  split_key() if k
-00008480: 6579 2069 7320 4e6f 6e65 2065 6c73 6520  ey is None else 
-00008490: 5f66 6f72 6d61 6c69 7a65 5f6b 6579 286b  _formalize_key(k
-000084a0: 6579 290a 2020 2020 6d65 616e 203d 205f  ey).    mean = _
-000084b0: 6368 6563 6b5f 7079 5f73 6571 285f 6173  check_py_seq(_as
-000084c0: 5f6a 6178 5f61 7272 6179 286d 6561 6e29  _jax_array(mean)
-000084d0: 290a 2020 2020 7363 616c 6520 3d20 5f63  ).    scale = _c
-000084e0: 6865 636b 5f70 795f 7365 7128 5f61 735f  heck_py_seq(_as_
-000084f0: 6a61 785f 6172 7261 7928 7363 616c 6529  jax_array(scale)
-00008500: 290a 2020 2020 6966 2073 697a 6520 6973  ).    if size is
-00008510: 204e 6f6e 653a 0a20 2020 2020 2073 697a   None:.      siz
-00008520: 6520 3d20 6c61 782e 6272 6f61 6463 6173  e = lax.broadcas
-00008530: 745f 7368 6170 6573 286a 6e70 2e73 6861  t_shapes(jnp.sha
-00008540: 7065 286d 6561 6e29 2c20 6a6e 702e 7368  pe(mean), jnp.sh
-00008550: 6170 6528 7363 616c 6529 290a 2020 2020  ape(scale)).    
-00008560: 7369 7a65 203d 205f 7369 7a65 3273 6861  size = _size2sha
-00008570: 7065 2873 697a 6529 0a20 2020 2073 616d  pe(size).    sam
-00008580: 706c 6564 5f63 6869 3220 3d20 6a6e 702e  pled_chi2 = jnp.
-00008590: 7371 7561 7265 285f 6173 5f6a 6178 5f61  square(_as_jax_a
-000085a0: 7272 6179 2873 656c 662e 7261 6e64 6e28  rray(self.randn(
-000085b0: 2a73 697a 6529 2929 0a20 2020 2073 616d  *size))).    sam
-000085c0: 706c 6564 5f75 6e69 666f 726d 203d 205f  pled_uniform = _
-000085d0: 6173 5f6a 6178 5f61 7272 6179 2873 656c  as_jax_array(sel
-000085e0: 662e 756e 6966 6f72 6d28 7369 7a65 3d73  f.uniform(size=s
-000085f0: 697a 652c 206b 6579 3d6b 6579 2929 0a20  ize, key=key)). 
-00008600: 2020 2023 2057 696b 6970 6564 6961 2064     # Wikipedia d
-00008610: 6566 696e 6573 2061 6e20 696e 7465 726d  efines an interm
-00008620: 6564 6961 7465 2078 2077 6974 6820 7468  ediate x with th
-00008630: 6520 666f 726d 756c 610a 2020 2020 2320  e formula.    # 
-00008640: 2020 7820 3d20 6c6f 6320 2b20 6c6f 6320    x = loc + loc 
-00008650: 2a2a 2032 202a 2079 202f 2028 3220 2a20  ** 2 * y / (2 * 
-00008660: 636f 6e63 2920 2d20 6c6f 6320 2f20 2832  conc) - loc / (2
-00008670: 202a 2063 6f6e 6329 202a 2073 7172 7428   * conc) * sqrt(
-00008680: 3420 2a20 6c6f 6320 2a20 636f 6e63 202a  4 * loc * conc *
-00008690: 2079 202b 206c 6f63 202a 2a20 3220 2a20   y + loc ** 2 * 
-000086a0: 7920 2a2a 2032 290a 2020 2020 2320 7768  y ** 2).    # wh
-000086b0: 6572 6520 7920 7e20 4e28 302c 2031 292a  ere y ~ N(0, 1)*
-000086c0: 2a32 2028 7361 6d70 6c65 645f 6368 6932  *2 (sampled_chi2
-000086d0: 2061 626f 7665 2920 616e 6420 636f 6e63   above) and conc
-000086e0: 2069 7320 7468 6520 636f 6e63 656e 7472   is the concentr
-000086f0: 6174 696f 6e2e 0a20 2020 2023 204c 6574  ation..    # Let
-00008700: 2075 7320 7772 6974 650a 2020 2020 2320   us write.    # 
-00008710: 2020 7720 3d20 6c6f 6320 2a20 7920 2f20    w = loc * y / 
-00008720: 2832 202a 2063 6f6e 6329 0a20 2020 2023  (2 * conc).    #
-00008730: 2054 6865 6e20 7765 2063 616e 2065 7874   Then we can ext
-00008740: 7261 6374 2074 6865 2063 6f6d 6d6f 6e20  ract the common 
-00008750: 6661 6374 6f72 2069 6e20 7468 6520 6c61  factor in the la
-00008760: 7374 2074 776f 2074 6572 6d73 2074 6f20  st two terms to 
-00008770: 6f62 7461 696e 0a20 2020 2023 2020 2078  obtain.    #   x
-00008780: 203d 206c 6f63 202b 206c 6f63 202a 2077   = loc + loc * w
-00008790: 202a 2028 3120 2d20 7371 7274 2832 202f   * (1 - sqrt(2 /
-000087a0: 2077 202b 2031 2929 0a20 2020 2023 204e   w + 1)).    # N
-000087b0: 6f77 2077 6520 7365 6520 7468 6174 2074  ow we see that t
-000087c0: 6865 2057 696b 6970 6564 6961 2066 6f72  he Wikipedia for
-000087d0: 6d75 6c61 2073 7566 6665 7273 2066 726f  mula suffers fro
-000087e0: 6d20 6361 7461 7374 7270 6869 630a 2020  m catastrphic.  
-000087f0: 2020 2320 6361 6e63 656c 6c61 7469 6f6e    # cancellation
-00008800: 2066 6f72 206c 6172 6765 2077 2028 652e   for large w (e.
-00008810: 672e 2c20 6966 2063 6f6e 6320 3c3c 206c  g., if conc << l
-00008820: 6f63 292e 0a20 2020 2023 0a20 2020 2023  oc)..    #.    #
-00008830: 2046 6f72 7475 6e61 7465 6c79 2c20 7765   Fortunately, we
-00008840: 2063 616e 2066 6978 2074 6869 7320 6279   can fix this by
-00008850: 206d 756c 7469 706c 7969 6e67 2062 6f74   multiplying bot
-00008860: 6820 7369 6465 730a 2020 2020 2320 6279  h sides.    # by
-00008870: 2031 202b 2073 7172 7428 3220 2f20 7720   1 + sqrt(2 / w 
-00008880: 2b20 3129 2e20 2057 6520 6765 740a 2020  + 1).  We get.  
-00008890: 2020 2320 2020 7820 2a20 2831 202b 2073    #   x * (1 + s
-000088a0: 7172 7428 3220 2f20 7720 2b20 3129 2920  qrt(2 / w + 1)) 
-000088b0: 3d0a 2020 2020 2320 2020 2020 3d20 6c6f  =.    #     = lo
-000088c0: 6320 2a20 2831 202b 2073 7172 7428 3220  c * (1 + sqrt(2 
-000088d0: 2f20 7720 2b20 3129 2920 2b20 6c6f 6320  / w + 1)) + loc 
-000088e0: 2a20 7720 2a20 2831 202d 2028 3220 2f20  * w * (1 - (2 / 
-000088f0: 7720 2b20 3129 290a 2020 2020 2320 2020  w + 1)).    #   
-00008900: 2020 3d20 6c6f 6320 2a20 2873 7172 7428    = loc * (sqrt(
-00008910: 3220 2f20 7720 2b20 3129 202d 2031 290a  2 / w + 1) - 1).
-00008920: 2020 2020 2320 5468 6520 7465 726d 2073      # The term s
-00008930: 7172 7428 3220 2f20 7720 2b20 3129 202b  qrt(2 / w + 1) +
-00008940: 2031 206e 6f20 6c6f 6e67 6572 2070 7265   1 no longer pre
-00008950: 7365 6e74 7320 6e75 6d65 7269 6361 6c0a  sents numerical.
-00008960: 2020 2020 2320 6469 6666 6963 756c 7469      # difficulti
-00008970: 6573 2066 6f72 206c 6172 6765 2077 2c20  es for large w, 
-00008980: 616e 6420 7371 7274 2832 202f 2077 202b  and sqrt(2 / w +
-00008990: 2031 2920 2d20 3120 6973 206a 7573 740a   1) - 1 is just.
-000089a0: 2020 2020 2320 7371 7274 3170 6d31 2832      # sqrt1pm1(2
-000089b0: 202f 2077 292c 2077 6869 6368 2077 6520   / w), which we 
-000089c0: 6b6e 6f77 2068 6f77 2074 6f20 636f 6d70  know how to comp
-000089d0: 7574 6520 6163 6375 7261 7465 6c79 2e0a  ute accurately..
-000089e0: 2020 2020 2320 5468 6973 206a 7573 7420      # This just 
-000089f0: 6c65 6176 6573 2074 6865 206d 6174 7465  leaves the matte
-00008a00: 7220 6f66 2073 6d61 6c6c 2077 2c20 7768  r of small w, wh
-00008a10: 6572 6520 3220 2f20 7720 6d61 790a 2020  ere 2 / w may.  
-00008a20: 2020 2320 6f76 6572 666c 6f77 2e20 2049    # overflow.  I
-00008a30: 6e20 7468 6520 6c69 6d69 7420 6120 7720  n the limit a w 
-00008a40: 2d3e 2030 2c20 7820 2d3e 206c 6f63 2c20  -> 0, x -> loc, 
-00008a50: 736f 2077 6520 6a75 7374 206d 6173 6b0a  so we just mask.
-00008a60: 2020 2020 2320 7468 6174 2063 6173 652e      # that case.
-00008a70: 0a20 2020 2073 7172 7431 706d 315f 6172  .    sqrt1pm1_ar
-00008a80: 6720 3d20 3420 2a20 7363 616c 6520 2f20  g = 4 * scale / 
-00008a90: 286d 6561 6e20 2a20 7361 6d70 6c65 645f  (mean * sampled_
-00008aa0: 6368 6932 2920 2023 2032 202f 2077 2061  chi2)  # 2 / w a
-00008ab0: 626f 7665 0a20 2020 2073 6166 655f 7371  bove.    safe_sq
-00008ac0: 7274 3170 6d31 5f61 7267 203d 206a 6e70  rt1pm1_arg = jnp
-00008ad0: 2e77 6865 7265 2873 7172 7431 706d 315f  .where(sqrt1pm1_
-00008ae0: 6172 6720 3c20 6e70 2e69 6e66 2c20 7371  arg < np.inf, sq
-00008af0: 7274 3170 6d31 5f61 7267 2c20 312e 3029  rt1pm1_arg, 1.0)
-00008b00: 0a20 2020 2064 656e 6f6d 696e 6174 6f72  .    denominator
-00008b10: 203d 2031 2e30 202b 206a 6e70 2e73 7172   = 1.0 + jnp.sqr
-00008b20: 7428 7361 6665 5f73 7172 7431 706d 315f  t(safe_sqrt1pm1_
-00008b30: 6172 6720 2b20 312e 3029 0a20 2020 2072  arg + 1.0).    r
-00008b40: 6174 696f 203d 206a 6e70 2e65 7870 6d31  atio = jnp.expm1
-00008b50: 2830 2e35 202a 206a 6e70 2e6c 6f67 3170  (0.5 * jnp.log1p
-00008b60: 2873 6166 655f 7371 7274 3170 6d31 5f61  (safe_sqrt1pm1_a
-00008b70: 7267 2929 202f 2064 656e 6f6d 696e 6174  rg)) / denominat
-00008b80: 6f72 0a20 2020 2073 616d 706c 6564 203d  or.    sampled =
-00008b90: 206d 6561 6e20 2a20 6a6e 702e 7768 6572   mean * jnp.wher
-00008ba0: 6528 7371 7274 3170 6d31 5f61 7267 203c  e(sqrt1pm1_arg <
-00008bb0: 206e 702e 696e 662c 2072 6174 696f 2c20   np.inf, ratio, 
-00008bc0: 312e 3029 2020 2320 7820 6162 6f76 650a  1.0)  # x above.
-00008bd0: 2020 2020 7265 7320 3d20 6a6e 702e 7768      res = jnp.wh
-00008be0: 6572 6528 7361 6d70 6c65 645f 756e 6966  ere(sampled_unif
-00008bf0: 6f72 6d20 3c3d 206d 6561 6e20 2f20 286d  orm <= mean / (m
-00008c00: 6561 6e20 2b20 7361 6d70 6c65 6429 2c0a  ean + sampled),.
-00008c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008c20: 2020 2020 7361 6d70 6c65 642c 0a20 2020      sampled,.   
-00008c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008c40: 206a 6e70 2e73 7175 6172 6528 6d65 616e   jnp.square(mean
-00008c50: 2920 2f20 7361 6d70 6c65 6429 0a20 2020  ) / sampled).   
-00008c60: 2072 6574 7572 6e20 5f72 6574 7572 6e28   return _return(
-00008c70: 7265 7329 0a0a 2020 6465 6620 7428 7365  res)..  def t(se
-00008c80: 6c66 2c20 6466 2c20 7369 7a65 3d4e 6f6e  lf, df, size=Non
-00008c90: 652c 206b 6579 3d4e 6f6e 6529 3a0a 2020  e, key=None):.  
-00008ca0: 2020 6466 203d 205f 6368 6563 6b5f 7079    df = _check_py
-00008cb0: 5f73 6571 285f 6173 5f6a 6178 5f61 7272  _seq(_as_jax_arr
-00008cc0: 6179 2864 6629 290a 2020 2020 6966 2073  ay(df)).    if s
-00008cd0: 697a 6520 6973 204e 6f6e 653a 0a20 2020  ize is None:.   
-00008ce0: 2020 2073 697a 6520 3d20 6e70 2e73 6861     size = np.sha
-00008cf0: 7065 2864 6629 0a20 2020 2065 6c73 653a  pe(df).    else:
-00008d00: 0a20 2020 2020 2073 697a 6520 3d20 5f73  .      size = _s
-00008d10: 697a 6532 7368 6170 6528 7369 7a65 290a  ize2shape(size).
-00008d20: 2020 2020 2020 5f63 6865 636b 5f73 6861        _check_sha
-00008d30: 7065 2822 7422 2c20 7369 7a65 2c20 6e70  pe("t", size, np
-00008d40: 2e73 6861 7065 2864 6629 290a 2020 2020  .shape(df)).    
-00008d50: 6966 206b 6579 2069 7320 4e6f 6e65 3a0a  if key is None:.
-00008d60: 2020 2020 2020 6b65 7973 203d 2073 656c        keys = sel
-00008d70: 662e 7370 6c69 745f 6b65 7973 2832 290a  f.split_keys(2).
-00008d80: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00008d90: 6b65 7973 203d 206a 722e 7370 6c69 7428  keys = jr.split(
-00008da0: 5f66 6f72 6d61 6c69 7a65 5f6b 6579 286b  _formalize_key(k
-00008db0: 6579 292c 2032 290a 2020 2020 6e20 3d20  ey), 2).    n = 
-00008dc0: 6a72 2e6e 6f72 6d61 6c28 6b65 7973 5b30  jr.normal(keys[0
-00008dd0: 5d2c 2073 697a 6529 0a20 2020 2074 776f  ], size).    two
-00008de0: 203d 205f 636f 6e73 7428 6e2c 2032 290a   = _const(n, 2).
-00008df0: 2020 2020 6861 6c66 5f64 6620 3d20 6c61      half_df = la
-00008e00: 782e 6469 7628 6466 2c20 7477 6f29 0a20  x.div(df, two). 
-00008e10: 2020 2067 203d 206a 722e 6761 6d6d 6128     g = jr.gamma(
-00008e20: 6b65 7973 5b31 5d2c 2068 616c 665f 6466  keys[1], half_df
-00008e30: 2c20 7369 7a65 290a 2020 2020 7220 3d20  , size).    r = 
-00008e40: 6e20 2a20 6a6e 702e 7371 7274 2868 616c  n * jnp.sqrt(hal
-00008e50: 665f 6466 202f 2067 290a 2020 2020 7265  f_df / g).    re
-00008e60: 7475 726e 205f 7265 7475 726e 2872 290a  turn _return(r).
-00008e70: 0a20 2064 6566 206f 7274 686f 676f 6e61  .  def orthogona
-00008e80: 6c28 7365 6c66 2c20 6e3a 2069 6e74 2c20  l(self, n: int, 
-00008e90: 7369 7a65 3d4e 6f6e 652c 206b 6579 3d4e  size=None, key=N
-00008ea0: 6f6e 6529 3a0a 2020 2020 6b65 7920 3d20  one):.    key = 
-00008eb0: 7365 6c66 2e73 706c 6974 5f6b 6579 2829  self.split_key()
-00008ec0: 2069 6620 6b65 7920 6973 204e 6f6e 6520   if key is None 
-00008ed0: 656c 7365 205f 666f 726d 616c 697a 655f  else _formalize_
-00008ee0: 6b65 7928 6b65 7929 0a20 2020 2073 697a  key(key).    siz
-00008ef0: 6520 3d20 5f73 697a 6532 7368 6170 6528  e = _size2shape(
-00008f00: 7369 7a65 290a 2020 2020 5f63 6865 636b  size).    _check
-00008f10: 5f73 6861 7065 2822 6f72 7468 6f67 6f6e  _shape("orthogon
-00008f20: 616c 222c 2073 697a 6529 0a20 2020 206e  al", size).    n
-00008f30: 203d 2063 6f72 652e 636f 6e63 7265 7465   = core.concrete
-00008f40: 5f6f 725f 6572 726f 7228 696e 6465 782c  _or_error(index,
-00008f50: 206e 2c20 2254 6865 2065 7272 6f72 206f   n, "The error o
-00008f60: 6363 7572 7265 6420 696e 206a 6178 2e72  ccurred in jax.r
-00008f70: 616e 646f 6d2e 6f72 7468 6f67 6f6e 616c  andom.orthogonal
-00008f80: 2829 2229 0a20 2020 207a 203d 206a 722e  ()").    z = jr.
-00008f90: 6e6f 726d 616c 286b 6579 2c20 7369 7a65  normal(key, size
-00008fa0: 202b 2028 6e2c 206e 2929 0a20 2020 2071   + (n, n)).    q
-00008fb0: 2c20 7220 3d20 6a6e 702e 6c69 6e61 6c67  , r = jnp.linalg
-00008fc0: 2e71 7228 7a29 0a20 2020 2064 203d 206a  .qr(z).    d = j
-00008fd0: 6e70 2e64 6961 676f 6e61 6c28 722c 2030  np.diagonal(r, 0
-00008fe0: 2c20 2d32 2c20 2d31 290a 2020 2020 7220  , -2, -1).    r 
-00008ff0: 3d20 7120 2a20 6a6e 702e 6578 7061 6e64  = q * jnp.expand
-00009000: 5f64 696d 7328 6420 2f20 6162 7328 6429  _dims(d / abs(d)
-00009010: 2c20 2d32 290a 2020 2020 7265 7475 726e  , -2).    return
-00009020: 205f 7265 7475 726e 2872 290a 0a20 2064   _return(r)..  d
-00009030: 6566 206e 6f6e 6365 6e74 7261 6c5f 6368  ef noncentral_ch
-00009040: 6973 7175 6172 6528 7365 6c66 2c20 6466  isquare(self, df
-00009050: 2c20 6e6f 6e63 2c20 7369 7a65 3d4e 6f6e  , nonc, size=Non
-00009060: 652c 206b 6579 3d4e 6f6e 6529 3a0a 2020  e, key=None):.  
-00009070: 2020 6466 203d 205f 6368 6563 6b5f 7079    df = _check_py
-00009080: 5f73 6571 285f 6173 5f6a 6178 5f61 7272  _seq(_as_jax_arr
-00009090: 6179 2864 6629 290a 2020 2020 6e6f 6e63  ay(df)).    nonc
-000090a0: 203d 205f 6368 6563 6b5f 7079 5f73 6571   = _check_py_seq
-000090b0: 285f 6173 5f6a 6178 5f61 7272 6179 286e  (_as_jax_array(n
-000090c0: 6f6e 6329 290a 2020 2020 6966 2073 697a  onc)).    if siz
-000090d0: 6520 6973 204e 6f6e 653a 0a20 2020 2020  e is None:.     
-000090e0: 2073 697a 6520 3d20 6c61 782e 6272 6f61   size = lax.broa
-000090f0: 6463 6173 745f 7368 6170 6573 286a 6e70  dcast_shapes(jnp
-00009100: 2e73 6861 7065 2864 6629 2c20 6a6e 702e  .shape(df), jnp.
-00009110: 7368 6170 6528 6e6f 6e63 2929 0a20 2020  shape(nonc)).   
-00009120: 2073 697a 6520 3d20 5f73 697a 6532 7368   size = _size2sh
-00009130: 6170 6528 7369 7a65 290a 2020 2020 6966  ape(size).    if
-00009140: 206b 6579 2069 7320 4e6f 6e65 3a0a 2020   key is None:.  
-00009150: 2020 2020 6b65 7973 203d 2073 656c 662e      keys = self.
-00009160: 7370 6c69 745f 6b65 7973 2833 290a 2020  split_keys(3).  
-00009170: 2020 656c 7365 3a0a 2020 2020 2020 6b65    else:.      ke
-00009180: 7973 203d 206a 722e 7370 6c69 7428 5f66  ys = jr.split(_f
-00009190: 6f72 6d61 6c69 7a65 5f6b 6579 286b 6579  ormalize_key(key
-000091a0: 292c 2033 290a 2020 2020 6920 3d20 6a72  ), 3).    i = jr
-000091b0: 2e70 6f69 7373 6f6e 286b 6579 735b 305d  .poisson(keys[0]
-000091c0: 2c20 302e 3520 2a20 6e6f 6e63 2c20 7368  , 0.5 * nonc, sh
-000091d0: 6170 653d 7369 7a65 290a 2020 2020 6e20  ape=size).    n 
-000091e0: 3d20 6a72 2e6e 6f72 6d61 6c28 6b65 7973  = jr.normal(keys
-000091f0: 5b31 5d2c 2073 6861 7065 3d73 697a 6529  [1], shape=size)
-00009200: 202b 206a 6e70 2e73 7172 7428 6e6f 6e63   + jnp.sqrt(nonc
-00009210: 290a 2020 2020 636f 6e64 203d 206a 6e70  ).    cond = jnp
-00009220: 2e67 7265 6174 6572 2864 662c 2031 2e30  .greater(df, 1.0
-00009230: 290a 2020 2020 6466 3220 3d20 6a6e 702e  ).    df2 = jnp.
-00009240: 7768 6572 6528 636f 6e64 2c20 6466 202d  where(cond, df -
-00009250: 2031 2e30 2c20 6466 202b 2032 2e30 202a   1.0, df + 2.0 *
-00009260: 2069 290a 2020 2020 6368 6932 203d 2032   i).    chi2 = 2
-00009270: 2e30 202a 206a 722e 6761 6d6d 6128 6b65  .0 * jr.gamma(ke
-00009280: 7973 5b32 5d2c 2030 2e35 202a 2064 6632  ys[2], 0.5 * df2
-00009290: 2c20 7368 6170 653d 7369 7a65 290a 2020  , shape=size).  
-000092a0: 2020 7220 3d20 6a6e 702e 7768 6572 6528    r = jnp.where(
-000092b0: 636f 6e64 2c20 6368 6932 202b 206e 202a  cond, chi2 + n *
-000092c0: 206e 2c20 6368 6932 290a 2020 2020 7265   n, chi2).    re
-000092d0: 7475 726e 205f 7265 7475 726e 2872 290a  turn _return(r).
-000092e0: 0a20 2064 6566 206c 6f67 6761 6d6d 6128  .  def loggamma(
-000092f0: 7365 6c66 2c20 612c 2073 697a 653d 4e6f  self, a, size=No
-00009300: 6e65 2c20 6b65 793d 4e6f 6e65 293a 0a20  ne, key=None):. 
-00009310: 2020 206b 6579 203d 2073 656c 662e 7370     key = self.sp
-00009320: 6c69 745f 6b65 7928 2920 6966 206b 6579  lit_key() if key
-00009330: 2069 7320 4e6f 6e65 2065 6c73 6520 5f66   is None else _f
-00009340: 6f72 6d61 6c69 7a65 5f6b 6579 286b 6579  ormalize_key(key
-00009350: 290a 2020 2020 6120 3d20 5f63 6865 636b  ).    a = _check
-00009360: 5f70 795f 7365 7128 5f61 735f 6a61 785f  _py_seq(_as_jax_
-00009370: 6172 7261 7928 6129 290a 2020 2020 6966  array(a)).    if
-00009380: 2073 697a 6520 6973 204e 6f6e 653a 0a20   size is None:. 
-00009390: 2020 2020 2073 697a 6520 3d20 6a6e 702e       size = jnp.
-000093a0: 7368 6170 6528 6129 0a20 2020 2072 203d  shape(a).    r =
-000093b0: 206a 722e 6c6f 6767 616d 6d61 286b 6579   jr.loggamma(key
-000093c0: 2c20 612c 2073 6861 7065 3d5f 7369 7a65  , a, shape=_size
-000093d0: 3273 6861 7065 2873 697a 6529 290a 2020  2shape(size)).  
-000093e0: 2020 7265 7475 726e 205f 7265 7475 726e    return _return
-000093f0: 2872 290a 0a20 2064 6566 2063 6174 6567  (r)..  def categ
-00009400: 6f72 6963 616c 2873 656c 662c 206c 6f67  orical(self, log
-00009410: 6974 732c 2061 7869 733a 2069 6e74 203d  its, axis: int =
-00009420: 202d 312c 2073 697a 653d 4e6f 6e65 2c20   -1, size=None, 
-00009430: 6b65 793d 4e6f 6e65 293a 0a20 2020 206b  key=None):.    k
-00009440: 6579 203d 2073 656c 662e 7370 6c69 745f  ey = self.split_
-00009450: 6b65 7928 2920 6966 206b 6579 2069 7320  key() if key is 
-00009460: 4e6f 6e65 2065 6c73 6520 5f66 6f72 6d61  None else _forma
-00009470: 6c69 7a65 5f6b 6579 286b 6579 290a 2020  lize_key(key).  
-00009480: 2020 6c6f 6769 7473 203d 205f 6368 6563    logits = _chec
-00009490: 6b5f 7079 5f73 6571 285f 6173 5f6a 6178  k_py_seq(_as_jax
-000094a0: 5f61 7272 6179 286c 6f67 6974 7329 290a  _array(logits)).
-000094b0: 2020 2020 6966 2073 697a 6520 6973 204e      if size is N
-000094c0: 6f6e 653a 0a20 2020 2020 2073 697a 6520  one:.      size 
-000094d0: 3d20 6c69 7374 286a 6e70 2e73 6861 7065  = list(jnp.shape
-000094e0: 286c 6f67 6974 7329 290a 2020 2020 2020  (logits)).      
-000094f0: 7369 7a65 2e70 6f70 2861 7869 7329 0a20  size.pop(axis). 
-00009500: 2020 2072 203d 206a 722e 6361 7465 676f     r = jr.catego
-00009510: 7269 6361 6c28 6b65 792c 206c 6f67 6974  rical(key, logit
-00009520: 732c 2061 7869 733d 6178 6973 2c20 7368  s, axis=axis, sh
-00009530: 6170 653d 5f73 697a 6532 7368 6170 6528  ape=_size2shape(
-00009540: 7369 7a65 2929 0a20 2020 2072 6574 7572  size)).    retur
-00009550: 6e20 5f72 6574 7572 6e28 7229 0a0a 2020  n _return(r)..  
-00009560: 6465 6620 7a69 7066 2873 656c 662c 2061  def zipf(self, a
-00009570: 2c20 7369 7a65 3d4e 6f6e 652c 206b 6579  , size=None, key
-00009580: 3d4e 6f6e 6529 3a0a 2020 2020 6120 3d20  =None):.    a = 
-00009590: 5f63 6865 636b 5f70 795f 7365 7128 5f61  _check_py_seq(_a
-000095a0: 735f 6a61 785f 6172 7261 7928 6129 290a  s_jax_array(a)).
-000095b0: 2020 2020 6966 2073 697a 6520 6973 204e      if size is N
-000095c0: 6f6e 653a 0a20 2020 2020 2073 697a 6520  one:.      size 
-000095d0: 3d20 6a6e 702e 7368 6170 6528 6129 0a20  = jnp.shape(a). 
-000095e0: 2020 2072 203d 2063 616c 6c28 6c61 6d62     r = call(lamb
-000095f0: 6461 2078 3a20 6e70 2e72 616e 646f 6d2e  da x: np.random.
-00009600: 7a69 7066 2878 2c20 7369 7a65 292c 0a20  zipf(x, size),. 
-00009610: 2020 2020 2020 2020 2020 2020 612c 0a20              a,. 
-00009620: 2020 2020 2020 2020 2020 2020 7265 7375              resu
-00009630: 6c74 5f73 6861 7065 3d6a 6178 2e53 6861  lt_shape=jax.Sha
-00009640: 7065 4474 7970 6553 7472 7563 7428 7369  peDtypeStruct(si
-00009650: 7a65 2c20 6a6e 702e 696e 745f 2929 0a20  ze, jnp.int_)). 
-00009660: 2020 2072 6574 7572 6e20 5f72 6574 7572     return _retur
-00009670: 6e28 7229 0a0a 2020 6465 6620 706f 7765  n(r)..  def powe
-00009680: 7228 7365 6c66 2c20 612c 2073 697a 653d  r(self, a, size=
-00009690: 4e6f 6e65 2c20 6b65 793d 4e6f 6e65 293a  None, key=None):
-000096a0: 0a20 2020 2061 203d 205f 6368 6563 6b5f  .    a = _check_
-000096b0: 7079 5f73 6571 285f 6173 5f6a 6178 5f61  py_seq(_as_jax_a
-000096c0: 7272 6179 2861 2929 0a20 2020 2069 6620  rray(a)).    if 
-000096d0: 7369 7a65 2069 7320 4e6f 6e65 3a0a 2020  size is None:.  
-000096e0: 2020 2020 7369 7a65 203d 206a 6e70 2e73      size = jnp.s
-000096f0: 6861 7065 2861 290a 2020 2020 7369 7a65  hape(a).    size
-00009700: 203d 205f 7369 7a65 3273 6861 7065 2873   = _size2shape(s
-00009710: 697a 6529 0a20 2020 2072 203d 2063 616c  ize).    r = cal
-00009720: 6c28 6c61 6d62 6461 2061 3a20 6e70 2e72  l(lambda a: np.r
-00009730: 616e 646f 6d2e 706f 7765 7228 613d 612c  andom.power(a=a,
-00009740: 2073 697a 653d 7369 7a65 292c 0a20 2020   size=size),.   
-00009750: 2020 2020 2020 2020 2020 612c 2072 6573            a, res
-00009760: 756c 745f 7368 6170 653d 6a61 782e 5368  ult_shape=jax.Sh
-00009770: 6170 6544 7479 7065 5374 7275 6374 2873  apeDtypeStruct(s
-00009780: 697a 652c 206a 6e70 2e66 6c6f 6174 5f29  ize, jnp.float_)
-00009790: 290a 2020 2020 7265 7475 726e 205f 7265  ).    return _re
-000097a0: 7475 726e 2872 290a 0a20 2064 6566 2066  turn(r)..  def f
-000097b0: 2873 656c 662c 2064 666e 756d 2c20 6466  (self, dfnum, df
-000097c0: 6465 6e2c 2073 697a 653d 4e6f 6e65 2c20  den, size=None, 
-000097d0: 6b65 793d 4e6f 6e65 293a 0a20 2020 2064  key=None):.    d
-000097e0: 666e 756d 203d 205f 6173 5f6a 6178 5f61  fnum = _as_jax_a
-000097f0: 7272 6179 2864 666e 756d 290a 2020 2020  rray(dfnum).    
-00009800: 6466 6465 6e20 3d20 5f61 735f 6a61 785f  dfden = _as_jax_
-00009810: 6172 7261 7928 6466 6465 6e29 0a20 2020  array(dfden).   
-00009820: 2064 666e 756d 203d 205f 6368 6563 6b5f   dfnum = _check_
-00009830: 7079 5f73 6571 2864 666e 756d 290a 2020  py_seq(dfnum).  
-00009840: 2020 6466 6465 6e20 3d20 5f63 6865 636b    dfden = _check
-00009850: 5f70 795f 7365 7128 6466 6465 6e29 0a20  _py_seq(dfden). 
-00009860: 2020 2069 6620 7369 7a65 2069 7320 4e6f     if size is No
-00009870: 6e65 3a0a 2020 2020 2020 7369 7a65 203d  ne:.      size =
-00009880: 206a 6e70 2e62 726f 6164 6361 7374 5f73   jnp.broadcast_s
-00009890: 6861 7065 7328 6a6e 702e 7368 6170 6528  hapes(jnp.shape(
-000098a0: 6466 6e75 6d29 2c20 6a6e 702e 7368 6170  dfnum), jnp.shap
-000098b0: 6528 6466 6465 6e29 290a 2020 2020 7369  e(dfden)).    si
-000098c0: 7a65 203d 205f 7369 7a65 3273 6861 7065  ze = _size2shape
-000098d0: 2873 697a 6529 0a20 2020 2064 203d 207b  (size).    d = {
-000098e0: 2764 666e 756d 273a 2064 666e 756d 2c20  'dfnum': dfnum, 
-000098f0: 2764 6664 656e 273a 2064 6664 656e 7d0a  'dfden': dfden}.
-00009900: 2020 2020 7220 3d20 6361 6c6c 286c 616d      r = call(lam
-00009910: 6264 6120 783a 206e 702e 7261 6e64 6f6d  bda x: np.random
-00009920: 2e66 2864 666e 756d 3d78 5b27 6466 6e75  .f(dfnum=x['dfnu
-00009930: 6d27 5d2c 0a20 2020 2020 2020 2020 2020  m'],.           
-00009940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009950: 2020 2020 2020 2020 6466 6465 6e3d 785b          dfden=x[
-00009960: 2764 6664 656e 275d 2c0a 2020 2020 2020  'dfden'],.      
-00009970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009980: 2020 2020 2020 2020 2020 2020 2073 697a               siz
-00009990: 653d 7369 7a65 292c 0a20 2020 2020 2020  e=size),.       
-000099a0: 2020 2020 2020 642c 0a20 2020 2020 2020        d,.       
-000099b0: 2020 2020 2020 7265 7375 6c74 5f73 6861        result_sha
-000099c0: 7065 3d6a 6178 2e53 6861 7065 4474 7970  pe=jax.ShapeDtyp
-000099d0: 6553 7472 7563 7428 7369 7a65 2c20 6a6e  eStruct(size, jn
-000099e0: 702e 666c 6f61 745f 2929 0a20 2020 2072  p.float_)).    r
-000099f0: 6574 7572 6e20 5f72 6574 7572 6e28 7229  eturn _return(r)
-00009a00: 0a0a 2020 6465 6620 6879 7065 7267 656f  ..  def hypergeo
-00009a10: 6d65 7472 6963 2873 656c 662c 206e 676f  metric(self, ngo
-00009a20: 6f64 2c20 6e62 6164 2c20 6e73 616d 706c  od, nbad, nsampl
-00009a30: 652c 2073 697a 653d 4e6f 6e65 2c20 6b65  e, size=None, ke
-00009a40: 793d 4e6f 6e65 293a 0a20 2020 206e 676f  y=None):.    ngo
-00009a50: 6f64 203d 205f 6368 6563 6b5f 7079 5f73  od = _check_py_s
-00009a60: 6571 285f 6173 5f6a 6178 5f61 7272 6179  eq(_as_jax_array
-00009a70: 286e 676f 6f64 2929 0a20 2020 206e 6261  (ngood)).    nba
-00009a80: 6420 3d20 5f63 6865 636b 5f70 795f 7365  d = _check_py_se
-00009a90: 7128 5f61 735f 6a61 785f 6172 7261 7928  q(_as_jax_array(
-00009aa0: 6e62 6164 2929 0a20 2020 206e 7361 6d70  nbad)).    nsamp
-00009ab0: 6c65 203d 205f 6368 6563 6b5f 7079 5f73  le = _check_py_s
-00009ac0: 6571 285f 6173 5f6a 6178 5f61 7272 6179  eq(_as_jax_array
-00009ad0: 286e 7361 6d70 6c65 2929 0a0a 2020 2020  (nsample))..    
-00009ae0: 6966 2073 697a 6520 6973 204e 6f6e 653a  if size is None:
-00009af0: 0a20 2020 2020 2073 697a 6520 3d20 6c61  .      size = la
-00009b00: 782e 6272 6f61 6463 6173 745f 7368 6170  x.broadcast_shap
-00009b10: 6573 286a 6e70 2e73 6861 7065 286e 676f  es(jnp.shape(ngo
-00009b20: 6f64 292c 0a20 2020 2020 2020 2020 2020  od),.           
-00009b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b40: 2020 2020 2020 206a 6e70 2e73 6861 7065         jnp.shape
-00009b50: 286e 6261 6429 2c0a 2020 2020 2020 2020  (nbad),.        
-00009b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b70: 2020 2020 2020 2020 2020 6a6e 702e 7368            jnp.sh
-00009b80: 6170 6528 6e73 616d 706c 6529 290a 2020  ape(nsample)).  
-00009b90: 2020 7369 7a65 203d 205f 7369 7a65 3273    size = _size2s
-00009ba0: 6861 7065 2873 697a 6529 0a20 2020 2064  hape(size).    d
-00009bb0: 203d 207b 276e 676f 6f64 273a 206e 676f   = {'ngood': ngo
-00009bc0: 6f64 2c20 276e 6261 6427 3a20 6e62 6164  od, 'nbad': nbad
-00009bd0: 2c20 276e 7361 6d70 6c65 273a 206e 7361  , 'nsample': nsa
-00009be0: 6d70 6c65 7d0a 2020 2020 7220 3d20 6361  mple}.    r = ca
-00009bf0: 6c6c 286c 616d 6264 6120 783a 206e 702e  ll(lambda x: np.
-00009c00: 7261 6e64 6f6d 2e68 7970 6572 6765 6f6d  random.hypergeom
-00009c10: 6574 7269 6328 6e67 6f6f 643d 785b 276e  etric(ngood=x['n
-00009c20: 676f 6f64 275d 2c0a 2020 2020 2020 2020  good'],.        
-00009c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c50: 2020 2020 2020 2020 6e62 6164 3d78 5b27          nbad=x['
-00009c60: 6e62 6164 275d 2c0a 2020 2020 2020 2020  nbad'],.        
-00009c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c90: 2020 2020 2020 2020 6e73 616d 706c 653d          nsample=
-00009ca0: 785b 276e 7361 6d70 6c65 275d 2c0a 2020  x['nsample'],.  
-00009cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009cd0: 2020 2020 2020 2020 2020 2020 2020 7369                si
-00009ce0: 7a65 3d73 697a 6529 2c0a 2020 2020 2020  ze=size),.      
-00009cf0: 2020 2020 2020 2064 2c20 7265 7375 6c74         d, result
-00009d00: 5f73 6861 7065 3d6a 6178 2e53 6861 7065  _shape=jax.Shape
-00009d10: 4474 7970 6553 7472 7563 7428 7369 7a65  DtypeStruct(size
-00009d20: 2c20 6a6e 702e 696e 745f 2929 0a20 2020  , jnp.int_)).   
-00009d30: 2072 6574 7572 6e20 5f72 6574 7572 6e28   return _return(
-00009d40: 7229 0a0a 2020 6465 6620 6c6f 6773 6572  r)..  def logser
-00009d50: 6965 7328 7365 6c66 2c20 702c 2073 697a  ies(self, p, siz
-00009d60: 653d 4e6f 6e65 2c20 6b65 793d 4e6f 6e65  e=None, key=None
-00009d70: 293a 0a20 2020 2070 203d 205f 6368 6563  ):.    p = _chec
-00009d80: 6b5f 7079 5f73 6571 285f 6173 5f6a 6178  k_py_seq(_as_jax
-00009d90: 5f61 7272 6179 2870 2929 0a20 2020 2069  _array(p)).    i
-00009da0: 6620 7369 7a65 2069 7320 4e6f 6e65 3a0a  f size is None:.
-00009db0: 2020 2020 2020 7369 7a65 203d 206a 6e70        size = jnp
-00009dc0: 2e73 6861 7065 2870 290a 2020 2020 7369  .shape(p).    si
-00009dd0: 7a65 203d 205f 7369 7a65 3273 6861 7065  ze = _size2shape
-00009de0: 2873 697a 6529 0a20 2020 2072 203d 2063  (size).    r = c
-00009df0: 616c 6c28 6c61 6d62 6461 2070 3a20 6e70  all(lambda p: np
-00009e00: 2e72 616e 646f 6d2e 6c6f 6773 6572 6965  .random.logserie
-00009e10: 7328 703d 702c 2073 697a 653d 7369 7a65  s(p=p, size=size
-00009e20: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-00009e30: 702c 2072 6573 756c 745f 7368 6170 653d  p, result_shape=
-00009e40: 6a61 782e 5368 6170 6544 7479 7065 5374  jax.ShapeDtypeSt
-00009e50: 7275 6374 2873 697a 652c 206a 6e70 2e69  ruct(size, jnp.i
-00009e60: 6e74 5f29 290a 2020 2020 7265 7475 726e  nt_)).    return
-00009e70: 205f 7265 7475 726e 2872 290a 0a20 2064   _return(r)..  d
-00009e80: 6566 206e 6f6e 6365 6e74 7261 6c5f 6628  ef noncentral_f(
-00009e90: 7365 6c66 2c20 6466 6e75 6d2c 2064 6664  self, dfnum, dfd
-00009ea0: 656e 2c20 6e6f 6e63 2c20 7369 7a65 3d4e  en, nonc, size=N
-00009eb0: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
-00009ec0: 2020 2020 6466 6e75 6d20 3d20 5f63 6865      dfnum = _che
-00009ed0: 636b 5f70 795f 7365 7128 5f61 735f 6a61  ck_py_seq(_as_ja
-00009ee0: 785f 6172 7261 7928 6466 6e75 6d29 290a  x_array(dfnum)).
-00009ef0: 2020 2020 6466 6465 6e20 3d20 5f63 6865      dfden = _che
-00009f00: 636b 5f70 795f 7365 7128 5f61 735f 6a61  ck_py_seq(_as_ja
-00009f10: 785f 6172 7261 7928 6466 6465 6e29 290a  x_array(dfden)).
-00009f20: 2020 2020 6e6f 6e63 203d 205f 6368 6563      nonc = _chec
-00009f30: 6b5f 7079 5f73 6571 285f 6173 5f6a 6178  k_py_seq(_as_jax
-00009f40: 5f61 7272 6179 286e 6f6e 6329 290a 2020  _array(nonc)).  
-00009f50: 2020 6966 2073 697a 6520 6973 204e 6f6e    if size is Non
-00009f60: 653a 0a20 2020 2020 2073 697a 6520 3d20  e:.      size = 
-00009f70: 6c61 782e 6272 6f61 6463 6173 745f 7368  lax.broadcast_sh
-00009f80: 6170 6573 286a 6e70 2e73 6861 7065 2864  apes(jnp.shape(d
-00009f90: 666e 756d 292c 0a20 2020 2020 2020 2020  fnum),.         
-00009fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009fb0: 2020 2020 2020 2020 206a 6e70 2e73 6861           jnp.sha
-00009fc0: 7065 2864 6664 656e 292c 0a20 2020 2020  pe(dfden),.     
-00009fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009fe0: 2020 2020 2020 2020 2020 2020 206a 6e70               jnp
-00009ff0: 2e73 6861 7065 286e 6f6e 6329 290a 2020  .shape(nonc)).  
-0000a000: 2020 7369 7a65 203d 205f 7369 7a65 3273    size = _size2s
-0000a010: 6861 7065 2873 697a 6529 0a20 2020 2064  hape(size).    d
-0000a020: 203d 207b 2764 666e 756d 273a 2064 666e   = {'dfnum': dfn
-0000a030: 756d 2c20 2764 6664 656e 273a 2064 6664  um, 'dfden': dfd
-0000a040: 656e 2c20 276e 6f6e 6327 3a20 6e6f 6e63  en, 'nonc': nonc
-0000a050: 7d0a 2020 2020 7220 3d20 6361 6c6c 286c  }.    r = call(l
-0000a060: 616d 6264 6120 783a 206e 702e 7261 6e64  ambda x: np.rand
-0000a070: 6f6d 2e6e 6f6e 6365 6e74 7261 6c5f 6628  om.noncentral_f(
-0000a080: 6466 6e75 6d3d 785b 2764 666e 756d 275d  dfnum=x['dfnum']
-0000a090: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000a0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000062c0: 7928 6b65 7929 0a20 2020 2072 203d 206a  y(key).    r = j
+000062d0: 722e 7428 6b65 792c 2064 663d 6466 2c20  r.t(key, df=df, 
+000062e0: 7368 6170 653d 5f73 697a 6532 7368 6170  shape=_size2shap
+000062f0: 6528 7369 7a65 2929 0a20 2020 2072 6574  e(size)).    ret
+00006300: 7572 6e20 5f72 6574 7572 6e28 7229 0a0a  urn _return(r)..
+00006310: 2020 6465 6620 756e 6966 6f72 6d28 7365    def uniform(se
+00006320: 6c66 2c20 6c6f 773d 302e 302c 2068 6967  lf, low=0.0, hig
+00006330: 683d 312e 302c 2073 697a 653d 4e6f 6e65  h=1.0, size=None
+00006340: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2020  , key=None):.   
+00006350: 206c 6f77 203d 205f 6173 5f6a 6178 5f61   low = _as_jax_a
+00006360: 7272 6179 286c 6f77 290a 2020 2020 6869  rray(low).    hi
+00006370: 6768 203d 205f 6173 5f6a 6178 5f61 7272  gh = _as_jax_arr
+00006380: 6179 2868 6967 6829 0a20 2020 206c 6f77  ay(high).    low
+00006390: 203d 205f 6368 6563 6b5f 7079 5f73 6571   = _check_py_seq
+000063a0: 286c 6f77 290a 2020 2020 6869 6768 203d  (low).    high =
+000063b0: 205f 6368 6563 6b5f 7079 5f73 6571 2868   _check_py_seq(h
+000063c0: 6967 6829 0a20 2020 2069 6620 7369 7a65  igh).    if size
+000063d0: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+000063e0: 7369 7a65 203d 206c 6178 2e62 726f 6164  size = lax.broad
+000063f0: 6361 7374 5f73 6861 7065 7328 6a6e 702e  cast_shapes(jnp.
+00006400: 7368 6170 6528 6c6f 7729 2c20 6a6e 702e  shape(low), jnp.
+00006410: 7368 6170 6528 6869 6768 2929 0a20 2020  shape(high)).   
+00006420: 206b 6579 203d 2073 656c 662e 7370 6c69   key = self.spli
+00006430: 745f 6b65 7928 2920 6966 206b 6579 2069  t_key() if key i
+00006440: 7320 4e6f 6e65 2065 6c73 6520 5f66 6f72  s None else _for
+00006450: 6d61 6c69 7a65 5f6b 6579 286b 6579 290a  malize_key(key).
+00006460: 2020 2020 7220 3d20 6a72 2e75 6e69 666f      r = jr.unifo
+00006470: 726d 286b 6579 2c20 7368 6170 653d 5f73  rm(key, shape=_s
+00006480: 697a 6532 7368 6170 6528 7369 7a65 292c  ize2shape(size),
+00006490: 206d 696e 7661 6c3d 6c6f 772c 206d 6178   minval=low, max
+000064a0: 7661 6c3d 6869 6768 290a 2020 2020 7265  val=high).    re
+000064b0: 7475 726e 205f 7265 7475 726e 2872 290a  turn _return(r).
+000064c0: 0a20 2064 6566 2074 7275 6e63 6174 6564  .  def truncated
+000064d0: 5f6e 6f72 6d61 6c28 7365 6c66 2c20 6c6f  _normal(self, lo
+000064e0: 7765 722c 2075 7070 6572 2c20 7369 7a65  wer, upper, size
+000064f0: 3d4e 6f6e 652c 2073 6361 6c65 3d4e 6f6e  =None, scale=Non
+00006500: 652c 206b 6579 3d4e 6f6e 6529 3a0a 2020  e, key=None):.  
+00006510: 2020 6c6f 7765 7220 3d20 5f61 735f 6a61    lower = _as_ja
+00006520: 785f 6172 7261 7928 6c6f 7765 7229 0a20  x_array(lower). 
+00006530: 2020 206c 6f77 6572 203d 205f 6368 6563     lower = _chec
+00006540: 6b5f 7079 5f73 6571 286c 6f77 6572 290a  k_py_seq(lower).
+00006550: 2020 2020 7570 7065 7220 3d20 5f61 735f      upper = _as_
+00006560: 6a61 785f 6172 7261 7928 7570 7065 7229  jax_array(upper)
+00006570: 0a20 2020 2075 7070 6572 203d 205f 6368  .    upper = _ch
+00006580: 6563 6b5f 7079 5f73 6571 2875 7070 6572  eck_py_seq(upper
+00006590: 290a 2020 2020 7363 616c 6520 3d20 5f61  ).    scale = _a
+000065a0: 735f 6a61 785f 6172 7261 7928 7363 616c  s_jax_array(scal
+000065b0: 6529 0a20 2020 2073 6361 6c65 203d 205f  e).    scale = _
+000065c0: 6368 6563 6b5f 7079 5f73 6571 2873 6361  check_py_seq(sca
+000065d0: 6c65 290a 2020 2020 6966 2073 697a 6520  le).    if size 
+000065e0: 6973 204e 6f6e 653a 0a20 2020 2020 2073  is None:.      s
+000065f0: 697a 6520 3d20 6c61 782e 6272 6f61 6463  ize = lax.broadc
+00006600: 6173 745f 7368 6170 6573 286a 6e70 2e73  ast_shapes(jnp.s
+00006610: 6861 7065 286c 6f77 6572 292c 0a20 2020  hape(lower),.   
+00006620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006630: 2020 2020 2020 2020 2020 2020 2020 206a                 j
+00006640: 6e70 2e73 6861 7065 2875 7070 6572 292c  np.shape(upper),
+00006650: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006670: 2020 206a 6e70 2e73 6861 7065 2873 6361     jnp.shape(sca
+00006680: 6c65 2929 0a20 2020 206b 6579 203d 2073  le)).    key = s
+00006690: 656c 662e 7370 6c69 745f 6b65 7928 2920  elf.split_key() 
+000066a0: 6966 206b 6579 2069 7320 4e6f 6e65 2065  if key is None e
+000066b0: 6c73 6520 5f66 6f72 6d61 6c69 7a65 5f6b  lse _formalize_k
+000066c0: 6579 286b 6579 290a 2020 2020 7261 6e64  ey(key).    rand
+000066d0: 7320 3d20 6a72 2e74 7275 6e63 6174 6564  s = jr.truncated
+000066e0: 5f6e 6f72 6d61 6c28 6b65 792c 0a20 2020  _normal(key,.   
+000066f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006700: 2020 2020 2020 2020 2020 2020 206c 6f77               low
+00006710: 6572 3d6c 6f77 6572 2c0a 2020 2020 2020  er=lower,.      
+00006720: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006730: 2020 2020 2020 2020 2020 7570 7065 723d            upper=
+00006740: 7570 7065 722c 0a20 2020 2020 2020 2020  upper,.         
+00006750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006760: 2020 2020 2020 2073 6861 7065 3d5f 7369         shape=_si
+00006770: 7a65 3273 6861 7065 2873 697a 6529 290a  ze2shape(size)).
+00006780: 2020 2020 6966 2073 6361 6c65 2069 7320      if scale is 
+00006790: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+000067a0: 7261 6e64 7320 3d20 7261 6e64 7320 2a20  rands = rands * 
+000067b0: 7363 616c 650a 2020 2020 7265 7475 726e  scale.    return
+000067c0: 205f 7265 7475 726e 2872 616e 6473 290a   _return(rands).
+000067d0: 0a20 2064 6566 205f 6368 6563 6b5f 7028  .  def _check_p(
+000067e0: 7365 6c66 2c20 7029 3a0a 2020 2020 7261  self, p):.    ra
+000067f0: 6973 6520 5661 6c75 6545 7272 6f72 2866  ise ValueError(f
+00006800: 2750 6172 616d 6574 6572 2070 2073 686f  'Parameter p sho
+00006810: 756c 6420 6265 2077 6974 6869 6e20 5b30  uld be within [0
+00006820: 2c20 315d 2c20 6275 7420 7765 2067 6f74  , 1], but we got
+00006830: 207b 707d 2729 0a0a 2020 6465 6620 6265   {p}')..  def be
+00006840: 726e 6f75 6c6c 6928 7365 6c66 2c20 702c  rnoulli(self, p,
+00006850: 2073 697a 653d 4e6f 6e65 2c20 6b65 793d   size=None, key=
+00006860: 4e6f 6e65 293a 0a20 2020 2070 203d 205f  None):.    p = _
+00006870: 6368 6563 6b5f 7079 5f73 6571 285f 6173  check_py_seq(_as
+00006880: 5f6a 6178 5f61 7272 6179 2870 2929 0a20  _jax_array(p)). 
+00006890: 2020 206a 6974 5f65 7272 6f72 5f63 6865     jit_error_che
+000068a0: 636b 696e 6728 6a6e 702e 616e 7928 6a6e  cking(jnp.any(jn
+000068b0: 702e 6c6f 6769 6361 6c5f 616e 6428 7020  p.logical_and(p 
+000068c0: 3c20 302c 2070 203e 2031 2929 2c20 7365  < 0, p > 1)), se
+000068d0: 6c66 2e5f 6368 6563 6b5f 702c 2070 290a  lf._check_p, p).
+000068e0: 2020 2020 6966 2073 697a 6520 6973 204e      if size is N
+000068f0: 6f6e 653a 0a20 2020 2020 2073 697a 6520  one:.      size 
+00006900: 3d20 6a6e 702e 7368 6170 6528 7029 0a20  = jnp.shape(p). 
+00006910: 2020 206b 6579 203d 2073 656c 662e 7370     key = self.sp
+00006920: 6c69 745f 6b65 7928 2920 6966 206b 6579  lit_key() if key
+00006930: 2069 7320 4e6f 6e65 2065 6c73 6520 5f66   is None else _f
+00006940: 6f72 6d61 6c69 7a65 5f6b 6579 286b 6579  ormalize_key(key
+00006950: 290a 2020 2020 7220 3d20 6a72 2e62 6572  ).    r = jr.ber
+00006960: 6e6f 756c 6c69 286b 6579 2c20 703d 702c  noulli(key, p=p,
+00006970: 2073 6861 7065 3d5f 7369 7a65 3273 6861   shape=_size2sha
+00006980: 7065 2873 697a 6529 290a 2020 2020 7265  pe(size)).    re
+00006990: 7475 726e 205f 7265 7475 726e 2872 290a  turn _return(r).
+000069a0: 0a20 2064 6566 206c 6f67 6e6f 726d 616c  .  def lognormal
+000069b0: 2873 656c 662c 206d 6561 6e3d 4e6f 6e65  (self, mean=None
+000069c0: 2c20 7369 676d 613d 4e6f 6e65 2c20 7369  , sigma=None, si
+000069d0: 7a65 3d4e 6f6e 652c 206b 6579 3d4e 6f6e  ze=None, key=Non
+000069e0: 6529 3a0a 2020 2020 6d65 616e 203d 205f  e):.    mean = _
+000069f0: 6368 6563 6b5f 7079 5f73 6571 285f 6173  check_py_seq(_as
+00006a00: 5f6a 6178 5f61 7272 6179 286d 6561 6e29  _jax_array(mean)
+00006a10: 290a 2020 2020 7369 676d 6120 3d20 5f63  ).    sigma = _c
+00006a20: 6865 636b 5f70 795f 7365 7128 5f61 735f  heck_py_seq(_as_
+00006a30: 6a61 785f 6172 7261 7928 7369 676d 6129  jax_array(sigma)
+00006a40: 290a 2020 2020 6966 2073 697a 6520 6973  ).    if size is
+00006a50: 204e 6f6e 653a 0a20 2020 2020 2073 697a   None:.      siz
+00006a60: 6520 3d20 6a6e 702e 6272 6f61 6463 6173  e = jnp.broadcas
+00006a70: 745f 7368 6170 6573 286a 6e70 2e73 6861  t_shapes(jnp.sha
+00006a80: 7065 286d 6561 6e29 2c0a 2020 2020 2020  pe(mean),.      
+00006a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006aa0: 2020 2020 2020 2020 2020 2020 6a6e 702e              jnp.
+00006ab0: 7368 6170 6528 7369 676d 6129 290a 2020  shape(sigma)).  
+00006ac0: 2020 6b65 7920 3d20 7365 6c66 2e73 706c    key = self.spl
+00006ad0: 6974 5f6b 6579 2829 2069 6620 6b65 7920  it_key() if key 
+00006ae0: 6973 204e 6f6e 6520 656c 7365 205f 666f  is None else _fo
+00006af0: 726d 616c 697a 655f 6b65 7928 6b65 7929  rmalize_key(key)
+00006b00: 0a20 2020 2073 616d 706c 6573 203d 206a  .    samples = j
+00006b10: 722e 6e6f 726d 616c 286b 6579 2c20 7368  r.normal(key, sh
+00006b20: 6170 653d 5f73 697a 6532 7368 6170 6528  ape=_size2shape(
+00006b30: 7369 7a65 2929 0a20 2020 2073 616d 706c  size)).    sampl
+00006b40: 6573 203d 205f 6c6f 635f 7363 616c 6528  es = _loc_scale(
+00006b50: 6d65 616e 2c20 7369 676d 612c 2073 616d  mean, sigma, sam
+00006b60: 706c 6573 290a 2020 2020 7361 6d70 6c65  ples).    sample
+00006b70: 7320 3d20 6a6e 702e 6578 7028 7361 6d70  s = jnp.exp(samp
+00006b80: 6c65 7329 0a20 2020 2072 6574 7572 6e20  les).    return 
+00006b90: 5f72 6574 7572 6e28 7361 6d70 6c65 7329  _return(samples)
+00006ba0: 0a0a 2020 6465 6620 6269 6e6f 6d69 616c  ..  def binomial
+00006bb0: 2873 656c 662c 206e 2c20 702c 2073 697a  (self, n, p, siz
+00006bc0: 653d 4e6f 6e65 2c20 6b65 793d 4e6f 6e65  e=None, key=None
+00006bd0: 293a 0a20 2020 206e 203d 205f 6368 6563  ):.    n = _chec
+00006be0: 6b5f 7079 5f73 6571 286e 2e76 616c 7565  k_py_seq(n.value
+00006bf0: 2069 6620 6973 696e 7374 616e 6365 286e   if isinstance(n
+00006c00: 2c20 4172 7261 7929 2065 6c73 6520 6e29  , Array) else n)
+00006c10: 0a20 2020 2070 203d 205f 6368 6563 6b5f  .    p = _check_
+00006c20: 7079 5f73 6571 2870 2e76 616c 7565 2069  py_seq(p.value i
+00006c30: 6620 6973 696e 7374 616e 6365 2870 2c20  f isinstance(p, 
+00006c40: 4172 7261 7929 2065 6c73 6520 7029 0a20  Array) else p). 
+00006c50: 2020 206a 6974 5f65 7272 6f72 5f63 6865     jit_error_che
+00006c60: 636b 696e 6728 6a6e 702e 616e 7928 6a6e  cking(jnp.any(jn
+00006c70: 702e 6c6f 6769 6361 6c5f 616e 6428 7020  p.logical_and(p 
+00006c80: 3c20 302c 2070 203e 2031 2929 2c20 7365  < 0, p > 1)), se
+00006c90: 6c66 2e5f 6368 6563 6b5f 702c 2070 290a  lf._check_p, p).
+00006ca0: 2020 2020 6966 2073 697a 6520 6973 204e      if size is N
+00006cb0: 6f6e 653a 0a20 2020 2020 2073 697a 6520  one:.      size 
+00006cc0: 3d20 6a6e 702e 6272 6f61 6463 6173 745f  = jnp.broadcast_
+00006cd0: 7368 6170 6573 286a 6e70 2e73 6861 7065  shapes(jnp.shape
+00006ce0: 286e 292c 206a 6e70 2e73 6861 7065 2870  (n), jnp.shape(p
+00006cf0: 2929 0a20 2020 206b 6579 203d 2073 656c  )).    key = sel
+00006d00: 662e 7370 6c69 745f 6b65 7928 2920 6966  f.split_key() if
+00006d10: 206b 6579 2069 7320 4e6f 6e65 2065 6c73   key is None els
+00006d20: 6520 5f66 6f72 6d61 6c69 7a65 5f6b 6579  e _formalize_key
+00006d30: 286b 6579 290a 2020 2020 7220 3d20 5f62  (key).    r = _b
+00006d40: 696e 6f6d 6961 6c28 6b65 792c 2070 2c20  inomial(key, p, 
+00006d50: 6e2c 2073 6861 7065 3d5f 7369 7a65 3273  n, shape=_size2s
+00006d60: 6861 7065 2873 697a 6529 290a 2020 2020  hape(size)).    
+00006d70: 7265 7475 726e 205f 7265 7475 726e 2872  return _return(r
+00006d80: 290a 0a20 2064 6566 2063 6869 7371 7561  )..  def chisqua
+00006d90: 7265 2873 656c 662c 2064 662c 2073 697a  re(self, df, siz
+00006da0: 653d 4e6f 6e65 2c20 6b65 793d 4e6f 6e65  e=None, key=None
+00006db0: 293a 0a20 2020 2064 6620 3d20 5f63 6865  ):.    df = _che
+00006dc0: 636b 5f70 795f 7365 7128 5f61 735f 6a61  ck_py_seq(_as_ja
+00006dd0: 785f 6172 7261 7928 6466 2929 0a20 2020  x_array(df)).   
+00006de0: 206b 6579 203d 2073 656c 662e 7370 6c69   key = self.spli
+00006df0: 745f 6b65 7928 2920 6966 206b 6579 2069  t_key() if key i
+00006e00: 7320 4e6f 6e65 2065 6c73 6520 5f66 6f72  s None else _for
+00006e10: 6d61 6c69 7a65 5f6b 6579 286b 6579 290a  malize_key(key).
+00006e20: 2020 2020 6966 2073 697a 6520 6973 204e      if size is N
+00006e30: 6f6e 653a 0a20 2020 2020 2069 6620 6a6e  one:.      if jn
+00006e40: 702e 6e64 696d 2864 6629 203d 3d20 303a  p.ndim(df) == 0:
+00006e50: 0a20 2020 2020 2020 2064 6973 7420 3d20  .        dist = 
+00006e60: 6a72 2e6e 6f72 6d61 6c28 6b65 792c 2028  jr.normal(key, (
+00006e70: 6466 2c29 2920 2a2a 2032 0a20 2020 2020  df,)) ** 2.     
+00006e80: 2020 2064 6973 7420 3d20 6469 7374 2e73     dist = dist.s
+00006e90: 756d 2829 0a20 2020 2020 2065 6c73 653a  um().      else:
+00006ea0: 0a20 2020 2020 2020 2072 6169 7365 204e  .        raise N
+00006eb0: 6f74 496d 706c 656d 656e 7465 6445 7272  otImplementedErr
+00006ec0: 6f72 2827 446f 206e 6f74 2073 7570 706f  or('Do not suppo
+00006ed0: 7274 206e 6f6e 2d73 6361 6c65 2022 6466  rt non-scale "df
+00006ee0: 2220 7768 656e 2022 7369 7a65 2220 6973  " when "size" is
+00006ef0: 204e 6f6e 6527 290a 2020 2020 656c 7365   None').    else
+00006f00: 3a0a 2020 2020 2020 6469 7374 203d 206a  :.      dist = j
+00006f10: 722e 6e6f 726d 616c 286b 6579 2c20 2864  r.normal(key, (d
+00006f20: 662c 2920 2b20 5f73 697a 6532 7368 6170  f,) + _size2shap
+00006f30: 6528 7369 7a65 2929 202a 2a20 320a 2020  e(size)) ** 2.  
+00006f40: 2020 2020 6469 7374 203d 2064 6973 742e      dist = dist.
+00006f50: 7375 6d28 6178 6973 3d30 290a 2020 2020  sum(axis=0).    
+00006f60: 7265 7475 726e 205f 7265 7475 726e 2864  return _return(d
+00006f70: 6973 7429 0a0a 2020 6465 6620 6469 7269  ist)..  def diri
+00006f80: 6368 6c65 7428 7365 6c66 2c20 616c 7068  chlet(self, alph
+00006f90: 612c 2073 697a 653d 4e6f 6e65 2c20 6b65  a, size=None, ke
+00006fa0: 793d 4e6f 6e65 293a 0a20 2020 206b 6579  y=None):.    key
+00006fb0: 203d 2073 656c 662e 7370 6c69 745f 6b65   = self.split_ke
+00006fc0: 7928 2920 6966 206b 6579 2069 7320 4e6f  y() if key is No
+00006fd0: 6e65 2065 6c73 6520 5f66 6f72 6d61 6c69  ne else _formali
+00006fe0: 7a65 5f6b 6579 286b 6579 290a 2020 2020  ze_key(key).    
+00006ff0: 616c 7068 6120 3d20 5f63 6865 636b 5f70  alpha = _check_p
+00007000: 795f 7365 7128 5f61 735f 6a61 785f 6172  y_seq(_as_jax_ar
+00007010: 7261 7928 616c 7068 6129 290a 2020 2020  ray(alpha)).    
+00007020: 7220 3d20 6a72 2e64 6972 6963 686c 6574  r = jr.dirichlet
+00007030: 286b 6579 2c20 616c 7068 613d 616c 7068  (key, alpha=alph
+00007040: 612c 2073 6861 7065 3d5f 7369 7a65 3273  a, shape=_size2s
+00007050: 6861 7065 2873 697a 6529 290a 2020 2020  hape(size)).    
+00007060: 7265 7475 726e 205f 7265 7475 726e 2872  return _return(r
+00007070: 290a 0a20 2064 6566 2067 656f 6d65 7472  )..  def geometr
+00007080: 6963 2873 656c 662c 2070 2c20 7369 7a65  ic(self, p, size
+00007090: 3d4e 6f6e 652c 206b 6579 3d4e 6f6e 6529  =None, key=None)
+000070a0: 3a0a 2020 2020 7020 3d20 5f61 735f 6a61  :.    p = _as_ja
+000070b0: 785f 6172 7261 7928 7029 0a20 2020 2070  x_array(p).    p
+000070c0: 203d 205f 6368 6563 6b5f 7079 5f73 6571   = _check_py_seq
+000070d0: 2870 290a 2020 2020 6966 2073 697a 6520  (p).    if size 
+000070e0: 6973 204e 6f6e 653a 0a20 2020 2020 2073  is None:.      s
+000070f0: 697a 6520 3d20 6a6e 702e 7368 6170 6528  ize = jnp.shape(
+00007100: 7029 0a20 2020 206b 6579 203d 2073 656c  p).    key = sel
+00007110: 662e 7370 6c69 745f 6b65 7928 2920 6966  f.split_key() if
+00007120: 206b 6579 2069 7320 4e6f 6e65 2065 6c73   key is None els
+00007130: 6520 5f66 6f72 6d61 6c69 7a65 5f6b 6579  e _formalize_key
+00007140: 286b 6579 290a 2020 2020 7520 3d20 6a72  (key).    u = jr
+00007150: 2e75 6e69 666f 726d 286b 6579 2c20 7369  .uniform(key, si
+00007160: 7a65 290a 2020 2020 7220 3d20 6a6e 702e  ze).    r = jnp.
+00007170: 666c 6f6f 7228 6a6e 702e 6c6f 6731 7028  floor(jnp.log1p(
+00007180: 2d75 2920 2f20 6a6e 702e 6c6f 6731 7028  -u) / jnp.log1p(
+00007190: 2d70 2929 0a20 2020 2072 6574 7572 6e20  -p)).    return 
+000071a0: 5f72 6574 7572 6e28 7229 0a0a 2020 6465  _return(r)..  de
+000071b0: 6620 5f63 6865 636b 5f70 3228 7365 6c66  f _check_p2(self
+000071c0: 2c20 7029 3a0a 2020 2020 7261 6973 6520  , p):.    raise 
+000071d0: 5661 6c75 6545 7272 6f72 2866 2757 6520  ValueError(f'We 
+000071e0: 7265 7175 6972 6520 6073 756d 2870 7661  require `sum(pva
+000071f0: 6c73 5b3a 2d31 5d29 203c 3d20 3160 2e20  ls[:-1]) <= 1`. 
+00007200: 4275 7420 7765 2067 6f74 207b 707d 2729  But we got {p}')
+00007210: 0a0a 2020 6465 6620 6d75 6c74 696e 6f6d  ..  def multinom
+00007220: 6961 6c28 7365 6c66 2c20 6e2c 2070 7661  ial(self, n, pva
+00007230: 6c73 2c20 7369 7a65 3d4e 6f6e 652c 206b  ls, size=None, k
+00007240: 6579 3d4e 6f6e 6529 3a0a 2020 2020 6b65  ey=None):.    ke
+00007250: 7920 3d20 7365 6c66 2e73 706c 6974 5f6b  y = self.split_k
+00007260: 6579 2829 2069 6620 6b65 7920 6973 204e  ey() if key is N
+00007270: 6f6e 6520 656c 7365 205f 666f 726d 616c  one else _formal
+00007280: 697a 655f 6b65 7928 6b65 7929 0a20 2020  ize_key(key).   
+00007290: 206e 203d 205f 6368 6563 6b5f 7079 5f73   n = _check_py_s
+000072a0: 6571 285f 6173 5f6a 6178 5f61 7272 6179  eq(_as_jax_array
+000072b0: 286e 2929 0a20 2020 2070 7661 6c73 203d  (n)).    pvals =
+000072c0: 205f 6368 6563 6b5f 7079 5f73 6571 285f   _check_py_seq(_
+000072d0: 6173 5f6a 6178 5f61 7272 6179 2870 7661  as_jax_array(pva
+000072e0: 6c73 2929 0a20 2020 206a 6974 5f65 7272  ls)).    jit_err
+000072f0: 6f72 5f63 6865 636b 696e 6728 6a6e 702e  or_checking(jnp.
+00007300: 7375 6d28 7076 616c 735b 3a2d 315d 2920  sum(pvals[:-1]) 
+00007310: 3e20 312e 2c20 7365 6c66 2e5f 6368 6563  > 1., self._chec
+00007320: 6b5f 7032 2c20 7076 616c 7329 0a20 2020  k_p2, pvals).   
+00007330: 2069 6620 6973 696e 7374 616e 6365 286e   if isinstance(n
+00007340: 2c20 6a61 782e 636f 7265 2e54 7261 6365  , jax.core.Trace
+00007350: 7229 3a0a 2020 2020 2020 7261 6973 6520  r):.      raise 
+00007360: 5661 6c75 6545 7272 6f72 2822 5468 6520  ValueError("The 
+00007370: 746f 7461 6c20 636f 756e 7420 7061 7261  total count para
+00007380: 6d65 7465 7220 606e 6020 7368 6f75 6c64  meter `n` should
+00007390: 206e 6f74 2062 6520 6120 6a61 7820 6162   not be a jax ab
+000073a0: 7374 7261 6374 2061 7272 6179 2e22 290a  stract array.").
+000073b0: 2020 2020 7369 7a65 203d 205f 7369 7a65      size = _size
+000073c0: 3273 6861 7065 2873 697a 6529 0a20 2020  2shape(size).   
+000073d0: 206e 5f6d 6178 203d 2069 6e74 286e 702e   n_max = int(np.
+000073e0: 6d61 7828 6a61 782e 6465 7669 6365 5f67  max(jax.device_g
+000073f0: 6574 286e 2929 290a 2020 2020 6261 7463  et(n))).    batc
+00007400: 685f 7368 6170 6520 3d20 6c61 782e 6272  h_shape = lax.br
+00007410: 6f61 6463 6173 745f 7368 6170 6573 286a  oadcast_shapes(j
+00007420: 6e70 2e73 6861 7065 2870 7661 6c73 295b  np.shape(pvals)[
+00007430: 3a2d 315d 2c20 6a6e 702e 7368 6170 6528  :-1], jnp.shape(
+00007440: 6e29 290a 2020 2020 7220 3d20 5f6d 756c  n)).    r = _mul
+00007450: 7469 6e6f 6d69 616c 286b 6579 2c20 7076  tinomial(key, pv
+00007460: 616c 732c 206e 2c20 6e5f 6d61 782c 2062  als, n, n_max, b
+00007470: 6174 6368 5f73 6861 7065 202b 2073 697a  atch_shape + siz
+00007480: 6529 0a20 2020 2072 6574 7572 6e20 5f72  e).    return _r
+00007490: 6574 7572 6e28 7229 0a0a 2020 6465 6620  eturn(r)..  def 
+000074a0: 6d75 6c74 6976 6172 6961 7465 5f6e 6f72  multivariate_nor
+000074b0: 6d61 6c28 7365 6c66 2c20 6d65 616e 2c20  mal(self, mean, 
+000074c0: 636f 762c 2073 697a 653d 4e6f 6e65 2c20  cov, size=None, 
+000074d0: 6d65 7468 6f64 3a20 7374 7220 3d20 2763  method: str = 'c
+000074e0: 686f 6c65 736b 7927 2c20 6b65 793d 4e6f  holesky', key=No
+000074f0: 6e65 293a 0a20 2020 2069 6620 6d65 7468  ne):.    if meth
+00007500: 6f64 206e 6f74 2069 6e20 7b27 7376 6427  od not in {'svd'
+00007510: 2c20 2765 6967 6827 2c20 2763 686f 6c65  , 'eigh', 'chole
+00007520: 736b 7927 7d3a 0a20 2020 2020 2072 6169  sky'}:.      rai
+00007530: 7365 2056 616c 7565 4572 726f 7228 226d  se ValueError("m
+00007540: 6574 686f 6420 6d75 7374 2062 6520 6f6e  ethod must be on
+00007550: 6520 6f66 207b 2773 7664 272c 2027 6569  e of {'svd', 'ei
+00007560: 6768 272c 2027 6368 6f6c 6573 6b79 277d  gh', 'cholesky'}
+00007570: 2229 0a20 2020 206d 6561 6e20 3d20 5f63  ").    mean = _c
+00007580: 6865 636b 5f70 795f 7365 7128 5f61 735f  heck_py_seq(_as_
+00007590: 6a61 785f 6172 7261 7928 6d65 616e 2929  jax_array(mean))
+000075a0: 0a20 2020 2063 6f76 203d 205f 6368 6563  .    cov = _chec
+000075b0: 6b5f 7079 5f73 6571 285f 6173 5f6a 6178  k_py_seq(_as_jax
+000075c0: 5f61 7272 6179 2863 6f76 2929 0a20 2020  _array(cov)).   
+000075d0: 206b 6579 203d 2073 656c 662e 7370 6c69   key = self.spli
+000075e0: 745f 6b65 7928 2920 6966 206b 6579 2069  t_key() if key i
+000075f0: 7320 4e6f 6e65 2065 6c73 6520 5f66 6f72  s None else _for
+00007600: 6d61 6c69 7a65 5f6b 6579 286b 6579 290a  malize_key(key).
+00007610: 0a20 2020 2069 6620 6e6f 7420 6a6e 702e  .    if not jnp.
+00007620: 6e64 696d 286d 6561 6e29 203e 3d20 313a  ndim(mean) >= 1:
+00007630: 0a20 2020 2020 2072 6169 7365 2056 616c  .      raise Val
+00007640: 7565 4572 726f 7228 6622 6d75 6c74 6976  ueError(f"multiv
+00007650: 6172 6961 7465 5f6e 6f72 6d61 6c20 7265  ariate_normal re
+00007660: 7175 6972 6573 206d 6561 6e2e 6e64 696d  quires mean.ndim
+00007670: 203e 3d20 312c 2067 6f74 206d 6561 6e2e   >= 1, got mean.
+00007680: 6e64 696d 203d 3d20 7b6a 6e70 2e6e 6469  ndim == {jnp.ndi
+00007690: 6d28 6d65 616e 297d 2229 0a20 2020 2069  m(mean)}").    i
+000076a0: 6620 6e6f 7420 6a6e 702e 6e64 696d 2863  f not jnp.ndim(c
+000076b0: 6f76 2920 3e3d 2032 3a0a 2020 2020 2020  ov) >= 2:.      
+000076c0: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+000076d0: 2866 226d 756c 7469 7661 7269 6174 655f  (f"multivariate_
+000076e0: 6e6f 726d 616c 2072 6571 7569 7265 7320  normal requires 
+000076f0: 636f 762e 6e64 696d 203e 3d20 322c 2067  cov.ndim >= 2, g
+00007700: 6f74 2063 6f76 2e6e 6469 6d20 3d3d 207b  ot cov.ndim == {
+00007710: 6a6e 702e 6e64 696d 2863 6f76 297d 2229  jnp.ndim(cov)}")
+00007720: 0a20 2020 206e 203d 206d 6561 6e2e 7368  .    n = mean.sh
+00007730: 6170 655b 2d31 5d0a 2020 2020 6966 206a  ape[-1].    if j
+00007740: 6e70 2e73 6861 7065 2863 6f76 295b 2d32  np.shape(cov)[-2
+00007750: 3a5d 2021 3d20 286e 2c20 6e29 3a0a 2020  :] != (n, n):.  
+00007760: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
+00007770: 7272 6f72 2866 226d 756c 7469 7661 7269  rror(f"multivari
+00007780: 6174 655f 6e6f 726d 616c 2072 6571 7569  ate_normal requi
+00007790: 7265 7320 636f 762e 7368 6170 6520 3d3d  res cov.shape ==
+000077a0: 2028 2e2e 2e2c 206e 2c20 6e29 2066 6f72   (..., n, n) for
+000077b0: 206e 3d7b 6e7d 2c20 220a 2020 2020 2020   n={n}, ".      
+000077c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000077d0: 2066 2262 7574 2067 6f74 2063 6f76 2e73   f"but got cov.s
+000077e0: 6861 7065 203d 3d20 7b6a 6e70 2e73 6861  hape == {jnp.sha
+000077f0: 7065 2863 6f76 297d 2e22 290a 2020 2020  pe(cov)}.").    
+00007800: 6966 2073 697a 6520 6973 204e 6f6e 653a  if size is None:
+00007810: 0a20 2020 2020 2073 697a 6520 3d20 6c61  .      size = la
+00007820: 782e 6272 6f61 6463 6173 745f 7368 6170  x.broadcast_shap
+00007830: 6573 286d 6561 6e2e 7368 6170 655b 3a2d  es(mean.shape[:-
+00007840: 315d 2c20 636f 762e 7368 6170 655b 3a2d  1], cov.shape[:-
+00007850: 325d 290a 2020 2020 656c 7365 3a0a 2020  2]).    else:.  
+00007860: 2020 2020 7369 7a65 203d 205f 7369 7a65      size = _size
+00007870: 3273 6861 7065 2873 697a 6529 0a20 2020  2shape(size).   
+00007880: 2020 205f 6368 6563 6b5f 7368 6170 6528     _check_shape(
+00007890: 226e 6f72 6d61 6c22 2c20 7369 7a65 2c20  "normal", size, 
+000078a0: 6d65 616e 2e73 6861 7065 5b3a 2d31 5d2c  mean.shape[:-1],
+000078b0: 2063 6f76 2e73 6861 7065 5b3a 2d32 5d29   cov.shape[:-2])
+000078c0: 0a0a 2020 2020 6966 206d 6574 686f 6420  ..    if method 
+000078d0: 3d3d 2027 7376 6427 3a0a 2020 2020 2020  == 'svd':.      
+000078e0: 2875 2c20 732c 205f 2920 3d20 6a6e 702e  (u, s, _) = jnp.
+000078f0: 6c69 6e61 6c67 2e73 7664 2863 6f76 290a  linalg.svd(cov).
+00007900: 2020 2020 2020 6661 6374 6f72 203d 2075        factor = u
+00007910: 202a 206a 6e70 2e73 7172 7428 735b 2e2e   * jnp.sqrt(s[..
+00007920: 2e2c 204e 6f6e 652c 203a 5d29 0a20 2020  ., None, :]).   
+00007930: 2065 6c69 6620 6d65 7468 6f64 203d 3d20   elif method == 
+00007940: 2765 6967 6827 3a0a 2020 2020 2020 2877  'eigh':.      (w
+00007950: 2c20 7629 203d 206a 6e70 2e6c 696e 616c  , v) = jnp.linal
+00007960: 672e 6569 6768 2863 6f76 290a 2020 2020  g.eigh(cov).    
+00007970: 2020 6661 6374 6f72 203d 2076 202a 206a    factor = v * j
+00007980: 6e70 2e73 7172 7428 775b 2e2e 2e2c 204e  np.sqrt(w[..., N
+00007990: 6f6e 652c 203a 5d29 0a20 2020 2065 6c73  one, :]).    els
+000079a0: 653a 2020 2320 2763 686f 6c65 736b 7927  e:  # 'cholesky'
+000079b0: 0a20 2020 2020 2066 6163 746f 7220 3d20  .      factor = 
+000079c0: 6a6e 702e 6c69 6e61 6c67 2e63 686f 6c65  jnp.linalg.chole
+000079d0: 736b 7928 636f 7629 0a20 2020 206e 6f72  sky(cov).    nor
+000079e0: 6d61 6c5f 7361 6d70 6c65 7320 3d20 6a72  mal_samples = jr
+000079f0: 2e6e 6f72 6d61 6c28 6b65 792c 2073 697a  .normal(key, siz
+00007a00: 6520 2b20 6d65 616e 2e73 6861 7065 5b2d  e + mean.shape[-
+00007a10: 313a 5d29 0a20 2020 2072 203d 206d 6561  1:]).    r = mea
+00007a20: 6e20 2b20 6a6e 702e 6569 6e73 756d 2827  n + jnp.einsum('
+00007a30: 2e2e 2e69 6a2c 2e2e 2e6a 2d3e 2e2e 2e69  ...ij,...j->...i
+00007a40: 272c 2066 6163 746f 722c 206e 6f72 6d61  ', factor, norma
+00007a50: 6c5f 7361 6d70 6c65 7329 0a20 2020 2072  l_samples).    r
+00007a60: 6574 7572 6e20 5f72 6574 7572 6e28 7229  eturn _return(r)
+00007a70: 0a0a 2020 6465 6620 7261 796c 6569 6768  ..  def rayleigh
+00007a80: 2873 656c 662c 2073 6361 6c65 3d31 2e30  (self, scale=1.0
+00007a90: 2c20 7369 7a65 3d4e 6f6e 652c 206b 6579  , size=None, key
+00007aa0: 3d4e 6f6e 6529 3a0a 2020 2020 7363 616c  =None):.    scal
+00007ab0: 6520 3d20 5f63 6865 636b 5f70 795f 7365  e = _check_py_se
+00007ac0: 7128 5f61 735f 6a61 785f 6172 7261 7928  q(_as_jax_array(
+00007ad0: 7363 616c 6529 290a 2020 2020 6966 2073  scale)).    if s
+00007ae0: 697a 6520 6973 204e 6f6e 653a 0a20 2020  ize is None:.   
+00007af0: 2020 2073 697a 6520 3d20 6a6e 702e 7368     size = jnp.sh
+00007b00: 6170 6528 7363 616c 6529 0a20 2020 206b  ape(scale).    k
+00007b10: 6579 203d 2073 656c 662e 7370 6c69 745f  ey = self.split_
+00007b20: 6b65 7928 2920 6966 206b 6579 2069 7320  key() if key is 
+00007b30: 4e6f 6e65 2065 6c73 6520 5f66 6f72 6d61  None else _forma
+00007b40: 6c69 7a65 5f6b 6579 286b 6579 290a 2020  lize_key(key).  
+00007b50: 2020 7820 3d20 6a6e 702e 7371 7274 282d    x = jnp.sqrt(-
+00007b60: 322e 202a 206a 6e70 2e6c 6f67 286a 722e  2. * jnp.log(jr.
+00007b70: 756e 6966 6f72 6d28 6b65 792c 2073 6861  uniform(key, sha
+00007b80: 7065 3d5f 7369 7a65 3273 6861 7065 2873  pe=_size2shape(s
+00007b90: 697a 6529 2c20 6d69 6e76 616c 3d30 2c20  ize), minval=0, 
+00007ba0: 6d61 7876 616c 3d31 2929 290a 2020 2020  maxval=1))).    
+00007bb0: 7220 3d20 7820 2a20 7363 616c 650a 2020  r = x * scale.  
+00007bc0: 2020 7265 7475 726e 205f 7265 7475 726e    return _return
+00007bd0: 2872 290a 0a20 2064 6566 2074 7269 616e  (r)..  def trian
+00007be0: 6775 6c61 7228 7365 6c66 2c20 7369 7a65  gular(self, size
+00007bf0: 3d4e 6f6e 652c 206b 6579 3d4e 6f6e 6529  =None, key=None)
+00007c00: 3a0a 2020 2020 6b65 7920 3d20 7365 6c66  :.    key = self
+00007c10: 2e73 706c 6974 5f6b 6579 2829 2069 6620  .split_key() if 
+00007c20: 6b65 7920 6973 204e 6f6e 6520 656c 7365  key is None else
+00007c30: 205f 666f 726d 616c 697a 655f 6b65 7928   _formalize_key(
+00007c40: 6b65 7929 0a20 2020 2062 6572 6e6f 756c  key).    bernoul
+00007c50: 6c69 5f73 616d 706c 6573 203d 206a 722e  li_samples = jr.
+00007c60: 6265 726e 6f75 6c6c 6928 6b65 792c 2070  bernoulli(key, p
+00007c70: 3d30 2e35 2c20 7368 6170 653d 5f73 697a  =0.5, shape=_siz
+00007c80: 6532 7368 6170 6528 7369 7a65 2929 0a20  e2shape(size)). 
+00007c90: 2020 2072 203d 2032 202a 2062 6572 6e6f     r = 2 * berno
+00007ca0: 756c 6c69 5f73 616d 706c 6573 202d 2031  ulli_samples - 1
+00007cb0: 0a20 2020 2072 6574 7572 6e20 5f72 6574  .    return _ret
+00007cc0: 7572 6e28 7229 0a0a 2020 6465 6620 766f  urn(r)..  def vo
+00007cd0: 6e6d 6973 6573 2873 656c 662c 206d 752c  nmises(self, mu,
+00007ce0: 206b 6170 7061 2c20 7369 7a65 3d4e 6f6e   kappa, size=Non
+00007cf0: 652c 206b 6579 3d4e 6f6e 6529 3a0a 2020  e, key=None):.  
+00007d00: 2020 6b65 7920 3d20 7365 6c66 2e73 706c    key = self.spl
+00007d10: 6974 5f6b 6579 2829 2069 6620 6b65 7920  it_key() if key 
+00007d20: 6973 204e 6f6e 6520 656c 7365 205f 666f  is None else _fo
+00007d30: 726d 616c 697a 655f 6b65 7928 6b65 7929  rmalize_key(key)
+00007d40: 0a20 2020 206d 7520 3d20 5f63 6865 636b  .    mu = _check
+00007d50: 5f70 795f 7365 7128 5f61 735f 6a61 785f  _py_seq(_as_jax_
+00007d60: 6172 7261 7928 6d75 2929 0a20 2020 206b  array(mu)).    k
+00007d70: 6170 7061 203d 205f 6368 6563 6b5f 7079  appa = _check_py
+00007d80: 5f73 6571 285f 6173 5f6a 6178 5f61 7272  _seq(_as_jax_arr
+00007d90: 6179 286b 6170 7061 2929 0a20 2020 2069  ay(kappa)).    i
+00007da0: 6620 7369 7a65 2069 7320 4e6f 6e65 3a0a  f size is None:.
+00007db0: 2020 2020 2020 7369 7a65 203d 206c 6178        size = lax
+00007dc0: 2e62 726f 6164 6361 7374 5f73 6861 7065  .broadcast_shape
+00007dd0: 7328 6a6e 702e 7368 6170 6528 6d75 292c  s(jnp.shape(mu),
+00007de0: 206a 6e70 2e73 6861 7065 286b 6170 7061   jnp.shape(kappa
+00007df0: 2929 0a20 2020 2073 697a 6520 3d20 5f73  )).    size = _s
+00007e00: 697a 6532 7368 6170 6528 7369 7a65 290a  ize2shape(size).
+00007e10: 2020 2020 7361 6d70 6c65 7320 3d20 5f76      samples = _v
+00007e20: 6f6e 5f6d 6973 6573 5f63 656e 7465 7265  on_mises_centere
+00007e30: 6428 6b65 792c 206b 6170 7061 2c20 7369  d(key, kappa, si
+00007e40: 7a65 290a 2020 2020 7361 6d70 6c65 7320  ze).    samples 
+00007e50: 3d20 7361 6d70 6c65 7320 2b20 6d75 0a20  = samples + mu. 
+00007e60: 2020 2073 616d 706c 6573 203d 2028 7361     samples = (sa
+00007e70: 6d70 6c65 7320 2b20 6a6e 702e 7069 2920  mples + jnp.pi) 
+00007e80: 2520 2832 2e30 202a 206a 6e70 2e70 6929  % (2.0 * jnp.pi)
+00007e90: 202d 206a 6e70 2e70 690a 2020 2020 7265   - jnp.pi.    re
+00007ea0: 7475 726e 205f 7265 7475 726e 2873 616d  turn _return(sam
+00007eb0: 706c 6573 290a 0a20 2064 6566 2077 6569  ples)..  def wei
+00007ec0: 6275 6c6c 2873 656c 662c 2061 2c20 7369  bull(self, a, si
+00007ed0: 7a65 3d4e 6f6e 652c 206b 6579 3d4e 6f6e  ze=None, key=Non
+00007ee0: 6529 3a0a 2020 2020 6b65 7920 3d20 7365  e):.    key = se
+00007ef0: 6c66 2e73 706c 6974 5f6b 6579 2829 2069  lf.split_key() i
+00007f00: 6620 6b65 7920 6973 204e 6f6e 6520 656c  f key is None el
+00007f10: 7365 205f 666f 726d 616c 697a 655f 6b65  se _formalize_ke
+00007f20: 7928 6b65 7929 0a20 2020 2061 203d 205f  y(key).    a = _
+00007f30: 6368 6563 6b5f 7079 5f73 6571 285f 6173  check_py_seq(_as
+00007f40: 5f6a 6178 5f61 7272 6179 2861 2929 0a20  _jax_array(a)). 
+00007f50: 2020 2069 6620 7369 7a65 2069 7320 4e6f     if size is No
+00007f60: 6e65 3a0a 2020 2020 2020 7369 7a65 203d  ne:.      size =
+00007f70: 206a 6e70 2e73 6861 7065 2861 290a 2020   jnp.shape(a).  
+00007f80: 2020 656c 7365 3a0a 2020 2020 2020 6966    else:.      if
+00007f90: 206a 6e70 2e73 697a 6528 6129 203e 2031   jnp.size(a) > 1
+00007fa0: 3a0a 2020 2020 2020 2020 7261 6973 6520  :.        raise 
+00007fb0: 5661 6c75 6545 7272 6f72 2866 2722 6122  ValueError(f'"a"
+00007fc0: 2073 686f 756c 6420 6265 2061 2073 6361   should be a sca
+00007fd0: 6c61 7220 7768 656e 2022 7369 7a65 2220  lar when "size" 
+00007fe0: 6973 2070 726f 7669 6465 642e 2042 7574  is provided. But
+00007ff0: 2077 6520 676f 7420 7b61 7d27 290a 2020   we got {a}').  
+00008000: 2020 7369 7a65 203d 205f 7369 7a65 3273    size = _size2s
+00008010: 6861 7065 2873 697a 6529 0a20 2020 2072  hape(size).    r
+00008020: 616e 646f 6d5f 756e 6966 6f72 6d20 3d20  andom_uniform = 
+00008030: 6a72 2e75 6e69 666f 726d 286b 6579 3d6b  jr.uniform(key=k
+00008040: 6579 2c20 7368 6170 653d 7369 7a65 2c20  ey, shape=size, 
+00008050: 6d69 6e76 616c 3d30 2c20 6d61 7876 616c  minval=0, maxval
+00008060: 3d31 290a 2020 2020 7220 3d20 6a6e 702e  =1).    r = jnp.
+00008070: 706f 7765 7228 2d6a 6e70 2e6c 6f67 3170  power(-jnp.log1p
+00008080: 282d 7261 6e64 6f6d 5f75 6e69 666f 726d  (-random_uniform
+00008090: 292c 2031 2e30 202f 2061 290a 2020 2020  ), 1.0 / a).    
+000080a0: 7265 7475 726e 205f 7265 7475 726e 2872  return _return(r
+000080b0: 290a 0a20 2064 6566 2077 6569 6275 6c6c  )..  def weibull
+000080c0: 5f6d 696e 2873 656c 662c 2061 2c20 7363  _min(self, a, sc
+000080d0: 616c 653d 4e6f 6e65 2c20 7369 7a65 3d4e  ale=None, size=N
+000080e0: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
+000080f0: 2020 2020 2222 2253 616d 706c 6520 6672      """Sample fr
+00008100: 6f6d 2061 2057 6569 6275 6c6c 206d 696e  om a Weibull min
+00008110: 696d 756d 2064 6973 7472 6962 7574 696f  imum distributio
+00008120: 6e2e 0a0a 2020 2020 5061 7261 6d65 7465  n...    Paramete
+00008130: 7273 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d  rs.    ---------
+00008140: 2d0a 2020 2020 613a 2066 6c6f 6174 2c20  -.    a: float, 
+00008150: 6172 7261 795f 6c69 6b65 0a20 2020 2020  array_like.     
+00008160: 2054 6865 2063 6f6e 6365 6e74 7261 7469   The concentrati
+00008170: 6f6e 2070 6172 616d 6574 6572 206f 6620  on parameter of 
+00008180: 7468 6520 6469 7374 7269 6275 7469 6f6e  the distribution
+00008190: 2e0a 2020 2020 7363 616c 653a 2066 6c6f  ..    scale: flo
+000081a0: 6174 2c20 6172 7261 795f 6c69 6b65 0a20  at, array_like. 
+000081b0: 2020 2020 2054 6865 2073 6361 6c65 2070       The scale p
+000081c0: 6172 616d 6574 6572 206f 6620 7468 6520  arameter of the 
+000081d0: 6469 7374 7269 6275 7469 6f6e 2e0a 2020  distribution..  
+000081e0: 2020 7369 7a65 3a20 6f70 7469 6f6e 616c    size: optional
+000081f0: 2c20 696e 742c 2074 7570 6c65 206f 6620  , int, tuple of 
+00008200: 696e 740a 2020 2020 2020 5468 6520 7368  int.      The sh
+00008210: 6170 6520 6164 6465 6420 746f 2074 6865  ape added to the
+00008220: 2070 6172 616d 6574 6572 7320 6c6f 6320   parameters loc 
+00008230: 616e 6420 7363 616c 6520 6272 6f61 6463  and scale broadc
+00008240: 6173 7461 626c 6520 7368 6170 652e 0a0a  astable shape...
+00008250: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
+00008260: 2d2d 2d2d 2d2d 2d0a 2020 2020 6f75 743a  -------.    out:
+00008270: 2061 7272 6179 5f6c 696b 650a 2020 2020   array_like.    
+00008280: 2020 5468 6520 7361 6d70 6c69 6e67 2072    The sampling r
+00008290: 6573 756c 7473 2e0a 2020 2020 2222 220a  esults..    """.
+000082a0: 2020 2020 6b65 7920 3d20 7365 6c66 2e73      key = self.s
+000082b0: 706c 6974 5f6b 6579 2829 2069 6620 6b65  plit_key() if ke
+000082c0: 7920 6973 204e 6f6e 6520 656c 7365 205f  y is None else _
+000082d0: 666f 726d 616c 697a 655f 6b65 7928 6b65  formalize_key(ke
+000082e0: 7929 0a20 2020 2061 203d 205f 6368 6563  y).    a = _chec
+000082f0: 6b5f 7079 5f73 6571 285f 6173 5f6a 6178  k_py_seq(_as_jax
+00008300: 5f61 7272 6179 2861 2929 0a20 2020 2073  _array(a)).    s
+00008310: 6361 6c65 203d 205f 6368 6563 6b5f 7079  cale = _check_py
+00008320: 5f73 6571 285f 6173 5f6a 6178 5f61 7272  _seq(_as_jax_arr
+00008330: 6179 2873 6361 6c65 2929 0a20 2020 2069  ay(scale)).    i
+00008340: 6620 7369 7a65 2069 7320 4e6f 6e65 3a0a  f size is None:.
+00008350: 2020 2020 2020 7369 7a65 203d 206a 6e70        size = jnp
+00008360: 2e62 726f 6164 6361 7374 5f73 6861 7065  .broadcast_shape
+00008370: 7328 6a6e 702e 7368 6170 6528 6129 2c20  s(jnp.shape(a), 
+00008380: 6a6e 702e 7368 6170 6528 7363 616c 6529  jnp.shape(scale)
+00008390: 290a 2020 2020 656c 7365 3a0a 2020 2020  ).    else:.    
+000083a0: 2020 6966 206a 6e70 2e73 697a 6528 6129    if jnp.size(a)
+000083b0: 203e 2031 3a0a 2020 2020 2020 2020 7261   > 1:.        ra
+000083c0: 6973 6520 5661 6c75 6545 7272 6f72 2866  ise ValueError(f
+000083d0: 2722 6122 2073 686f 756c 6420 6265 2061  '"a" should be a
+000083e0: 2073 6361 6c61 7220 7768 656e 2022 7369   scalar when "si
+000083f0: 7a65 2220 6973 2070 726f 7669 6465 642e  ze" is provided.
+00008400: 2042 7574 2077 6520 676f 7420 7b61 7d27   But we got {a}'
+00008410: 290a 2020 2020 7369 7a65 203d 205f 7369  ).    size = _si
+00008420: 7a65 3273 6861 7065 2873 697a 6529 0a20  ze2shape(size). 
+00008430: 2020 2072 616e 646f 6d5f 756e 6966 6f72     random_unifor
+00008440: 6d20 3d20 6a72 2e75 6e69 666f 726d 286b  m = jr.uniform(k
+00008450: 6579 3d6b 6579 2c20 7368 6170 653d 7369  ey=key, shape=si
+00008460: 7a65 2c20 6d69 6e76 616c 3d30 2c20 6d61  ze, minval=0, ma
+00008470: 7876 616c 3d31 290a 2020 2020 7220 3d20  xval=1).    r = 
+00008480: 6a6e 702e 706f 7765 7228 2d6a 6e70 2e6c  jnp.power(-jnp.l
+00008490: 6f67 3170 282d 7261 6e64 6f6d 5f75 6e69  og1p(-random_uni
+000084a0: 666f 726d 292c 2031 2e30 202f 2061 290a  form), 1.0 / a).
+000084b0: 2020 2020 6966 2073 6361 6c65 2069 7320      if scale is 
+000084c0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+000084d0: 7220 2f3d 2073 6361 6c65 0a20 2020 2072  r /= scale.    r
+000084e0: 6574 7572 6e20 5f72 6574 7572 6e28 7229  eturn _return(r)
+000084f0: 0a0a 2020 6465 6620 6d61 7877 656c 6c28  ..  def maxwell(
+00008500: 7365 6c66 2c20 7369 7a65 3d4e 6f6e 652c  self, size=None,
+00008510: 206b 6579 3d4e 6f6e 6529 3a0a 2020 2020   key=None):.    
+00008520: 6b65 7920 3d20 7365 6c66 2e73 706c 6974  key = self.split
+00008530: 5f6b 6579 2829 2069 6620 6b65 7920 6973  _key() if key is
+00008540: 204e 6f6e 6520 656c 7365 205f 666f 726d   None else _form
+00008550: 616c 697a 655f 6b65 7928 6b65 7929 0a20  alize_key(key). 
+00008560: 2020 2073 6861 7065 203d 2063 6f72 652e     shape = core.
+00008570: 6361 6e6f 6e69 6361 6c69 7a65 5f73 6861  canonicalize_sha
+00008580: 7065 285f 7369 7a65 3273 6861 7065 2873  pe(_size2shape(s
+00008590: 697a 6529 2920 2b20 2833 2c29 0a20 2020  ize)) + (3,).   
+000085a0: 206e 6f72 6d5f 7276 7320 3d20 6a72 2e6e   norm_rvs = jr.n
+000085b0: 6f72 6d61 6c28 6b65 793d 6b65 792c 2073  ormal(key=key, s
+000085c0: 6861 7065 3d73 6861 7065 290a 2020 2020  hape=shape).    
+000085d0: 7220 3d20 6a6e 702e 6c69 6e61 6c67 2e6e  r = jnp.linalg.n
+000085e0: 6f72 6d28 6e6f 726d 5f72 7673 2c20 6178  orm(norm_rvs, ax
+000085f0: 6973 3d2d 3129 0a20 2020 2072 6574 7572  is=-1).    retur
+00008600: 6e20 5f72 6574 7572 6e28 7229 0a0a 2020  n _return(r)..  
+00008610: 6465 6620 6e65 6761 7469 7665 5f62 696e  def negative_bin
+00008620: 6f6d 6961 6c28 7365 6c66 2c20 6e2c 2070  omial(self, n, p
+00008630: 2c20 7369 7a65 3d4e 6f6e 652c 206b 6579  , size=None, key
+00008640: 3d4e 6f6e 6529 3a0a 2020 2020 6e20 3d20  =None):.    n = 
+00008650: 5f63 6865 636b 5f70 795f 7365 7128 5f61  _check_py_seq(_a
+00008660: 735f 6a61 785f 6172 7261 7928 6e29 290a  s_jax_array(n)).
+00008670: 2020 2020 7020 3d20 5f63 6865 636b 5f70      p = _check_p
+00008680: 795f 7365 7128 5f61 735f 6a61 785f 6172  y_seq(_as_jax_ar
+00008690: 7261 7928 7029 290a 2020 2020 6966 2073  ray(p)).    if s
+000086a0: 697a 6520 6973 204e 6f6e 653a 0a20 2020  ize is None:.   
+000086b0: 2020 2073 697a 6520 3d20 6c61 782e 6272     size = lax.br
+000086c0: 6f61 6463 6173 745f 7368 6170 6573 286a  oadcast_shapes(j
+000086d0: 6e70 2e73 6861 7065 286e 292c 206a 6e70  np.shape(n), jnp
+000086e0: 2e73 6861 7065 2870 2929 0a20 2020 2073  .shape(p)).    s
+000086f0: 697a 6520 3d20 5f73 697a 6532 7368 6170  ize = _size2shap
+00008700: 6528 7369 7a65 290a 2020 2020 6c6f 6769  e(size).    logi
+00008710: 7473 203d 206a 6e70 2e6c 6f67 2870 2920  ts = jnp.log(p) 
+00008720: 2d20 6a6e 702e 6c6f 6731 7028 2d70 290a  - jnp.log1p(-p).
+00008730: 2020 2020 6966 206b 6579 2069 7320 4e6f      if key is No
+00008740: 6e65 3a0a 2020 2020 2020 6b65 7973 203d  ne:.      keys =
+00008750: 2073 656c 662e 7370 6c69 745f 6b65 7973   self.split_keys
+00008760: 2832 290a 2020 2020 656c 7365 3a0a 2020  (2).    else:.  
+00008770: 2020 2020 6b65 7973 203d 206a 722e 7370      keys = jr.sp
+00008780: 6c69 7428 5f66 6f72 6d61 6c69 7a65 5f6b  lit(_formalize_k
+00008790: 6579 286b 6579 292c 2032 290a 2020 2020  ey(key), 2).    
+000087a0: 7261 7465 203d 2073 656c 662e 6761 6d6d  rate = self.gamm
+000087b0: 6128 7368 6170 653d 6e2c 2073 6361 6c65  a(shape=n, scale
+000087c0: 3d6a 6e70 2e65 7870 282d 6c6f 6769 7473  =jnp.exp(-logits
+000087d0: 292c 2073 697a 653d 7369 7a65 2c20 6b65  ), size=size, ke
+000087e0: 793d 6b65 7973 5b30 5d29 0a20 2020 2072  y=keys[0]).    r
+000087f0: 203d 2073 656c 662e 706f 6973 736f 6e28   = self.poisson(
+00008800: 6c61 6d3d 7261 7465 2c20 6b65 793d 6b65  lam=rate, key=ke
+00008810: 7973 5b31 5d29 0a20 2020 2072 6574 7572  ys[1]).    retur
+00008820: 6e20 5f72 6574 7572 6e28 7229 0a0a 2020  n _return(r)..  
+00008830: 6465 6620 7761 6c64 2873 656c 662c 206d  def wald(self, m
+00008840: 6561 6e2c 2073 6361 6c65 2c20 7369 7a65  ean, scale, size
+00008850: 3d4e 6f6e 652c 206b 6579 3d4e 6f6e 6529  =None, key=None)
+00008860: 3a0a 2020 2020 6b65 7920 3d20 7365 6c66  :.    key = self
+00008870: 2e73 706c 6974 5f6b 6579 2829 2069 6620  .split_key() if 
+00008880: 6b65 7920 6973 204e 6f6e 6520 656c 7365  key is None else
+00008890: 205f 666f 726d 616c 697a 655f 6b65 7928   _formalize_key(
+000088a0: 6b65 7929 0a20 2020 206d 6561 6e20 3d20  key).    mean = 
+000088b0: 5f63 6865 636b 5f70 795f 7365 7128 5f61  _check_py_seq(_a
+000088c0: 735f 6a61 785f 6172 7261 7928 6d65 616e  s_jax_array(mean
+000088d0: 2929 0a20 2020 2073 6361 6c65 203d 205f  )).    scale = _
+000088e0: 6368 6563 6b5f 7079 5f73 6571 285f 6173  check_py_seq(_as
+000088f0: 5f6a 6178 5f61 7272 6179 2873 6361 6c65  _jax_array(scale
+00008900: 2929 0a20 2020 2069 6620 7369 7a65 2069  )).    if size i
+00008910: 7320 4e6f 6e65 3a0a 2020 2020 2020 7369  s None:.      si
+00008920: 7a65 203d 206c 6178 2e62 726f 6164 6361  ze = lax.broadca
+00008930: 7374 5f73 6861 7065 7328 6a6e 702e 7368  st_shapes(jnp.sh
+00008940: 6170 6528 6d65 616e 292c 206a 6e70 2e73  ape(mean), jnp.s
+00008950: 6861 7065 2873 6361 6c65 2929 0a20 2020  hape(scale)).   
+00008960: 2073 697a 6520 3d20 5f73 697a 6532 7368   size = _size2sh
+00008970: 6170 6528 7369 7a65 290a 2020 2020 7361  ape(size).    sa
+00008980: 6d70 6c65 645f 6368 6932 203d 206a 6e70  mpled_chi2 = jnp
+00008990: 2e73 7175 6172 6528 5f61 735f 6a61 785f  .square(_as_jax_
+000089a0: 6172 7261 7928 7365 6c66 2e72 616e 646e  array(self.randn
+000089b0: 282a 7369 7a65 2929 290a 2020 2020 7361  (*size))).    sa
+000089c0: 6d70 6c65 645f 756e 6966 6f72 6d20 3d20  mpled_uniform = 
+000089d0: 5f61 735f 6a61 785f 6172 7261 7928 7365  _as_jax_array(se
+000089e0: 6c66 2e75 6e69 666f 726d 2873 697a 653d  lf.uniform(size=
+000089f0: 7369 7a65 2c20 6b65 793d 6b65 7929 290a  size, key=key)).
+00008a00: 2020 2020 2320 5769 6b69 7065 6469 6120      # Wikipedia 
+00008a10: 6465 6669 6e65 7320 616e 2069 6e74 6572  defines an inter
+00008a20: 6d65 6469 6174 6520 7820 7769 7468 2074  mediate x with t
+00008a30: 6865 2066 6f72 6d75 6c61 0a20 2020 2023  he formula.    #
+00008a40: 2020 2078 203d 206c 6f63 202b 206c 6f63     x = loc + loc
+00008a50: 202a 2a20 3220 2a20 7920 2f20 2832 202a   ** 2 * y / (2 *
+00008a60: 2063 6f6e 6329 202d 206c 6f63 202f 2028   conc) - loc / (
+00008a70: 3220 2a20 636f 6e63 2920 2a20 7371 7274  2 * conc) * sqrt
+00008a80: 2834 202a 206c 6f63 202a 2063 6f6e 6320  (4 * loc * conc 
+00008a90: 2a20 7920 2b20 6c6f 6320 2a2a 2032 202a  * y + loc ** 2 *
+00008aa0: 2079 202a 2a20 3229 0a20 2020 2023 2077   y ** 2).    # w
+00008ab0: 6865 7265 2079 207e 204e 2830 2c20 3129  here y ~ N(0, 1)
+00008ac0: 2a2a 3220 2873 616d 706c 6564 5f63 6869  **2 (sampled_chi
+00008ad0: 3220 6162 6f76 6529 2061 6e64 2063 6f6e  2 above) and con
+00008ae0: 6320 6973 2074 6865 2063 6f6e 6365 6e74  c is the concent
+00008af0: 7261 7469 6f6e 2e0a 2020 2020 2320 4c65  ration..    # Le
+00008b00: 7420 7573 2077 7269 7465 0a20 2020 2023  t us write.    #
+00008b10: 2020 2077 203d 206c 6f63 202a 2079 202f     w = loc * y /
+00008b20: 2028 3220 2a20 636f 6e63 290a 2020 2020   (2 * conc).    
+00008b30: 2320 5468 656e 2077 6520 6361 6e20 6578  # Then we can ex
+00008b40: 7472 6163 7420 7468 6520 636f 6d6d 6f6e  tract the common
+00008b50: 2066 6163 746f 7220 696e 2074 6865 206c   factor in the l
+00008b60: 6173 7420 7477 6f20 7465 726d 7320 746f  ast two terms to
+00008b70: 206f 6274 6169 6e0a 2020 2020 2320 2020   obtain.    #   
+00008b80: 7820 3d20 6c6f 6320 2b20 6c6f 6320 2a20  x = loc + loc * 
+00008b90: 7720 2a20 2831 202d 2073 7172 7428 3220  w * (1 - sqrt(2 
+00008ba0: 2f20 7720 2b20 3129 290a 2020 2020 2320  / w + 1)).    # 
+00008bb0: 4e6f 7720 7765 2073 6565 2074 6861 7420  Now we see that 
+00008bc0: 7468 6520 5769 6b69 7065 6469 6120 666f  the Wikipedia fo
+00008bd0: 726d 756c 6120 7375 6666 6572 7320 6672  rmula suffers fr
+00008be0: 6f6d 2063 6174 6173 7472 7068 6963 0a20  om catastrphic. 
+00008bf0: 2020 2023 2063 616e 6365 6c6c 6174 696f     # cancellatio
+00008c00: 6e20 666f 7220 6c61 7267 6520 7720 2865  n for large w (e
+00008c10: 2e67 2e2c 2069 6620 636f 6e63 203c 3c20  .g., if conc << 
+00008c20: 6c6f 6329 2e0a 2020 2020 230a 2020 2020  loc)..    #.    
+00008c30: 2320 466f 7274 756e 6174 656c 792c 2077  # Fortunately, w
+00008c40: 6520 6361 6e20 6669 7820 7468 6973 2062  e can fix this b
+00008c50: 7920 6d75 6c74 6970 6c79 696e 6720 626f  y multiplying bo
+00008c60: 7468 2073 6964 6573 0a20 2020 2023 2062  th sides.    # b
+00008c70: 7920 3120 2b20 7371 7274 2832 202f 2077  y 1 + sqrt(2 / w
+00008c80: 202b 2031 292e 2020 5765 2067 6574 0a20   + 1).  We get. 
+00008c90: 2020 2023 2020 2078 202a 2028 3120 2b20     #   x * (1 + 
+00008ca0: 7371 7274 2832 202f 2077 202b 2031 2929  sqrt(2 / w + 1))
+00008cb0: 203d 0a20 2020 2023 2020 2020 203d 206c   =.    #     = l
+00008cc0: 6f63 202a 2028 3120 2b20 7371 7274 2832  oc * (1 + sqrt(2
+00008cd0: 202f 2077 202b 2031 2929 202b 206c 6f63   / w + 1)) + loc
+00008ce0: 202a 2077 202a 2028 3120 2d20 2832 202f   * w * (1 - (2 /
+00008cf0: 2077 202b 2031 2929 0a20 2020 2023 2020   w + 1)).    #  
+00008d00: 2020 203d 206c 6f63 202a 2028 7371 7274     = loc * (sqrt
+00008d10: 2832 202f 2077 202b 2031 2920 2d20 3129  (2 / w + 1) - 1)
+00008d20: 0a20 2020 2023 2054 6865 2074 6572 6d20  .    # The term 
+00008d30: 7371 7274 2832 202f 2077 202b 2031 2920  sqrt(2 / w + 1) 
+00008d40: 2b20 3120 6e6f 206c 6f6e 6765 7220 7072  + 1 no longer pr
+00008d50: 6573 656e 7473 206e 756d 6572 6963 616c  esents numerical
+00008d60: 0a20 2020 2023 2064 6966 6669 6375 6c74  .    # difficult
+00008d70: 6965 7320 666f 7220 6c61 7267 6520 772c  ies for large w,
+00008d80: 2061 6e64 2073 7172 7428 3220 2f20 7720   and sqrt(2 / w 
+00008d90: 2b20 3129 202d 2031 2069 7320 6a75 7374  + 1) - 1 is just
+00008da0: 0a20 2020 2023 2073 7172 7431 706d 3128  .    # sqrt1pm1(
+00008db0: 3220 2f20 7729 2c20 7768 6963 6820 7765  2 / w), which we
+00008dc0: 206b 6e6f 7720 686f 7720 746f 2063 6f6d   know how to com
+00008dd0: 7075 7465 2061 6363 7572 6174 656c 792e  pute accurately.
+00008de0: 0a20 2020 2023 2054 6869 7320 6a75 7374  .    # This just
+00008df0: 206c 6561 7665 7320 7468 6520 6d61 7474   leaves the matt
+00008e00: 6572 206f 6620 736d 616c 6c20 772c 2077  er of small w, w
+00008e10: 6865 7265 2032 202f 2077 206d 6179 0a20  here 2 / w may. 
+00008e20: 2020 2023 206f 7665 7266 6c6f 772e 2020     # overflow.  
+00008e30: 496e 2074 6865 206c 696d 6974 2061 2077  In the limit a w
+00008e40: 202d 3e20 302c 2078 202d 3e20 6c6f 632c   -> 0, x -> loc,
+00008e50: 2073 6f20 7765 206a 7573 7420 6d61 736b   so we just mask
+00008e60: 0a20 2020 2023 2074 6861 7420 6361 7365  .    # that case
+00008e70: 2e0a 2020 2020 7371 7274 3170 6d31 5f61  ..    sqrt1pm1_a
+00008e80: 7267 203d 2034 202a 2073 6361 6c65 202f  rg = 4 * scale /
+00008e90: 2028 6d65 616e 202a 2073 616d 706c 6564   (mean * sampled
+00008ea0: 5f63 6869 3229 2020 2320 3220 2f20 7720  _chi2)  # 2 / w 
+00008eb0: 6162 6f76 650a 2020 2020 7361 6665 5f73  above.    safe_s
+00008ec0: 7172 7431 706d 315f 6172 6720 3d20 6a6e  qrt1pm1_arg = jn
+00008ed0: 702e 7768 6572 6528 7371 7274 3170 6d31  p.where(sqrt1pm1
+00008ee0: 5f61 7267 203c 206e 702e 696e 662c 2073  _arg < np.inf, s
+00008ef0: 7172 7431 706d 315f 6172 672c 2031 2e30  qrt1pm1_arg, 1.0
+00008f00: 290a 2020 2020 6465 6e6f 6d69 6e61 746f  ).    denominato
+00008f10: 7220 3d20 312e 3020 2b20 6a6e 702e 7371  r = 1.0 + jnp.sq
+00008f20: 7274 2873 6166 655f 7371 7274 3170 6d31  rt(safe_sqrt1pm1
+00008f30: 5f61 7267 202b 2031 2e30 290a 2020 2020  _arg + 1.0).    
+00008f40: 7261 7469 6f20 3d20 6a6e 702e 6578 706d  ratio = jnp.expm
+00008f50: 3128 302e 3520 2a20 6a6e 702e 6c6f 6731  1(0.5 * jnp.log1
+00008f60: 7028 7361 6665 5f73 7172 7431 706d 315f  p(safe_sqrt1pm1_
+00008f70: 6172 6729 2920 2f20 6465 6e6f 6d69 6e61  arg)) / denomina
+00008f80: 746f 720a 2020 2020 7361 6d70 6c65 6420  tor.    sampled 
+00008f90: 3d20 6d65 616e 202a 206a 6e70 2e77 6865  = mean * jnp.whe
+00008fa0: 7265 2873 7172 7431 706d 315f 6172 6720  re(sqrt1pm1_arg 
+00008fb0: 3c20 6e70 2e69 6e66 2c20 7261 7469 6f2c  < np.inf, ratio,
+00008fc0: 2031 2e30 2920 2023 2078 2061 626f 7665   1.0)  # x above
+00008fd0: 0a20 2020 2072 6573 203d 206a 6e70 2e77  .    res = jnp.w
+00008fe0: 6865 7265 2873 616d 706c 6564 5f75 6e69  here(sampled_uni
+00008ff0: 666f 726d 203c 3d20 6d65 616e 202f 2028  form <= mean / (
+00009000: 6d65 616e 202b 2073 616d 706c 6564 292c  mean + sampled),
+00009010: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009020: 2020 2020 2073 616d 706c 6564 2c0a 2020       sampled,.  
+00009030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009040: 2020 6a6e 702e 7371 7561 7265 286d 6561    jnp.square(mea
+00009050: 6e29 202f 2073 616d 706c 6564 290a 2020  n) / sampled).  
+00009060: 2020 7265 7475 726e 205f 7265 7475 726e    return _return
+00009070: 2872 6573 290a 0a20 2064 6566 2074 2873  (res)..  def t(s
+00009080: 656c 662c 2064 662c 2073 697a 653d 4e6f  elf, df, size=No
+00009090: 6e65 2c20 6b65 793d 4e6f 6e65 293a 0a20  ne, key=None):. 
+000090a0: 2020 2064 6620 3d20 5f63 6865 636b 5f70     df = _check_p
+000090b0: 795f 7365 7128 5f61 735f 6a61 785f 6172  y_seq(_as_jax_ar
+000090c0: 7261 7928 6466 2929 0a20 2020 2069 6620  ray(df)).    if 
+000090d0: 7369 7a65 2069 7320 4e6f 6e65 3a0a 2020  size is None:.  
+000090e0: 2020 2020 7369 7a65 203d 206e 702e 7368      size = np.sh
+000090f0: 6170 6528 6466 290a 2020 2020 656c 7365  ape(df).    else
+00009100: 3a0a 2020 2020 2020 7369 7a65 203d 205f  :.      size = _
+00009110: 7369 7a65 3273 6861 7065 2873 697a 6529  size2shape(size)
+00009120: 0a20 2020 2020 205f 6368 6563 6b5f 7368  .      _check_sh
+00009130: 6170 6528 2274 222c 2073 697a 652c 206e  ape("t", size, n
+00009140: 702e 7368 6170 6528 6466 2929 0a20 2020  p.shape(df)).   
+00009150: 2069 6620 6b65 7920 6973 204e 6f6e 653a   if key is None:
+00009160: 0a20 2020 2020 206b 6579 7320 3d20 7365  .      keys = se
+00009170: 6c66 2e73 706c 6974 5f6b 6579 7328 3229  lf.split_keys(2)
+00009180: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+00009190: 206b 6579 7320 3d20 6a72 2e73 706c 6974   keys = jr.split
+000091a0: 285f 666f 726d 616c 697a 655f 6b65 7928  (_formalize_key(
+000091b0: 6b65 7929 2c20 3229 0a20 2020 206e 203d  key), 2).    n =
+000091c0: 206a 722e 6e6f 726d 616c 286b 6579 735b   jr.normal(keys[
+000091d0: 305d 2c20 7369 7a65 290a 2020 2020 7477  0], size).    tw
+000091e0: 6f20 3d20 5f63 6f6e 7374 286e 2c20 3229  o = _const(n, 2)
+000091f0: 0a20 2020 2068 616c 665f 6466 203d 206c  .    half_df = l
+00009200: 6178 2e64 6976 2864 662c 2074 776f 290a  ax.div(df, two).
+00009210: 2020 2020 6720 3d20 6a72 2e67 616d 6d61      g = jr.gamma
+00009220: 286b 6579 735b 315d 2c20 6861 6c66 5f64  (keys[1], half_d
+00009230: 662c 2073 697a 6529 0a20 2020 2072 203d  f, size).    r =
+00009240: 206e 202a 206a 6e70 2e73 7172 7428 6861   n * jnp.sqrt(ha
+00009250: 6c66 5f64 6620 2f20 6729 0a20 2020 2072  lf_df / g).    r
+00009260: 6574 7572 6e20 5f72 6574 7572 6e28 7229  eturn _return(r)
+00009270: 0a0a 2020 6465 6620 6f72 7468 6f67 6f6e  ..  def orthogon
+00009280: 616c 2873 656c 662c 206e 3a20 696e 742c  al(self, n: int,
+00009290: 2073 697a 653d 4e6f 6e65 2c20 6b65 793d   size=None, key=
+000092a0: 4e6f 6e65 293a 0a20 2020 206b 6579 203d  None):.    key =
+000092b0: 2073 656c 662e 7370 6c69 745f 6b65 7928   self.split_key(
+000092c0: 2920 6966 206b 6579 2069 7320 4e6f 6e65  ) if key is None
+000092d0: 2065 6c73 6520 5f66 6f72 6d61 6c69 7a65   else _formalize
+000092e0: 5f6b 6579 286b 6579 290a 2020 2020 7369  _key(key).    si
+000092f0: 7a65 203d 205f 7369 7a65 3273 6861 7065  ze = _size2shape
+00009300: 2873 697a 6529 0a20 2020 205f 6368 6563  (size).    _chec
+00009310: 6b5f 7368 6170 6528 226f 7274 686f 676f  k_shape("orthogo
+00009320: 6e61 6c22 2c20 7369 7a65 290a 2020 2020  nal", size).    
+00009330: 6e20 3d20 636f 7265 2e63 6f6e 6372 6574  n = core.concret
+00009340: 655f 6f72 5f65 7272 6f72 2869 6e64 6578  e_or_error(index
+00009350: 2c20 6e2c 2022 5468 6520 6572 726f 7220  , n, "The error 
+00009360: 6f63 6375 7272 6564 2069 6e20 6a61 782e  occurred in jax.
+00009370: 7261 6e64 6f6d 2e6f 7274 686f 676f 6e61  random.orthogona
+00009380: 6c28 2922 290a 2020 2020 7a20 3d20 6a72  l()").    z = jr
+00009390: 2e6e 6f72 6d61 6c28 6b65 792c 2073 697a  .normal(key, siz
+000093a0: 6520 2b20 286e 2c20 6e29 290a 2020 2020  e + (n, n)).    
+000093b0: 712c 2072 203d 206a 6e70 2e6c 696e 616c  q, r = jnp.linal
+000093c0: 672e 7172 287a 290a 2020 2020 6420 3d20  g.qr(z).    d = 
+000093d0: 6a6e 702e 6469 6167 6f6e 616c 2872 2c20  jnp.diagonal(r, 
+000093e0: 302c 202d 322c 202d 3129 0a20 2020 2072  0, -2, -1).    r
+000093f0: 203d 2071 202a 206a 6e70 2e65 7870 616e   = q * jnp.expan
+00009400: 645f 6469 6d73 2864 202f 2061 6273 2864  d_dims(d / abs(d
+00009410: 292c 202d 3229 0a20 2020 2072 6574 7572  ), -2).    retur
+00009420: 6e20 5f72 6574 7572 6e28 7229 0a0a 2020  n _return(r)..  
+00009430: 6465 6620 6e6f 6e63 656e 7472 616c 5f63  def noncentral_c
+00009440: 6869 7371 7561 7265 2873 656c 662c 2064  hisquare(self, d
+00009450: 662c 206e 6f6e 632c 2073 697a 653d 4e6f  f, nonc, size=No
+00009460: 6e65 2c20 6b65 793d 4e6f 6e65 293a 0a20  ne, key=None):. 
+00009470: 2020 2064 6620 3d20 5f63 6865 636b 5f70     df = _check_p
+00009480: 795f 7365 7128 5f61 735f 6a61 785f 6172  y_seq(_as_jax_ar
+00009490: 7261 7928 6466 2929 0a20 2020 206e 6f6e  ray(df)).    non
+000094a0: 6320 3d20 5f63 6865 636b 5f70 795f 7365  c = _check_py_se
+000094b0: 7128 5f61 735f 6a61 785f 6172 7261 7928  q(_as_jax_array(
+000094c0: 6e6f 6e63 2929 0a20 2020 2069 6620 7369  nonc)).    if si
+000094d0: 7a65 2069 7320 4e6f 6e65 3a0a 2020 2020  ze is None:.    
+000094e0: 2020 7369 7a65 203d 206c 6178 2e62 726f    size = lax.bro
+000094f0: 6164 6361 7374 5f73 6861 7065 7328 6a6e  adcast_shapes(jn
+00009500: 702e 7368 6170 6528 6466 292c 206a 6e70  p.shape(df), jnp
+00009510: 2e73 6861 7065 286e 6f6e 6329 290a 2020  .shape(nonc)).  
+00009520: 2020 7369 7a65 203d 205f 7369 7a65 3273    size = _size2s
+00009530: 6861 7065 2873 697a 6529 0a20 2020 2069  hape(size).    i
+00009540: 6620 6b65 7920 6973 204e 6f6e 653a 0a20  f key is None:. 
+00009550: 2020 2020 206b 6579 7320 3d20 7365 6c66       keys = self
+00009560: 2e73 706c 6974 5f6b 6579 7328 3329 0a20  .split_keys(3). 
+00009570: 2020 2065 6c73 653a 0a20 2020 2020 206b     else:.      k
+00009580: 6579 7320 3d20 6a72 2e73 706c 6974 285f  eys = jr.split(_
+00009590: 666f 726d 616c 697a 655f 6b65 7928 6b65  formalize_key(ke
+000095a0: 7929 2c20 3329 0a20 2020 2069 203d 206a  y), 3).    i = j
+000095b0: 722e 706f 6973 736f 6e28 6b65 7973 5b30  r.poisson(keys[0
+000095c0: 5d2c 2030 2e35 202a 206e 6f6e 632c 2073  ], 0.5 * nonc, s
+000095d0: 6861 7065 3d73 697a 6529 0a20 2020 206e  hape=size).    n
+000095e0: 203d 206a 722e 6e6f 726d 616c 286b 6579   = jr.normal(key
+000095f0: 735b 315d 2c20 7368 6170 653d 7369 7a65  s[1], shape=size
+00009600: 2920 2b20 6a6e 702e 7371 7274 286e 6f6e  ) + jnp.sqrt(non
+00009610: 6329 0a20 2020 2063 6f6e 6420 3d20 6a6e  c).    cond = jn
+00009620: 702e 6772 6561 7465 7228 6466 2c20 312e  p.greater(df, 1.
+00009630: 3029 0a20 2020 2064 6632 203d 206a 6e70  0).    df2 = jnp
+00009640: 2e77 6865 7265 2863 6f6e 642c 2064 6620  .where(cond, df 
+00009650: 2d20 312e 302c 2064 6620 2b20 322e 3020  - 1.0, df + 2.0 
+00009660: 2a20 6929 0a20 2020 2063 6869 3220 3d20  * i).    chi2 = 
+00009670: 322e 3020 2a20 6a72 2e67 616d 6d61 286b  2.0 * jr.gamma(k
+00009680: 6579 735b 325d 2c20 302e 3520 2a20 6466  eys[2], 0.5 * df
+00009690: 322c 2073 6861 7065 3d73 697a 6529 0a20  2, shape=size). 
+000096a0: 2020 2072 203d 206a 6e70 2e77 6865 7265     r = jnp.where
+000096b0: 2863 6f6e 642c 2063 6869 3220 2b20 6e20  (cond, chi2 + n 
+000096c0: 2a20 6e2c 2063 6869 3229 0a20 2020 2072  * n, chi2).    r
+000096d0: 6574 7572 6e20 5f72 6574 7572 6e28 7229  eturn _return(r)
+000096e0: 0a0a 2020 6465 6620 6c6f 6767 616d 6d61  ..  def loggamma
+000096f0: 2873 656c 662c 2061 2c20 7369 7a65 3d4e  (self, a, size=N
+00009700: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
+00009710: 2020 2020 6b65 7920 3d20 7365 6c66 2e73      key = self.s
+00009720: 706c 6974 5f6b 6579 2829 2069 6620 6b65  plit_key() if ke
+00009730: 7920 6973 204e 6f6e 6520 656c 7365 205f  y is None else _
+00009740: 666f 726d 616c 697a 655f 6b65 7928 6b65  formalize_key(ke
+00009750: 7929 0a20 2020 2061 203d 205f 6368 6563  y).    a = _chec
+00009760: 6b5f 7079 5f73 6571 285f 6173 5f6a 6178  k_py_seq(_as_jax
+00009770: 5f61 7272 6179 2861 2929 0a20 2020 2069  _array(a)).    i
+00009780: 6620 7369 7a65 2069 7320 4e6f 6e65 3a0a  f size is None:.
+00009790: 2020 2020 2020 7369 7a65 203d 206a 6e70        size = jnp
+000097a0: 2e73 6861 7065 2861 290a 2020 2020 7220  .shape(a).    r 
+000097b0: 3d20 6a72 2e6c 6f67 6761 6d6d 6128 6b65  = jr.loggamma(ke
+000097c0: 792c 2061 2c20 7368 6170 653d 5f73 697a  y, a, shape=_siz
+000097d0: 6532 7368 6170 6528 7369 7a65 2929 0a20  e2shape(size)). 
+000097e0: 2020 2072 6574 7572 6e20 5f72 6574 7572     return _retur
+000097f0: 6e28 7229 0a0a 2020 6465 6620 6361 7465  n(r)..  def cate
+00009800: 676f 7269 6361 6c28 7365 6c66 2c20 6c6f  gorical(self, lo
+00009810: 6769 7473 2c20 6178 6973 3a20 696e 7420  gits, axis: int 
+00009820: 3d20 2d31 2c20 7369 7a65 3d4e 6f6e 652c  = -1, size=None,
+00009830: 206b 6579 3d4e 6f6e 6529 3a0a 2020 2020   key=None):.    
+00009840: 6b65 7920 3d20 7365 6c66 2e73 706c 6974  key = self.split
+00009850: 5f6b 6579 2829 2069 6620 6b65 7920 6973  _key() if key is
+00009860: 204e 6f6e 6520 656c 7365 205f 666f 726d   None else _form
+00009870: 616c 697a 655f 6b65 7928 6b65 7929 0a20  alize_key(key). 
+00009880: 2020 206c 6f67 6974 7320 3d20 5f63 6865     logits = _che
+00009890: 636b 5f70 795f 7365 7128 5f61 735f 6a61  ck_py_seq(_as_ja
+000098a0: 785f 6172 7261 7928 6c6f 6769 7473 2929  x_array(logits))
+000098b0: 0a20 2020 2069 6620 7369 7a65 2069 7320  .    if size is 
+000098c0: 4e6f 6e65 3a0a 2020 2020 2020 7369 7a65  None:.      size
+000098d0: 203d 206c 6973 7428 6a6e 702e 7368 6170   = list(jnp.shap
+000098e0: 6528 6c6f 6769 7473 2929 0a20 2020 2020  e(logits)).     
+000098f0: 2073 697a 652e 706f 7028 6178 6973 290a   size.pop(axis).
+00009900: 2020 2020 7220 3d20 6a72 2e63 6174 6567      r = jr.categ
+00009910: 6f72 6963 616c 286b 6579 2c20 6c6f 6769  orical(key, logi
+00009920: 7473 2c20 6178 6973 3d61 7869 732c 2073  ts, axis=axis, s
+00009930: 6861 7065 3d5f 7369 7a65 3273 6861 7065  hape=_size2shape
+00009940: 2873 697a 6529 290a 2020 2020 7265 7475  (size)).    retu
+00009950: 726e 205f 7265 7475 726e 2872 290a 0a20  rn _return(r).. 
+00009960: 2064 6566 207a 6970 6628 7365 6c66 2c20   def zipf(self, 
+00009970: 612c 2073 697a 653d 4e6f 6e65 2c20 6b65  a, size=None, ke
+00009980: 793d 4e6f 6e65 293a 0a20 2020 2061 203d  y=None):.    a =
+00009990: 205f 6368 6563 6b5f 7079 5f73 6571 285f   _check_py_seq(_
+000099a0: 6173 5f6a 6178 5f61 7272 6179 2861 2929  as_jax_array(a))
+000099b0: 0a20 2020 2069 6620 7369 7a65 2069 7320  .    if size is 
+000099c0: 4e6f 6e65 3a0a 2020 2020 2020 7369 7a65  None:.      size
+000099d0: 203d 206a 6e70 2e73 6861 7065 2861 290a   = jnp.shape(a).
+000099e0: 2020 2020 7220 3d20 6361 6c6c 286c 616d      r = call(lam
+000099f0: 6264 6120 783a 206e 702e 7261 6e64 6f6d  bda x: np.random
+00009a00: 2e7a 6970 6628 782c 2073 697a 6529 2c0a  .zipf(x, size),.
+00009a10: 2020 2020 2020 2020 2020 2020 2061 2c0a               a,.
+00009a20: 2020 2020 2020 2020 2020 2020 2072 6573               res
+00009a30: 756c 745f 7368 6170 653d 6a61 782e 5368  ult_shape=jax.Sh
+00009a40: 6170 6544 7479 7065 5374 7275 6374 2873  apeDtypeStruct(s
+00009a50: 697a 652c 206a 6e70 2e69 6e74 5f29 290a  ize, jnp.int_)).
+00009a60: 2020 2020 7265 7475 726e 205f 7265 7475      return _retu
+00009a70: 726e 2872 290a 0a20 2064 6566 2070 6f77  rn(r)..  def pow
+00009a80: 6572 2873 656c 662c 2061 2c20 7369 7a65  er(self, a, size
+00009a90: 3d4e 6f6e 652c 206b 6579 3d4e 6f6e 6529  =None, key=None)
+00009aa0: 3a0a 2020 2020 6120 3d20 5f63 6865 636b  :.    a = _check
+00009ab0: 5f70 795f 7365 7128 5f61 735f 6a61 785f  _py_seq(_as_jax_
+00009ac0: 6172 7261 7928 6129 290a 2020 2020 6966  array(a)).    if
+00009ad0: 2073 697a 6520 6973 204e 6f6e 653a 0a20   size is None:. 
+00009ae0: 2020 2020 2073 697a 6520 3d20 6a6e 702e       size = jnp.
+00009af0: 7368 6170 6528 6129 0a20 2020 2073 697a  shape(a).    siz
+00009b00: 6520 3d20 5f73 697a 6532 7368 6170 6528  e = _size2shape(
+00009b10: 7369 7a65 290a 2020 2020 7220 3d20 6361  size).    r = ca
+00009b20: 6c6c 286c 616d 6264 6120 613a 206e 702e  ll(lambda a: np.
+00009b30: 7261 6e64 6f6d 2e70 6f77 6572 2861 3d61  random.power(a=a
+00009b40: 2c20 7369 7a65 3d73 697a 6529 2c0a 2020  , size=size),.  
+00009b50: 2020 2020 2020 2020 2020 2061 2c20 7265             a, re
+00009b60: 7375 6c74 5f73 6861 7065 3d6a 6178 2e53  sult_shape=jax.S
+00009b70: 6861 7065 4474 7970 6553 7472 7563 7428  hapeDtypeStruct(
+00009b80: 7369 7a65 2c20 6a6e 702e 666c 6f61 745f  size, jnp.float_
+00009b90: 2929 0a20 2020 2072 6574 7572 6e20 5f72  )).    return _r
+00009ba0: 6574 7572 6e28 7229 0a0a 2020 6465 6620  eturn(r)..  def 
+00009bb0: 6628 7365 6c66 2c20 6466 6e75 6d2c 2064  f(self, dfnum, d
+00009bc0: 6664 656e 2c20 7369 7a65 3d4e 6f6e 652c  fden, size=None,
+00009bd0: 206b 6579 3d4e 6f6e 6529 3a0a 2020 2020   key=None):.    
+00009be0: 6466 6e75 6d20 3d20 5f61 735f 6a61 785f  dfnum = _as_jax_
+00009bf0: 6172 7261 7928 6466 6e75 6d29 0a20 2020  array(dfnum).   
+00009c00: 2064 6664 656e 203d 205f 6173 5f6a 6178   dfden = _as_jax
+00009c10: 5f61 7272 6179 2864 6664 656e 290a 2020  _array(dfden).  
+00009c20: 2020 6466 6e75 6d20 3d20 5f63 6865 636b    dfnum = _check
+00009c30: 5f70 795f 7365 7128 6466 6e75 6d29 0a20  _py_seq(dfnum). 
+00009c40: 2020 2064 6664 656e 203d 205f 6368 6563     dfden = _chec
+00009c50: 6b5f 7079 5f73 6571 2864 6664 656e 290a  k_py_seq(dfden).
+00009c60: 2020 2020 6966 2073 697a 6520 6973 204e      if size is N
+00009c70: 6f6e 653a 0a20 2020 2020 2073 697a 6520  one:.      size 
+00009c80: 3d20 6a6e 702e 6272 6f61 6463 6173 745f  = jnp.broadcast_
+00009c90: 7368 6170 6573 286a 6e70 2e73 6861 7065  shapes(jnp.shape
+00009ca0: 2864 666e 756d 292c 206a 6e70 2e73 6861  (dfnum), jnp.sha
+00009cb0: 7065 2864 6664 656e 2929 0a20 2020 2073  pe(dfden)).    s
+00009cc0: 697a 6520 3d20 5f73 697a 6532 7368 6170  ize = _size2shap
+00009cd0: 6528 7369 7a65 290a 2020 2020 6420 3d20  e(size).    d = 
+00009ce0: 7b27 6466 6e75 6d27 3a20 6466 6e75 6d2c  {'dfnum': dfnum,
+00009cf0: 2027 6466 6465 6e27 3a20 6466 6465 6e7d   'dfden': dfden}
+00009d00: 0a20 2020 2072 203d 2063 616c 6c28 6c61  .    r = call(la
+00009d10: 6d62 6461 2078 3a20 6e70 2e72 616e 646f  mbda x: np.rando
+00009d20: 6d2e 6628 6466 6e75 6d3d 785b 2764 666e  m.f(dfnum=x['dfn
+00009d30: 756d 275d 2c0a 2020 2020 2020 2020 2020  um'],.          
+00009d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009d50: 2020 2020 2020 2020 2064 6664 656e 3d78           dfden=x
+00009d60: 5b27 6466 6465 6e27 5d2c 0a20 2020 2020  ['dfden'],.     
+00009d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009d80: 2020 2020 2020 2020 2020 2020 2020 7369                si
+00009d90: 7a65 3d73 697a 6529 2c0a 2020 2020 2020  ze=size),.      
+00009da0: 2020 2020 2020 2064 2c0a 2020 2020 2020         d,.      
+00009db0: 2020 2020 2020 2072 6573 756c 745f 7368         result_sh
+00009dc0: 6170 653d 6a61 782e 5368 6170 6544 7479  ape=jax.ShapeDty
+00009dd0: 7065 5374 7275 6374 2873 697a 652c 206a  peStruct(size, j
+00009de0: 6e70 2e66 6c6f 6174 5f29 290a 2020 2020  np.float_)).    
+00009df0: 7265 7475 726e 205f 7265 7475 726e 2872  return _return(r
+00009e00: 290a 0a20 2064 6566 2068 7970 6572 6765  )..  def hyperge
+00009e10: 6f6d 6574 7269 6328 7365 6c66 2c20 6e67  ometric(self, ng
+00009e20: 6f6f 642c 206e 6261 642c 206e 7361 6d70  ood, nbad, nsamp
+00009e30: 6c65 2c20 7369 7a65 3d4e 6f6e 652c 206b  le, size=None, k
+00009e40: 6579 3d4e 6f6e 6529 3a0a 2020 2020 6e67  ey=None):.    ng
+00009e50: 6f6f 6420 3d20 5f63 6865 636b 5f70 795f  ood = _check_py_
+00009e60: 7365 7128 5f61 735f 6a61 785f 6172 7261  seq(_as_jax_arra
+00009e70: 7928 6e67 6f6f 6429 290a 2020 2020 6e62  y(ngood)).    nb
+00009e80: 6164 203d 205f 6368 6563 6b5f 7079 5f73  ad = _check_py_s
+00009e90: 6571 285f 6173 5f6a 6178 5f61 7272 6179  eq(_as_jax_array
+00009ea0: 286e 6261 6429 290a 2020 2020 6e73 616d  (nbad)).    nsam
+00009eb0: 706c 6520 3d20 5f63 6865 636b 5f70 795f  ple = _check_py_
+00009ec0: 7365 7128 5f61 735f 6a61 785f 6172 7261  seq(_as_jax_arra
+00009ed0: 7928 6e73 616d 706c 6529 290a 0a20 2020  y(nsample))..   
+00009ee0: 2069 6620 7369 7a65 2069 7320 4e6f 6e65   if size is None
+00009ef0: 3a0a 2020 2020 2020 7369 7a65 203d 206c  :.      size = l
+00009f00: 6178 2e62 726f 6164 6361 7374 5f73 6861  ax.broadcast_sha
+00009f10: 7065 7328 6a6e 702e 7368 6170 6528 6e67  pes(jnp.shape(ng
+00009f20: 6f6f 6429 2c0a 2020 2020 2020 2020 2020  ood),.          
+00009f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009f40: 2020 2020 2020 2020 6a6e 702e 7368 6170          jnp.shap
+00009f50: 6528 6e62 6164 292c 0a20 2020 2020 2020  e(nbad),.       
+00009f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009f70: 2020 2020 2020 2020 2020 206a 6e70 2e73             jnp.s
+00009f80: 6861 7065 286e 7361 6d70 6c65 2929 0a20  hape(nsample)). 
+00009f90: 2020 2073 697a 6520 3d20 5f73 697a 6532     size = _size2
+00009fa0: 7368 6170 6528 7369 7a65 290a 2020 2020  shape(size).    
+00009fb0: 6420 3d20 7b27 6e67 6f6f 6427 3a20 6e67  d = {'ngood': ng
+00009fc0: 6f6f 642c 2027 6e62 6164 273a 206e 6261  ood, 'nbad': nba
+00009fd0: 642c 2027 6e73 616d 706c 6527 3a20 6e73  d, 'nsample': ns
+00009fe0: 616d 706c 657d 0a20 2020 2072 203d 2063  ample}.    r = c
+00009ff0: 616c 6c28 6c61 6d62 6461 2078 3a20 6e70  all(lambda x: np
+0000a000: 2e72 616e 646f 6d2e 6879 7065 7267 656f  .random.hypergeo
+0000a010: 6d65 7472 6963 286e 676f 6f64 3d78 5b27  metric(ngood=x['
+0000a020: 6e67 6f6f 6427 5d2c 0a20 2020 2020 2020  ngood'],.       
+0000a030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a050: 2020 2020 2020 2020 206e 6261 643d 785b           nbad=x[
+0000a060: 276e 6261 6427 5d2c 0a20 2020 2020 2020  'nbad'],.       
+0000a070: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a090: 2020 2020 2020 2020 206e 7361 6d70 6c65           nsample
+0000a0a0: 3d78 5b27 6e73 616d 706c 6527 5d2c 0a20  =x['nsample'],. 
 0000a0b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a0c0: 6466 6465 6e3d 785b 2764 6664 656e 275d  dfden=x['dfden']
-0000a0d0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000a0e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a100: 6e6f 6e63 3d78 5b27 6e6f 6e63 275d 2c0a  nonc=x['nonc'],.
-0000a110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a130: 2020 2020 2020 2020 2020 2020 2020 7369                si
-0000a140: 7a65 3d73 697a 6529 2c0a 2020 2020 2020  ze=size),.      
-0000a150: 2020 2020 2020 2064 2c20 7265 7375 6c74         d, result
-0000a160: 5f73 6861 7065 3d6a 6178 2e53 6861 7065  _shape=jax.Shape
-0000a170: 4474 7970 6553 7472 7563 7428 7369 7a65  DtypeStruct(size
-0000a180: 2c20 6a6e 702e 666c 6f61 745f 2929 0a20  , jnp.float_)). 
-0000a190: 2020 2072 6574 7572 6e20 5f72 6574 7572     return _retur
-0000a1a0: 6e28 7229 0a0a 2020 2320 5079 546f 7263  n(r)..  # PyTorc
-0000a1b0: 6820 636f 6d70 6174 6962 696c 6974 7920  h compatibility 
-0000a1c0: 230a 2020 2320 2d2d 2d2d 2d2d 2d2d 2d2d  #.  # ----------
-0000a1d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d20 230a 0a20  ----------- #.. 
-0000a1e0: 2064 6566 2072 616e 645f 6c69 6b65 2873   def rand_like(s
-0000a1f0: 656c 662c 2069 6e70 7574 2c20 2a2c 2064  elf, input, *, d
-0000a200: 7479 7065 3d4e 6f6e 652c 206b 6579 3d4e  type=None, key=N
-0000a210: 6f6e 6529 3a0a 2020 2020 2222 2252 6574  one):.    """Ret
-0000a220: 7572 6e73 2061 2074 656e 736f 7220 7769  urns a tensor wi
-0000a230: 7468 2074 6865 2073 616d 6520 7369 7a65  th the same size
-0000a240: 2061 7320 696e 7075 7420 7468 6174 2069   as input that i
-0000a250: 7320 6669 6c6c 6564 2077 6974 6820 7261  s filled with ra
-0000a260: 6e64 6f6d 0a20 2020 206e 756d 6265 7273  ndom.    numbers
-0000a270: 2066 726f 6d20 6120 756e 6966 6f72 6d20   from a uniform 
-0000a280: 6469 7374 7269 6275 7469 6f6e 206f 6e20  distribution on 
-0000a290: 7468 6520 696e 7465 7276 616c 2060 605b  the interval ``[
-0000a2a0: 302c 2031 2960 602e 0a0a 2020 2020 4172  0, 1)``...    Ar
-0000a2b0: 6773 3a0a 2020 2020 2020 696e 7075 743a  gs:.      input:
-0000a2c0: 2020 7468 6520 6060 7369 7a65 6060 206f    the ``size`` o
-0000a2d0: 6620 696e 7075 7420 7769 6c6c 2064 6574  f input will det
-0000a2e0: 6572 6d69 6e65 2073 697a 6520 6f66 2074  ermine size of t
-0000a2f0: 6865 206f 7574 7075 7420 7465 6e73 6f72  he output tensor
-0000a300: 2e0a 2020 2020 2020 6474 7970 653a 2020  ..      dtype:  
-0000a310: 7468 6520 6465 7369 7265 6420 6461 7461  the desired data
-0000a320: 2074 7970 6520 6f66 2072 6574 7572 6e65   type of returne
-0000a330: 6420 5465 6e73 6f72 2e20 4465 6661 756c  d Tensor. Defaul
-0000a340: 743a 2069 6620 6060 4e6f 6e65 6060 2c20  t: if ``None``, 
-0000a350: 6465 6661 756c 7473 2074 6f20 7468 6520  defaults to the 
-0000a360: 6474 7970 6520 6f66 2069 6e70 7574 2e0a  dtype of input..
-0000a370: 2020 2020 2020 6b65 793a 2074 6865 2073        key: the s
-0000a380: 6565 6420 6f72 206b 6579 2066 6f72 2074  eed or key for t
-0000a390: 6865 2072 616e 646f 6d2e 0a0a 2020 2020  he random...    
-0000a3a0: 5265 7475 726e 733a 0a20 2020 2020 2054  Returns:.      T
-0000a3b0: 6865 2072 616e 646f 6d20 6461 7461 2e0a  he random data..
-0000a3c0: 2020 2020 2222 220a 2020 2020 7265 7475      """.    retu
-0000a3d0: 726e 2073 656c 662e 7261 6e64 6f6d 2873  rn self.random(s
-0000a3e0: 6861 7065 2869 6e70 7574 292c 206b 6579  hape(input), key
-0000a3f0: 3d6b 6579 292e 6173 7479 7065 2864 7479  =key).astype(dty
-0000a400: 7065 290a 0a20 2064 6566 2072 616e 646e  pe)..  def randn
-0000a410: 5f6c 696b 6528 7365 6c66 2c20 696e 7075  _like(self, inpu
-0000a420: 742c 202a 2c20 6474 7970 653d 4e6f 6e65  t, *, dtype=None
-0000a430: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2020  , key=None):.   
-0000a440: 2022 2222 5265 7475 726e 7320 6120 7465   """Returns a te
-0000a450: 6e73 6f72 2077 6974 6820 7468 6520 7361  nsor with the sa
-0000a460: 6d65 2073 697a 6520 6173 2060 6069 6e70  me size as ``inp
-0000a470: 7574 6060 2074 6861 7420 6973 2066 696c  ut`` that is fil
-0000a480: 6c65 6420 7769 7468 0a20 2020 2072 616e  led with.    ran
-0000a490: 646f 6d20 6e75 6d62 6572 7320 6672 6f6d  dom numbers from
-0000a4a0: 2061 206e 6f72 6d61 6c20 6469 7374 7269   a normal distri
-0000a4b0: 6275 7469 6f6e 2077 6974 6820 6d65 616e  bution with mean
-0000a4c0: 2030 2061 6e64 2076 6172 6961 6e63 6520   0 and variance 
-0000a4d0: 312e 0a0a 2020 2020 4172 6773 3a0a 2020  1...    Args:.  
-0000a4e0: 2020 2020 696e 7075 743a 2020 7468 6520      input:  the 
-0000a4f0: 6060 7369 7a65 6060 206f 6620 696e 7075  ``size`` of inpu
-0000a500: 7420 7769 6c6c 2064 6574 6572 6d69 6e65  t will determine
-0000a510: 2073 697a 6520 6f66 2074 6865 206f 7574   size of the out
-0000a520: 7075 7420 7465 6e73 6f72 2e0a 2020 2020  put tensor..    
-0000a530: 2020 6474 7970 653a 2020 7468 6520 6465    dtype:  the de
-0000a540: 7369 7265 6420 6461 7461 2074 7970 6520  sired data type 
-0000a550: 6f66 2072 6574 7572 6e65 6420 5465 6e73  of returned Tens
-0000a560: 6f72 2e20 4465 6661 756c 743a 2069 6620  or. Default: if 
-0000a570: 6060 4e6f 6e65 6060 2c20 6465 6661 756c  ``None``, defaul
-0000a580: 7473 2074 6f20 7468 6520 6474 7970 6520  ts to the dtype 
-0000a590: 6f66 2069 6e70 7574 2e0a 2020 2020 2020  of input..      
-0000a5a0: 6b65 793a 2074 6865 2073 6565 6420 6f72  key: the seed or
-0000a5b0: 206b 6579 2066 6f72 2074 6865 2072 616e   key for the ran
-0000a5c0: 646f 6d2e 0a0a 2020 2020 5265 7475 726e  dom...    Return
-0000a5d0: 733a 0a20 2020 2020 2054 6865 2072 616e  s:.      The ran
-0000a5e0: 646f 6d20 6461 7461 2e0a 2020 2020 2222  dom data..    ""
-0000a5f0: 220a 2020 2020 7265 7475 726e 2073 656c  ".    return sel
-0000a600: 662e 7261 6e64 6e28 2a73 6861 7065 2869  f.randn(*shape(i
-0000a610: 6e70 7574 292c 206b 6579 3d6b 6579 292e  nput), key=key).
-0000a620: 6173 7479 7065 2864 7479 7065 290a 0a20  astype(dtype).. 
-0000a630: 2064 6566 2072 616e 6469 6e74 5f6c 696b   def randint_lik
-0000a640: 6528 7365 6c66 2c20 696e 7075 742c 206c  e(self, input, l
-0000a650: 6f77 3d30 2c20 6869 6768 3d4e 6f6e 652c  ow=0, high=None,
-0000a660: 202a 2c20 6474 7970 653d 4e6f 6e65 2c20   *, dtype=None, 
-0000a670: 6b65 793d 4e6f 6e65 293a 0a20 2020 2069  key=None):.    i
-0000a680: 6620 6869 6768 2069 7320 4e6f 6e65 3a0a  f high is None:.
-0000a690: 2020 2020 2020 6869 6768 203d 206d 6178        high = max
-0000a6a0: 2869 6e70 7574 290a 2020 2020 7265 7475  (input).    retu
-0000a6b0: 726e 2073 656c 662e 7261 6e64 696e 7428  rn self.randint(
-0000a6c0: 6c6f 772c 2068 6967 683d 6869 6768 2c20  low, high=high, 
-0000a6d0: 7369 7a65 3d73 6861 7065 2869 6e70 7574  size=shape(input
-0000a6e0: 292c 2064 7479 7065 3d64 7479 7065 2c20  ), dtype=dtype, 
-0000a6f0: 6b65 793d 6b65 7929 0a0a 0a23 2061 6c69  key=key)...# ali
-0000a700: 6173 0a47 656e 6572 6174 6f72 203d 2052  as.Generator = R
-0000a710: 616e 646f 6d53 7461 7465 0a0a 2320 7265  andomState..# re
-0000a720: 6769 7374 6572 2070 7974 7265 650a 7265  gister pytree.re
-0000a730: 6769 7374 6572 5f70 7974 7265 655f 6e6f  gister_pytree_no
-0000a740: 6465 2852 616e 646f 6d53 7461 7465 2c0a  de(RandomState,.
-0000a750: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a760: 2020 2020 206c 616d 6264 6120 743a 2028       lambda t: (
-0000a770: 2874 2e76 616c 7565 2c29 2c20 4e6f 6e65  (t.value,), None
-0000a780: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-0000a790: 2020 2020 2020 2020 6c61 6d62 6461 2061          lambda a
-0000a7a0: 7578 5f64 6174 612c 2066 6c61 745f 636f  ux_data, flat_co
-0000a7b0: 6e74 656e 7473 3a20 5261 6e64 6f6d 5374  ntents: RandomSt
-0000a7c0: 6174 6528 2a66 6c61 745f 636f 6e74 656e  ate(*flat_conten
-0000a7d0: 7473 2929 0a0a 2320 6465 6661 756c 7420  ts))..# default 
-0000a7e0: 7261 6e64 6f6d 2067 656e 6572 6174 6f72  random generator
-0000a7f0: 0a5f 5f61 203d 2041 7272 6179 284e 6f6e  .__a = Array(Non
-0000a800: 6529 0a5f 5f61 2e5f 7661 6c75 6520 3d20  e).__a._value = 
-0000a810: 6e70 2e72 616e 646f 6d2e 7261 6e64 696e  np.random.randin
-0000a820: 7428 302c 2031 3030 3030 2c20 7369 7a65  t(0, 10000, size
-0000a830: 3d32 2c20 6474 7970 653d 6e70 2e75 696e  =2, dtype=np.uin
-0000a840: 7433 3229 0a44 4546 4155 4c54 203d 2052  t32).DEFAULT = R
-0000a850: 616e 646f 6d53 7461 7465 285f 5f61 290a  andomState(__a).
-0000a860: 6465 6c20 5f5f 610a 0a0a 6465 6620 7370  del __a...def sp
-0000a870: 6c69 745f 6b65 7928 293a 0a20 2072 6574  lit_key():.  ret
-0000a880: 7572 6e20 4445 4641 554c 542e 7370 6c69  urn DEFAULT.spli
-0000a890: 745f 6b65 7928 290a 0a0a 6465 6620 636c  t_key()...def cl
-0000a8a0: 6f6e 655f 726e 6728 7365 6564 5f6f 725f  one_rng(seed_or_
-0000a8b0: 6b65 793d 4e6f 6e65 2c20 636c 6f6e 653a  key=None, clone:
-0000a8c0: 2062 6f6f 6c20 3d20 5472 7565 2920 2d3e   bool = True) ->
-0000a8d0: 2052 616e 646f 6d53 7461 7465 3a0a 2020   RandomState:.  
-0000a8e0: 6966 2073 6565 645f 6f72 5f6b 6579 2069  if seed_or_key i
-0000a8f0: 7320 4e6f 6e65 3a0a 2020 2020 7265 7475  s None:.    retu
-0000a900: 726e 2044 4546 4155 4c54 2e63 6c6f 6e65  rn DEFAULT.clone
-0000a910: 2829 2069 6620 636c 6f6e 6520 656c 7365  () if clone else
-0000a920: 2044 4546 4155 4c54 0a20 2065 6c73 653a   DEFAULT.  else:
-0000a930: 0a20 2020 2072 6574 7572 6e20 5261 6e64  .    return Rand
-0000a940: 6f6d 5374 6174 6528 7365 6564 5f6f 725f  omState(seed_or_
-0000a950: 6b65 7929 0a0a 0a23 2040 7772 6170 7328  key)...# @wraps(
-0000a960: 6e70 2e72 616e 646f 6d2e 6465 6661 756c  np.random.defaul
-0000a970: 745f 726e 6729 0a64 6566 2064 6566 6175  t_rng).def defau
-0000a980: 6c74 5f72 6e67 2873 6565 645f 6f72 5f6b  lt_rng(seed_or_k
-0000a990: 6579 3d4e 6f6e 652c 2063 6c6f 6e65 3d54  ey=None, clone=T
-0000a9a0: 7275 6529 202d 3e20 5261 6e64 6f6d 5374  rue) -> RandomSt
-0000a9b0: 6174 653a 0a20 2069 6620 7365 6564 5f6f  ate:.  if seed_o
-0000a9c0: 725f 6b65 7920 6973 204e 6f6e 653a 0a20  r_key is None:. 
-0000a9d0: 2020 2072 6574 7572 6e20 4445 4641 554c     return DEFAUL
-0000a9e0: 542e 636c 6f6e 6528 2920 6966 2063 6c6f  T.clone() if clo
-0000a9f0: 6e65 2065 6c73 6520 4445 4641 554c 540a  ne else DEFAULT.
-0000aa00: 2020 656c 7365 3a0a 2020 2020 7265 7475    else:.    retu
-0000aa10: 726e 2052 616e 646f 6d53 7461 7465 2873  rn RandomState(s
-0000aa20: 6565 645f 6f72 5f6b 6579 290a 0a0a 6465  eed_or_key)...de
-0000aa30: 6620 7365 6564 2873 6565 643a 2069 6e74  f seed(seed: int
-0000aa40: 3d4e 6f6e 6529 3a0a 2020 2222 2253 6574  =None):.  """Set
-0000aa50: 7320 6120 6e65 7720 7261 6e64 6f6d 2073  s a new random s
-0000aa60: 6565 642e 0a0a 2020 5061 7261 6d65 7465  eed...  Paramete
-0000aa70: 7273 0a20 202d 2d2d 2d2d 2d2d 2d2d 2d0a  rs.  ----------.
-0000aa80: 2020 7365 6564 3a20 696e 742c 206f 7074    seed: int, opt
-0000aa90: 696f 6e61 6c0a 2020 2020 5468 6520 7261  ional.    The ra
-0000aaa0: 6e64 6f6d 2073 6565 642e 0a20 2022 2222  ndom seed..  """
-0000aab0: 0a20 2069 6620 7365 6564 2069 7320 4e6f  .  if seed is No
-0000aac0: 6e65 3a20 7365 6564 203d 206e 702e 7261  ne: seed = np.ra
-0000aad0: 6e64 6f6d 2e72 616e 6469 6e74 2830 2c20  ndom.randint(0, 
-0000aae0: 3130 3030 3030 290a 2020 4445 4641 554c  100000).  DEFAUL
-0000aaf0: 542e 7365 6564 2873 6565 6429 0a20 206e  T.seed(seed).  n
-0000ab00: 702e 7261 6e64 6f6d 2e73 6565 6428 7365  p.random.seed(se
-0000ab10: 6564 290a 0a0a 6465 6620 7261 6e64 282a  ed)...def rand(*
-0000ab20: 646e 2c20 6b65 793d 4e6f 6e65 293a 0a20  dn, key=None):. 
-0000ab30: 2072 2222 2252 616e 646f 6d20 7661 6c75   r"""Random valu
-0000ab40: 6573 2069 6e20 6120 6769 7665 6e20 7368  es in a given sh
-0000ab50: 6170 652e 0a0a 2020 2e2e 206e 6f74 653a  ape...  .. note:
-0000ab60: 3a0a 2020 2020 2020 5468 6973 2069 7320  :.      This is 
-0000ab70: 6120 636f 6e76 656e 6965 6e63 6520 6675  a convenience fu
-0000ab80: 6e63 7469 6f6e 2066 6f72 2075 7365 7273  nction for users
-0000ab90: 2070 6f72 7469 6e67 2063 6f64 6520 6672   porting code fr
-0000aba0: 6f6d 204d 6174 6c61 622c 0a20 2020 2020  om Matlab,.     
-0000abb0: 2061 6e64 2077 7261 7073 2060 7261 6e64   and wraps `rand
-0000abc0: 6f6d 5f73 616d 706c 6560 2e20 5468 6174  om_sample`. That
-0000abd0: 2066 756e 6374 696f 6e20 7461 6b65 7320   function takes 
-0000abe0: 610a 2020 2020 2020 7475 706c 6520 746f  a.      tuple to
-0000abf0: 2073 7065 6369 6679 2074 6865 2073 697a   specify the siz
-0000ac00: 6520 6f66 2074 6865 206f 7574 7075 742c  e of the output,
-0000ac10: 2077 6869 6368 2069 7320 636f 6e73 6973   which is consis
-0000ac20: 7465 6e74 2077 6974 680a 2020 2020 2020  tent with.      
-0000ac30: 6f74 6865 7220 4e75 6d50 7920 6675 6e63  other NumPy func
-0000ac40: 7469 6f6e 7320 6c69 6b65 2060 6e75 6d70  tions like `nump
-0000ac50: 792e 7a65 726f 7360 2061 6e64 2060 6e75  y.zeros` and `nu
-0000ac60: 6d70 792e 6f6e 6573 602e 0a0a 2020 4372  mpy.ones`...  Cr
-0000ac70: 6561 7465 2061 6e20 6172 7261 7920 6f66  eate an array of
-0000ac80: 2074 6865 2067 6976 656e 2073 6861 7065   the given shape
-0000ac90: 2061 6e64 2070 6f70 756c 6174 6520 6974   and populate it
-0000aca0: 2077 6974 680a 2020 7261 6e64 6f6d 2073   with.  random s
-0000acb0: 616d 706c 6573 2066 726f 6d20 6120 756e  amples from a un
-0000acc0: 6966 6f72 6d20 6469 7374 7269 6275 7469  iform distributi
-0000acd0: 6f6e 0a20 206f 7665 7220 6060 5b30 2c20  on.  over ``[0, 
-0000ace0: 3129 6060 2e0a 0a20 2050 6172 616d 6574  1)``...  Paramet
-0000acf0: 6572 730a 2020 2d2d 2d2d 2d2d 2d2d 2d2d  ers.  ----------
-0000ad00: 0a20 2064 302c 2064 312c 202e 2e2e 2c20  .  d0, d1, ..., 
-0000ad10: 646e 203a 2069 6e74 2c20 6f70 7469 6f6e  dn : int, option
-0000ad20: 616c 0a20 2020 2020 2054 6865 2064 696d  al.      The dim
-0000ad30: 656e 7369 6f6e 7320 6f66 2074 6865 2072  ensions of the r
-0000ad40: 6574 7572 6e65 6420 6172 7261 792c 206d  eturned array, m
-0000ad50: 7573 7420 6265 206e 6f6e 2d6e 6567 6174  ust be non-negat
-0000ad60: 6976 652e 0a20 2020 2020 2049 6620 6e6f  ive..      If no
-0000ad70: 2061 7267 756d 656e 7420 6973 2067 6976   argument is giv
-0000ad80: 656e 2061 2073 696e 676c 6520 5079 7468  en a single Pyth
-0000ad90: 6f6e 2066 6c6f 6174 2069 7320 7265 7475  on float is retu
-0000ada0: 726e 6564 2e0a 0a20 2052 6574 7572 6e73  rned...  Returns
-0000adb0: 0a20 202d 2d2d 2d2d 2d2d 0a20 206f 7574  .  -------.  out
-0000adc0: 203a 206e 6461 7272 6179 2c20 7368 6170   : ndarray, shap
-0000add0: 6520 6060 2864 302c 2064 312c 202e 2e2e  e ``(d0, d1, ...
-0000ade0: 2c20 646e 2960 600a 2020 2020 2020 5261  , dn)``.      Ra
-0000adf0: 6e64 6f6d 2076 616c 7565 732e 0a0a 2020  ndom values...  
-0000ae00: 5365 6520 416c 736f 0a20 202d 2d2d 2d2d  See Also.  -----
-0000ae10: 2d2d 2d0a 2020 7261 6e64 6f6d 0a0a 2020  ---.  random..  
-0000ae20: 4578 616d 706c 6573 0a20 202d 2d2d 2d2d  Examples.  -----
-0000ae30: 2d2d 2d0a 2020 3e3e 3e20 6272 6169 6e70  ---.  >>> brainp
-0000ae40: 792e 6d61 7468 2e72 616e 646f 6d2e 7261  y.math.random.ra
-0000ae50: 6e64 2833 2c32 290a 2020 6172 7261 7928  nd(3,2).  array(
-0000ae60: 5b5b 2030 2e31 3430 3232 3437 312c 2020  [[ 0.14022471,  
-0000ae70: 302e 3936 3336 3036 3138 5d2c 2020 2372  0.96360618],  #r
-0000ae80: 616e 646f 6d0a 2020 2020 2020 2020 205b  andom.         [
-0000ae90: 2030 2e33 3736 3031 3033 322c 2020 302e   0.37601032,  0.
-0000aea0: 3235 3532 3834 3131 5d2c 2020 2372 616e  25528411],  #ran
-0000aeb0: 646f 6d0a 2020 2020 2020 2020 205b 2030  dom.         [ 0
-0000aec0: 2e34 3933 3133 3034 392c 2020 302e 3934  .49313049,  0.94
-0000aed0: 3930 3938 3738 5d5d 2920 2372 616e 646f  909878]]) #rando
-0000aee0: 6d0a 2020 2222 220a 2020 7265 7475 726e  m.  """.  return
-0000aef0: 2044 4546 4155 4c54 2e72 616e 6428 2a64   DEFAULT.rand(*d
-0000af00: 6e2c 206b 6579 3d6b 6579 290a 0a0a 0a0a  n, key=key).....
-0000af10: 6465 6620 7261 6e64 696e 7428 6c6f 772c  def randint(low,
-0000af20: 2068 6967 683d 4e6f 6e65 2c20 7369 7a65   high=None, size
-0000af30: 3d4e 6f6e 652c 2064 7479 7065 3d6a 6e70  =None, dtype=jnp
-0000af40: 2e69 6e74 5f2c 206b 6579 3d4e 6f6e 6529  .int_, key=None)
-0000af50: 3a0a 2020 7222 2222 5265 7475 726e 2072  :.  r"""Return r
-0000af60: 616e 646f 6d20 696e 7465 6765 7273 2066  andom integers f
-0000af70: 726f 6d20 606c 6f77 6020 2869 6e63 6c75  rom `low` (inclu
-0000af80: 7369 7665 2920 746f 2060 6869 6768 6020  sive) to `high` 
-0000af90: 2865 7863 6c75 7369 7665 292e 0a0a 2020  (exclusive)...  
-0000afa0: 5265 7475 726e 2072 616e 646f 6d20 696e  Return random in
-0000afb0: 7465 6765 7273 2066 726f 6d20 7468 6520  tegers from the 
-0000afc0: 2264 6973 6372 6574 6520 756e 6966 6f72  "discrete unifor
-0000afd0: 6d22 2064 6973 7472 6962 7574 696f 6e20  m" distribution 
-0000afe0: 6f66 0a20 2074 6865 2073 7065 6369 6669  of.  the specifi
-0000aff0: 6564 2064 7479 7065 2069 6e20 7468 6520  ed dtype in the 
-0000b000: 2268 616c 662d 6f70 656e 2220 696e 7465  "half-open" inte
-0000b010: 7276 616c 205b 606c 6f77 602c 2060 6869  rval [`low`, `hi
-0000b020: 6768 6029 2e20 4966 0a20 2060 6869 6768  gh`). If.  `high
-0000b030: 6020 6973 204e 6f6e 6520 2874 6865 2064  ` is None (the d
-0000b040: 6566 6175 6c74 292c 2074 6865 6e20 7265  efault), then re
-0000b050: 7375 6c74 7320 6172 6520 6672 6f6d 205b  sults are from [
-0000b060: 302c 2060 6c6f 7760 292e 0a0a 2020 5061  0, `low`)...  Pa
-0000b070: 7261 6d65 7465 7273 0a20 202d 2d2d 2d2d  rameters.  -----
-0000b080: 2d2d 2d2d 2d0a 2020 6c6f 7720 3a20 696e  -----.  low : in
-0000b090: 7420 6f72 2061 7272 6179 2d6c 696b 6520  t or array-like 
-0000b0a0: 6f66 2069 6e74 730a 2020 2020 2020 4c6f  of ints.      Lo
-0000b0b0: 7765 7374 2028 7369 676e 6564 2920 696e  west (signed) in
-0000b0c0: 7465 6765 7273 2074 6f20 6265 2064 7261  tegers to be dra
-0000b0d0: 776e 2066 726f 6d20 7468 6520 6469 7374  wn from the dist
-0000b0e0: 7269 6275 7469 6f6e 2028 756e 6c65 7373  ribution (unless
-0000b0f0: 0a20 2020 2020 2060 6068 6967 683d 4e6f  .      ``high=No
-0000b100: 6e65 6060 2c20 696e 2077 6869 6368 2063  ne``, in which c
-0000b110: 6173 6520 7468 6973 2070 6172 616d 6574  ase this paramet
-0000b120: 6572 2069 7320 6f6e 6520 6162 6f76 6520  er is one above 
-0000b130: 7468 650a 2020 2020 2020 2a68 6967 6865  the.      *highe
-0000b140: 7374 2a20 7375 6368 2069 6e74 6567 6572  st* such integer
-0000b150: 292e 0a20 2068 6967 6820 3a20 696e 7420  )..  high : int 
-0000b160: 6f72 2061 7272 6179 2d6c 696b 6520 6f66  or array-like of
-0000b170: 2069 6e74 732c 206f 7074 696f 6e61 6c0a   ints, optional.
-0000b180: 2020 2020 2020 4966 2070 726f 7669 6465        If provide
-0000b190: 642c 206f 6e65 2061 626f 7665 2074 6865  d, one above the
-0000b1a0: 206c 6172 6765 7374 2028 7369 676e 6564   largest (signed
-0000b1b0: 2920 696e 7465 6765 7220 746f 2062 6520  ) integer to be 
-0000b1c0: 6472 6177 6e0a 2020 2020 2020 6672 6f6d  drawn.      from
-0000b1d0: 2074 6865 2064 6973 7472 6962 7574 696f   the distributio
-0000b1e0: 6e20 2873 6565 2061 626f 7665 2066 6f72  n (see above for
-0000b1f0: 2062 6568 6176 696f 7220 6966 2060 6068   behavior if ``h
-0000b200: 6967 683d 4e6f 6e65 6060 292e 0a20 2020  igh=None``)..   
-0000b210: 2020 2049 6620 6172 7261 792d 6c69 6b65     If array-like
-0000b220: 2c20 6d75 7374 2063 6f6e 7461 696e 2069  , must contain i
-0000b230: 6e74 6567 6572 2076 616c 7565 730a 2020  nteger values.  
-0000b240: 7369 7a65 203a 2069 6e74 206f 7220 7475  size : int or tu
-0000b250: 706c 6520 6f66 2069 6e74 732c 206f 7074  ple of ints, opt
-0000b260: 696f 6e61 6c0a 2020 2020 2020 4f75 7470  ional.      Outp
-0000b270: 7574 2073 6861 7065 2e20 2049 6620 7468  ut shape.  If th
-0000b280: 6520 6769 7665 6e20 7368 6170 6520 6973  e given shape is
-0000b290: 2c20 652e 672e 2c20 6060 286d 2c20 6e2c  , e.g., ``(m, n,
-0000b2a0: 206b 2960 602c 2074 6865 6e0a 2020 2020   k)``, then.    
-0000b2b0: 2020 6060 6d20 2a20 6e20 2a20 6b60 6020    ``m * n * k`` 
-0000b2c0: 7361 6d70 6c65 7320 6172 6520 6472 6177  samples are draw
-0000b2d0: 6e2e 2020 4465 6661 756c 7420 6973 204e  n.  Default is N
-0000b2e0: 6f6e 652c 2069 6e20 7768 6963 6820 6361  one, in which ca
-0000b2f0: 7365 2061 0a20 2020 2020 2073 696e 676c  se a.      singl
-0000b300: 6520 7661 6c75 6520 6973 2072 6574 7572  e value is retur
-0000b310: 6e65 642e 0a20 2064 7479 7065 203a 2064  ned..  dtype : d
-0000b320: 7479 7065 2c20 6f70 7469 6f6e 616c 0a20  type, optional. 
-0000b330: 2020 2020 2044 6573 6972 6564 2064 7479       Desired dty
-0000b340: 7065 206f 6620 7468 6520 7265 7375 6c74  pe of the result
-0000b350: 2e20 4279 7465 6f72 6465 7220 6d75 7374  . Byteorder must
-0000b360: 2062 6520 6e61 7469 7665 2e0a 2020 2020   be native..    
-0000b370: 2020 5468 6520 6465 6661 756c 7420 7661    The default va
-0000b380: 6c75 6520 6973 2069 6e74 2e0a 0a20 2052  lue is int...  R
-0000b390: 6574 7572 6e73 0a20 202d 2d2d 2d2d 2d2d  eturns.  -------
-0000b3a0: 0a20 206f 7574 203a 2069 6e74 206f 7220  .  out : int or 
-0000b3b0: 6e64 6172 7261 7920 6f66 2069 6e74 730a  ndarray of ints.
-0000b3c0: 2020 2020 2020 6073 697a 6560 2d73 6861        `size`-sha
-0000b3d0: 7065 6420 6172 7261 7920 6f66 2072 616e  ped array of ran
-0000b3e0: 646f 6d20 696e 7465 6765 7273 2066 726f  dom integers fro
-0000b3f0: 6d20 7468 6520 6170 7072 6f70 7269 6174  m the appropriat
-0000b400: 650a 2020 2020 2020 6469 7374 7269 6275  e.      distribu
-0000b410: 7469 6f6e 2c20 6f72 2061 2073 696e 676c  tion, or a singl
-0000b420: 6520 7375 6368 2072 616e 646f 6d20 696e  e such random in
-0000b430: 7420 6966 2060 7369 7a65 6020 6e6f 7420  t if `size` not 
-0000b440: 7072 6f76 6964 6564 2e0a 0a20 2053 6565  provided...  See
-0000b450: 2041 6c73 6f0a 2020 2d2d 2d2d 2d2d 2d2d   Also.  --------
-0000b460: 0a20 2072 616e 646f 6d5f 696e 7465 6765  .  random_intege
-0000b470: 7273 203a 2073 696d 696c 6172 2074 6f20  rs : similar to 
-0000b480: 6072 616e 6469 6e74 602c 206f 6e6c 7920  `randint`, only 
-0000b490: 666f 7220 7468 6520 636c 6f73 6564 0a20  for the closed. 
-0000b4a0: 2020 2020 2069 6e74 6572 7661 6c20 5b60       interval [`
-0000b4b0: 6c6f 7760 2c20 6068 6967 6860 5d2c 2061  low`, `high`], a
-0000b4c0: 6e64 2031 2069 7320 7468 6520 6c6f 7765  nd 1 is the lowe
-0000b4d0: 7374 2076 616c 7565 2069 6620 6068 6967  st value if `hig
-0000b4e0: 6860 2069 730a 2020 2020 2020 6f6d 6974  h` is.      omit
-0000b4f0: 7465 642e 0a20 2047 656e 6572 6174 6f72  ted..  Generator
-0000b500: 2e69 6e74 6567 6572 733a 2077 6869 6368  .integers: which
-0000b510: 2073 686f 756c 6420 6265 2075 7365 6420   should be used 
-0000b520: 666f 7220 6e65 7720 636f 6465 2e0a 0a20  for new code... 
-0000b530: 2045 7861 6d70 6c65 730a 2020 2d2d 2d2d   Examples.  ----
-0000b540: 2d2d 2d2d 0a20 203e 3e3e 2062 6d2e 7261  ----.  >>> bm.ra
-0000b550: 6e64 6f6d 2e72 616e 6469 6e74 2832 2c20  ndom.randint(2, 
-0000b560: 7369 7a65 3d31 3029 0a20 2061 7272 6179  size=10).  array
-0000b570: 285b 312c 2030 2c20 302c 2030 2c20 312c  ([1, 0, 0, 0, 1,
-0000b580: 2031 2c20 302c 2030 2c20 312c 2030 5d29   1, 0, 0, 1, 0])
-0000b590: 2023 2072 616e 646f 6d0a 2020 3e3e 3e20   # random.  >>> 
-0000b5a0: 626d 2e72 616e 646f 6d2e 7261 6e64 696e  bm.random.randin
-0000b5b0: 7428 312c 2073 697a 653d 3130 290a 2020  t(1, size=10).  
-0000b5c0: 6172 7261 7928 5b30 2c20 302c 2030 2c20  array([0, 0, 0, 
-0000b5d0: 302c 2030 2c20 302c 2030 2c20 302c 2030  0, 0, 0, 0, 0, 0
-0000b5e0: 2c20 305d 290a 0a20 2047 656e 6572 6174  , 0])..  Generat
-0000b5f0: 6520 6120 3220 7820 3420 6172 7261 7920  e a 2 x 4 array 
-0000b600: 6f66 2069 6e74 7320 6265 7477 6565 6e20  of ints between 
-0000b610: 3020 616e 6420 342c 2069 6e63 6c75 7369  0 and 4, inclusi
-0000b620: 7665 3a0a 0a20 203e 3e3e 2062 6d2e 7261  ve:..  >>> bm.ra
-0000b630: 6e64 6f6d 2e72 616e 6469 6e74 2835 2c20  ndom.randint(5, 
-0000b640: 7369 7a65 3d28 322c 2034 2929 0a20 2061  size=(2, 4)).  a
-0000b650: 7272 6179 285b 5b34 2c20 302c 2032 2c20  rray([[4, 0, 2, 
-0000b660: 315d 2c20 2320 7261 6e64 6f6d 0a20 2020  1], # random.   
-0000b670: 2020 2020 2020 5b33 2c20 322c 2032 2c20        [3, 2, 2, 
-0000b680: 305d 5d29 0a0a 2020 4765 6e65 7261 7465  0]])..  Generate
-0000b690: 2061 2031 2078 2033 2061 7272 6179 2077   a 1 x 3 array w
-0000b6a0: 6974 6820 3320 6469 6666 6572 656e 7420  ith 3 different 
-0000b6b0: 7570 7065 7220 626f 756e 6473 0a0a 2020  upper bounds..  
-0000b6c0: 3e3e 3e20 626d 2e72 616e 646f 6d2e 7261  >>> bm.random.ra
-0000b6d0: 6e64 696e 7428 312c 205b 332c 2035 2c20  ndint(1, [3, 5, 
-0000b6e0: 3130 5d29 0a20 2061 7272 6179 285b 322c  10]).  array([2,
-0000b6f0: 2032 2c20 395d 2920 2320 7261 6e64 6f6d   2, 9]) # random
-0000b700: 0a0a 2020 4765 6e65 7261 7465 2061 2031  ..  Generate a 1
-0000b710: 2062 7920 3320 6172 7261 7920 7769 7468   by 3 array with
-0000b720: 2033 2064 6966 6665 7265 6e74 206c 6f77   3 different low
-0000b730: 6572 2062 6f75 6e64 730a 0a20 203e 3e3e  er bounds..  >>>
-0000b740: 2062 6d2e 7261 6e64 6f6d 2e72 616e 6469   bm.random.randi
-0000b750: 6e74 285b 312c 2035 2c20 375d 2c20 3130  nt([1, 5, 7], 10
-0000b760: 290a 2020 6172 7261 7928 5b39 2c20 382c  ).  array([9, 8,
-0000b770: 2037 5d29 2023 2072 616e 646f 6d0a 0a20   7]) # random.. 
-0000b780: 2047 656e 6572 6174 6520 6120 3220 6279   Generate a 2 by
-0000b790: 2034 2061 7272 6179 2075 7369 6e67 2062   4 array using b
-0000b7a0: 726f 6164 6361 7374 696e 6720 7769 7468  roadcasting with
-0000b7b0: 2064 7479 7065 206f 6620 7569 6e74 380a   dtype of uint8.
-0000b7c0: 0a20 203e 3e3e 2062 6d2e 7261 6e64 6f6d  .  >>> bm.random
-0000b7d0: 2e72 616e 6469 6e74 285b 312c 2033 2c20  .randint([1, 3, 
-0000b7e0: 352c 2037 5d2c 205b 5b31 305d 2c20 5b32  5, 7], [[10], [2
-0000b7f0: 305d 5d2c 2064 7479 7065 3d6e 702e 7569  0]], dtype=np.ui
-0000b800: 6e74 3829 0a20 2061 7272 6179 285b 5b20  nt8).  array([[ 
-0000b810: 382c 2020 362c 2020 392c 2020 375d 2c20  8,  6,  9,  7], 
-0000b820: 2320 7261 6e64 6f6d 0a20 2020 2020 2020  # random.       
-0000b830: 2020 5b20 312c 2031 362c 2020 392c 2031    [ 1, 16,  9, 1
-0000b840: 325d 5d2c 2064 7479 7065 3d75 696e 7438  2]], dtype=uint8
-0000b850: 290a 2020 2222 220a 0a20 2072 6574 7572  ).  """..  retur
-0000b860: 6e20 4445 4641 554c 542e 7261 6e64 696e  n DEFAULT.randin
-0000b870: 7428 6c6f 772c 2068 6967 683d 6869 6768  t(low, high=high
-0000b880: 2c20 7369 7a65 3d73 697a 652c 2064 7479  , size=size, dty
-0000b890: 7065 3d64 7479 7065 2c20 6b65 793d 6b65  pe=dtype, key=ke
-0000b8a0: 7929 0a0a 0a0a 6465 6620 7261 6e64 6f6d  y)....def random
-0000b8b0: 5f69 6e74 6567 6572 7328 6c6f 772c 2068  _integers(low, h
-0000b8c0: 6967 683d 4e6f 6e65 2c20 7369 7a65 3d4e  igh=None, size=N
-0000b8d0: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
-0000b8e0: 2020 7222 2222 0a20 2052 616e 646f 6d20    r""".  Random 
-0000b8f0: 696e 7465 6765 7273 206f 6620 7479 7065  integers of type
-0000b900: 2060 6e70 2e69 6e74 5f60 2062 6574 7765   `np.int_` betwe
-0000b910: 656e 2060 6c6f 7760 2061 6e64 2060 6869  en `low` and `hi
-0000b920: 6768 602c 2069 6e63 6c75 7369 7665 2e0a  gh`, inclusive..
-0000b930: 0a20 2052 6574 7572 6e20 7261 6e64 6f6d  .  Return random
-0000b940: 2069 6e74 6567 6572 7320 6f66 2074 7970   integers of typ
-0000b950: 6520 606e 702e 696e 745f 6020 6672 6f6d  e `np.int_` from
-0000b960: 2074 6865 2022 6469 7363 7265 7465 2075   the "discrete u
-0000b970: 6e69 666f 726d 220a 2020 6469 7374 7269  niform".  distri
-0000b980: 6275 7469 6f6e 2069 6e20 7468 6520 636c  bution in the cl
-0000b990: 6f73 6564 2069 6e74 6572 7661 6c20 5b60  osed interval [`
-0000b9a0: 6c6f 7760 2c20 6068 6967 6860 5d2e 2020  low`, `high`].  
-0000b9b0: 4966 2060 6869 6768 6020 6973 0a20 204e  If `high` is.  N
-0000b9c0: 6f6e 6520 2874 6865 2064 6566 6175 6c74  one (the default
-0000b9d0: 292c 2074 6865 6e20 7265 7375 6c74 7320  ), then results 
-0000b9e0: 6172 6520 6672 6f6d 205b 312c 2060 6c6f  are from [1, `lo
-0000b9f0: 7760 5d2e 2054 6865 2060 6e70 2e69 6e74  w`]. The `np.int
-0000ba00: 5f60 0a20 2074 7970 6520 7472 616e 736c  _`.  type transl
-0000ba10: 6174 6573 2074 6f20 7468 6520 4320 6c6f  ates to the C lo
-0000ba20: 6e67 2069 6e74 6567 6572 2074 7970 6520  ng integer type 
-0000ba30: 616e 6420 6974 7320 7072 6563 6973 696f  and its precisio
-0000ba40: 6e0a 2020 6973 2070 6c61 7466 6f72 6d20  n.  is platform 
-0000ba50: 6465 7065 6e64 656e 742e 0a0a 2020 5061  dependent...  Pa
-0000ba60: 7261 6d65 7465 7273 0a20 202d 2d2d 2d2d  rameters.  -----
-0000ba70: 2d2d 2d2d 2d0a 2020 6c6f 7720 3a20 696e  -----.  low : in
-0000ba80: 740a 2020 2020 2020 4c6f 7765 7374 2028  t.      Lowest (
-0000ba90: 7369 676e 6564 2920 696e 7465 6765 7220  signed) integer 
-0000baa0: 746f 2062 6520 6472 6177 6e20 6672 6f6d  to be drawn from
-0000bab0: 2074 6865 2064 6973 7472 6962 7574 696f   the distributio
-0000bac0: 6e20 2875 6e6c 6573 730a 2020 2020 2020  n (unless.      
-0000bad0: 6060 6869 6768 3d4e 6f6e 6560 602c 2069  ``high=None``, i
-0000bae0: 6e20 7768 6963 6820 6361 7365 2074 6869  n which case thi
-0000baf0: 7320 7061 7261 6d65 7465 7220 6973 2074  s parameter is t
-0000bb00: 6865 202a 6869 6768 6573 742a 2073 7563  he *highest* suc
-0000bb10: 680a 2020 2020 2020 696e 7465 6765 7229  h.      integer)
-0000bb20: 2e0a 2020 6869 6768 203a 2069 6e74 2c20  ..  high : int, 
-0000bb30: 6f70 7469 6f6e 616c 0a20 2020 2020 2049  optional.      I
-0000bb40: 6620 7072 6f76 6964 6564 2c20 7468 6520  f provided, the 
-0000bb50: 6c61 7267 6573 7420 2873 6967 6e65 6429  largest (signed)
-0000bb60: 2069 6e74 6567 6572 2074 6f20 6265 2064   integer to be d
-0000bb70: 7261 776e 2066 726f 6d20 7468 650a 2020  rawn from the.  
-0000bb80: 2020 2020 6469 7374 7269 6275 7469 6f6e      distribution
-0000bb90: 2028 7365 6520 6162 6f76 6520 666f 7220   (see above for 
-0000bba0: 6265 6861 7669 6f72 2069 6620 6060 6869  behavior if ``hi
-0000bbb0: 6768 3d4e 6f6e 6560 6029 2e0a 2020 7369  gh=None``)..  si
-0000bbc0: 7a65 203a 2069 6e74 206f 7220 7475 706c  ze : int or tupl
-0000bbd0: 6520 6f66 2069 6e74 732c 206f 7074 696f  e of ints, optio
-0000bbe0: 6e61 6c0a 2020 2020 2020 4f75 7470 7574  nal.      Output
-0000bbf0: 2073 6861 7065 2e20 2049 6620 7468 6520   shape.  If the 
-0000bc00: 6769 7665 6e20 7368 6170 6520 6973 2c20  given shape is, 
-0000bc10: 652e 672e 2c20 6060 286d 2c20 6e2c 206b  e.g., ``(m, n, k
-0000bc20: 2960 602c 2074 6865 6e0a 2020 2020 2020  )``, then.      
-0000bc30: 6060 6d20 2a20 6e20 2a20 6b60 6020 7361  ``m * n * k`` sa
-0000bc40: 6d70 6c65 7320 6172 6520 6472 6177 6e2e  mples are drawn.
-0000bc50: 2020 4465 6661 756c 7420 6973 204e 6f6e    Default is Non
-0000bc60: 652c 2069 6e20 7768 6963 6820 6361 7365  e, in which case
-0000bc70: 2061 0a20 2020 2020 2073 696e 676c 6520   a.      single 
-0000bc80: 7661 6c75 6520 6973 2072 6574 7572 6e65  value is returne
-0000bc90: 642e 0a0a 2020 5265 7475 726e 730a 2020  d...  Returns.  
-0000bca0: 2d2d 2d2d 2d2d 2d0a 2020 6f75 7420 3a20  -------.  out : 
-0000bcb0: 696e 7420 6f72 206e 6461 7272 6179 206f  int or ndarray o
-0000bcc0: 6620 696e 7473 0a20 2020 2020 2060 7369  f ints.      `si
-0000bcd0: 7a65 602d 7368 6170 6564 2061 7272 6179  ze`-shaped array
-0000bce0: 206f 6620 7261 6e64 6f6d 2069 6e74 6567   of random integ
-0000bcf0: 6572 7320 6672 6f6d 2074 6865 2061 7070  ers from the app
-0000bd00: 726f 7072 6961 7465 0a20 2020 2020 2064  ropriate.      d
-0000bd10: 6973 7472 6962 7574 696f 6e2c 206f 7220  istribution, or 
-0000bd20: 6120 7369 6e67 6c65 2073 7563 6820 7261  a single such ra
-0000bd30: 6e64 6f6d 2069 6e74 2069 6620 6073 697a  ndom int if `siz
-0000bd40: 6560 206e 6f74 2070 726f 7669 6465 642e  e` not provided.
-0000bd50: 0a0a 2020 5365 6520 416c 736f 0a20 202d  ..  See Also.  -
-0000bd60: 2d2d 2d2d 2d2d 2d0a 2020 7261 6e64 696e  -------.  randin
-0000bd70: 7420 3a20 5369 6d69 6c61 7220 746f 2060  t : Similar to `
-0000bd80: 7261 6e64 6f6d 5f69 6e74 6567 6572 7360  random_integers`
-0000bd90: 2c20 6f6e 6c79 2066 6f72 2074 6865 2068  , only for the h
-0000bda0: 616c 662d 6f70 656e 0a20 2020 2020 2069  alf-open.      i
-0000bdb0: 6e74 6572 7661 6c20 5b60 6c6f 7760 2c20  nterval [`low`, 
-0000bdc0: 6068 6967 6860 292c 2061 6e64 2030 2069  `high`), and 0 i
-0000bdd0: 7320 7468 6520 6c6f 7765 7374 2076 616c  s the lowest val
-0000bde0: 7565 2069 6620 6068 6967 6860 2069 730a  ue if `high` is.
-0000bdf0: 2020 2020 2020 6f6d 6974 7465 642e 0a0a        omitted...
-0000be00: 2020 4e6f 7465 730a 2020 2d2d 2d2d 2d0a    Notes.  -----.
-0000be10: 2020 546f 2073 616d 706c 6520 6672 6f6d    To sample from
-0000be20: 204e 2065 7665 6e6c 7920 7370 6163 6564   N evenly spaced
-0000be30: 2066 6c6f 6174 696e 672d 706f 696e 7420   floating-point 
-0000be40: 6e75 6d62 6572 7320 6265 7477 6565 6e20  numbers between 
-0000be50: 6120 616e 6420 622c 0a20 2075 7365 3a3a  a and b,.  use::
-0000be60: 0a0a 2020 2020 6120 2b20 2862 202d 2061  ..    a + (b - a
-0000be70: 2920 2a20 2862 6d2e 7261 6e64 6f6d 2e72  ) * (bm.random.r
-0000be80: 616e 646f 6d5f 696e 7465 6765 7273 284e  andom_integers(N
-0000be90: 2920 2d20 3129 202f 2028 4e20 2d20 312e  ) - 1) / (N - 1.
-0000bea0: 290a 0a20 2045 7861 6d70 6c65 730a 2020  )..  Examples.  
-0000beb0: 2d2d 2d2d 2d2d 2d2d 0a20 203e 3e3e 2062  --------.  >>> b
-0000bec0: 6d2e 7261 6e64 6f6d 2e72 616e 646f 6d5f  m.random.random_
-0000bed0: 696e 7465 6765 7273 2835 290a 2020 3420  integers(5).  4 
-0000bee0: 2320 7261 6e64 6f6d 0a20 203e 3e3e 2074  # random.  >>> t
-0000bef0: 7970 6528 626d 2e72 616e 646f 6d2e 7261  ype(bm.random.ra
-0000bf00: 6e64 6f6d 5f69 6e74 6567 6572 7328 3529  ndom_integers(5)
-0000bf10: 290a 2020 3c63 6c61 7373 2027 6e75 6d70  ).  <class 'nump
-0000bf20: 792e 696e 7436 3427 3e0a 2020 3e3e 3e20  y.int64'>.  >>> 
-0000bf30: 626d 2e72 616e 646f 6d2e 7261 6e64 6f6d  bm.random.random
-0000bf40: 5f69 6e74 6567 6572 7328 352c 2073 697a  _integers(5, siz
-0000bf50: 653d 2833 2c32 2929 0a20 2061 7272 6179  e=(3,2)).  array
-0000bf60: 285b 5b35 2c20 345d 2c20 2320 7261 6e64  ([[5, 4], # rand
-0000bf70: 6f6d 0a20 2020 2020 2020 2020 5b33 2c20  om.         [3, 
-0000bf80: 335d 2c0a 2020 2020 2020 2020 205b 342c  3],.         [4,
-0000bf90: 2035 5d5d 290a 0a20 2043 686f 6f73 6520   5]])..  Choose 
-0000bfa0: 6669 7665 2072 616e 646f 6d20 6e75 6d62  five random numb
-0000bfb0: 6572 7320 6672 6f6d 2074 6865 2073 6574  ers from the set
-0000bfc0: 206f 6620 6669 7665 2065 7665 6e6c 792d   of five evenly-
-0000bfd0: 7370 6163 6564 0a20 206e 756d 6265 7273  spaced.  numbers
-0000bfe0: 2062 6574 7765 656e 2030 2061 6e64 2032   between 0 and 2
-0000bff0: 2e35 2c20 696e 636c 7573 6976 6520 282a  .5, inclusive (*
-0000c000: 692e 652e 2a2c 2066 726f 6d20 7468 6520  i.e.*, from the 
-0000c010: 7365 740a 2020 3a6d 6174 683a 607b 302c  set.  :math:`{0,
-0000c020: 2035 2f38 2c20 3130 2f38 2c20 3135 2f38   5/8, 10/8, 15/8
-0000c030: 2c20 3230 2f38 7d60 293a 0a0a 2020 3e3e  , 20/8}`):..  >>
-0000c040: 3e20 322e 3520 2a20 2862 6d2e 7261 6e64  > 2.5 * (bm.rand
-0000c050: 6f6d 2e72 616e 646f 6d5f 696e 7465 6765  om.random_intege
-0000c060: 7273 2835 2c20 7369 7a65 3d28 352c 2929  rs(5, size=(5,))
-0000c070: 202d 2031 2920 2f20 342e 0a20 2061 7272   - 1) / 4..  arr
-0000c080: 6179 285b 2030 2e36 3235 2c20 2031 2e32  ay([ 0.625,  1.2
-0000c090: 3520 2c20 2030 2e36 3235 2c20 2030 2e36  5 ,  0.625,  0.6
-0000c0a0: 3235 2c20 2032 2e35 2020 5d29 2023 2072  25,  2.5  ]) # r
-0000c0b0: 616e 646f 6d0a 0a20 2052 6f6c 6c20 7477  andom..  Roll tw
-0000c0c0: 6f20 7369 7820 7369 6465 6420 6469 6365  o six sided dice
-0000c0d0: 2031 3030 3020 7469 6d65 7320 616e 6420   1000 times and 
-0000c0e0: 7375 6d20 7468 6520 7265 7375 6c74 733a  sum the results:
-0000c0f0: 0a0a 2020 3e3e 3e20 6431 203d 2062 6d2e  ..  >>> d1 = bm.
-0000c100: 7261 6e64 6f6d 2e72 616e 646f 6d5f 696e  random.random_in
-0000c110: 7465 6765 7273 2831 2c20 362c 2031 3030  tegers(1, 6, 100
-0000c120: 3029 0a20 203e 3e3e 2064 3220 3d20 626d  0).  >>> d2 = bm
-0000c130: 2e72 616e 646f 6d2e 7261 6e64 6f6d 5f69  .random.random_i
-0000c140: 6e74 6567 6572 7328 312c 2036 2c20 3130  ntegers(1, 6, 10
-0000c150: 3030 290a 2020 3e3e 3e20 6473 756d 7320  00).  >>> dsums 
-0000c160: 3d20 6431 202b 2064 320a 0a20 2044 6973  = d1 + d2..  Dis
-0000c170: 706c 6179 2072 6573 756c 7473 2061 7320  play results as 
-0000c180: 6120 6869 7374 6f67 7261 6d3a 0a0a 2020  a histogram:..  
-0000c190: 3e3e 3e20 696d 706f 7274 206d 6174 706c  >>> import matpl
-0000c1a0: 6f74 6c69 622e 7079 706c 6f74 2061 7320  otlib.pyplot as 
-0000c1b0: 706c 740a 2020 3e3e 3e20 636f 756e 742c  plt.  >>> count,
-0000c1c0: 2062 696e 732c 2069 676e 6f72 6564 203d   bins, ignored =
-0000c1d0: 2070 6c74 2e68 6973 7428 6473 756d 732c   plt.hist(dsums,
-0000c1e0: 2031 312c 2064 656e 7369 7479 3d54 7275   11, density=Tru
-0000c1f0: 6529 0a20 203e 3e3e 2070 6c74 2e73 686f  e).  >>> plt.sho
-0000c200: 7728 290a 2020 2222 220a 0a20 2072 6574  w().  """..  ret
-0000c210: 7572 6e20 4445 4641 554c 542e 7261 6e64  urn DEFAULT.rand
-0000c220: 6f6d 5f69 6e74 6567 6572 7328 6c6f 772c  om_integers(low,
-0000c230: 2068 6967 683d 6869 6768 2c20 7369 7a65   high=high, size
-0000c240: 3d73 697a 652c 206b 6579 3d6b 6579 290a  =size, key=key).
-0000c250: 0a0a 0a0a 6465 6620 7261 6e64 6e28 2a64  ....def randn(*d
-0000c260: 6e2c 206b 6579 3d4e 6f6e 6529 3a0a 2020  n, key=None):.  
-0000c270: 7222 2222 0a20 2052 6574 7572 6e20 6120  r""".  Return a 
-0000c280: 7361 6d70 6c65 2028 6f72 2073 616d 706c  sample (or sampl
-0000c290: 6573 2920 6672 6f6d 2074 6865 2022 7374  es) from the "st
-0000c2a0: 616e 6461 7264 206e 6f72 6d61 6c22 2064  andard normal" d
-0000c2b0: 6973 7472 6962 7574 696f 6e2e 0a0a 2020  istribution...  
-0000c2c0: 2e2e 206e 6f74 653a 3a0a 2020 2020 2020  .. note::.      
-0000c2d0: 5468 6973 2069 7320 6120 636f 6e76 656e  This is a conven
-0000c2e0: 6965 6e63 6520 6675 6e63 7469 6f6e 2066  ience function f
-0000c2f0: 6f72 2075 7365 7273 2070 6f72 7469 6e67  or users porting
-0000c300: 2063 6f64 6520 6672 6f6d 204d 6174 6c61   code from Matla
-0000c310: 622c 0a20 2020 2020 2061 6e64 2077 7261  b,.      and wra
-0000c320: 7073 2060 7374 616e 6461 7264 5f6e 6f72  ps `standard_nor
-0000c330: 6d61 6c60 2e20 5468 6174 2066 756e 6374  mal`. That funct
-0000c340: 696f 6e20 7461 6b65 7320 610a 2020 2020  ion takes a.    
-0000c350: 2020 7475 706c 6520 746f 2073 7065 6369    tuple to speci
-0000c360: 6679 2074 6865 2073 697a 6520 6f66 2074  fy the size of t
-0000c370: 6865 206f 7574 7075 742c 2077 6869 6368  he output, which
-0000c380: 2069 7320 636f 6e73 6973 7465 6e74 2077   is consistent w
-0000c390: 6974 680a 2020 2020 2020 6f74 6865 7220  ith.      other 
-0000c3a0: 4e75 6d50 7920 6675 6e63 7469 6f6e 7320  NumPy functions 
-0000c3b0: 6c69 6b65 2060 6e75 6d70 792e 7a65 726f  like `numpy.zero
-0000c3c0: 7360 2061 6e64 2060 6e75 6d70 792e 6f6e  s` and `numpy.on
-0000c3d0: 6573 602e 0a0a 2020 2e2e 206e 6f74 653a  es`...  .. note:
-0000c3e0: 3a0a 2020 2020 2020 4e65 7720 636f 6465  :.      New code
-0000c3f0: 2073 686f 756c 6420 7573 6520 7468 6520   should use the 
-0000c400: 6060 7374 616e 6461 7264 5f6e 6f72 6d61  ``standard_norma
-0000c410: 6c60 6020 6d65 7468 6f64 206f 6620 6120  l`` method of a 
-0000c420: 6060 6465 6661 756c 745f 726e 6728 2960  ``default_rng()`
-0000c430: 600a 2020 2020 2020 696e 7374 616e 6365  `.      instance
-0000c440: 2069 6e73 7465 6164 3b20 706c 6561 7365   instead; please
-0000c450: 2073 6565 2074 6865 203a 7265 663a 6072   see the :ref:`r
-0000c460: 616e 646f 6d2d 7175 6963 6b2d 7374 6172  andom-quick-star
-0000c470: 7460 2e0a 0a20 2049 6620 706f 7369 7469  t`...  If positi
-0000c480: 7665 2069 6e74 5f6c 696b 6520 6172 6775  ve int_like argu
-0000c490: 6d65 6e74 7320 6172 6520 7072 6f76 6964  ments are provid
-0000c4a0: 6564 2c20 6072 616e 646e 6020 6765 6e65  ed, `randn` gene
-0000c4b0: 7261 7465 7320 616e 2061 7272 6179 0a20  rates an array. 
-0000c4c0: 206f 6620 7368 6170 6520 6060 2864 302c   of shape ``(d0,
-0000c4d0: 2064 312c 202e 2e2e 2c20 646e 2960 602c   d1, ..., dn)``,
-0000c4e0: 2066 696c 6c65 640a 2020 7769 7468 2072   filled.  with r
-0000c4f0: 616e 646f 6d20 666c 6f61 7473 2073 616d  andom floats sam
-0000c500: 706c 6564 2066 726f 6d20 6120 756e 6976  pled from a univ
-0000c510: 6172 6961 7465 2022 6e6f 726d 616c 2220  ariate "normal" 
-0000c520: 2847 6175 7373 6961 6e29 0a20 2064 6973  (Gaussian).  dis
-0000c530: 7472 6962 7574 696f 6e20 6f66 206d 6561  tribution of mea
-0000c540: 6e20 3020 616e 6420 7661 7269 616e 6365  n 0 and variance
-0000c550: 2031 2e20 4120 7369 6e67 6c65 2066 6c6f   1. A single flo
-0000c560: 6174 2072 616e 646f 6d6c 7920 7361 6d70  at randomly samp
-0000c570: 6c65 640a 2020 6672 6f6d 2074 6865 2064  led.  from the d
-0000c580: 6973 7472 6962 7574 696f 6e20 6973 2072  istribution is r
-0000c590: 6574 7572 6e65 6420 6966 206e 6f20 6172  eturned if no ar
-0000c5a0: 6775 6d65 6e74 2069 7320 7072 6f76 6964  gument is provid
-0000c5b0: 6564 2e0a 0a20 2050 6172 616d 6574 6572  ed...  Parameter
-0000c5c0: 730a 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  s.  ----------. 
-0000c5d0: 2064 302c 2064 312c 202e 2e2e 2c20 646e   d0, d1, ..., dn
-0000c5e0: 203a 2069 6e74 2c20 6f70 7469 6f6e 616c   : int, optional
-0000c5f0: 0a20 2020 2020 2054 6865 2064 696d 656e  .      The dimen
-0000c600: 7369 6f6e 7320 6f66 2074 6865 2072 6574  sions of the ret
-0000c610: 7572 6e65 6420 6172 7261 792c 206d 7573  urned array, mus
-0000c620: 7420 6265 206e 6f6e 2d6e 6567 6174 6976  t be non-negativ
-0000c630: 652e 0a20 2020 2020 2049 6620 6e6f 2061  e..      If no a
-0000c640: 7267 756d 656e 7420 6973 2067 6976 656e  rgument is given
-0000c650: 2061 2073 696e 676c 6520 5079 7468 6f6e   a single Python
-0000c660: 2066 6c6f 6174 2069 7320 7265 7475 726e   float is return
-0000c670: 6564 2e0a 0a20 2052 6574 7572 6e73 0a20  ed...  Returns. 
-0000c680: 202d 2d2d 2d2d 2d2d 0a20 205a 203a 206e   -------.  Z : n
-0000c690: 6461 7272 6179 206f 7220 666c 6f61 740a  darray or float.
-0000c6a0: 2020 2020 2020 4120 6060 2864 302c 2064        A ``(d0, d
-0000c6b0: 312c 202e 2e2e 2c20 646e 2960 602d 7368  1, ..., dn)``-sh
-0000c6c0: 6170 6564 2061 7272 6179 206f 6620 666c  aped array of fl
-0000c6d0: 6f61 7469 6e67 2d70 6f69 6e74 2073 616d  oating-point sam
-0000c6e0: 706c 6573 2066 726f 6d0a 2020 2020 2020  ples from.      
-0000c6f0: 7468 6520 7374 616e 6461 7264 206e 6f72  the standard nor
-0000c700: 6d61 6c20 6469 7374 7269 6275 7469 6f6e  mal distribution
-0000c710: 2c20 6f72 2061 2073 696e 676c 6520 7375  , or a single su
-0000c720: 6368 2066 6c6f 6174 2069 660a 2020 2020  ch float if.    
-0000c730: 2020 6e6f 2070 6172 616d 6574 6572 7320    no parameters 
-0000c740: 7765 7265 2073 7570 706c 6965 642e 0a0a  were supplied...
-0000c750: 2020 5365 6520 416c 736f 0a20 202d 2d2d    See Also.  ---
-0000c760: 2d2d 2d2d 2d0a 2020 7374 616e 6461 7264  -----.  standard
-0000c770: 5f6e 6f72 6d61 6c20 3a20 5369 6d69 6c61  _normal : Simila
-0000c780: 722c 2062 7574 2074 616b 6573 2061 2074  r, but takes a t
-0000c790: 7570 6c65 2061 7320 6974 7320 6172 6775  uple as its argu
-0000c7a0: 6d65 6e74 2e0a 2020 6e6f 726d 616c 203a  ment..  normal :
-0000c7b0: 2041 6c73 6f20 6163 6365 7074 7320 6d75   Also accepts mu
-0000c7c0: 2061 6e64 2073 6967 6d61 2061 7267 756d   and sigma argum
-0000c7d0: 656e 7473 2e0a 2020 7261 6e64 6f6d 2e47  ents..  random.G
-0000c7e0: 656e 6572 6174 6f72 2e73 7461 6e64 6172  enerator.standar
-0000c7f0: 645f 6e6f 726d 616c 3a20 7768 6963 6820  d_normal: which 
-0000c800: 7368 6f75 6c64 2062 6520 7573 6564 2066  should be used f
-0000c810: 6f72 206e 6577 2063 6f64 652e 0a0a 2020  or new code...  
-0000c820: 4e6f 7465 730a 2020 2d2d 2d2d 2d0a 2020  Notes.  -----.  
-0000c830: 466f 7220 7261 6e64 6f6d 2073 616d 706c  For random sampl
-0000c840: 6573 2066 726f 6d20 3a6d 6174 683a 604e  es from :math:`N
-0000c850: 285c 6d75 2c20 5c73 6967 6d61 5e32 2960  (\mu, \sigma^2)`
-0000c860: 2c20 7573 653a 0a0a 2020 6060 7369 676d  , use:..  ``sigm
-0000c870: 6120 2a20 626d 2e72 616e 646f 6d2e 7261  a * bm.random.ra
-0000c880: 6e64 6e28 2e2e 2e29 202b 206d 7560 600a  ndn(...) + mu``.
-0000c890: 0a20 2045 7861 6d70 6c65 730a 2020 2d2d  .  Examples.  --
-0000c8a0: 2d2d 2d2d 2d2d 0a20 203e 3e3e 2062 6d2e  ------.  >>> bm.
-0000c8b0: 7261 6e64 6f6d 2e72 616e 646e 2829 0a20  random.randn(). 
-0000c8c0: 2032 2e31 3932 3338 3735 3333 3535 3337   2.1923875335537
-0000c8d0: 3331 3520 2023 2072 616e 646f 6d0a 0a20  315  # random.. 
-0000c8e0: 2054 776f 2d62 792d 666f 7572 2061 7272   Two-by-four arr
-0000c8f0: 6179 206f 6620 7361 6d70 6c65 7320 6672  ay of samples fr
-0000c900: 6f6d 204e 2833 2c20 362e 3235 293a 0a0a  om N(3, 6.25):..
-0000c910: 2020 3e3e 3e20 3320 2b20 322e 3520 2a20    >>> 3 + 2.5 * 
-0000c920: 626d 2e72 616e 646f 6d2e 7261 6e64 6e28  bm.random.randn(
-0000c930: 322c 2034 290a 2020 6172 7261 7928 5b5b  2, 4).  array([[
-0000c940: 2d34 2e34 3934 3031 3530 312c 2020 342e  -4.49401501,  4.
-0000c950: 3030 3935 3030 3334 2c20 2d31 2e38 3138  00950034, -1.818
-0000c960: 3134 3836 372c 2020 372e 3239 3731 3836  14867,  7.297186
-0000c970: 3737 5d2c 2020 2023 2072 616e 646f 6d0a  77],   # random.
-0000c980: 2020 2020 2020 2020 205b 2030 2e33 3939           [ 0.399
-0000c990: 3234 3830 342c 2020 342e 3638 3435 3633  24804,  4.684563
-0000c9a0: 3136 2c20 2034 2e39 3933 3934 3532 392c  16,  4.99394529,
-0000c9b0: 2020 342e 3834 3035 3732 3534 5d5d 2920    4.84057254]]) 
-0000c9c0: 2023 2072 616e 646f 6d0a 2020 2222 220a   # random.  """.
-0000c9d0: 0a20 2072 6574 7572 6e20 4445 4641 554c  .  return DEFAUL
-0000c9e0: 542e 7261 6e64 6e28 2a64 6e2c 206b 6579  T.randn(*dn, key
-0000c9f0: 3d6b 6579 290a 0a0a 0a0a 6465 6620 7261  =key).....def ra
-0000ca00: 6e64 6f6d 2873 697a 653d 4e6f 6e65 2c20  ndom(size=None, 
-0000ca10: 6b65 793d 4e6f 6e65 293a 0a20 2022 2222  key=None):.  """
-0000ca20: 0a20 2052 6574 7572 6e20 7261 6e64 6f6d  .  Return random
-0000ca30: 2066 6c6f 6174 7320 696e 2074 6865 2068   floats in the h
-0000ca40: 616c 662d 6f70 656e 2069 6e74 6572 7661  alf-open interva
-0000ca50: 6c20 5b30 2e30 2c20 312e 3029 2e20 416c  l [0.0, 1.0). Al
-0000ca60: 6961 7320 666f 720a 2020 6072 616e 646f  ias for.  `rando
-0000ca70: 6d5f 7361 6d70 6c65 6020 746f 2065 6173  m_sample` to eas
-0000ca80: 6520 666f 7277 6172 642d 706f 7274 696e  e forward-portin
-0000ca90: 6720 746f 2074 6865 206e 6577 2072 616e  g to the new ran
-0000caa0: 646f 6d20 4150 492e 0a20 2022 2222 0a20  dom API..  """. 
-0000cab0: 2072 6574 7572 6e20 4445 4641 554c 542e   return DEFAULT.
-0000cac0: 7261 6e64 6f6d 2873 697a 652c 206b 6579  random(size, key
-0000cad0: 3d6b 6579 290a 0a0a 0a64 6566 2072 616e  =key)....def ran
-0000cae0: 646f 6d5f 7361 6d70 6c65 2873 697a 653d  dom_sample(size=
-0000caf0: 4e6f 6e65 2c20 6b65 793d 4e6f 6e65 293a  None, key=None):
-0000cb00: 0a20 2072 2222 220a 2020 5265 7475 726e  .  r""".  Return
-0000cb10: 2072 616e 646f 6d20 666c 6f61 7473 2069   random floats i
-0000cb20: 6e20 7468 6520 6861 6c66 2d6f 7065 6e20  n the half-open 
-0000cb30: 696e 7465 7276 616c 205b 302e 302c 2031  interval [0.0, 1
-0000cb40: 2e30 292e 0a0a 2020 5265 7375 6c74 7320  .0)...  Results 
-0000cb50: 6172 6520 6672 6f6d 2074 6865 2022 636f  are from the "co
-0000cb60: 6e74 696e 756f 7573 2075 6e69 666f 726d  ntinuous uniform
-0000cb70: 2220 6469 7374 7269 6275 7469 6f6e 206f  " distribution o
-0000cb80: 7665 7220 7468 650a 2020 7374 6174 6564  ver the.  stated
-0000cb90: 2069 6e74 6572 7661 6c2e 2020 546f 2073   interval.  To s
-0000cba0: 616d 706c 6520 3a6d 6174 683a 6055 6e69  ample :math:`Uni
-0000cbb0: 665b 612c 2062 292c 2062 203e 2061 6020  f[a, b), b > a` 
-0000cbc0: 6d75 6c74 6970 6c79 0a20 2074 6865 206f  multiply.  the o
-0000cbd0: 7574 7075 7420 6f66 2060 7261 6e64 6f6d  utput of `random
-0000cbe0: 5f73 616d 706c 6560 2062 7920 6028 622d  _sample` by `(b-
-0000cbf0: 6129 6020 616e 6420 6164 6420 6061 603a  a)` and add `a`:
-0000cc00: 3a0a 0a20 2020 2028 6220 2d20 6129 202a  :..    (b - a) *
-0000cc10: 2072 616e 646f 6d5f 7361 6d70 6c65 2829   random_sample()
-0000cc20: 202b 2061 0a0a 2020 2e2e 206e 6f74 653a   + a..  .. note:
-0000cc30: 3a0a 2020 2020 2020 4e65 7720 636f 6465  :.      New code
-0000cc40: 2073 686f 756c 6420 7573 6520 7468 6520   should use the 
-0000cc50: 6060 7261 6e64 6f6d 6060 206d 6574 686f  ``random`` metho
-0000cc60: 6420 6f66 2061 2060 6064 6566 6175 6c74  d of a ``default
-0000cc70: 5f72 6e67 2829 6060 0a20 2020 2020 2069  _rng()``.      i
-0000cc80: 6e73 7461 6e63 6520 696e 7374 6561 643b  nstance instead;
-0000cc90: 2070 6c65 6173 6520 7365 6520 7468 6520   please see the 
-0000cca0: 3a72 6566 3a60 7261 6e64 6f6d 2d71 7569  :ref:`random-qui
-0000ccb0: 636b 2d73 7461 7274 602e 0a0a 2020 5061  ck-start`...  Pa
-0000ccc0: 7261 6d65 7465 7273 0a20 202d 2d2d 2d2d  rameters.  -----
-0000ccd0: 2d2d 2d2d 2d0a 2020 7369 7a65 203a 2069  -----.  size : i
-0000cce0: 6e74 206f 7220 7475 706c 6520 6f66 2069  nt or tuple of i
-0000ccf0: 6e74 732c 206f 7074 696f 6e61 6c0a 2020  nts, optional.  
-0000cd00: 2020 2020 4f75 7470 7574 2073 6861 7065      Output shape
-0000cd10: 2e20 2049 6620 7468 6520 6769 7665 6e20  .  If the given 
-0000cd20: 7368 6170 6520 6973 2c20 652e 672e 2c20  shape is, e.g., 
-0000cd30: 6060 286d 2c20 6e2c 206b 2960 602c 2074  ``(m, n, k)``, t
-0000cd40: 6865 6e0a 2020 2020 2020 6060 6d20 2a20  hen.      ``m * 
-0000cd50: 6e20 2a20 6b60 6020 7361 6d70 6c65 7320  n * k`` samples 
-0000cd60: 6172 6520 6472 6177 6e2e 2020 4465 6661  are drawn.  Defa
-0000cd70: 756c 7420 6973 204e 6f6e 652c 2069 6e20  ult is None, in 
-0000cd80: 7768 6963 6820 6361 7365 2061 0a20 2020  which case a.   
-0000cd90: 2020 2073 696e 676c 6520 7661 6c75 6520     single value 
-0000cda0: 6973 2072 6574 7572 6e65 642e 0a0a 2020  is returned...  
-0000cdb0: 5265 7475 726e 730a 2020 2d2d 2d2d 2d2d  Returns.  ------
-0000cdc0: 2d0a 2020 6f75 7420 3a20 666c 6f61 7420  -.  out : float 
-0000cdd0: 6f72 206e 6461 7272 6179 206f 6620 666c  or ndarray of fl
-0000cde0: 6f61 7473 0a20 2020 2020 2041 7272 6179  oats.      Array
-0000cdf0: 206f 6620 7261 6e64 6f6d 2066 6c6f 6174   of random float
-0000ce00: 7320 6f66 2073 6861 7065 2060 7369 7a65  s of shape `size
-0000ce10: 6020 2875 6e6c 6573 7320 6060 7369 7a65  ` (unless ``size
-0000ce20: 3d4e 6f6e 6560 602c 2069 6e20 7768 6963  =None``, in whic
-0000ce30: 680a 2020 2020 2020 6361 7365 2061 2073  h.      case a s
-0000ce40: 696e 676c 6520 666c 6f61 7420 6973 2072  ingle float is r
-0000ce50: 6574 7572 6e65 6429 2e0a 0a20 2053 6565  eturned)...  See
-0000ce60: 2041 6c73 6f0a 2020 2d2d 2d2d 2d2d 2d2d   Also.  --------
-0000ce70: 0a20 2047 656e 6572 6174 6f72 2e72 616e  .  Generator.ran
-0000ce80: 646f 6d3a 2077 6869 6368 2073 686f 756c  dom: which shoul
-0000ce90: 6420 6265 2075 7365 6420 666f 7220 6e65  d be used for ne
-0000cea0: 7720 636f 6465 2e0a 0a20 2045 7861 6d70  w code...  Examp
-0000ceb0: 6c65 730a 2020 2d2d 2d2d 2d2d 2d2d 0a20  les.  --------. 
-0000cec0: 203e 3e3e 2062 7261 696e 7079 2e6d 6174   >>> brainpy.mat
-0000ced0: 682e 7261 6e64 6f6d 2e72 616e 646f 6d5f  h.random.random_
-0000cee0: 7361 6d70 6c65 2829 0a20 2030 2e34 3731  sample().  0.471
-0000cef0: 3038 3534 3739 3935 3335 3630 3938 2023  08547995356098 #
-0000cf00: 2072 616e 646f 6d0a 2020 3e3e 3e20 7479   random.  >>> ty
-0000cf10: 7065 2862 7261 696e 7079 2e6d 6174 682e  pe(brainpy.math.
-0000cf20: 7261 6e64 6f6d 2e72 616e 646f 6d5f 7361  random.random_sa
-0000cf30: 6d70 6c65 2829 290a 2020 3c63 6c61 7373  mple()).  <class
-0000cf40: 2027 666c 6f61 7427 3e0a 2020 3e3e 3e20   'float'>.  >>> 
-0000cf50: 6272 6169 6e70 792e 6d61 7468 2e72 616e  brainpy.math.ran
-0000cf60: 646f 6d2e 7261 6e64 6f6d 5f73 616d 706c  dom.random_sampl
-0000cf70: 6528 2835 2c29 290a 2020 6172 7261 7928  e((5,)).  array(
-0000cf80: 5b20 302e 3330 3232 3034 3832 2c20 2030  [ 0.30220482,  0
-0000cf90: 2e38 3638 3230 3430 312c 2020 302e 3136  .86820401,  0.16
-0000cfa0: 3534 3530 3320 2c20 2030 2e31 3136 3539  54503 ,  0.11659
-0000cfb0: 3134 392c 2020 302e 3534 3332 3334 3238  149,  0.54323428
-0000cfc0: 5d29 2023 2072 616e 646f 6d0a 0a20 2054  ]) # random..  T
-0000cfd0: 6872 6565 2d62 792d 7477 6f20 6172 7261  hree-by-two arra
-0000cfe0: 7920 6f66 2072 616e 646f 6d20 6e75 6d62  y of random numb
-0000cff0: 6572 7320 6672 6f6d 205b 2d35 2c20 3029  ers from [-5, 0)
-0000d000: 3a0a 0a20 203e 3e3e 2035 202a 2062 7261  :..  >>> 5 * bra
-0000d010: 696e 7079 2e6d 6174 682e 7261 6e64 6f6d  inpy.math.random
-0000d020: 2e72 616e 646f 6d5f 7361 6d70 6c65 2828  .random_sample((
-0000d030: 332c 2032 2929 202d 2035 0a20 2061 7272  3, 2)) - 5.  arr
-0000d040: 6179 285b 5b2d 332e 3939 3134 3939 3839  ay([[-3.99149989
-0000d050: 2c20 2d30 2e35 3233 3338 3938 345d 2c20  , -0.52338984], 
-0000d060: 2320 7261 6e64 6f6d 0a20 2020 2020 2020  # random.       
-0000d070: 2020 5b2d 322e 3939 3039 3138 3538 2c20    [-2.99091858, 
-0000d080: 2d30 2e37 3934 3739 3530 385d 2c0a 2020  -0.79479508],.  
-0000d090: 2020 2020 2020 205b 2d31 2e32 3332 3034         [-1.23204
-0000d0a0: 3334 352c 202d 312e 3735 3232 3434 3934  345, -1.75224494
-0000d0b0: 5d5d 290a 2020 2222 220a 2020 7265 7475  ]]).  """.  retu
-0000d0c0: 726e 2044 4546 4155 4c54 2e72 616e 646f  rn DEFAULT.rando
-0000d0d0: 6d5f 7361 6d70 6c65 2873 697a 652c 206b  m_sample(size, k
-0000d0e0: 6579 3d6b 6579 290a 0a0a 6465 6620 7261  ey=key)...def ra
-0000d0f0: 6e66 2873 697a 653d 4e6f 6e65 2c20 6b65  nf(size=None, ke
-0000d100: 793d 4e6f 6e65 293a 0a20 2022 2222 0a20  y=None):.  """. 
-0000d110: 2054 6869 7320 6973 2061 6e20 616c 6961   This is an alia
-0000d120: 7320 6f66 2060 7261 6e64 6f6d 5f73 616d  s of `random_sam
-0000d130: 706c 6560 2e20 5365 6520 6072 616e 646f  ple`. See `rando
-0000d140: 6d5f 7361 6d70 6c65 6020 2066 6f72 2074  m_sample`  for t
-0000d150: 6865 2063 6f6d 706c 6574 650a 2020 2020  he complete.    
-0000d160: 2020 646f 6375 6d65 6e74 6174 696f 6e2e    documentation.
-0000d170: 0a20 2022 2222 0a20 2072 6574 7572 6e20  .  """.  return 
-0000d180: 4445 4641 554c 542e 7261 6e66 2873 697a  DEFAULT.ranf(siz
-0000d190: 652c 206b 6579 3d6b 6579 290a 0a0a 6465  e, key=key)...de
-0000d1a0: 6620 7361 6d70 6c65 2873 697a 653d 4e6f  f sample(size=No
-0000d1b0: 6e65 2c20 6b65 793d 4e6f 6e65 293a 0a20  ne, key=None):. 
-0000d1c0: 2022 2222 0a20 2054 6869 7320 6973 2061   """.  This is a
-0000d1d0: 6e20 616c 6961 7320 6f66 2060 7261 6e64  n alias of `rand
-0000d1e0: 6f6d 5f73 616d 706c 6560 2e20 5365 6520  om_sample`. See 
-0000d1f0: 6072 616e 646f 6d5f 7361 6d70 6c65 6020  `random_sample` 
-0000d200: 2066 6f72 2074 6865 2063 6f6d 706c 6574   for the complet
-0000d210: 650a 2020 2020 2020 646f 6375 6d65 6e74  e.      document
-0000d220: 6174 696f 6e2e 0a20 2022 2222 0a20 2072  ation..  """.  r
-0000d230: 6574 7572 6e20 4445 4641 554c 542e 7361  eturn DEFAULT.sa
-0000d240: 6d70 6c65 2873 697a 652c 206b 6579 3d6b  mple(size, key=k
-0000d250: 6579 290a 0a0a 6465 6620 6368 6f69 6365  ey)...def choice
-0000d260: 2861 2c20 7369 7a65 3d4e 6f6e 652c 2072  (a, size=None, r
-0000d270: 6570 6c61 6365 3d54 7275 652c 2070 3d4e  eplace=True, p=N
-0000d280: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
-0000d290: 2020 7222 2222 0a20 2047 656e 6572 6174    r""".  Generat
-0000d2a0: 6573 2061 2072 616e 646f 6d20 7361 6d70  es a random samp
-0000d2b0: 6c65 2066 726f 6d20 6120 6769 7665 6e20  le from a given 
-0000d2c0: 312d 4420 6172 7261 790a 0a20 2050 6172  1-D array..  Par
-0000d2d0: 616d 6574 6572 730a 2020 2d2d 2d2d 2d2d  ameters.  ------
-0000d2e0: 2d2d 2d2d 0a20 2061 203a 2031 2d44 2061  ----.  a : 1-D a
-0000d2f0: 7272 6179 2d6c 696b 6520 6f72 2069 6e74  rray-like or int
-0000d300: 0a20 2020 2020 2049 6620 616e 206e 6461  .      If an nda
-0000d310: 7272 6179 2c20 6120 7261 6e64 6f6d 2073  rray, a random s
-0000d320: 616d 706c 6520 6973 2067 656e 6572 6174  ample is generat
-0000d330: 6564 2066 726f 6d20 6974 7320 656c 656d  ed from its elem
-0000d340: 656e 7473 2e0a 2020 2020 2020 4966 2061  ents..      If a
-0000d350: 6e20 696e 742c 2074 6865 2072 616e 646f  n int, the rando
-0000d360: 6d20 7361 6d70 6c65 2069 7320 6765 6e65  m sample is gene
-0000d370: 7261 7465 6420 6173 2069 6620 6974 2077  rated as if it w
-0000d380: 6572 6520 6060 6e70 2e61 7261 6e67 6528  ere ``np.arange(
-0000d390: 6129 6060 0a20 2073 697a 6520 3a20 696e  a)``.  size : in
-0000d3a0: 7420 6f72 2074 7570 6c65 206f 6620 696e  t or tuple of in
-0000d3b0: 7473 2c20 6f70 7469 6f6e 616c 0a20 2020  ts, optional.   
-0000d3c0: 2020 204f 7574 7075 7420 7368 6170 652e     Output shape.
-0000d3d0: 2020 4966 2074 6865 2067 6976 656e 2073    If the given s
-0000d3e0: 6861 7065 2069 732c 2065 2e67 2e2c 2060  hape is, e.g., `
-0000d3f0: 6028 6d2c 206e 2c20 6b29 6060 2c20 7468  `(m, n, k)``, th
-0000d400: 656e 0a20 2020 2020 2060 606d 202a 206e  en.      ``m * n
-0000d410: 202a 206b 6060 2073 616d 706c 6573 2061   * k`` samples a
-0000d420: 7265 2064 7261 776e 2e20 2044 6566 6175  re drawn.  Defau
-0000d430: 6c74 2069 7320 4e6f 6e65 2c20 696e 2077  lt is None, in w
-0000d440: 6869 6368 2063 6173 6520 610a 2020 2020  hich case a.    
-0000d450: 2020 7369 6e67 6c65 2076 616c 7565 2069    single value i
-0000d460: 7320 7265 7475 726e 6564 2e0a 2020 7265  s returned..  re
-0000d470: 706c 6163 6520 3a20 626f 6f6c 6561 6e2c  place : boolean,
-0000d480: 206f 7074 696f 6e61 6c0a 2020 2020 2020   optional.      
-0000d490: 5768 6574 6865 7220 7468 6520 7361 6d70  Whether the samp
-0000d4a0: 6c65 2069 7320 7769 7468 206f 7220 7769  le is with or wi
-0000d4b0: 7468 6f75 7420 7265 706c 6163 656d 656e  thout replacemen
-0000d4c0: 742e 2044 6566 6175 6c74 2069 7320 5472  t. Default is Tr
-0000d4d0: 7565 2c0a 2020 2020 2020 6d65 616e 696e  ue,.      meanin
-0000d4e0: 6720 7468 6174 2061 2076 616c 7565 206f  g that a value o
-0000d4f0: 6620 6060 6160 6020 6361 6e20 6265 2073  f ``a`` can be s
-0000d500: 656c 6563 7465 6420 6d75 6c74 6970 6c65  elected multiple
-0000d510: 2074 696d 6573 2e0a 2020 7020 3a20 312d   times..  p : 1-
-0000d520: 4420 6172 7261 792d 6c69 6b65 2c20 6f70  D array-like, op
-0000d530: 7469 6f6e 616c 0a20 2020 2020 2054 6865  tional.      The
-0000d540: 2070 726f 6261 6269 6c69 7469 6573 2061   probabilities a
-0000d550: 7373 6f63 6961 7465 6420 7769 7468 2065  ssociated with e
-0000d560: 6163 6820 656e 7472 7920 696e 2061 2e0a  ach entry in a..
-0000d570: 2020 2020 2020 4966 206e 6f74 2067 6976        If not giv
-0000d580: 656e 2c20 7468 6520 7361 6d70 6c65 2061  en, the sample a
-0000d590: 7373 756d 6573 2061 2075 6e69 666f 726d  ssumes a uniform
-0000d5a0: 2064 6973 7472 6962 7574 696f 6e20 6f76   distribution ov
-0000d5b0: 6572 2061 6c6c 0a20 2020 2020 2065 6e74  er all.      ent
-0000d5c0: 7269 6573 2069 6e20 6060 6160 602e 0a0a  ries in ``a``...
-0000d5d0: 2020 5265 7475 726e 730a 2020 2d2d 2d2d    Returns.  ----
-0000d5e0: 2d2d 2d0a 2020 7361 6d70 6c65 7320 3a20  ---.  samples : 
-0000d5f0: 7369 6e67 6c65 2069 7465 6d20 6f72 206e  single item or n
-0000d600: 6461 7272 6179 0a20 2020 2020 2054 6865  darray.      The
-0000d610: 2067 656e 6572 6174 6564 2072 616e 646f   generated rando
-0000d620: 6d20 7361 6d70 6c65 730a 0a20 2052 6169  m samples..  Rai
-0000d630: 7365 730a 2020 2d2d 2d2d 2d2d 0a20 2056  ses.  ------.  V
-0000d640: 616c 7565 4572 726f 720a 2020 2020 2020  alueError.      
-0000d650: 4966 2061 2069 7320 616e 2069 6e74 2061  If a is an int a
-0000d660: 6e64 206c 6573 7320 7468 616e 207a 6572  nd less than zer
-0000d670: 6f2c 2069 6620 6120 6f72 2070 2061 7265  o, if a or p are
-0000d680: 206e 6f74 2031 2d64 696d 656e 7369 6f6e   not 1-dimension
-0000d690: 616c 2c0a 2020 2020 2020 6966 2061 2069  al,.      if a i
-0000d6a0: 7320 616e 2061 7272 6179 2d6c 696b 6520  s an array-like 
-0000d6b0: 6f66 2073 697a 6520 302c 2069 6620 7020  of size 0, if p 
-0000d6c0: 6973 206e 6f74 2061 2076 6563 746f 7220  is not a vector 
-0000d6d0: 6f66 0a20 2020 2020 2070 726f 6261 6269  of.      probabi
-0000d6e0: 6c69 7469 6573 2c20 6966 2061 2061 6e64  lities, if a and
-0000d6f0: 2070 2068 6176 6520 6469 6666 6572 656e   p have differen
-0000d700: 7420 6c65 6e67 7468 732c 206f 7220 6966  t lengths, or if
-0000d710: 0a20 2020 2020 2072 6570 6c61 6365 3d46  .      replace=F
-0000d720: 616c 7365 2061 6e64 2074 6865 2073 616d  alse and the sam
-0000d730: 706c 6520 7369 7a65 2069 7320 6772 6561  ple size is grea
-0000d740: 7465 7220 7468 616e 2074 6865 2070 6f70  ter than the pop
-0000d750: 756c 6174 696f 6e0a 2020 2020 2020 7369  ulation.      si
-0000d760: 7a65 0a0a 2020 5365 6520 416c 736f 0a20  ze..  See Also. 
-0000d770: 202d 2d2d 2d2d 2d2d 2d0a 2020 7261 6e64   --------.  rand
-0000d780: 696e 742c 2073 6875 6666 6c65 2c20 7065  int, shuffle, pe
-0000d790: 726d 7574 6174 696f 6e0a 2020 4765 6e65  rmutation.  Gene
-0000d7a0: 7261 746f 722e 6368 6f69 6365 3a20 7768  rator.choice: wh
-0000d7b0: 6963 6820 7368 6f75 6c64 2062 6520 7573  ich should be us
-0000d7c0: 6564 2069 6e20 6e65 7720 636f 6465 0a0a  ed in new code..
-0000d7d0: 2020 4e6f 7465 730a 2020 2d2d 2d2d 2d0a    Notes.  -----.
-0000d7e0: 2020 5365 7474 696e 6720 7573 6572 2d73    Setting user-s
-0000d7f0: 7065 6369 6669 6564 2070 726f 6261 6269  pecified probabi
-0000d800: 6c69 7469 6573 2074 6872 6f75 6768 2060  lities through `
-0000d810: 6070 6060 2075 7365 7320 6120 6d6f 7265  `p`` uses a more
-0000d820: 2067 656e 6572 616c 2062 7574 206c 6573   general but les
-0000d830: 730a 2020 6566 6669 6369 656e 7420 7361  s.  efficient sa
-0000d840: 6d70 6c65 7220 7468 616e 2074 6865 2064  mpler than the d
-0000d850: 6566 6175 6c74 2e20 5468 6520 6765 6e65  efault. The gene
-0000d860: 7261 6c20 7361 6d70 6c65 7220 7072 6f64  ral sampler prod
-0000d870: 7563 6573 2061 2064 6966 6665 7265 6e74  uces a different
-0000d880: 2073 616d 706c 650a 2020 7468 616e 2074   sample.  than t
-0000d890: 6865 206f 7074 696d 697a 6564 2073 616d  he optimized sam
-0000d8a0: 706c 6572 2065 7665 6e20 6966 2065 6163  pler even if eac
-0000d8b0: 6820 656c 656d 656e 7420 6f66 2060 6070  h element of ``p
-0000d8c0: 6060 2069 7320 3120 2f20 6c65 6e28 6129  `` is 1 / len(a)
-0000d8d0: 2e0a 0a20 2053 616d 706c 696e 6720 7261  ...  Sampling ra
-0000d8e0: 6e64 6f6d 2072 6f77 7320 6672 6f6d 2061  ndom rows from a
-0000d8f0: 2032 2d44 2061 7272 6179 2069 7320 6e6f   2-D array is no
-0000d900: 7420 706f 7373 6962 6c65 2077 6974 6820  t possible with 
-0000d910: 7468 6973 2066 756e 6374 696f 6e2c 0a20  this function,. 
-0000d920: 2062 7574 2069 7320 706f 7373 6962 6c65   but is possible
-0000d930: 2077 6974 6820 6047 656e 6572 6174 6f72   with `Generator
-0000d940: 2e63 686f 6963 6560 2074 6872 6f75 6768  .choice` through
-0000d950: 2069 7473 2060 6061 7869 7360 6020 6b65   its ``axis`` ke
-0000d960: 7977 6f72 642e 0a0a 2020 4578 616d 706c  yword...  Exampl
-0000d970: 6573 0a20 202d 2d2d 2d2d 2d2d 2d0a 2020  es.  --------.  
-0000d980: 4765 6e65 7261 7465 2061 2075 6e69 666f  Generate a unifo
-0000d990: 726d 2072 616e 646f 6d20 7361 6d70 6c65  rm random sample
-0000d9a0: 2066 726f 6d20 6e70 2e61 7261 6e67 6528   from np.arange(
-0000d9b0: 3529 206f 6620 7369 7a65 2033 3a0a 0a20  5) of size 3:.. 
-0000d9c0: 203e 3e3e 2062 7261 696e 7079 2e6d 6174   >>> brainpy.mat
-0000d9d0: 682e 7261 6e64 6f6d 2e63 686f 6963 6528  h.random.choice(
-0000d9e0: 352c 2033 290a 2020 6172 7261 7928 5b30  5, 3).  array([0
-0000d9f0: 2c20 332c 2034 5d29 2023 2072 616e 646f  , 3, 4]) # rando
-0000da00: 6d0a 2020 3e3e 3e20 2354 6869 7320 6973  m.  >>> #This is
-0000da10: 2065 7175 6976 616c 656e 7420 746f 2062   equivalent to b
-0000da20: 7261 696e 7079 2e6d 6174 682e 7261 6e64  rainpy.math.rand
-0000da30: 6f6d 2e72 616e 6469 6e74 2830 2c35 2c33  om.randint(0,5,3
-0000da40: 290a 0a20 2047 656e 6572 6174 6520 6120  )..  Generate a 
-0000da50: 6e6f 6e2d 756e 6966 6f72 6d20 7261 6e64  non-uniform rand
-0000da60: 6f6d 2073 616d 706c 6520 6672 6f6d 206e  om sample from n
-0000da70: 702e 6172 616e 6765 2835 2920 6f66 2073  p.arange(5) of s
-0000da80: 697a 6520 333a 0a0a 2020 3e3e 3e20 6272  ize 3:..  >>> br
-0000da90: 6169 6e70 792e 6d61 7468 2e72 616e 646f  ainpy.math.rando
-0000daa0: 6d2e 6368 6f69 6365 2835 2c20 332c 2070  m.choice(5, 3, p
-0000dab0: 3d5b 302e 312c 2030 2c20 302e 332c 2030  =[0.1, 0, 0.3, 0
-0000dac0: 2e36 2c20 305d 290a 2020 6172 7261 7928  .6, 0]).  array(
-0000dad0: 5b33 2c20 332c 2030 5d29 2023 2072 616e  [3, 3, 0]) # ran
-0000dae0: 646f 6d0a 0a20 2047 656e 6572 6174 6520  dom..  Generate 
-0000daf0: 6120 756e 6966 6f72 6d20 7261 6e64 6f6d  a uniform random
-0000db00: 2073 616d 706c 6520 6672 6f6d 206e 702e   sample from np.
-0000db10: 6172 616e 6765 2835 2920 6f66 2073 697a  arange(5) of siz
-0000db20: 6520 3320 7769 7468 6f75 740a 2020 7265  e 3 without.  re
-0000db30: 706c 6163 656d 656e 743a 0a0a 2020 3e3e  placement:..  >>
-0000db40: 3e20 6272 6169 6e70 792e 6d61 7468 2e72  > brainpy.math.r
-0000db50: 616e 646f 6d2e 6368 6f69 6365 2835 2c20  andom.choice(5, 
-0000db60: 332c 2072 6570 6c61 6365 3d46 616c 7365  3, replace=False
-0000db70: 290a 2020 6172 7261 7928 5b33 2c31 2c30  ).  array([3,1,0
-0000db80: 5d29 2023 2072 616e 646f 6d0a 2020 3e3e  ]) # random.  >>
-0000db90: 3e20 2354 6869 7320 6973 2065 7175 6976  > #This is equiv
-0000dba0: 616c 656e 7420 746f 2062 7261 696e 7079  alent to brainpy
-0000dbb0: 2e6d 6174 682e 7261 6e64 6f6d 2e70 6572  .math.random.per
-0000dbc0: 6d75 7461 7469 6f6e 286e 702e 6172 616e  mutation(np.aran
-0000dbd0: 6765 2835 2929 5b3a 335d 0a0a 2020 4765  ge(5))[:3]..  Ge
-0000dbe0: 6e65 7261 7465 2061 206e 6f6e 2d75 6e69  nerate a non-uni
-0000dbf0: 666f 726d 2072 616e 646f 6d20 7361 6d70  form random samp
-0000dc00: 6c65 2066 726f 6d20 6e70 2e61 7261 6e67  le from np.arang
-0000dc10: 6528 3529 206f 6620 7369 7a65 0a20 2033  e(5) of size.  3
-0000dc20: 2077 6974 686f 7574 2072 6570 6c61 6365   without replace
-0000dc30: 6d65 6e74 3a0a 0a20 203e 3e3e 2062 7261  ment:..  >>> bra
-0000dc40: 696e 7079 2e6d 6174 682e 7261 6e64 6f6d  inpy.math.random
-0000dc50: 2e63 686f 6963 6528 352c 2033 2c20 7265  .choice(5, 3, re
-0000dc60: 706c 6163 653d 4661 6c73 652c 2070 3d5b  place=False, p=[
-0000dc70: 302e 312c 2030 2c20 302e 332c 2030 2e36  0.1, 0, 0.3, 0.6
-0000dc80: 2c20 305d 290a 2020 6172 7261 7928 5b32  , 0]).  array([2
-0000dc90: 2c20 332c 2030 5d29 2023 2072 616e 646f  , 3, 0]) # rando
-0000dca0: 6d0a 0a20 2041 6e79 206f 6620 7468 6520  m..  Any of the 
-0000dcb0: 6162 6f76 6520 6361 6e20 6265 2072 6570  above can be rep
-0000dcc0: 6561 7465 6420 7769 7468 2061 6e20 6172  eated with an ar
-0000dcd0: 6269 7472 6172 7920 6172 7261 792d 6c69  bitrary array-li
-0000dce0: 6b65 0a20 2069 6e73 7465 6164 206f 6620  ke.  instead of 
-0000dcf0: 6a75 7374 2069 6e74 6567 6572 732e 2046  just integers. F
-0000dd00: 6f72 2069 6e73 7461 6e63 653a 0a0a 2020  or instance:..  
-0000dd10: 3e3e 3e20 6161 5f6d 696c 6e65 5f61 7272  >>> aa_milne_arr
-0000dd20: 203d 205b 2770 6f6f 6827 2c20 2772 6162   = ['pooh', 'rab
-0000dd30: 6269 7427 2c20 2770 6967 6c65 7427 2c20  bit', 'piglet', 
-0000dd40: 2743 6872 6973 746f 7068 6572 275d 0a20  'Christopher']. 
-0000dd50: 203e 3e3e 2062 7261 696e 7079 2e6d 6174   >>> brainpy.mat
-0000dd60: 682e 7261 6e64 6f6d 2e63 686f 6963 6528  h.random.choice(
-0000dd70: 6161 5f6d 696c 6e65 5f61 7272 2c20 352c  aa_milne_arr, 5,
-0000dd80: 2070 3d5b 302e 352c 2030 2e31 2c20 302e   p=[0.5, 0.1, 0.
-0000dd90: 312c 2030 2e33 5d29 0a20 2061 7272 6179  1, 0.3]).  array
-0000dda0: 285b 2770 6f6f 6827 2c20 2770 6f6f 6827  (['pooh', 'pooh'
-0000ddb0: 2c20 2770 6f6f 6827 2c20 2743 6872 6973  , 'pooh', 'Chris
-0000ddc0: 746f 7068 6572 272c 2027 7069 676c 6574  topher', 'piglet
-0000ddd0: 275d 2c20 2320 7261 6e64 6f6d 0a20 2020  '], # random.   
-0000dde0: 2020 2020 2064 7479 7065 3d27 3c55 3131       dtype='<U11
-0000ddf0: 2729 0a20 2022 2222 0a20 2061 203d 205f  ').  """.  a = _
-0000de00: 6173 5f6a 6178 5f61 7272 6179 2861 290a  as_jax_array(a).
-0000de10: 2020 7265 7475 726e 2044 4546 4155 4c54    return DEFAULT
-0000de20: 2e63 686f 6963 6528 613d 612c 2073 697a  .choice(a=a, siz
-0000de30: 653d 7369 7a65 2c20 7265 706c 6163 653d  e=size, replace=
-0000de40: 7265 706c 6163 652c 2070 3d70 2c20 6b65  replace, p=p, ke
-0000de50: 793d 6b65 7929 0a0a 0a64 6566 2070 6572  y=key)...def per
-0000de60: 6d75 7461 7469 6f6e 2878 2c20 6178 6973  mutation(x, axis
-0000de70: 3a20 696e 7420 3d20 302c 2069 6e64 6570  : int = 0, indep
-0000de80: 656e 6465 6e74 3a20 626f 6f6c 203d 2046  endent: bool = F
-0000de90: 616c 7365 2c20 6b65 793d 4e6f 6e65 293a  alse, key=None):
-0000dea0: 0a20 2072 2222 220a 2020 5261 6e64 6f6d  .  r""".  Random
-0000deb0: 6c79 2070 6572 6d75 7465 2061 2073 6571  ly permute a seq
-0000dec0: 7565 6e63 652c 206f 7220 7265 7475 726e  uence, or return
-0000ded0: 2061 2070 6572 6d75 7465 6420 7261 6e67   a permuted rang
-0000dee0: 652e 0a0a 2020 4966 2060 7860 2069 7320  e...  If `x` is 
-0000def0: 6120 6d75 6c74 692d 6469 6d65 6e73 696f  a multi-dimensio
-0000df00: 6e61 6c20 6172 7261 792c 2069 7420 6973  nal array, it is
-0000df10: 206f 6e6c 7920 7368 7566 666c 6564 2061   only shuffled a
-0000df20: 6c6f 6e67 2069 7473 0a20 2066 6972 7374  long its.  first
-0000df30: 2069 6e64 6578 2e0a 0a20 2050 6172 616d   index...  Param
-0000df40: 6574 6572 730a 2020 2d2d 2d2d 2d2d 2d2d  eters.  --------
-0000df50: 2d2d 0a20 2078 203a 2069 6e74 206f 7220  --.  x : int or 
-0000df60: 6172 7261 795f 6c69 6b65 0a20 2020 2020  array_like.     
-0000df70: 2049 6620 6078 6020 6973 2061 6e20 696e   If `x` is an in
-0000df80: 7465 6765 722c 2072 616e 646f 6d6c 7920  teger, randomly 
-0000df90: 7065 726d 7574 6520 6060 6e70 2e61 7261  permute ``np.ara
-0000dfa0: 6e67 6528 7829 6060 2e0a 2020 2020 2020  nge(x)``..      
-0000dfb0: 4966 2060 7860 2069 7320 616e 2061 7272  If `x` is an arr
-0000dfc0: 6179 2c20 6d61 6b65 2061 2063 6f70 7920  ay, make a copy 
-0000dfd0: 616e 6420 7368 7566 666c 6520 7468 6520  and shuffle the 
-0000dfe0: 656c 656d 656e 7473 0a20 2020 2020 2072  elements.      r
-0000dff0: 616e 646f 6d6c 792e 0a0a 2020 5265 7475  andomly...  Retu
-0000e000: 726e 730a 2020 2d2d 2d2d 2d2d 2d0a 2020  rns.  -------.  
-0000e010: 6f75 7420 3a20 6e64 6172 7261 790a 2020  out : ndarray.  
-0000e020: 2020 2020 5065 726d 7574 6564 2073 6571      Permuted seq
-0000e030: 7565 6e63 6520 6f72 2061 7272 6179 2072  uence or array r
-0000e040: 616e 6765 2e0a 0a20 2053 6565 2041 6c73  ange...  See Als
-0000e050: 6f0a 2020 2d2d 2d2d 2d2d 2d2d 0a20 2072  o.  --------.  r
-0000e060: 616e 646f 6d2e 4765 6e65 7261 746f 722e  andom.Generator.
-0000e070: 7065 726d 7574 6174 696f 6e3a 2077 6869  permutation: whi
-0000e080: 6368 2073 686f 756c 6420 6265 2075 7365  ch should be use
-0000e090: 6420 666f 7220 6e65 7720 636f 6465 2e0a  d for new code..
-0000e0a0: 0a20 2045 7861 6d70 6c65 730a 2020 2d2d  .  Examples.  --
-0000e0b0: 2d2d 2d2d 2d2d 0a20 203e 3e3e 2062 7261  ------.  >>> bra
-0000e0c0: 696e 7079 2e6d 6174 682e 7261 6e64 6f6d  inpy.math.random
-0000e0d0: 2e70 6572 6d75 7461 7469 6f6e 2831 3029  .permutation(10)
-0000e0e0: 0a20 2061 7272 6179 285b 312c 2037 2c20  .  array([1, 7, 
-0000e0f0: 342c 2033 2c20 302c 2039 2c20 322c 2035  4, 3, 0, 9, 2, 5
-0000e100: 2c20 382c 2036 5d29 2023 2072 616e 646f  , 8, 6]) # rando
-0000e110: 6d0a 0a20 203e 3e3e 2062 7261 696e 7079  m..  >>> brainpy
-0000e120: 2e6d 6174 682e 7261 6e64 6f6d 2e70 6572  .math.random.per
-0000e130: 6d75 7461 7469 6f6e 285b 312c 2034 2c20  mutation([1, 4, 
-0000e140: 392c 2031 322c 2031 355d 290a 2020 6172  9, 12, 15]).  ar
-0000e150: 7261 7928 5b31 352c 2020 312c 2020 392c  ray([15,  1,  9,
-0000e160: 2020 342c 2031 325d 2920 2320 7261 6e64    4, 12]) # rand
-0000e170: 6f6d 0a0a 2020 3e3e 3e20 6172 7220 3d20  om..  >>> arr = 
-0000e180: 6e70 2e61 7261 6e67 6528 3929 2e72 6573  np.arange(9).res
-0000e190: 6861 7065 2828 332c 2033 2929 0a20 203e  hape((3, 3)).  >
-0000e1a0: 3e3e 2062 7261 696e 7079 2e6d 6174 682e  >> brainpy.math.
-0000e1b0: 7261 6e64 6f6d 2e70 6572 6d75 7461 7469  random.permutati
-0000e1c0: 6f6e 2861 7272 290a 2020 6172 7261 7928  on(arr).  array(
-0000e1d0: 5b5b 362c 2037 2c20 385d 2c20 2320 7261  [[6, 7, 8], # ra
-0000e1e0: 6e64 6f6d 0a20 2020 2020 2020 2020 5b30  ndom.         [0
-0000e1f0: 2c20 312c 2032 5d2c 0a20 2020 2020 2020  , 1, 2],.       
-0000e200: 2020 5b33 2c20 342c 2035 5d5d 290a 2020    [3, 4, 5]]).  
-0000e210: 2222 220a 2020 7265 7475 726e 2044 4546  """.  return DEF
-0000e220: 4155 4c54 2e70 6572 6d75 7461 7469 6f6e  AULT.permutation
-0000e230: 2878 2c20 6178 6973 3d61 7869 732c 2069  (x, axis=axis, i
-0000e240: 6e64 6570 656e 6465 6e74 3d69 6e64 6570  ndependent=indep
-0000e250: 656e 6465 6e74 2c20 6b65 793d 6b65 7929  endent, key=key)
-0000e260: 0a0a 0a64 6566 2073 6875 6666 6c65 2878  ...def shuffle(x
-0000e270: 2c20 6178 6973 3d30 2c20 6b65 793d 4e6f  , axis=0, key=No
-0000e280: 6e65 293a 0a20 2072 2222 220a 2020 4d6f  ne):.  r""".  Mo
-0000e290: 6469 6679 2061 2073 6571 7565 6e63 6520  dify a sequence 
-0000e2a0: 696e 2d70 6c61 6365 2062 7920 7368 7566  in-place by shuf
-0000e2b0: 666c 696e 6720 6974 7320 636f 6e74 656e  fling its conten
-0000e2c0: 7473 2e0a 0a20 2054 6869 7320 6675 6e63  ts...  This func
-0000e2d0: 7469 6f6e 206f 6e6c 7920 7368 7566 666c  tion only shuffl
-0000e2e0: 6573 2074 6865 2061 7272 6179 2061 6c6f  es the array alo
-0000e2f0: 6e67 2074 6865 2066 6972 7374 2061 7869  ng the first axi
-0000e300: 7320 6f66 2061 0a20 206d 756c 7469 2d64  s of a.  multi-d
-0000e310: 696d 656e 7369 6f6e 616c 2061 7272 6179  imensional array
-0000e320: 2e20 5468 6520 6f72 6465 7220 6f66 2073  . The order of s
-0000e330: 7562 2d61 7272 6179 7320 6973 2063 6861  ub-arrays is cha
-0000e340: 6e67 6564 2062 7574 0a20 2074 6865 6972  nged but.  their
-0000e350: 2063 6f6e 7465 6e74 7320 7265 6d61 696e   contents remain
-0000e360: 7320 7468 6520 7361 6d65 2e0a 0a20 2050  s the same...  P
-0000e370: 6172 616d 6574 6572 730a 2020 2d2d 2d2d  arameters.  ----
-0000e380: 2d2d 2d2d 2d2d 0a20 2078 203a 206e 6461  ------.  x : nda
-0000e390: 7272 6179 206f 7220 4d75 7461 626c 6553  rray or MutableS
-0000e3a0: 6571 7565 6e63 650a 2020 2020 2020 5468  equence.      Th
-0000e3b0: 6520 6172 7261 792c 206c 6973 7420 6f72  e array, list or
-0000e3c0: 206d 7574 6162 6c65 2073 6571 7565 6e63   mutable sequenc
-0000e3d0: 6520 746f 2062 6520 7368 7566 666c 6564  e to be shuffled
-0000e3e0: 2e0a 0a20 2052 6574 7572 6e73 0a20 202d  ...  Returns.  -
-0000e3f0: 2d2d 2d2d 2d2d 0a20 204e 6f6e 650a 0a20  ------.  None.. 
-0000e400: 2053 6565 2041 6c73 6f0a 2020 2d2d 2d2d   See Also.  ----
-0000e410: 2d2d 2d2d 0a20 2072 616e 646f 6d2e 4765  ----.  random.Ge
-0000e420: 6e65 7261 746f 722e 7368 7566 666c 653a  nerator.shuffle:
-0000e430: 2077 6869 6368 2073 686f 756c 6420 6265   which should be
-0000e440: 2075 7365 6420 666f 7220 6e65 7720 636f   used for new co
-0000e450: 6465 2e0a 0a20 2045 7861 6d70 6c65 730a  de...  Examples.
-0000e460: 2020 2d2d 2d2d 2d2d 2d2d 0a20 203e 3e3e    --------.  >>>
-0000e470: 2061 7272 203d 206e 702e 6172 616e 6765   arr = np.arange
-0000e480: 2831 3029 0a20 203e 3e3e 2062 7261 696e  (10).  >>> brain
-0000e490: 7079 2e6d 6174 682e 7261 6e64 6f6d 2e73  py.math.random.s
-0000e4a0: 6875 6666 6c65 2861 7272 290a 2020 3e3e  huffle(arr).  >>
-0000e4b0: 3e20 6172 720a 2020 5b31 2037 2035 2032  > arr.  [1 7 5 2
-0000e4c0: 2039 2034 2033 2036 2030 2038 5d20 2320   9 4 3 6 0 8] # 
-0000e4d0: 7261 6e64 6f6d 0a0a 2020 4d75 6c74 692d  random..  Multi-
-0000e4e0: 6469 6d65 6e73 696f 6e61 6c20 6172 7261  dimensional arra
-0000e4f0: 7973 2061 7265 206f 6e6c 7920 7368 7566  ys are only shuf
-0000e500: 666c 6564 2061 6c6f 6e67 2074 6865 2066  fled along the f
-0000e510: 6972 7374 2061 7869 733a 0a0a 2020 3e3e  irst axis:..  >>
-0000e520: 3e20 6172 7220 3d20 6e70 2e61 7261 6e67  > arr = np.arang
-0000e530: 6528 3929 2e72 6573 6861 7065 2828 332c  e(9).reshape((3,
-0000e540: 2033 2929 0a20 203e 3e3e 2062 7261 696e   3)).  >>> brain
-0000e550: 7079 2e6d 6174 682e 7261 6e64 6f6d 2e73  py.math.random.s
-0000e560: 6875 6666 6c65 2861 7272 290a 2020 3e3e  huffle(arr).  >>
-0000e570: 3e20 6172 720a 2020 6172 7261 7928 5b5b  > arr.  array([[
-0000e580: 332c 2034 2c20 355d 2c20 2320 7261 6e64  3, 4, 5], # rand
-0000e590: 6f6d 0a20 2020 2020 2020 2020 5b36 2c20  om.         [6, 
-0000e5a0: 372c 2038 5d2c 0a20 2020 2020 2020 2020  7, 8],.         
-0000e5b0: 5b30 2c20 312c 2032 5d5d 290a 2020 2222  [0, 1, 2]]).  ""
-0000e5c0: 220a 2020 4445 4641 554c 542e 7368 7566  ".  DEFAULT.shuf
-0000e5d0: 666c 6528 782c 2061 7869 732c 206b 6579  fle(x, axis, key
-0000e5e0: 3d6b 6579 290a 0a0a 6465 6620 6265 7461  =key)...def beta
-0000e5f0: 2861 2c20 622c 2073 697a 653d 4e6f 6e65  (a, b, size=None
-0000e600: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2072  , key=None):.  r
-0000e610: 2222 220a 2020 4472 6177 2073 616d 706c  """.  Draw sampl
-0000e620: 6573 2066 726f 6d20 6120 4265 7461 2064  es from a Beta d
-0000e630: 6973 7472 6962 7574 696f 6e2e 0a0a 2020  istribution...  
-0000e640: 5468 6520 4265 7461 2064 6973 7472 6962  The Beta distrib
-0000e650: 7574 696f 6e20 6973 2061 2073 7065 6369  ution is a speci
-0000e660: 616c 2063 6173 6520 6f66 2074 6865 2044  al case of the D
-0000e670: 6972 6963 686c 6574 2064 6973 7472 6962  irichlet distrib
-0000e680: 7574 696f 6e2c 0a20 2061 6e64 2069 7320  ution,.  and is 
-0000e690: 7265 6c61 7465 6420 746f 2074 6865 2047  related to the G
-0000e6a0: 616d 6d61 2064 6973 7472 6962 7574 696f  amma distributio
-0000e6b0: 6e2e 2020 4974 2068 6173 2074 6865 2070  n.  It has the p
-0000e6c0: 726f 6261 6269 6c69 7479 0a20 2064 6973  robability.  dis
-0000e6d0: 7472 6962 7574 696f 6e20 6675 6e63 7469  tribution functi
-0000e6e0: 6f6e 0a0a 2020 2e2e 206d 6174 683a 3a20  on..  .. math:: 
-0000e6f0: 6628 783b 2061 2c62 2920 3d20 5c66 7261  f(x; a,b) = \fra
-0000e700: 637b 317d 7b42 285c 616c 7068 612c 205c  c{1}{B(\alpha, \
-0000e710: 6265 7461 297d 2078 5e7b 5c61 6c70 6861  beta)} x^{\alpha
-0000e720: 202d 2031 7d0a 2020 2020 2020 2020 2020   - 1}.          
-0000e730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e750: 2020 2020 2020 2020 2028 3120 2d20 7829           (1 - x)
-0000e760: 5e7b 5c62 6574 6120 2d20 317d 2c0a 0a20  ^{\beta - 1},.. 
-0000e770: 2077 6865 7265 2074 6865 206e 6f72 6d61   where the norma
-0000e780: 6c69 7a61 7469 6f6e 2c20 422c 2069 7320  lization, B, is 
-0000e790: 7468 6520 6265 7461 2066 756e 6374 696f  the beta functio
-0000e7a0: 6e2c 0a0a 2020 2e2e 206d 6174 683a 3a20  n,..  .. math:: 
-0000e7b0: 4228 5c61 6c70 6861 2c20 5c62 6574 6129  B(\alpha, \beta)
-0000e7c0: 203d 205c 696e 745f 305e 3120 745e 7b5c   = \int_0^1 t^{\
-0000e7d0: 616c 7068 6120 2d20 317d 0a20 2020 2020  alpha - 1}.     
-0000e7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e7f0: 2020 2020 2020 2020 2020 2831 202d 2074            (1 - t
-0000e800: 295e 7b5c 6265 7461 202d 2031 7d20 6474  )^{\beta - 1} dt
-0000e810: 2e0a 0a20 2049 7420 6973 206f 6674 656e  ...  It is often
-0000e820: 2073 6565 6e20 696e 2042 6179 6573 6961   seen in Bayesia
-0000e830: 6e20 696e 6665 7265 6e63 6520 616e 6420  n inference and 
-0000e840: 6f72 6465 7220 7374 6174 6973 7469 6373  order statistics
-0000e850: 2e0a 0a20 2050 6172 616d 6574 6572 730a  ...  Parameters.
-0000e860: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2061    ----------.  a
-0000e870: 203a 2066 6c6f 6174 206f 7220 6172 7261   : float or arra
-0000e880: 795f 6c69 6b65 206f 6620 666c 6f61 7473  y_like of floats
-0000e890: 0a20 2020 2020 2041 6c70 6861 2c20 706f  .      Alpha, po
-0000e8a0: 7369 7469 7665 2028 3e30 292e 0a20 2062  sitive (>0)..  b
-0000e8b0: 203a 2066 6c6f 6174 206f 7220 6172 7261   : float or arra
-0000e8c0: 795f 6c69 6b65 206f 6620 666c 6f61 7473  y_like of floats
-0000e8d0: 0a20 2020 2020 2042 6574 612c 2070 6f73  .      Beta, pos
-0000e8e0: 6974 6976 6520 283e 3029 2e0a 2020 7369  itive (>0)..  si
-0000e8f0: 7a65 203a 2069 6e74 206f 7220 7475 706c  ze : int or tupl
-0000e900: 6520 6f66 2069 6e74 732c 206f 7074 696f  e of ints, optio
-0000e910: 6e61 6c0a 2020 2020 2020 4f75 7470 7574  nal.      Output
-0000e920: 2073 6861 7065 2e20 2049 6620 7468 6520   shape.  If the 
-0000e930: 6769 7665 6e20 7368 6170 6520 6973 2c20  given shape is, 
-0000e940: 652e 672e 2c20 6060 286d 2c20 6e2c 206b  e.g., ``(m, n, k
-0000e950: 2960 602c 2074 6865 6e0a 2020 2020 2020  )``, then.      
-0000e960: 6060 6d20 2a20 6e20 2a20 6b60 6020 7361  ``m * n * k`` sa
-0000e970: 6d70 6c65 7320 6172 6520 6472 6177 6e2e  mples are drawn.
-0000e980: 2020 4966 2073 697a 6520 6973 2060 604e    If size is ``N
-0000e990: 6f6e 6560 6020 2864 6566 6175 6c74 292c  one`` (default),
-0000e9a0: 0a20 2020 2020 2061 2073 696e 676c 6520  .      a single 
-0000e9b0: 7661 6c75 6520 6973 2072 6574 7572 6e65  value is returne
-0000e9c0: 6420 6966 2060 6061 6060 2061 6e64 2060  d if ``a`` and `
-0000e9d0: 6062 6060 2061 7265 2062 6f74 6820 7363  `b`` are both sc
-0000e9e0: 616c 6172 732e 0a20 2020 2020 204f 7468  alars..      Oth
-0000e9f0: 6572 7769 7365 2c20 6060 6e70 2e62 726f  erwise, ``np.bro
-0000ea00: 6164 6361 7374 2861 2c20 6229 2e73 697a  adcast(a, b).siz
-0000ea10: 6560 6020 7361 6d70 6c65 7320 6172 6520  e`` samples are 
-0000ea20: 6472 6177 6e2e 0a0a 2020 5265 7475 726e  drawn...  Return
-0000ea30: 730a 2020 2d2d 2d2d 2d2d 2d0a 2020 6f75  s.  -------.  ou
-0000ea40: 7420 3a20 6e64 6172 7261 7920 6f72 2073  t : ndarray or s
-0000ea50: 6361 6c61 720a 2020 2020 2020 4472 6177  calar.      Draw
-0000ea60: 6e20 7361 6d70 6c65 7320 6672 6f6d 2074  n samples from t
-0000ea70: 6865 2070 6172 616d 6574 6572 697a 6564  he parameterized
-0000ea80: 2062 6574 6120 6469 7374 7269 6275 7469   beta distributi
-0000ea90: 6f6e 2e0a 0a20 2053 6565 2041 6c73 6f0a  on...  See Also.
-0000eaa0: 2020 2d2d 2d2d 2d2d 2d2d 0a20 2072 616e    --------.  ran
-0000eab0: 646f 6d2e 4765 6e65 7261 746f 722e 6265  dom.Generator.be
-0000eac0: 7461 3a20 7768 6963 6820 7368 6f75 6c64  ta: which should
-0000ead0: 2062 6520 7573 6564 2066 6f72 206e 6577   be used for new
-0000eae0: 2063 6f64 652e 0a20 2022 2222 0a20 2072   code..  """.  r
-0000eaf0: 6574 7572 6e20 4445 4641 554c 542e 6265  eturn DEFAULT.be
-0000eb00: 7461 2861 2c20 622c 2073 697a 653d 7369  ta(a, b, size=si
-0000eb10: 7a65 2c20 6b65 793d 6b65 7929 0a0a 0a23  ze, key=key)...#
-0000eb20: 2040 7772 6170 7328 6e70 2e72 616e 646f   @wraps(np.rando
-0000eb30: 6d2e 6578 706f 6e65 6e74 6961 6c29 0a64  m.exponential).d
-0000eb40: 6566 2065 7870 6f6e 656e 7469 616c 2873  ef exponential(s
-0000eb50: 6361 6c65 3d4e 6f6e 652c 2073 697a 653d  cale=None, size=
-0000eb60: 4e6f 6e65 2c20 6b65 793d 4e6f 6e65 293a  None, key=None):
-0000eb70: 0a20 2072 6574 7572 6e20 4445 4641 554c  .  return DEFAUL
-0000eb80: 542e 6578 706f 6e65 6e74 6961 6c28 7363  T.exponential(sc
-0000eb90: 616c 652c 2073 697a 652c 206b 6579 3d6b  ale, size, key=k
-0000eba0: 6579 290a 0a0a 2320 4077 7261 7073 286e  ey)...# @wraps(n
-0000ebb0: 702e 7261 6e64 6f6d 2e67 616d 6d61 290a  p.random.gamma).
-0000ebc0: 6465 6620 6761 6d6d 6128 7368 6170 652c  def gamma(shape,
-0000ebd0: 2073 6361 6c65 3d4e 6f6e 652c 2073 697a   scale=None, siz
-0000ebe0: 653d 4e6f 6e65 2c20 6b65 793d 4e6f 6e65  e=None, key=None
-0000ebf0: 293a 0a20 2072 6574 7572 6e20 4445 4641  ):.  return DEFA
-0000ec00: 554c 542e 6761 6d6d 6128 7368 6170 652c  ULT.gamma(shape,
-0000ec10: 2073 6361 6c65 2c20 7369 7a65 3d73 697a   scale, size=siz
-0000ec20: 652c 206b 6579 3d6b 6579 290a 0a0a 2320  e, key=key)...# 
-0000ec30: 4077 7261 7073 286e 702e 7261 6e64 6f6d  @wraps(np.random
-0000ec40: 2e67 756d 6265 6c29 0a64 6566 2067 756d  .gumbel).def gum
-0000ec50: 6265 6c28 6c6f 633d 4e6f 6e65 2c20 7363  bel(loc=None, sc
-0000ec60: 616c 653d 4e6f 6e65 2c20 7369 7a65 3d4e  ale=None, size=N
-0000ec70: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
-0000ec80: 2020 7265 7475 726e 2044 4546 4155 4c54    return DEFAULT
-0000ec90: 2e67 756d 6265 6c28 6c6f 632c 2073 6361  .gumbel(loc, sca
-0000eca0: 6c65 2c20 7369 7a65 3d73 697a 652c 206b  le, size=size, k
-0000ecb0: 6579 3d6b 6579 290a 0a0a 2320 4077 7261  ey=key)...# @wra
-0000ecc0: 7073 286e 702e 7261 6e64 6f6d 2e6c 6170  ps(np.random.lap
-0000ecd0: 6c61 6365 290a 6465 6620 6c61 706c 6163  lace).def laplac
-0000ece0: 6528 6c6f 633d 4e6f 6e65 2c20 7363 616c  e(loc=None, scal
-0000ecf0: 653d 4e6f 6e65 2c20 7369 7a65 3d4e 6f6e  e=None, size=Non
-0000ed00: 652c 206b 6579 3d4e 6f6e 6529 3a0a 2020  e, key=None):.  
-0000ed10: 7265 7475 726e 2044 4546 4155 4c54 2e6c  return DEFAULT.l
-0000ed20: 6170 6c61 6365 286c 6f63 2c20 7363 616c  aplace(loc, scal
-0000ed30: 652c 2073 697a 652c 206b 6579 3d6b 6579  e, size, key=key
-0000ed40: 290a 0a0a 2320 4077 7261 7073 286e 702e  )...# @wraps(np.
-0000ed50: 7261 6e64 6f6d 2e6c 6f67 6973 7469 6329  random.logistic)
-0000ed60: 0a64 6566 206c 6f67 6973 7469 6328 6c6f  .def logistic(lo
-0000ed70: 633d 4e6f 6e65 2c20 7363 616c 653d 4e6f  c=None, scale=No
-0000ed80: 6e65 2c20 7369 7a65 3d4e 6f6e 652c 206b  ne, size=None, k
-0000ed90: 6579 3d4e 6f6e 6529 3a0a 2020 7265 7475  ey=None):.  retu
-0000eda0: 726e 2044 4546 4155 4c54 2e6c 6f67 6973  rn DEFAULT.logis
-0000edb0: 7469 6328 6c6f 632c 2073 6361 6c65 2c20  tic(loc, scale, 
-0000edc0: 7369 7a65 2c20 6b65 793d 6b65 7929 0a0a  size, key=key)..
-0000edd0: 0a23 2040 7772 6170 7328 6e70 2e72 616e  .# @wraps(np.ran
-0000ede0: 646f 6d2e 6e6f 726d 616c 290a 6465 6620  dom.normal).def 
-0000edf0: 6e6f 726d 616c 286c 6f63 3d4e 6f6e 652c  normal(loc=None,
-0000ee00: 2073 6361 6c65 3d4e 6f6e 652c 2073 697a   scale=None, siz
-0000ee10: 653d 4e6f 6e65 2c20 6b65 793d 4e6f 6e65  e=None, key=None
-0000ee20: 293a 0a20 2072 6574 7572 6e20 4445 4641  ):.  return DEFA
-0000ee30: 554c 542e 6e6f 726d 616c 286c 6f63 2c20  ULT.normal(loc, 
-0000ee40: 7363 616c 652c 2073 697a 652c 206b 6579  scale, size, key
-0000ee50: 3d6b 6579 290a 0a0a 2320 4077 7261 7073  =key)...# @wraps
-0000ee60: 286e 702e 7261 6e64 6f6d 2e70 6172 6574  (np.random.paret
-0000ee70: 6f29 0a64 6566 2070 6172 6574 6f28 612c  o).def pareto(a,
-0000ee80: 2073 697a 653d 4e6f 6e65 2c20 6b65 793d   size=None, key=
-0000ee90: 4e6f 6e65 293a 0a20 2072 6574 7572 6e20  None):.  return 
-0000eea0: 4445 4641 554c 542e 7061 7265 746f 2861  DEFAULT.pareto(a
-0000eeb0: 2c20 7369 7a65 2c20 6b65 793d 6b65 7929  , size, key=key)
-0000eec0: 0a0a 0a23 2040 7772 6170 7328 6e70 2e72  ...# @wraps(np.r
-0000eed0: 616e 646f 6d2e 706f 6973 736f 6e29 0a64  andom.poisson).d
-0000eee0: 6566 2070 6f69 7373 6f6e 286c 616d 3d31  ef poisson(lam=1
-0000eef0: 2e30 2c20 7369 7a65 3d4e 6f6e 652c 206b  .0, size=None, k
-0000ef00: 6579 3d4e 6f6e 6529 3a0a 2020 7265 7475  ey=None):.  retu
-0000ef10: 726e 2044 4546 4155 4c54 2e70 6f69 7373  rn DEFAULT.poiss
-0000ef20: 6f6e 286c 616d 2c20 7369 7a65 2c20 6b65  on(lam, size, ke
-0000ef30: 793d 6b65 7929 0a0a 0a23 2040 7772 6170  y=key)...# @wrap
-0000ef40: 7328 6e70 2e72 616e 646f 6d2e 7374 616e  s(np.random.stan
-0000ef50: 6461 7264 5f63 6175 6368 7929 0a64 6566  dard_cauchy).def
-0000ef60: 2073 7461 6e64 6172 645f 6361 7563 6879   standard_cauchy
-0000ef70: 2873 697a 653d 4e6f 6e65 2c20 6b65 793d  (size=None, key=
-0000ef80: 4e6f 6e65 293a 0a20 2072 6574 7572 6e20  None):.  return 
-0000ef90: 4445 4641 554c 542e 7374 616e 6461 7264  DEFAULT.standard
-0000efa0: 5f63 6175 6368 7928 7369 7a65 2c20 6b65  _cauchy(size, ke
-0000efb0: 793d 6b65 7929 0a0a 0a23 2040 7772 6170  y=key)...# @wrap
-0000efc0: 7328 6e70 2e72 616e 646f 6d2e 7374 616e  s(np.random.stan
-0000efd0: 6461 7264 5f65 7870 6f6e 656e 7469 616c  dard_exponential
-0000efe0: 290a 6465 6620 7374 616e 6461 7264 5f65  ).def standard_e
-0000eff0: 7870 6f6e 656e 7469 616c 2873 697a 653d  xponential(size=
-0000f000: 4e6f 6e65 2c20 6b65 793d 4e6f 6e65 293a  None, key=None):
-0000f010: 0a20 2072 6574 7572 6e20 4445 4641 554c  .  return DEFAUL
-0000f020: 542e 7374 616e 6461 7264 5f65 7870 6f6e  T.standard_expon
-0000f030: 656e 7469 616c 2873 697a 652c 206b 6579  ential(size, key
-0000f040: 3d6b 6579 290a 0a0a 2320 4077 7261 7073  =key)...# @wraps
-0000f050: 286e 702e 7261 6e64 6f6d 2e73 7461 6e64  (np.random.stand
-0000f060: 6172 645f 6761 6d6d 6129 0a64 6566 2073  ard_gamma).def s
-0000f070: 7461 6e64 6172 645f 6761 6d6d 6128 7368  tandard_gamma(sh
-0000f080: 6170 652c 2073 697a 653d 4e6f 6e65 2c20  ape, size=None, 
-0000f090: 6b65 793d 4e6f 6e65 293a 0a20 2072 6574  key=None):.  ret
-0000f0a0: 7572 6e20 4445 4641 554c 542e 7374 616e  urn DEFAULT.stan
-0000f0b0: 6461 7264 5f67 616d 6d61 2873 6861 7065  dard_gamma(shape
-0000f0c0: 2c20 7369 7a65 2c20 6b65 793d 6b65 7929  , size, key=key)
-0000f0d0: 0a0a 0a23 2040 7772 6170 7328 6e70 2e72  ...# @wraps(np.r
-0000f0e0: 616e 646f 6d2e 7374 616e 6461 7264 5f6e  andom.standard_n
-0000f0f0: 6f72 6d61 6c29 0a64 6566 2073 7461 6e64  ormal).def stand
-0000f100: 6172 645f 6e6f 726d 616c 2873 697a 653d  ard_normal(size=
-0000f110: 4e6f 6e65 2c20 6b65 793d 4e6f 6e65 293a  None, key=None):
-0000f120: 0a20 2072 6574 7572 6e20 4445 4641 554c  .  return DEFAUL
-0000f130: 542e 7374 616e 6461 7264 5f6e 6f72 6d61  T.standard_norma
-0000f140: 6c28 7369 7a65 2c20 6b65 793d 6b65 7929  l(size, key=key)
-0000f150: 0a0a 0a23 2040 7772 6170 7328 6e70 2e72  ...# @wraps(np.r
-0000f160: 616e 646f 6d2e 7374 616e 6461 7264 5f74  andom.standard_t
-0000f170: 290a 6465 6620 7374 616e 6461 7264 5f74  ).def standard_t
-0000f180: 2864 662c 2073 697a 653d 4e6f 6e65 2c20  (df, size=None, 
-0000f190: 6b65 793d 4e6f 6e65 293a 0a20 2072 6574  key=None):.  ret
-0000f1a0: 7572 6e20 4445 4641 554c 542e 7374 616e  urn DEFAULT.stan
-0000f1b0: 6461 7264 5f74 2864 662c 2073 697a 652c  dard_t(df, size,
-0000f1c0: 206b 6579 3d6b 6579 290a 0a0a 2320 4077   key=key)...# @w
-0000f1d0: 7261 7073 286e 702e 7261 6e64 6f6d 2e75  raps(np.random.u
-0000f1e0: 6e69 666f 726d 290a 6465 6620 756e 6966  niform).def unif
-0000f1f0: 6f72 6d28 6c6f 773d 302e 302c 2068 6967  orm(low=0.0, hig
-0000f200: 683d 312e 302c 2073 697a 653d 4e6f 6e65  h=1.0, size=None
-0000f210: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2072  , key=None):.  r
-0000f220: 6574 7572 6e20 4445 4641 554c 542e 756e  eturn DEFAULT.un
-0000f230: 6966 6f72 6d28 6c6f 772c 2068 6967 682c  iform(low, high,
-0000f240: 2073 697a 652c 206b 6579 3d6b 6579 290a   size, key=key).
-0000f250: 0a0a 6465 6620 7472 756e 6361 7465 645f  ..def truncated_
-0000f260: 6e6f 726d 616c 286c 6f77 6572 2c20 7570  normal(lower, up
-0000f270: 7065 722c 2073 697a 653d 4e6f 6e65 2c20  per, size=None, 
-0000f280: 7363 616c 653d 4e6f 6e65 2c20 6b65 793d  scale=None, key=
-0000f290: 4e6f 6e65 293a 0a20 2022 2222 5361 6d70  None):.  """Samp
-0000f2a0: 6c65 2074 7275 6e63 6174 6564 2073 7461  le truncated sta
-0000f2b0: 6e64 6172 6420 6e6f 726d 616c 2072 616e  ndard normal ran
-0000f2c0: 646f 6d20 7661 6c75 6573 2077 6974 6820  dom values with 
-0000f2d0: 6769 7665 6e20 7368 6170 6520 616e 6420  given shape and 
-0000f2e0: 6474 7970 652e 0a0a 2020 5061 7261 6d65  dtype...  Parame
-0000f2f0: 7465 7273 0a20 202d 2d2d 2d2d 2d2d 2d2d  ters.  ---------
-0000f300: 2d0a 2020 6c6f 7765 7220 3a20 666c 6f61  -.  lower : floa
-0000f310: 742c 206e 6461 7272 6179 0a20 2020 2041  t, ndarray.    A
-0000f320: 2066 6c6f 6174 206f 7220 6172 7261 7920   float or array 
-0000f330: 6f66 2066 6c6f 6174 7320 7265 7072 6573  of floats repres
-0000f340: 656e 7469 6e67 2074 6865 206c 6f77 6572  enting the lower
-0000f350: 2062 6f75 6e64 2066 6f72 0a20 2020 2074   bound for.    t
-0000f360: 7275 6e63 6174 696f 6e2e 204d 7573 7420  runcation. Must 
-0000f370: 6265 2062 726f 6164 6361 7374 2d63 6f6d  be broadcast-com
-0000f380: 7061 7469 626c 6520 7769 7468 2060 6075  patible with ``u
-0000f390: 7070 6572 6060 2e0a 2020 7570 7065 7220  pper``..  upper 
-0000f3a0: 3a20 666c 6f61 742c 206e 6461 7272 6179  : float, ndarray
-0000f3b0: 0a20 2020 2041 2066 6c6f 6174 206f 7220  .    A float or 
-0000f3c0: 6172 7261 7920 6f66 2066 6c6f 6174 7320  array of floats 
-0000f3d0: 7265 7072 6573 656e 7469 6e67 2074 6865  representing the
-0000f3e0: 2020 7570 7065 7220 626f 756e 6420 666f    upper bound fo
-0000f3f0: 720a 2020 2020 7472 756e 6361 7469 6f6e  r.    truncation
-0000f400: 2e20 4d75 7374 2062 6520 6272 6f61 6463  . Must be broadc
-0000f410: 6173 742d 636f 6d70 6174 6962 6c65 2077  ast-compatible w
-0000f420: 6974 6820 6060 6c6f 7765 7260 602e 0a20  ith ``lower``.. 
-0000f430: 2073 697a 6520 3a20 6f70 7469 6f6e 616c   size : optional
-0000f440: 2c20 6c69 7374 206f 6620 696e 742c 2074  , list of int, t
-0000f450: 7570 6c65 206f 6620 696e 740a 2020 2020  uple of int.    
-0000f460: 4120 7475 706c 6520 6f66 206e 6f6e 6e65  A tuple of nonne
-0000f470: 6761 7469 7665 2069 6e74 6567 6572 7320  gative integers 
-0000f480: 7370 6563 6966 7969 6e67 2074 6865 2072  specifying the r
-0000f490: 6573 756c 740a 2020 2020 7368 6170 652e  esult.    shape.
-0000f4a0: 204d 7573 7420 6265 2062 726f 6164 6361   Must be broadca
-0000f4b0: 7374 2d63 6f6d 7061 7469 626c 6520 7769  st-compatible wi
-0000f4c0: 7468 2060 606c 6f77 6572 6060 2061 6e64  th ``lower`` and
-0000f4d0: 2060 6075 7070 6572 6060 2e20 5468 650a   ``upper``. The.
-0000f4e0: 2020 2020 6465 6661 756c 7420 284e 6f6e      default (Non
-0000f4f0: 6529 2070 726f 6475 6365 7320 6120 7265  e) produces a re
-0000f500: 7375 6c74 2073 6861 7065 2062 7920 6272  sult shape by br
-0000f510: 6f61 6463 6173 7469 6e67 2060 606c 6f77  oadcasting ``low
-0000f520: 6572 6060 2061 6e64 0a20 2020 2060 6075  er`` and.    ``u
-0000f530: 7070 6572 6060 2e0a 2020 7363 616c 6520  pper``..  scale 
-0000f540: 3a20 666c 6f61 742c 206e 6461 7272 6179  : float, ndarray
-0000f550: 0a20 2020 2053 7461 6e64 6172 6420 6465  .    Standard de
-0000f560: 7669 6174 696f 6e20 2873 7072 6561 6420  viation (spread 
-0000f570: 6f72 2022 7769 6474 6822 2920 6f66 2074  or "width") of t
-0000f580: 6865 2064 6973 7472 6962 7574 696f 6e2e  he distribution.
-0000f590: 204d 7573 7420 6265 0a20 2020 206e 6f6e   Must be.    non
-0000f5a0: 2d6e 6567 6174 6976 652e 0a0a 2020 5265  -negative...  Re
-0000f5b0: 7475 726e 730a 2020 2d2d 2d2d 2d2d 2d0a  turns.  -------.
-0000f5c0: 2020 6f75 7420 3a20 4172 7261 790a 2020    out : Array.  
-0000f5d0: 2020 4120 7261 6e64 6f6d 2061 7272 6179    A random array
-0000f5e0: 2077 6974 6820 7468 6520 7370 6563 6966   with the specif
-0000f5f0: 6965 6420 6474 7970 6520 616e 6420 7368  ied dtype and sh
-0000f600: 6170 6520 6769 7665 6e20 6279 2060 6073  ape given by ``s
-0000f610: 6861 7065 6060 2069 660a 2020 2020 6060  hape`` if.    ``
-0000f620: 7368 6170 6560 6020 6973 206e 6f74 204e  shape`` is not N
-0000f630: 6f6e 652c 206f 7220 656c 7365 2062 7920  one, or else by 
-0000f640: 6272 6f61 6463 6173 7469 6e67 2060 606c  broadcasting ``l
-0000f650: 6f77 6572 6060 2061 6e64 2060 6075 7070  ower`` and ``upp
-0000f660: 6572 6060 2e0a 2020 2020 5265 7475 726e  er``..    Return
-0000f670: 7320 7661 6c75 6573 2069 6e20 7468 6520  s values in the 
-0000f680: 6f70 656e 2069 6e74 6572 7661 6c20 6060  open interval ``
-0000f690: 286c 6f77 6572 2c20 7570 7065 7229 6060  (lower, upper)``
-0000f6a0: 2e0a 2020 2222 220a 2020 7265 7475 726e  ..  """.  return
-0000f6b0: 2044 4546 4155 4c54 2e74 7275 6e63 6174   DEFAULT.truncat
-0000f6c0: 6564 5f6e 6f72 6d61 6c28 6c6f 7765 722c  ed_normal(lower,
-0000f6d0: 2075 7070 6572 2c20 7369 7a65 2c20 7363   upper, size, sc
-0000f6e0: 616c 652c 206b 6579 3d6b 6579 290a 0a0a  ale, key=key)...
-0000f6f0: 6465 6620 6265 726e 6f75 6c6c 6928 703d  def bernoulli(p=
-0000f700: 302e 352c 2073 697a 653d 4e6f 6e65 2c20  0.5, size=None, 
-0000f710: 6b65 793d 4e6f 6e65 293a 0a20 2022 2222  key=None):.  """
-0000f720: 5361 6d70 6c65 2042 6572 6e6f 756c 6c69  Sample Bernoulli
-0000f730: 2072 616e 646f 6d20 7661 6c75 6573 2077   random values w
-0000f740: 6974 6820 6769 7665 6e20 7368 6170 6520  ith given shape 
-0000f750: 616e 6420 6d65 616e 2e0a 0a20 2050 6172  and mean...  Par
-0000f760: 616d 6574 6572 730a 2020 2d2d 2d2d 2d2d  ameters.  ------
-0000f770: 2d2d 2d2d 0a20 2070 3a20 666c 6f61 742c  ----.  p: float,
-0000f780: 2061 7272 6179 5f6c 696b 652c 206f 7074   array_like, opt
-0000f790: 696f 6e61 6c0a 2020 2020 4120 666c 6f61  ional.    A floa
-0000f7a0: 7420 6f72 2061 7272 6179 206f 6620 666c  t or array of fl
-0000f7b0: 6f61 7473 2066 6f72 2074 6865 206d 6561  oats for the mea
-0000f7c0: 6e20 6f66 2074 6865 2072 616e 646f 6d0a  n of the random.
-0000f7d0: 2020 2020 7661 7269 6162 6c65 732e 204d      variables. M
-0000f7e0: 7573 7420 6265 2062 726f 6164 6361 7374  ust be broadcast
-0000f7f0: 2d63 6f6d 7061 7469 626c 6520 7769 7468  -compatible with
-0000f800: 2060 6073 6861 7065 6060 2061 6e64 2074   ``shape`` and t
-0000f810: 6865 2076 616c 7565 730a 2020 2020 7368  he values.    sh
-0000f820: 6f75 6c64 2062 6520 7769 7468 696e 205b  ould be within [
-0000f830: 302c 2031 5d2e 2044 6566 6175 6c74 2030  0, 1]. Default 0
-0000f840: 2e35 2e0a 2020 7369 7a65 3a20 6f70 7469  .5..  size: opti
-0000f850: 6f6e 616c 2c20 7475 706c 6520 6f66 2069  onal, tuple of i
-0000f860: 6e74 2c20 696e 740a 2020 2020 4120 7475  nt, int.    A tu
-0000f870: 706c 6520 6f66 206e 6f6e 6e65 6761 7469  ple of nonnegati
-0000f880: 7665 2069 6e74 6567 6572 7320 7265 7072  ve integers repr
-0000f890: 6573 656e 7469 6e67 2074 6865 2072 6573  esenting the res
-0000f8a0: 756c 740a 2020 2020 7368 6170 652e 204d  ult.    shape. M
-0000f8b0: 7573 7420 6265 2062 726f 6164 6361 7374  ust be broadcast
-0000f8c0: 2d63 6f6d 7061 7469 626c 6520 7769 7468  -compatible with
-0000f8d0: 2060 6070 2e73 6861 7065 6060 2e20 5468   ``p.shape``. Th
-0000f8e0: 6520 6465 6661 756c 7420 284e 6f6e 6529  e default (None)
-0000f8f0: 0a20 2020 2070 726f 6475 6365 7320 6120  .    produces a 
-0000f900: 7265 7375 6c74 2073 6861 7065 2065 7175  result shape equ
-0000f910: 616c 2074 6f20 6060 702e 7368 6170 6560  al to ``p.shape`
-0000f920: 602e 0a0a 2020 5265 7475 726e 730a 2020  `...  Returns.  
-0000f930: 2d2d 2d2d 2d2d 2d0a 2020 6f75 743a 2061  -------.  out: a
-0000f940: 7272 6179 5f6c 696b 650a 2020 2020 4120  rray_like.    A 
-0000f950: 7261 6e64 6f6d 2061 7272 6179 2077 6974  random array wit
-0000f960: 6820 626f 6f6c 6561 6e20 6474 7970 6520  h boolean dtype 
-0000f970: 616e 6420 7368 6170 6520 6769 7665 6e20  and shape given 
-0000f980: 6279 2060 6073 6861 7065 6060 2069 6620  by ``shape`` if 
-0000f990: 6060 7368 6170 6560 600a 2020 2020 6973  ``shape``.    is
-0000f9a0: 206e 6f74 204e 6f6e 652c 206f 7220 656c   not None, or el
-0000f9b0: 7365 2060 6070 2e73 6861 7065 6060 2e0a  se ``p.shape``..
-0000f9c0: 2020 2222 220a 2020 7265 7475 726e 2044    """.  return D
-0000f9d0: 4546 4155 4c54 2e62 6572 6e6f 756c 6c69  EFAULT.bernoulli
-0000f9e0: 2870 2c20 7369 7a65 2c20 6b65 793d 6b65  (p, size, key=ke
-0000f9f0: 7929 0a0a 0a23 2040 7772 6170 7328 6e70  y)...# @wraps(np
-0000fa00: 2e72 616e 646f 6d2e 6c6f 676e 6f72 6d61  .random.lognorma
-0000fa10: 6c29 0a64 6566 206c 6f67 6e6f 726d 616c  l).def lognormal
-0000fa20: 286d 6561 6e3d 4e6f 6e65 2c20 7369 676d  (mean=None, sigm
-0000fa30: 613d 4e6f 6e65 2c20 7369 7a65 3d4e 6f6e  a=None, size=Non
-0000fa40: 652c 206b 6579 3d4e 6f6e 6529 3a0a 2020  e, key=None):.  
-0000fa50: 7265 7475 726e 2044 4546 4155 4c54 2e6c  return DEFAULT.l
-0000fa60: 6f67 6e6f 726d 616c 286d 6561 6e2c 2073  ognormal(mean, s
-0000fa70: 6967 6d61 2c20 7369 7a65 2c20 6b65 793d  igma, size, key=
-0000fa80: 6b65 7929 0a0a 0a23 2040 7772 6170 7328  key)...# @wraps(
-0000fa90: 6e70 2e72 616e 646f 6d2e 6269 6e6f 6d69  np.random.binomi
-0000faa0: 616c 290a 6465 6620 6269 6e6f 6d69 616c  al).def binomial
-0000fab0: 286e 2c20 702c 2073 697a 653d 4e6f 6e65  (n, p, size=None
-0000fac0: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2072  , key=None):.  r
-0000fad0: 6574 7572 6e20 4445 4641 554c 542e 6269  eturn DEFAULT.bi
-0000fae0: 6e6f 6d69 616c 286e 2c20 702c 2073 697a  nomial(n, p, siz
-0000faf0: 652c 206b 6579 3d6b 6579 290a 0a0a 2320  e, key=key)...# 
-0000fb00: 4077 7261 7073 286e 702e 7261 6e64 6f6d  @wraps(np.random
-0000fb10: 2e63 6869 7371 7561 7265 290a 6465 6620  .chisquare).def 
-0000fb20: 6368 6973 7175 6172 6528 6466 2c20 7369  chisquare(df, si
-0000fb30: 7a65 3d4e 6f6e 652c 206b 6579 3d4e 6f6e  ze=None, key=Non
-0000fb40: 6529 3a0a 2020 7265 7475 726e 2044 4546  e):.  return DEF
-0000fb50: 4155 4c54 2e63 6869 7371 7561 7265 2864  AULT.chisquare(d
-0000fb60: 662c 2073 697a 652c 206b 6579 3d6b 6579  f, size, key=key
-0000fb70: 290a 0a0a 2320 4077 7261 7073 286e 702e  )...# @wraps(np.
-0000fb80: 7261 6e64 6f6d 2e64 6972 6963 686c 6574  random.dirichlet
-0000fb90: 290a 6465 6620 6469 7269 6368 6c65 7428  ).def dirichlet(
-0000fba0: 616c 7068 612c 2073 697a 653d 4e6f 6e65  alpha, size=None
-0000fbb0: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2072  , key=None):.  r
-0000fbc0: 6574 7572 6e20 4445 4641 554c 542e 6469  eturn DEFAULT.di
-0000fbd0: 7269 6368 6c65 7428 616c 7068 612c 2073  richlet(alpha, s
-0000fbe0: 697a 652c 206b 6579 3d6b 6579 290a 0a0a  ize, key=key)...
-0000fbf0: 2320 4077 7261 7073 286e 702e 7261 6e64  # @wraps(np.rand
-0000fc00: 6f6d 2e67 656f 6d65 7472 6963 290a 6465  om.geometric).de
-0000fc10: 6620 6765 6f6d 6574 7269 6328 702c 2073  f geometric(p, s
-0000fc20: 697a 653d 4e6f 6e65 2c20 6b65 793d 4e6f  ize=None, key=No
-0000fc30: 6e65 293a 0a20 2072 6574 7572 6e20 4445  ne):.  return DE
-0000fc40: 4641 554c 542e 6765 6f6d 6574 7269 6328  FAULT.geometric(
-0000fc50: 702c 2073 697a 652c 206b 6579 3d6b 6579  p, size, key=key
-0000fc60: 290a 0a0a 2320 4077 7261 7073 286e 702e  )...# @wraps(np.
-0000fc70: 7261 6e64 6f6d 2e66 290a 6465 6620 6628  random.f).def f(
-0000fc80: 6466 6e75 6d2c 2064 6664 656e 2c20 7369  dfnum, dfden, si
-0000fc90: 7a65 3d4e 6f6e 652c 206b 6579 3d4e 6f6e  ze=None, key=Non
-0000fca0: 6529 3a0a 2020 7265 7475 726e 2044 4546  e):.  return DEF
-0000fcb0: 4155 4c54 2e66 2864 666e 756d 2c20 6466  AULT.f(dfnum, df
-0000fcc0: 6465 6e2c 2073 697a 652c 206b 6579 3d6b  den, size, key=k
-0000fcd0: 6579 290a 0a0a 2320 4077 7261 7073 286e  ey)...# @wraps(n
-0000fce0: 702e 7261 6e64 6f6d 2e68 7970 6572 6765  p.random.hyperge
-0000fcf0: 6f6d 6574 7269 6329 0a64 6566 2068 7970  ometric).def hyp
-0000fd00: 6572 6765 6f6d 6574 7269 6328 6e67 6f6f  ergeometric(ngoo
-0000fd10: 642c 206e 6261 642c 206e 7361 6d70 6c65  d, nbad, nsample
-0000fd20: 2c20 7369 7a65 3d4e 6f6e 652c 206b 6579  , size=None, key
-0000fd30: 3d4e 6f6e 6529 3a0a 2020 7265 7475 726e  =None):.  return
-0000fd40: 2044 4546 4155 4c54 2e68 7970 6572 6765   DEFAULT.hyperge
-0000fd50: 6f6d 6574 7269 6328 6e67 6f6f 642c 206e  ometric(ngood, n
-0000fd60: 6261 642c 206e 7361 6d70 6c65 2c20 7369  bad, nsample, si
-0000fd70: 7a65 2c20 6b65 793d 6b65 7929 0a0a 0a23  ze, key=key)...#
-0000fd80: 2040 7772 6170 7328 6e70 2e72 616e 646f   @wraps(np.rando
-0000fd90: 6d2e 6c6f 6773 6572 6965 7329 0a64 6566  m.logseries).def
-0000fda0: 206c 6f67 7365 7269 6573 2870 2c20 7369   logseries(p, si
-0000fdb0: 7a65 3d4e 6f6e 652c 206b 6579 3d4e 6f6e  ze=None, key=Non
-0000fdc0: 6529 3a0a 2020 7265 7475 726e 2044 4546  e):.  return DEF
-0000fdd0: 4155 4c54 2e6c 6f67 7365 7269 6573 2870  AULT.logseries(p
-0000fde0: 2c20 7369 7a65 2c20 6b65 793d 6b65 7929  , size, key=key)
-0000fdf0: 0a0a 0a23 2040 7772 6170 7328 6e70 2e72  ...# @wraps(np.r
-0000fe00: 616e 646f 6d2e 6d75 6c74 696e 6f6d 6961  andom.multinomia
-0000fe10: 6c29 0a64 6566 206d 756c 7469 6e6f 6d69  l).def multinomi
-0000fe20: 616c 286e 2c20 7076 616c 732c 2073 697a  al(n, pvals, siz
-0000fe30: 653d 4e6f 6e65 2c20 6b65 793d 4e6f 6e65  e=None, key=None
-0000fe40: 293a 0a20 2072 6574 7572 6e20 4445 4641  ):.  return DEFA
-0000fe50: 554c 542e 6d75 6c74 696e 6f6d 6961 6c28  ULT.multinomial(
-0000fe60: 6e2c 2070 7661 6c73 2c20 7369 7a65 2c20  n, pvals, size, 
-0000fe70: 6b65 793d 6b65 7929 0a0a 0a23 2040 7772  key=key)...# @wr
-0000fe80: 6170 7328 6e70 2e72 616e 646f 6d2e 6d75  aps(np.random.mu
-0000fe90: 6c74 6976 6172 6961 7465 5f6e 6f72 6d61  ltivariate_norma
-0000fea0: 6c29 0a64 6566 206d 756c 7469 7661 7269  l).def multivari
-0000feb0: 6174 655f 6e6f 726d 616c 286d 6561 6e2c  ate_normal(mean,
-0000fec0: 2063 6f76 2c20 7369 7a65 3d4e 6f6e 652c   cov, size=None,
-0000fed0: 206d 6574 686f 643a 2073 7472 203d 2027   method: str = '
-0000fee0: 6368 6f6c 6573 6b79 272c 206b 6579 3d4e  cholesky', key=N
-0000fef0: 6f6e 6529 3a0a 2020 7265 7475 726e 2044  one):.  return D
-0000ff00: 4546 4155 4c54 2e6d 756c 7469 7661 7269  EFAULT.multivari
-0000ff10: 6174 655f 6e6f 726d 616c 286d 6561 6e2c  ate_normal(mean,
-0000ff20: 2063 6f76 2c20 7369 7a65 2c20 6d65 7468   cov, size, meth
-0000ff30: 6f64 2c20 6b65 793d 6b65 7929 0a0a 0a23  od, key=key)...#
-0000ff40: 2040 7772 6170 7328 6e70 2e72 616e 646f   @wraps(np.rando
-0000ff50: 6d2e 6e65 6761 7469 7665 5f62 696e 6f6d  m.negative_binom
-0000ff60: 6961 6c29 0a64 6566 206e 6567 6174 6976  ial).def negativ
-0000ff70: 655f 6269 6e6f 6d69 616c 286e 2c20 702c  e_binomial(n, p,
-0000ff80: 2073 697a 653d 4e6f 6e65 2c20 6b65 793d   size=None, key=
-0000ff90: 4e6f 6e65 293a 0a20 2072 6574 7572 6e20  None):.  return 
-0000ffa0: 4445 4641 554c 542e 6e65 6761 7469 7665  DEFAULT.negative
-0000ffb0: 5f62 696e 6f6d 6961 6c28 6e2c 2070 2c20  _binomial(n, p, 
-0000ffc0: 7369 7a65 2c20 6b65 793d 6b65 7929 0a0a  size, key=key)..
-0000ffd0: 0a23 2040 7772 6170 7328 6e70 2e72 616e  .# @wraps(np.ran
-0000ffe0: 646f 6d2e 6e6f 6e63 656e 7472 616c 5f63  dom.noncentral_c
-0000fff0: 6869 7371 7561 7265 290a 6465 6620 6e6f  hisquare).def no
-00010000: 6e63 656e 7472 616c 5f63 6869 7371 7561  ncentral_chisqua
-00010010: 7265 2864 662c 206e 6f6e 632c 2073 697a  re(df, nonc, siz
-00010020: 653d 4e6f 6e65 2c20 6b65 793d 4e6f 6e65  e=None, key=None
-00010030: 293a 0a20 2072 6574 7572 6e20 4445 4641  ):.  return DEFA
-00010040: 554c 542e 6e6f 6e63 656e 7472 616c 5f63  ULT.noncentral_c
-00010050: 6869 7371 7561 7265 2864 662c 206e 6f6e  hisquare(df, non
-00010060: 632c 2073 697a 652c 206b 6579 3d6b 6579  c, size, key=key
-00010070: 290a 0a0a 2320 4077 7261 7073 286e 702e  )...# @wraps(np.
-00010080: 7261 6e64 6f6d 2e6e 6f6e 6365 6e74 7261  random.noncentra
-00010090: 6c5f 6629 0a64 6566 206e 6f6e 6365 6e74  l_f).def noncent
-000100a0: 7261 6c5f 6628 6466 6e75 6d2c 2064 6664  ral_f(dfnum, dfd
-000100b0: 656e 2c20 6e6f 6e63 2c20 7369 7a65 3d4e  en, nonc, size=N
-000100c0: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
-000100d0: 2020 7265 7475 726e 2044 4546 4155 4c54    return DEFAULT
-000100e0: 2e6e 6f6e 6365 6e74 7261 6c5f 6628 6466  .noncentral_f(df
-000100f0: 6e75 6d2c 2064 6664 656e 2c20 6e6f 6e63  num, dfden, nonc
-00010100: 2c20 7369 7a65 2c20 6b65 793d 6b65 7929  , size, key=key)
-00010110: 0a0a 0a23 2040 7772 6170 7328 6e70 2e72  ...# @wraps(np.r
-00010120: 616e 646f 6d2e 706f 7765 7229 0a64 6566  andom.power).def
-00010130: 2070 6f77 6572 2861 2c20 7369 7a65 3d4e   power(a, size=N
-00010140: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
-00010150: 2020 7265 7475 726e 2044 4546 4155 4c54    return DEFAULT
-00010160: 2e70 6f77 6572 2861 2c20 7369 7a65 2c20  .power(a, size, 
-00010170: 6b65 793d 6b65 7929 0a0a 0a23 2040 7772  key=key)...# @wr
-00010180: 6170 7328 6e70 2e72 616e 646f 6d2e 7261  aps(np.random.ra
-00010190: 796c 6569 6768 290a 6465 6620 7261 796c  yleigh).def rayl
-000101a0: 6569 6768 2873 6361 6c65 3d31 2e30 2c20  eigh(scale=1.0, 
-000101b0: 7369 7a65 3d4e 6f6e 652c 206b 6579 3d4e  size=None, key=N
-000101c0: 6f6e 6529 3a0a 2020 7265 7475 726e 2044  one):.  return D
-000101d0: 4546 4155 4c54 2e72 6179 6c65 6967 6828  EFAULT.rayleigh(
-000101e0: 7363 616c 652c 2073 697a 652c 206b 6579  scale, size, key
-000101f0: 3d6b 6579 290a 0a0a 2320 4077 7261 7073  =key)...# @wraps
-00010200: 286e 702e 7261 6e64 6f6d 2e74 7269 616e  (np.random.trian
-00010210: 6775 6c61 7229 0a64 6566 2074 7269 616e  gular).def trian
-00010220: 6775 6c61 7228 7369 7a65 3d4e 6f6e 652c  gular(size=None,
-00010230: 206b 6579 3d4e 6f6e 6529 3a0a 2020 7265   key=None):.  re
-00010240: 7475 726e 2044 4546 4155 4c54 2e74 7269  turn DEFAULT.tri
-00010250: 616e 6775 6c61 7228 7369 7a65 2c20 6b65  angular(size, ke
-00010260: 793d 6b65 7929 0a0a 0a23 2040 7772 6170  y=key)...# @wrap
-00010270: 7328 6e70 2e72 616e 646f 6d2e 766f 6e6d  s(np.random.vonm
-00010280: 6973 6573 290a 6465 6620 766f 6e6d 6973  ises).def vonmis
-00010290: 6573 286d 752c 206b 6170 7061 2c20 7369  es(mu, kappa, si
-000102a0: 7a65 3d4e 6f6e 652c 206b 6579 3d4e 6f6e  ze=None, key=Non
-000102b0: 6529 3a0a 2020 7265 7475 726e 2044 4546  e):.  return DEF
-000102c0: 4155 4c54 2e76 6f6e 6d69 7365 7328 6d75  AULT.vonmises(mu
-000102d0: 2c20 6b61 7070 612c 2073 697a 652c 206b  , kappa, size, k
-000102e0: 6579 3d6b 6579 290a 0a0a 2320 4077 7261  ey=key)...# @wra
-000102f0: 7073 286e 702e 7261 6e64 6f6d 2e77 616c  ps(np.random.wal
-00010300: 6429 0a64 6566 2077 616c 6428 6d65 616e  d).def wald(mean
-00010310: 2c20 7363 616c 652c 2073 697a 653d 4e6f  , scale, size=No
-00010320: 6e65 2c20 6b65 793d 4e6f 6e65 293a 0a20  ne, key=None):. 
-00010330: 2072 6574 7572 6e20 4445 4641 554c 542e   return DEFAULT.
-00010340: 7761 6c64 286d 6561 6e2c 2073 6361 6c65  wald(mean, scale
-00010350: 2c20 7369 7a65 2c20 6b65 793d 6b65 7929  , size, key=key)
-00010360: 0a0a 0a64 6566 2077 6569 6275 6c6c 2861  ...def weibull(a
-00010370: 2c20 7369 7a65 3d4e 6f6e 652c 206b 6579  , size=None, key
-00010380: 3d4e 6f6e 6529 3a0a 2020 7222 2222 0a20  =None):.  r""". 
-00010390: 2044 7261 7720 7361 6d70 6c65 7320 6672   Draw samples fr
-000103a0: 6f6d 2061 2057 6569 6275 6c6c 2064 6973  om a Weibull dis
-000103b0: 7472 6962 7574 696f 6e2e 0a20 2020 200a  tribution..    .
-000103c0: 2020 4472 6177 2073 616d 706c 6573 2066    Draw samples f
-000103d0: 726f 6d20 6120 312d 7061 7261 6d65 7465  rom a 1-paramete
-000103e0: 7220 5765 6962 756c 6c20 6469 7374 7269  r Weibull distri
-000103f0: 6275 7469 6f6e 2077 6974 6820 7468 6520  bution with the 
-00010400: 6769 7665 6e0a 2020 7368 6170 6520 7061  given.  shape pa
-00010410: 7261 6d65 7465 7220 6061 602e 0a0a 2020  rameter `a`...  
-00010420: 2e2e 206d 6174 683a 3a20 5820 3d20 282d  .. math:: X = (-
-00010430: 6c6e 2855 2929 5e7b 312f 617d 0a0a 2020  ln(U))^{1/a}..  
-00010440: 4865 7265 2c20 5520 6973 2064 7261 776e  Here, U is drawn
-00010450: 2066 726f 6d20 7468 6520 756e 6966 6f72   from the unifor
-00010460: 6d20 6469 7374 7269 6275 7469 6f6e 206f  m distribution o
-00010470: 7665 7220 2830 2c31 5d2e 0a0a 2020 5468  ver (0,1]...  Th
-00010480: 6520 6d6f 7265 2063 6f6d 6d6f 6e20 322d  e more common 2-
-00010490: 7061 7261 6d65 7465 7220 5765 6962 756c  parameter Weibul
-000104a0: 6c2c 2069 6e63 6c75 6469 6e67 2061 2073  l, including a s
-000104b0: 6361 6c65 2070 6172 616d 6574 6572 0a20  cale parameter. 
-000104c0: 203a 6d61 7468 3a60 5c6c 616d 6264 6160   :math:`\lambda`
-000104d0: 2069 7320 6a75 7374 203a 6d61 7468 3a60   is just :math:`
-000104e0: 5820 3d20 5c6c 616d 6264 6128 2d6c 6e28  X = \lambda(-ln(
-000104f0: 5529 295e 7b31 2f61 7d60 2e0a 0a20 202e  U))^{1/a}`...  .
-00010500: 2e20 6e6f 7465 3a3a 0a20 2020 2020 204e  . note::.      N
-00010510: 6577 2063 6f64 6520 7368 6f75 6c64 2075  ew code should u
-00010520: 7365 2074 6865 2060 6077 6569 6275 6c6c  se the ``weibull
-00010530: 6060 206d 6574 686f 6420 6f66 2061 2060  `` method of a `
-00010540: 6064 6566 6175 6c74 5f72 6e67 2829 6060  `default_rng()``
-00010550: 0a20 2020 2020 2069 6e73 7461 6e63 6520  .      instance 
-00010560: 696e 7374 6561 643b 2070 6c65 6173 6520  instead; please 
-00010570: 7365 6520 7468 6520 3a72 6566 3a60 7261  see the :ref:`ra
-00010580: 6e64 6f6d 2d71 7569 636b 2d73 7461 7274  ndom-quick-start
-00010590: 602e 0a0a 2020 5061 7261 6d65 7465 7273  `...  Parameters
-000105a0: 0a20 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020  .  ----------.  
-000105b0: 6120 3a20 666c 6f61 7420 6f72 2061 7272  a : float or arr
-000105c0: 6179 5f6c 696b 6520 6f66 2066 6c6f 6174  ay_like of float
-000105d0: 730a 2020 2020 2020 5368 6170 6520 7061  s.      Shape pa
-000105e0: 7261 6d65 7465 7220 6f66 2074 6865 2064  rameter of the d
-000105f0: 6973 7472 6962 7574 696f 6e2e 2020 4d75  istribution.  Mu
-00010600: 7374 2062 6520 6e6f 6e6e 6567 6174 6976  st be nonnegativ
-00010610: 652e 0a20 2073 697a 6520 3a20 696e 7420  e..  size : int 
-00010620: 6f72 2074 7570 6c65 206f 6620 696e 7473  or tuple of ints
-00010630: 2c20 6f70 7469 6f6e 616c 0a20 2020 2020  , optional.     
-00010640: 204f 7574 7075 7420 7368 6170 652e 2020   Output shape.  
-00010650: 4966 2074 6865 2067 6976 656e 2073 6861  If the given sha
-00010660: 7065 2069 732c 2065 2e67 2e2c 2060 6028  pe is, e.g., ``(
-00010670: 6d2c 206e 2c20 6b29 6060 2c20 7468 656e  m, n, k)``, then
-00010680: 0a20 2020 2020 2060 606d 202a 206e 202a  .      ``m * n *
-00010690: 206b 6060 2073 616d 706c 6573 2061 7265   k`` samples are
-000106a0: 2064 7261 776e 2e20 2049 6620 7369 7a65   drawn.  If size
-000106b0: 2069 7320 6060 4e6f 6e65 6060 2028 6465   is ``None`` (de
-000106c0: 6661 756c 7429 2c0a 2020 2020 2020 6120  fault),.      a 
-000106d0: 7369 6e67 6c65 2076 616c 7565 2069 7320  single value is 
-000106e0: 7265 7475 726e 6564 2069 6620 6060 6160  returned if ``a`
-000106f0: 6020 6973 2061 2073 6361 6c61 722e 2020  ` is a scalar.  
-00010700: 4f74 6865 7277 6973 652c 0a20 2020 2020  Otherwise,.     
-00010710: 2060 606e 702e 6172 7261 7928 6129 2e73   ``np.array(a).s
-00010720: 697a 6560 6020 7361 6d70 6c65 7320 6172  ize`` samples ar
-00010730: 6520 6472 6177 6e2e 0a0a 2020 5265 7475  e drawn...  Retu
-00010740: 726e 730a 2020 2d2d 2d2d 2d2d 2d0a 2020  rns.  -------.  
-00010750: 6f75 7420 3a20 6e64 6172 7261 7920 6f72  out : ndarray or
-00010760: 2073 6361 6c61 720a 2020 2020 2020 4472   scalar.      Dr
-00010770: 6177 6e20 7361 6d70 6c65 7320 6672 6f6d  awn samples from
-00010780: 2074 6865 2070 6172 616d 6574 6572 697a   the parameteriz
-00010790: 6564 2057 6569 6275 6c6c 2064 6973 7472  ed Weibull distr
-000107a0: 6962 7574 696f 6e2e 0a0a 2020 5365 6520  ibution...  See 
-000107b0: 416c 736f 0a20 202d 2d2d 2d2d 2d2d 2d0a  Also.  --------.
-000107c0: 2020 7363 6970 792e 7374 6174 732e 7765    scipy.stats.we
-000107d0: 6962 756c 6c5f 6d61 780a 2020 7363 6970  ibull_max.  scip
-000107e0: 792e 7374 6174 732e 7765 6962 756c 6c5f  y.stats.weibull_
-000107f0: 6d69 6e0a 2020 7363 6970 792e 7374 6174  min.  scipy.stat
-00010800: 732e 6765 6e65 7874 7265 6d65 0a20 2067  s.genextreme.  g
-00010810: 756d 6265 6c0a 2020 7261 6e64 6f6d 2e47  umbel.  random.G
-00010820: 656e 6572 6174 6f72 2e77 6569 6275 6c6c  enerator.weibull
-00010830: 3a20 7768 6963 6820 7368 6f75 6c64 2062  : which should b
-00010840: 6520 7573 6564 2066 6f72 206e 6577 2063  e used for new c
-00010850: 6f64 652e 0a0a 2020 4e6f 7465 730a 2020  ode...  Notes.  
-00010860: 2d2d 2d2d 2d0a 2020 5468 6520 5765 6962  -----.  The Weib
-00010870: 756c 6c20 286f 7220 5479 7065 2049 4949  ull (or Type III
-00010880: 2061 7379 6d70 746f 7469 6320 6578 7472   asymptotic extr
-00010890: 656d 6520 7661 6c75 6520 6469 7374 7269  eme value distri
-000108a0: 6275 7469 6f6e 0a20 2066 6f72 2073 6d61  bution.  for sma
-000108b0: 6c6c 6573 7420 7661 6c75 6573 2c20 5345  llest values, SE
-000108c0: 5620 5479 7065 2049 4949 2c20 6f72 2052  V Type III, or R
-000108d0: 6f73 696e 2d52 616d 6d6c 6572 0a20 2064  osin-Rammler.  d
-000108e0: 6973 7472 6962 7574 696f 6e29 2069 7320  istribution) is 
-000108f0: 6f6e 6520 6f66 2061 2063 6c61 7373 206f  one of a class o
-00010900: 6620 4765 6e65 7261 6c69 7a65 6420 4578  f Generalized Ex
-00010910: 7472 656d 6520 5661 6c75 650a 2020 2847  treme Value.  (G
-00010920: 4556 2920 6469 7374 7269 6275 7469 6f6e  EV) distribution
-00010930: 7320 7573 6564 2069 6e20 6d6f 6465 6c69  s used in modeli
-00010940: 6e67 2065 7874 7265 6d65 2076 616c 7565  ng extreme value
-00010950: 2070 726f 626c 656d 732e 0a20 2054 6869   problems..  Thi
-00010960: 7320 636c 6173 7320 696e 636c 7564 6573  s class includes
-00010970: 2074 6865 2047 756d 6265 6c20 616e 6420   the Gumbel and 
-00010980: 4672 6563 6865 7420 6469 7374 7269 6275  Frechet distribu
-00010990: 7469 6f6e 732e 0a0a 2020 5468 6520 7072  tions...  The pr
-000109a0: 6f62 6162 696c 6974 7920 6465 6e73 6974  obability densit
-000109b0: 7920 666f 7220 7468 6520 5765 6962 756c  y for the Weibul
-000109c0: 6c20 6469 7374 7269 6275 7469 6f6e 2069  l distribution i
-000109d0: 730a 0a20 202e 2e20 6d61 7468 3a3a 2070  s..  .. math:: p
-000109e0: 2878 2920 3d20 5c66 7261 637b 617d 0a20  (x) = \frac{a}. 
-000109f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010a00: 2020 7b5c 6c61 6d62 6461 7d28 5c66 7261    {\lambda}(\fra
-00010a10: 637b 787d 7b5c 6c61 6d62 6461 7d29 5e7b  c{x}{\lambda})^{
-00010a20: 612d 317d 655e 7b2d 2878 2f5c 6c61 6d62  a-1}e^{-(x/\lamb
-00010a30: 6461 295e 617d 2c0a 0a20 2077 6865 7265  da)^a},..  where
-00010a40: 203a 6d61 7468 3a60 6160 2069 7320 7468   :math:`a` is th
-00010a50: 6520 7368 6170 6520 616e 6420 3a6d 6174  e shape and :mat
-00010a60: 683a 605c 6c61 6d62 6461 6020 7468 6520  h:`\lambda` the 
-00010a70: 7363 616c 652e 0a0a 2020 5468 6520 6675  scale...  The fu
-00010a80: 6e63 7469 6f6e 2068 6173 2069 7473 2070  nction has its p
-00010a90: 6561 6b20 2874 6865 206d 6f64 6529 2061  eak (the mode) a
-00010aa0: 740a 2020 3a6d 6174 683a 605c 6c61 6d62  t.  :math:`\lamb
-00010ab0: 6461 285c 6672 6163 7b61 2d31 7d7b 617d  da(\frac{a-1}{a}
-00010ac0: 295e 7b31 2f61 7d60 2e0a 0a20 2057 6865  )^{1/a}`...  Whe
-00010ad0: 6e20 6060 6120 3d20 3160 602c 2074 6865  n ``a = 1``, the
-00010ae0: 2057 6569 6275 6c6c 2064 6973 7472 6962   Weibull distrib
-00010af0: 7574 696f 6e20 7265 6475 6365 7320 746f  ution reduces to
-00010b00: 2074 6865 2065 7870 6f6e 656e 7469 616c   the exponential
-00010b10: 0a20 2064 6973 7472 6962 7574 696f 6e2e  .  distribution.
-00010b20: 0a0a 2020 5265 6665 7265 6e63 6573 0a20  ..  References. 
-00010b30: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2e2e   ----------.  ..
-00010b40: 205b 315d 2057 616c 6f64 6469 2057 6569   [1] Waloddi Wei
-00010b50: 6275 6c6c 2c20 526f 7961 6c20 5465 6368  bull, Royal Tech
-00010b60: 6e69 6361 6c20 556e 6976 6572 7369 7479  nical University
-00010b70: 2c20 5374 6f63 6b68 6f6c 6d2c 0a20 2020  , Stockholm,.   
-00010b80: 2020 2020 2020 3139 3339 2022 4120 5374        1939 "A St
-00010b90: 6174 6973 7469 6361 6c20 5468 656f 7279  atistical Theory
-00010ba0: 204f 6620 5468 6520 5374 7265 6e67 7468   Of The Strength
-00010bb0: 204f 6620 4d61 7465 7269 616c 7322 2c0a   Of Materials",.
-00010bc0: 2020 2020 2020 2020 2049 6e67 656e 696f           Ingenio
-00010bd0: 7273 7665 7465 6e73 6b61 7073 616b 6164  rsvetenskapsakad
-00010be0: 656d 6965 6e73 2048 616e 646c 696e 6761  emiens Handlinga
-00010bf0: 7220 4e72 2031 3531 2c20 3139 3339 2c0a  r Nr 151, 1939,.
-00010c00: 2020 2020 2020 2020 2047 656e 6572 616c           General
-00010c10: 7374 6162 656e 7320 4c69 746f 6772 6166  stabens Litograf
-00010c20: 6973 6b61 2041 6e73 7461 6c74 7320 466f  iska Anstalts Fo
-00010c30: 726c 6167 2c20 5374 6f63 6b68 6f6c 6d2e  rlag, Stockholm.
-00010c40: 0a20 202e 2e20 5b32 5d20 5761 6c6f 6464  .  .. [2] Walodd
-00010c50: 6920 5765 6962 756c 6c2c 2022 4120 5374  i Weibull, "A St
-00010c60: 6174 6973 7469 6361 6c20 4469 7374 7269  atistical Distri
-00010c70: 6275 7469 6f6e 2046 756e 6374 696f 6e20  bution Function 
-00010c80: 6f66 0a20 2020 2020 2020 2020 5769 6465  of.         Wide
-00010c90: 2041 7070 6c69 6361 6269 6c69 7479 222c   Applicability",
-00010ca0: 204a 6f75 726e 616c 204f 6620 4170 706c   Journal Of Appl
-00010cb0: 6965 6420 4d65 6368 616e 6963 7320 4153  ied Mechanics AS
-00010cc0: 4d45 2050 6170 6572 0a20 2020 2020 2020  ME Paper.       
-00010cd0: 2020 3139 3531 2e0a 2020 2e2e 205b 335d    1951..  .. [3]
-00010ce0: 2057 696b 6970 6564 6961 2c20 2257 6569   Wikipedia, "Wei
-00010cf0: 6275 6c6c 2064 6973 7472 6962 7574 696f  bull distributio
-00010d00: 6e22 2c0a 2020 2020 2020 2020 2068 7474  n",.         htt
-00010d10: 7073 3a2f 2f65 6e2e 7769 6b69 7065 6469  ps://en.wikipedi
-00010d20: 612e 6f72 672f 7769 6b69 2f57 6569 6275  a.org/wiki/Weibu
-00010d30: 6c6c 5f64 6973 7472 6962 7574 696f 6e0a  ll_distribution.
-00010d40: 0a20 2045 7861 6d70 6c65 730a 2020 2d2d  .  Examples.  --
-00010d50: 2d2d 2d2d 2d2d 0a20 2044 7261 7720 7361  ------.  Draw sa
-00010d60: 6d70 6c65 7320 6672 6f6d 2074 6865 2064  mples from the d
-00010d70: 6973 7472 6962 7574 696f 6e3a 0a0a 2020  istribution:..  
-00010d80: 3e3e 3e20 6120 3d20 352e 2023 2073 6861  >>> a = 5. # sha
-00010d90: 7065 0a20 203e 3e3e 2073 203d 2062 7261  pe.  >>> s = bra
-00010da0: 696e 7079 2e6d 6174 682e 7261 6e64 6f6d  inpy.math.random
-00010db0: 2e77 6569 6275 6c6c 2861 2c20 3130 3030  .weibull(a, 1000
-00010dc0: 290a 0a20 2044 6973 706c 6179 2074 6865  )..  Display the
-00010dd0: 2068 6973 746f 6772 616d 206f 6620 7468   histogram of th
-00010de0: 6520 7361 6d70 6c65 732c 2061 6c6f 6e67  e samples, along
-00010df0: 2077 6974 680a 2020 7468 6520 7072 6f62   with.  the prob
-00010e00: 6162 696c 6974 7920 6465 6e73 6974 7920  ability density 
-00010e10: 6675 6e63 7469 6f6e 3a0a 0a20 203e 3e3e  function:..  >>>
-00010e20: 2069 6d70 6f72 7420 6d61 7470 6c6f 746c   import matplotl
-00010e30: 6962 2e70 7970 6c6f 7420 6173 2070 6c74  ib.pyplot as plt
-00010e40: 0a20 203e 3e3e 2078 203d 206e 702e 6172  .  >>> x = np.ar
-00010e50: 616e 6765 2831 2c31 3030 2e29 2f35 302e  ange(1,100.)/50.
-00010e60: 0a20 203e 3e3e 2064 6566 2077 6569 6228  .  >>> def weib(
-00010e70: 782c 6e2c 6129 3a0a 2020 2e2e 2e20 2020  x,n,a):.  ...   
-00010e80: 2020 7265 7475 726e 2028 6120 2f20 6e29    return (a / n)
-00010e90: 202a 2028 7820 2f20 6e29 2a2a 2861 202d   * (x / n)**(a -
-00010ea0: 2031 2920 2a20 6e70 2e65 7870 282d 2878   1) * np.exp(-(x
-00010eb0: 202f 206e 292a 2a61 290a 0a20 203e 3e3e   / n)**a)..  >>>
-00010ec0: 2063 6f75 6e74 2c20 6269 6e73 2c20 6967   count, bins, ig
-00010ed0: 6e6f 7265 6420 3d20 706c 742e 6869 7374  nored = plt.hist
-00010ee0: 2862 7261 696e 7079 2e6d 6174 682e 7261  (brainpy.math.ra
-00010ef0: 6e64 6f6d 2e77 6569 6275 6c6c 2835 2e2c  ndom.weibull(5.,
-00010f00: 3130 3030 2929 0a20 203e 3e3e 2078 203d  1000)).  >>> x =
-00010f10: 206e 702e 6172 616e 6765 2831 2c31 3030   np.arange(1,100
-00010f20: 2e29 2f35 302e 0a20 203e 3e3e 2073 6361  .)/50..  >>> sca
-00010f30: 6c65 203d 2063 6f75 6e74 2e6d 6178 2829  le = count.max()
-00010f40: 2f77 6569 6228 782c 2031 2e2c 2035 2e29  /weib(x, 1., 5.)
-00010f50: 2e6d 6178 2829 0a20 203e 3e3e 2070 6c74  .max().  >>> plt
-00010f60: 2e70 6c6f 7428 782c 2077 6569 6228 782c  .plot(x, weib(x,
-00010f70: 2031 2e2c 2035 2e29 2a73 6361 6c65 290a   1., 5.)*scale).
-00010f80: 2020 3e3e 3e20 706c 742e 7368 6f77 2829    >>> plt.show()
-00010f90: 0a0a 2020 2222 220a 2020 7265 7475 726e  ..  """.  return
-00010fa0: 2044 4546 4155 4c54 2e77 6569 6275 6c6c   DEFAULT.weibull
-00010fb0: 2861 2c20 7369 7a65 2c20 6b65 793d 6b65  (a, size, key=ke
-00010fc0: 7929 0a0a 0a64 6566 2077 6569 6275 6c6c  y)...def weibull
-00010fd0: 5f6d 696e 2861 2c20 7363 616c 653d 4e6f  _min(a, scale=No
-00010fe0: 6e65 2c20 7369 7a65 3d4e 6f6e 652c 206b  ne, size=None, k
-00010ff0: 6579 3d4e 6f6e 6529 3a0a 2020 2222 2253  ey=None):.  """S
-00011000: 616d 706c 6520 6672 6f6d 2061 2057 6569  ample from a Wei
-00011010: 6275 6c6c 2064 6973 7472 6962 7574 696f  bull distributio
-00011020: 6e2e 0a0a 2020 5468 6520 7363 6970 7920  n...  The scipy 
-00011030: 636f 756e 7465 7270 6172 7420 6973 2060  counterpart is `
-00011040: 7363 6970 792e 7374 6174 732e 7765 6962  scipy.stats.weib
-00011050: 756c 6c5f 6d69 6e60 2e0a 0a20 2041 7267  ull_min`...  Arg
-00011060: 733a 0a20 2020 2073 6361 6c65 3a20 5468  s:.    scale: Th
-00011070: 6520 7363 616c 6520 7061 7261 6d65 7465  e scale paramete
-00011080: 7220 6f66 2074 6865 2064 6973 7472 6962  r of the distrib
-00011090: 7574 696f 6e2e 0a20 2020 2063 6f6e 6365  ution..    conce
-000110a0: 6e74 7261 7469 6f6e 3a20 5468 6520 636f  ntration: The co
-000110b0: 6e63 656e 7472 6174 696f 6e20 7061 7261  ncentration para
-000110c0: 6d65 7465 7220 6f66 2074 6865 2064 6973  meter of the dis
-000110d0: 7472 6962 7574 696f 6e2e 0a20 2020 2073  tribution..    s
-000110e0: 6861 7065 3a20 5468 6520 7368 6170 6520  hape: The shape 
-000110f0: 6164 6465 6420 746f 2074 6865 2070 6172  added to the par
-00011100: 616d 6574 6572 7320 6c6f 6320 616e 6420  ameters loc and 
-00011110: 7363 616c 6520 6272 6f61 6463 6173 7461  scale broadcasta
-00011120: 626c 6520 7368 6170 652e 0a20 2020 2064  ble shape..    d
-00011130: 7479 7065 3a20 5468 6520 7479 7065 2075  type: The type u
-00011140: 7365 6420 666f 7220 7361 6d70 6c65 732e  sed for samples.
-00011150: 0a20 2020 206b 6579 3a20 6120 5052 4e47  .    key: a PRNG
-00011160: 206b 6579 206f 7220 6120 7365 6564 2e0a   key or a seed..
-00011170: 0a20 2052 6574 7572 6e73 3a0a 2020 2020  .  Returns:.    
-00011180: 4120 6a6e 702e 6172 7261 7920 6f66 2073  A jnp.array of s
-00011190: 616d 706c 6573 2e0a 0a20 2022 2222 0a20  amples...  """. 
-000111a0: 2072 6574 7572 6e20 4445 4641 554c 542e   return DEFAULT.
-000111b0: 7765 6962 756c 6c5f 6d69 6e28 612c 2073  weibull_min(a, s
-000111c0: 6361 6c65 2c20 7369 7a65 2c20 6b65 793d  cale, size, key=
-000111d0: 6b65 7929 0a0a 0a64 6566 207a 6970 6628  key)...def zipf(
-000111e0: 612c 2073 697a 653d 4e6f 6e65 2c20 6b65  a, size=None, ke
-000111f0: 793d 4e6f 6e65 293a 0a20 2072 2222 220a  y=None):.  r""".
-00011200: 2020 4472 6177 2073 616d 706c 6573 2066    Draw samples f
-00011210: 726f 6d20 6120 5a69 7066 2064 6973 7472  rom a Zipf distr
-00011220: 6962 7574 696f 6e2e 0a0a 2020 5361 6d70  ibution...  Samp
-00011230: 6c65 7320 6172 6520 6472 6177 6e20 6672  les are drawn fr
-00011240: 6f6d 2061 205a 6970 6620 6469 7374 7269  om a Zipf distri
-00011250: 6275 7469 6f6e 2077 6974 6820 7370 6563  bution with spec
-00011260: 6966 6965 6420 7061 7261 6d65 7465 720a  ified parameter.
-00011270: 2020 6061 6020 3e20 312e 0a0a 2020 5468    `a` > 1...  Th
-00011280: 6520 5a69 7066 2064 6973 7472 6962 7574  e Zipf distribut
-00011290: 696f 6e20 2861 6c73 6f20 6b6e 6f77 6e20  ion (also known 
-000112a0: 6173 2074 6865 207a 6574 6120 6469 7374  as the zeta dist
-000112b0: 7269 6275 7469 6f6e 2920 6973 2061 0a20  ribution) is a. 
-000112c0: 2064 6973 6372 6574 6520 7072 6f62 6162   discrete probab
-000112d0: 696c 6974 7920 6469 7374 7269 6275 7469  ility distributi
-000112e0: 6f6e 2074 6861 7420 7361 7469 7366 6965  on that satisfie
-000112f0: 7320 5a69 7066 2773 206c 6177 3a20 7468  s Zipf's law: th
-00011300: 650a 2020 6672 6571 7565 6e63 7920 6f66  e.  frequency of
-00011310: 2061 6e20 6974 656d 2069 7320 696e 7665   an item is inve
-00011320: 7273 656c 7920 7072 6f70 6f72 7469 6f6e  rsely proportion
-00011330: 616c 2074 6f20 6974 7320 7261 6e6b 2069  al to its rank i
-00011340: 6e20 610a 2020 6672 6571 7565 6e63 7920  n a.  frequency 
-00011350: 7461 626c 652e 0a0a 2020 2e2e 206e 6f74  table...  .. not
-00011360: 653a 3a0a 2020 2020 2020 4e65 7720 636f  e::.      New co
-00011370: 6465 2073 686f 756c 6420 7573 6520 7468  de should use th
-00011380: 6520 6060 7a69 7066 6060 206d 6574 686f  e ``zipf`` metho
-00011390: 6420 6f66 2061 2060 6064 6566 6175 6c74  d of a ``default
-000113a0: 5f72 6e67 2829 6060 0a20 2020 2020 2069  _rng()``.      i
-000113b0: 6e73 7461 6e63 6520 696e 7374 6561 643b  nstance instead;
-000113c0: 2070 6c65 6173 6520 7365 6520 7468 6520   please see the 
-000113d0: 3a72 6566 3a60 7261 6e64 6f6d 2d71 7569  :ref:`random-qui
-000113e0: 636b 2d73 7461 7274 602e 0a0a 2020 5061  ck-start`...  Pa
-000113f0: 7261 6d65 7465 7273 0a20 202d 2d2d 2d2d  rameters.  -----
-00011400: 2d2d 2d2d 2d0a 2020 6120 3a20 666c 6f61  -----.  a : floa
-00011410: 7420 6f72 2061 7272 6179 5f6c 696b 6520  t or array_like 
-00011420: 6f66 2066 6c6f 6174 730a 2020 2020 2020  of floats.      
-00011430: 4469 7374 7269 6275 7469 6f6e 2070 6172  Distribution par
-00011440: 616d 6574 6572 2e20 4d75 7374 2062 6520  ameter. Must be 
-00011450: 6772 6561 7465 7220 7468 616e 2031 2e0a  greater than 1..
-00011460: 2020 7369 7a65 203a 2069 6e74 206f 7220    size : int or 
-00011470: 7475 706c 6520 6f66 2069 6e74 732c 206f  tuple of ints, o
-00011480: 7074 696f 6e61 6c0a 2020 2020 2020 4f75  ptional.      Ou
-00011490: 7470 7574 2073 6861 7065 2e20 2049 6620  tput shape.  If 
-000114a0: 7468 6520 6769 7665 6e20 7368 6170 6520  the given shape 
-000114b0: 6973 2c20 652e 672e 2c20 6060 286d 2c20  is, e.g., ``(m, 
-000114c0: 6e2c 206b 2960 602c 2074 6865 6e0a 2020  n, k)``, then.  
-000114d0: 2020 2020 6060 6d20 2a20 6e20 2a20 6b60      ``m * n * k`
-000114e0: 6020 7361 6d70 6c65 7320 6172 6520 6472  ` samples are dr
-000114f0: 6177 6e2e 2020 4966 2073 697a 6520 6973  awn.  If size is
-00011500: 2060 604e 6f6e 6560 6020 2864 6566 6175   ``None`` (defau
-00011510: 6c74 292c 0a20 2020 2020 2061 2073 696e  lt),.      a sin
-00011520: 676c 6520 7661 6c75 6520 6973 2072 6574  gle value is ret
-00011530: 7572 6e65 6420 6966 2060 6061 6060 2069  urned if ``a`` i
-00011540: 7320 6120 7363 616c 6172 2e20 4f74 6865  s a scalar. Othe
-00011550: 7277 6973 652c 0a20 2020 2020 2060 606e  rwise,.      ``n
-00011560: 702e 6172 7261 7928 6129 2e73 697a 6560  p.array(a).size`
-00011570: 6020 7361 6d70 6c65 7320 6172 6520 6472  ` samples are dr
-00011580: 6177 6e2e 0a0a 2020 5265 7475 726e 730a  awn...  Returns.
-00011590: 2020 2d2d 2d2d 2d2d 2d0a 2020 6f75 7420    -------.  out 
-000115a0: 3a20 6e64 6172 7261 7920 6f72 2073 6361  : ndarray or sca
-000115b0: 6c61 720a 2020 2020 2020 4472 6177 6e20  lar.      Drawn 
-000115c0: 7361 6d70 6c65 7320 6672 6f6d 2074 6865  samples from the
-000115d0: 2070 6172 616d 6574 6572 697a 6564 205a   parameterized Z
-000115e0: 6970 6620 6469 7374 7269 6275 7469 6f6e  ipf distribution
-000115f0: 2e0a 0a20 2053 6565 2041 6c73 6f0a 2020  ...  See Also.  
-00011600: 2d2d 2d2d 2d2d 2d2d 0a20 2073 6369 7079  --------.  scipy
-00011610: 2e73 7461 7473 2e7a 6970 6620 3a20 7072  .stats.zipf : pr
-00011620: 6f62 6162 696c 6974 7920 6465 6e73 6974  obability densit
-00011630: 7920 6675 6e63 7469 6f6e 2c20 6469 7374  y function, dist
-00011640: 7269 6275 7469 6f6e 2c20 6f72 0a20 2020  ribution, or.   
-00011650: 2020 2063 756d 756c 6174 6976 6520 6465     cumulative de
-00011660: 6e73 6974 7920 6675 6e63 7469 6f6e 2c20  nsity function, 
-00011670: 6574 632e 0a20 2072 616e 646f 6d2e 4765  etc..  random.Ge
-00011680: 6e65 7261 746f 722e 7a69 7066 3a20 7768  nerator.zipf: wh
-00011690: 6963 6820 7368 6f75 6c64 2062 6520 7573  ich should be us
-000116a0: 6564 2066 6f72 206e 6577 2063 6f64 652e  ed for new code.
-000116b0: 0a0a 2020 4e6f 7465 730a 2020 2d2d 2d2d  ..  Notes.  ----
-000116c0: 2d0a 2020 5468 6520 7072 6f62 6162 696c  -.  The probabil
-000116d0: 6974 7920 6465 6e73 6974 7920 666f 7220  ity density for 
-000116e0: 7468 6520 5a69 7066 2064 6973 7472 6962  the Zipf distrib
-000116f0: 7574 696f 6e20 6973 0a0a 2020 2e2e 206d  ution is..  .. m
-00011700: 6174 683a 3a20 7028 6b29 203d 205c 6672  ath:: p(k) = \fr
-00011710: 6163 7b6b 5e7b 2d61 7d7d 7b5c 7a65 7461  ac{k^{-a}}{\zeta
-00011720: 2861 297d 2c0a 0a20 2066 6f72 2069 6e74  (a)},..  for int
-00011730: 6567 6572 7320 3a6d 6174 683a 606b 205c  egers :math:`k \
-00011740: 6765 7120 3160 2c20 7768 6572 6520 3a6d  geq 1`, where :m
-00011750: 6174 683a 605c 7a65 7461 6020 6973 2074  ath:`\zeta` is t
-00011760: 6865 2052 6965 6d61 6e6e 205a 6574 610a  he Riemann Zeta.
-00011770: 2020 6675 6e63 7469 6f6e 2e0a 0a20 2049    function...  I
-00011780: 7420 6973 206e 616d 6564 2066 6f72 2074  t is named for t
-00011790: 6865 2041 6d65 7269 6361 6e20 6c69 6e67  he American ling
-000117a0: 7569 7374 2047 656f 7267 6520 4b69 6e67  uist George King
-000117b0: 736c 6579 205a 6970 662c 2077 686f 206e  sley Zipf, who n
-000117c0: 6f74 6564 0a20 2074 6861 7420 7468 6520  oted.  that the 
-000117d0: 6672 6571 7565 6e63 7920 6f66 2061 6e79  frequency of any
-000117e0: 2077 6f72 6420 696e 2061 2073 616d 706c   word in a sampl
-000117f0: 6520 6f66 2061 206c 616e 6775 6167 6520  e of a language 
-00011800: 6973 2069 6e76 6572 7365 6c79 0a20 2070  is inversely.  p
-00011810: 726f 706f 7274 696f 6e61 6c20 746f 2069  roportional to i
-00011820: 7473 2072 616e 6b20 696e 2074 6865 2066  ts rank in the f
-00011830: 7265 7175 656e 6379 2074 6162 6c65 2e0a  requency table..
-00011840: 0a20 2052 6566 6572 656e 6365 730a 2020  .  References.  
-00011850: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 202e 2e20  ----------.  .. 
-00011860: 5b31 5d20 5a69 7066 2c20 472e 204b 2e2c  [1] Zipf, G. K.,
-00011870: 2022 5365 6c65 6374 6564 2053 7475 6469   "Selected Studi
-00011880: 6573 206f 6620 7468 6520 5072 696e 6369  es of the Princi
-00011890: 706c 6520 6f66 2052 656c 6174 6976 650a  ple of Relative.
-000118a0: 2020 2020 2020 2020 2046 7265 7175 656e           Frequen
-000118b0: 6379 2069 6e20 4c61 6e67 7561 6765 2c22  cy in Language,"
-000118c0: 2043 616d 6272 6964 6765 2c20 4d41 3a20   Cambridge, MA: 
-000118d0: 4861 7276 6172 6420 556e 6976 2e20 5072  Harvard Univ. Pr
-000118e0: 6573 732c 0a20 2020 2020 2020 2020 3139  ess,.         19
-000118f0: 3332 2e0a 0a20 2045 7861 6d70 6c65 730a  32...  Examples.
-00011900: 2020 2d2d 2d2d 2d2d 2d2d 0a20 2044 7261    --------.  Dra
-00011910: 7720 7361 6d70 6c65 7320 6672 6f6d 2074  w samples from t
-00011920: 6865 2064 6973 7472 6962 7574 696f 6e3a  he distribution:
-00011930: 0a0a 2020 3e3e 3e20 6120 3d20 342e 300a  ..  >>> a = 4.0.
-00011940: 2020 3e3e 3e20 6e20 3d20 3230 3030 300a    >>> n = 20000.
-00011950: 2020 3e3e 3e20 7320 3d20 6272 6169 6e70    >>> s = brainp
-00011960: 792e 6d61 7468 2e72 616e 646f 6d2e 7a69  y.math.random.zi
-00011970: 7066 2861 2c20 6e29 0a0a 2020 4469 7370  pf(a, n)..  Disp
-00011980: 6c61 7920 7468 6520 6869 7374 6f67 7261  lay the histogra
-00011990: 6d20 6f66 2074 6865 2073 616d 706c 6573  m of the samples
-000119a0: 2c20 616c 6f6e 6720 7769 7468 0a20 2074  , along with.  t
-000119b0: 6865 2065 7870 6563 7465 6420 6869 7374  he expected hist
-000119c0: 6f67 7261 6d20 6261 7365 6420 6f6e 2074  ogram based on t
-000119d0: 6865 2070 726f 6261 6269 6c69 7479 0a20  he probability. 
-000119e0: 2064 656e 7369 7479 2066 756e 6374 696f   density functio
-000119f0: 6e3a 0a0a 2020 3e3e 3e20 696d 706f 7274  n:..  >>> import
-00011a00: 206d 6174 706c 6f74 6c69 622e 7079 706c   matplotlib.pypl
-00011a10: 6f74 2061 7320 706c 740a 2020 3e3e 3e20  ot as plt.  >>> 
-00011a20: 6672 6f6d 2073 6369 7079 2e73 7065 6369  from scipy.speci
-00011a30: 616c 2069 6d70 6f72 7420 7a65 7461 2020  al import zeta  
-00011a40: 2320 646f 6374 6573 743a 202b 534b 4950  # doctest: +SKIP
-00011a50: 0a0a 2020 6062 696e 636f 756e 7460 2070  ..  `bincount` p
-00011a60: 726f 7669 6465 7320 6120 6661 7374 2068  rovides a fast h
-00011a70: 6973 746f 6772 616d 2066 6f72 2073 6d61  istogram for sma
-00011a80: 6c6c 2069 6e74 6567 6572 732e 0a0a 2020  ll integers...  
-00011a90: 3e3e 3e20 636f 756e 7420 3d20 6e70 2e62  >>> count = np.b
-00011aa0: 696e 636f 756e 7428 7329 0a20 203e 3e3e  incount(s).  >>>
-00011ab0: 206b 203d 206e 702e 6172 616e 6765 2831   k = np.arange(1
-00011ac0: 2c20 732e 6d61 7828 2920 2b20 3129 0a0a  , s.max() + 1)..
-00011ad0: 2020 3e3e 3e20 706c 742e 6261 7228 6b2c    >>> plt.bar(k,
-00011ae0: 2063 6f75 6e74 5b31 3a5d 2c20 616c 7068   count[1:], alph
-00011af0: 613d 302e 352c 206c 6162 656c 3d27 7361  a=0.5, label='sa
-00011b00: 6d70 6c65 2063 6f75 6e74 2729 0a20 203e  mple count').  >
-00011b10: 3e3e 2070 6c74 2e70 6c6f 7428 6b2c 206e  >> plt.plot(k, n
-00011b20: 2a28 6b2a 2a2d 6129 2f7a 6574 6128 6129  *(k**-a)/zeta(a)
-00011b30: 2c20 276b 2e2d 272c 2061 6c70 6861 3d30  , 'k.-', alpha=0
-00011b40: 2e35 2c0a 2020 2e2e 2e20 2020 2020 2020  .5,.  ...       
-00011b50: 2020 206c 6162 656c 3d27 6578 7065 6374     label='expect
-00011b60: 6564 2063 6f75 6e74 2729 2020 2023 2064  ed count')   # d
-00011b70: 6f63 7465 7374 3a20 2b53 4b49 500a 2020  octest: +SKIP.  
-00011b80: 3e3e 3e20 706c 742e 7365 6d69 6c6f 6779  >>> plt.semilogy
-00011b90: 2829 0a20 203e 3e3e 2070 6c74 2e67 7269  ().  >>> plt.gri
-00011ba0: 6428 616c 7068 613d 302e 3429 0a20 203e  d(alpha=0.4).  >
-00011bb0: 3e3e 2070 6c74 2e6c 6567 656e 6428 290a  >> plt.legend().
-00011bc0: 2020 3e3e 3e20 706c 742e 7469 746c 6528    >>> plt.title(
-00011bd0: 6627 5a69 7066 2073 616d 706c 652c 2061  f'Zipf sample, a
-00011be0: 3d7b 617d 2c20 7369 7a65 3d7b 6e7d 2729  ={a}, size={n}')
-00011bf0: 0a20 203e 3e3e 2070 6c74 2e73 686f 7728  .  >>> plt.show(
-00011c00: 290a 2020 2222 220a 2020 7265 7475 726e  ).  """.  return
-00011c10: 2044 4546 4155 4c54 2e7a 6970 6628 612c   DEFAULT.zipf(a,
-00011c20: 2073 697a 652c 206b 6579 3d6b 6579 290a   size, key=key).
-00011c30: 0a0a 6465 6620 6d61 7877 656c 6c28 7369  ..def maxwell(si
-00011c40: 7a65 3d4e 6f6e 652c 206b 6579 3d4e 6f6e  ze=None, key=Non
-00011c50: 6529 3a0a 2020 2222 2253 616d 706c 6520  e):.  """Sample 
-00011c60: 6672 6f6d 2061 206f 6e65 2073 6964 6564  from a one sided
-00011c70: 204d 6178 7765 6c6c 2064 6973 7472 6962   Maxwell distrib
-00011c80: 7574 696f 6e2e 0a0a 2020 5468 6520 7363  ution...  The sc
-00011c90: 6970 7920 636f 756e 7465 7270 6172 7420  ipy counterpart 
-00011ca0: 6973 2060 7363 6970 792e 7374 6174 732e  is `scipy.stats.
-00011cb0: 6d61 7877 656c 6c60 2e0a 0a20 2041 7267  maxwell`...  Arg
-00011cc0: 733a 0a20 2020 206b 6579 3a20 6120 5052  s:.    key: a PR
-00011cd0: 4e47 206b 6579 2e0a 2020 2020 7369 7a65  NG key..    size
-00011ce0: 3a20 5468 6520 7368 6170 6520 6f66 2074  : The shape of t
-00011cf0: 6865 2072 6574 7572 6e65 6420 7361 6d70  he returned samp
-00011d00: 6c65 732e 0a20 2020 2064 7479 7065 3a20  les..    dtype: 
-00011d10: 5468 6520 7479 7065 2075 7365 6420 666f  The type used fo
-00011d20: 7220 7361 6d70 6c65 732e 0a0a 2020 5265  r samples...  Re
-00011d30: 7475 726e 733a 0a20 2020 2041 206a 6e70  turns:.    A jnp
-00011d40: 2e61 7272 6179 206f 6620 7361 6d70 6c65  .array of sample
-00011d50: 732c 206f 6620 7368 6170 6520 6073 6861  s, of shape `sha
-00011d60: 7065 602e 0a0a 2020 2222 220a 2020 7265  pe`...  """.  re
-00011d70: 7475 726e 2044 4546 4155 4c54 2e6d 6178  turn DEFAULT.max
-00011d80: 7765 6c6c 2873 697a 652c 206b 6579 3d6b  well(size, key=k
-00011d90: 6579 290a 0a0a 6465 6620 7428 6466 2c20  ey)...def t(df, 
-00011da0: 7369 7a65 3d4e 6f6e 652c 206b 6579 3d4e  size=None, key=N
-00011db0: 6f6e 6529 3a0a 2020 2222 2253 616d 706c  one):.  """Sampl
-00011dc0: 6520 5374 7564 656e 74e2 8099 7320 7420  e Student...s t 
-00011dd0: 7261 6e64 6f6d 2076 616c 7565 732e 0a0a  random values...
-00011de0: 2020 5061 7261 6d65 7465 7273 0a20 202d    Parameters.  -
-00011df0: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 6466 3a20  ---------.  df: 
-00011e00: 666c 6f61 742c 2061 7272 6179 5f6c 696b  float, array_lik
-00011e10: 650a 2020 2020 4120 666c 6f61 7420 6f72  e.    A float or
-00011e20: 2061 7272 6179 206f 6620 666c 6f61 7473   array of floats
-00011e30: 2062 726f 6164 6361 7374 2d63 6f6d 7061   broadcast-compa
-00011e40: 7469 626c 6520 7769 7468 2073 6861 7065  tible with shape
-00011e50: 2072 6570 7265 7365 6e74 696e 6720 7468   representing th
-00011e60: 6520 7061 7261 6d65 7465 7220 6f66 2074  e parameter of t
-00011e70: 6865 2064 6973 7472 6962 7574 696f 6e2e  he distribution.
-00011e80: 0a20 2073 697a 653a 206f 7074 696f 6e61  .  size: optiona
-00011e90: 6c2c 2069 6e74 2c20 7475 706c 6520 6f66  l, int, tuple of
-00011ea0: 2069 6e74 0a20 2020 2041 2074 7570 6c65   int.    A tuple
-00011eb0: 206f 6620 6e6f 6e2d 6e65 6761 7469 7665   of non-negative
-00011ec0: 2069 6e74 6567 6572 7320 7370 6563 6966   integers specif
-00011ed0: 7969 6e67 2074 6865 2072 6573 756c 7420  ying the result 
-00011ee0: 7368 6170 652e 0a20 2020 204d 7573 7420  shape..    Must 
-00011ef0: 6265 2062 726f 6164 6361 7374 2d63 6f6d  be broadcast-com
-00011f00: 7061 7469 626c 6520 7769 7468 2060 6466  patible with `df
-00011f10: 602e 2054 6865 2064 6566 6175 6c74 2028  `. The default (
-00011f20: 4e6f 6e65 2920 7072 6f64 7563 6573 2061  None) produces a
-00011f30: 2072 6573 756c 7420 7368 6170 6520 6571   result shape eq
-00011f40: 7561 6c20 746f 2060 6466 2e73 6861 7065  ual to `df.shape
-00011f50: 602e 0a0a 2020 5265 7475 726e 730a 2020  `...  Returns.  
-00011f60: 2d2d 2d2d 2d2d 2d0a 2020 6f75 743a 2061  -------.  out: a
-00011f70: 7272 6179 5f6c 696b 650a 2020 2020 5468  rray_like.    Th
-00011f80: 6520 7361 6d70 6c65 6420 7661 6c75 652e  e sampled value.
-00011f90: 0a20 2022 2222 0a20 2072 6574 7572 6e20  .  """.  return 
-00011fa0: 4445 4641 554c 542e 7428 6466 2c20 7369  DEFAULT.t(df, si
-00011fb0: 7a65 2c20 6b65 793d 6b65 7929 0a0a 0a64  ze, key=key)...d
-00011fc0: 6566 206f 7274 686f 676f 6e61 6c28 6e3a  ef orthogonal(n:
-00011fd0: 2069 6e74 2c20 7369 7a65 3d4e 6f6e 652c   int, size=None,
-00011fe0: 206b 6579 3d4e 6f6e 6529 3a0a 2020 2222   key=None):.  ""
-00011ff0: 2253 616d 706c 6520 756e 6966 6f72 6d6c  "Sample uniforml
-00012000: 7920 6672 6f6d 2074 6865 206f 7274 686f  y from the ortho
-00012010: 676f 6e61 6c20 6772 6f75 7020 604f 286e  gonal group `O(n
-00012020: 2960 2e0a 0a20 2050 6172 616d 6574 6572  )`...  Parameter
-00012030: 730a 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  s.  ----------. 
-00012040: 206e 3a20 696e 740a 2020 2020 2041 6e20   n: int.     An 
-00012050: 696e 7465 6765 7220 696e 6469 6361 7469  integer indicati
-00012060: 6e67 2074 6865 2072 6573 756c 7469 6e67  ng the resulting
-00012070: 2064 696d 656e 7369 6f6e 2e0a 2020 7369   dimension..  si
-00012080: 7a65 3a20 6f70 7469 6f6e 616c 2c20 696e  ze: optional, in
-00012090: 742c 2074 7570 6c65 206f 6620 696e 740a  t, tuple of int.
-000120a0: 2020 2020 5468 6520 6261 7463 6820 6469      The batch di
-000120b0: 6d65 6e73 696f 6e73 206f 6620 7468 6520  mensions of the 
-000120c0: 7265 7375 6c74 2e0a 0a20 2052 6574 7572  result...  Retur
-000120d0: 6e73 0a20 202d 2d2d 2d2d 2d2d 0a20 206f  ns.  -------.  o
-000120e0: 7574 3a20 4172 7261 790a 2020 2020 5468  ut: Array.    Th
-000120f0: 6520 7361 6d70 6c65 6420 7265 7375 6c74  e sampled result
-00012100: 732e 0a20 2022 2222 0a20 2072 6574 7572  s..  """.  retur
-00012110: 6e20 4445 4641 554c 542e 6f72 7468 6f67  n DEFAULT.orthog
-00012120: 6f6e 616c 286e 2c20 7369 7a65 2c20 6b65  onal(n, size, ke
-00012130: 793d 6b65 7929 0a0a 0a64 6566 206c 6f67  y=key)...def log
-00012140: 6761 6d6d 6128 612c 2073 697a 653d 4e6f  gamma(a, size=No
-00012150: 6e65 2c20 6b65 793d 4e6f 6e65 293a 0a20  ne, key=None):. 
-00012160: 2022 2222 5361 6d70 6c65 206c 6f67 2d67   """Sample log-g
-00012170: 616d 6d61 2072 616e 646f 6d20 7661 6c75  amma random valu
-00012180: 6573 2e0a 0a20 2050 6172 616d 6574 6572  es...  Parameter
-00012190: 730a 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  s.  ----------. 
-000121a0: 2061 3a20 666c 6f61 742c 2061 7272 6179   a: float, array
-000121b0: 5f6c 696b 650a 2020 2020 4120 666c 6f61  _like.    A floa
-000121c0: 7420 6f72 2061 7272 6179 206f 6620 666c  t or array of fl
-000121d0: 6f61 7473 2062 726f 6164 6361 7374 2d63  oats broadcast-c
-000121e0: 6f6d 7061 7469 626c 6520 7769 7468 2073  ompatible with s
-000121f0: 6861 7065 2072 6570 7265 7365 6e74 696e  hape representin
-00012200: 6720 7468 6520 7061 7261 6d65 7465 7220  g the parameter 
-00012210: 6f66 2074 6865 2064 6973 7472 6962 7574  of the distribut
-00012220: 696f 6e2e 0a20 2073 697a 653a 206f 7074  ion..  size: opt
-00012230: 696f 6e61 6c2c 2069 6e74 2c20 7475 706c  ional, int, tupl
-00012240: 6520 6f66 2069 6e74 0a20 2020 2041 2074  e of int.    A t
-00012250: 7570 6c65 206f 6620 6e6f 6e6e 6567 6174  uple of nonnegat
-00012260: 6976 6520 696e 7465 6765 7273 2073 7065  ive integers spe
-00012270: 6369 6679 696e 6720 7468 6520 7265 7375  cifying the resu
-00012280: 6c74 2073 6861 7065 2e0a 2020 2020 4d75  lt shape..    Mu
-00012290: 7374 2062 6520 6272 6f61 6463 6173 742d  st be broadcast-
-000122a0: 636f 6d70 6174 6962 6c65 2077 6974 6820  compatible with 
-000122b0: 6061 602e 2054 6865 2064 6566 6175 6c74  `a`. The default
-000122c0: 2028 4e6f 6e65 2920 7072 6f64 7563 6573   (None) produces
-000122d0: 2061 2072 6573 756c 7420 7368 6170 6520   a result shape 
-000122e0: 6571 7561 6c20 746f 2060 612e 7368 6170  equal to `a.shap
-000122f0: 6560 2e0a 0a20 2052 6574 7572 6e73 0a20  e`...  Returns. 
-00012300: 202d 2d2d 2d2d 2d2d 0a20 206f 7574 3a20   -------.  out: 
-00012310: 6172 7261 795f 6c69 6b65 0a20 2020 2054  array_like.    T
-00012320: 6865 2073 616d 706c 6564 2072 6573 756c  he sampled resul
-00012330: 7473 2e0a 2020 2222 220a 2020 7265 7475  ts..  """.  retu
-00012340: 726e 2044 4546 4155 4c54 2e6c 6f67 6761  rn DEFAULT.logga
-00012350: 6d6d 6128 612c 2073 697a 6529 0a0a 0a64  mma(a, size)...d
-00012360: 6566 2063 6174 6567 6f72 6963 616c 286c  ef categorical(l
-00012370: 6f67 6974 732c 2061 7869 733a 2069 6e74  ogits, axis: int
-00012380: 203d 202d 312c 2073 697a 653d 4e6f 6e65   = -1, size=None
-00012390: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2022  , key=None):.  "
-000123a0: 2222 5361 6d70 6c65 2072 616e 646f 6d20  ""Sample random 
-000123b0: 7661 6c75 6573 2066 726f 6d20 6361 7465  values from cate
-000123c0: 676f 7269 6361 6c20 6469 7374 7269 6275  gorical distribu
-000123d0: 7469 6f6e 732e 0a0a 2020 4172 6773 3a0a  tions...  Args:.
-000123e0: 2020 2020 6c6f 6769 7473 3a20 556e 6e6f      logits: Unno
-000123f0: 726d 616c 697a 6564 206c 6f67 2070 726f  rmalized log pro
-00012400: 6261 6269 6c69 7469 6573 206f 6620 7468  babilities of th
-00012410: 6520 6361 7465 676f 7269 6361 6c20 6469  e categorical di
-00012420: 7374 7269 6275 7469 6f6e 2873 2920 746f  stribution(s) to
-00012430: 2073 616d 706c 6520 6672 6f6d 2c0a 2020   sample from,.  
-00012440: 2020 2020 736f 2074 6861 7420 6073 6f66      so that `sof
-00012450: 746d 6178 286c 6f67 6974 732c 2061 7869  tmax(logits, axi
-00012460: 7329 6020 6769 7665 7320 7468 6520 636f  s)` gives the co
-00012470: 7272 6573 706f 6e64 696e 6720 7072 6f62  rresponding prob
-00012480: 6162 696c 6974 6965 732e 0a20 2020 2061  abilities..    a
-00012490: 7869 733a 2041 7869 7320 616c 6f6e 6720  xis: Axis along 
-000124a0: 7768 6963 6820 6c6f 6769 7473 2062 656c  which logits bel
-000124b0: 6f6e 6720 746f 2074 6865 2073 616d 6520  ong to the same 
-000124c0: 6361 7465 676f 7269 6361 6c20 6469 7374  categorical dist
-000124d0: 7269 6275 7469 6f6e 2e0a 2020 2020 7368  ribution..    sh
-000124e0: 6170 653a 204f 7074 696f 6e61 6c2c 2061  ape: Optional, a
-000124f0: 2074 7570 6c65 206f 6620 6e6f 6e6e 6567   tuple of nonneg
-00012500: 6174 6976 6520 696e 7465 6765 7273 2072  ative integers r
-00012510: 6570 7265 7365 6e74 696e 6720 7468 6520  epresenting the 
-00012520: 7265 7375 6c74 2073 6861 7065 2e0a 2020  result shape..  
-00012530: 2020 2020 4d75 7374 2062 6520 6272 6f61      Must be broa
-00012540: 6463 6173 742d 636f 6d70 6174 6962 6c65  dcast-compatible
-00012550: 2077 6974 6820 6060 6e70 2e64 656c 6574   with ``np.delet
-00012560: 6528 6c6f 6769 7473 2e73 6861 7065 2c20  e(logits.shape, 
-00012570: 6178 6973 2960 602e 0a20 2020 2020 2054  axis)``..      T
-00012580: 6865 2064 6566 6175 6c74 2028 4e6f 6e65  he default (None
-00012590: 2920 7072 6f64 7563 6573 2061 2072 6573  ) produces a res
-000125a0: 756c 7420 7368 6170 6520 6571 7561 6c20  ult shape equal 
-000125b0: 746f 2060 606e 702e 6465 6c65 7465 286c  to ``np.delete(l
-000125c0: 6f67 6974 732e 7368 6170 652c 2061 7869  ogits.shape, axi
-000125d0: 7329 6060 2e0a 2020 2020 6b65 793a 2061  s)``..    key: a
-000125e0: 2050 524e 4720 6b65 7920 7573 6564 2061   PRNG key used a
-000125f0: 7320 7468 6520 7261 6e64 6f6d 206b 6579  s the random key
-00012600: 2e0a 0a20 2052 6574 7572 6e73 3a0a 2020  ...  Returns:.  
-00012610: 2020 4120 7261 6e64 6f6d 2061 7272 6179    A random array
-00012620: 2077 6974 6820 696e 7420 6474 7970 6520   with int dtype 
-00012630: 616e 6420 7368 6170 6520 6769 7665 6e20  and shape given 
-00012640: 6279 2060 6073 6861 7065 6060 2069 6620  by ``shape`` if 
-00012650: 6060 7368 6170 6560 600a 2020 2020 6973  ``shape``.    is
-00012660: 206e 6f74 204e 6f6e 652c 206f 7220 656c   not None, or el
-00012670: 7365 2060 606e 702e 6465 6c65 7465 286c  se ``np.delete(l
-00012680: 6f67 6974 732e 7368 6170 652c 2061 7869  ogits.shape, axi
-00012690: 7329 6060 2e0a 2020 2222 220a 2020 7265  s)``..  """.  re
-000126a0: 7475 726e 2044 4546 4155 4c54 2e63 6174  turn DEFAULT.cat
-000126b0: 6567 6f72 6963 616c 286c 6f67 6974 732c  egorical(logits,
-000126c0: 2061 7869 732c 2073 697a 652c 206b 6579   axis, size, key
-000126d0: 3d6b 6579 290a 0a0a 0a64 6566 2072 616e  =key)....def ran
-000126e0: 645f 6c69 6b65 2869 6e70 7574 2c20 2a2c  d_like(input, *,
-000126f0: 2064 7479 7065 3d4e 6f6e 652c 206b 6579   dtype=None, key
-00012700: 3d4e 6f6e 6529 3a0a 2020 2222 2253 696d  =None):.  """Sim
-00012710: 696c 6172 2074 6f20 6060 7261 6e64 5f6c  ilar to ``rand_l
-00012720: 696b 6560 6020 696e 2074 6f72 6368 2e20  ike`` in torch. 
-00012730: 0a20 200a 2020 5265 7475 726e 7320 6120  .  .  Returns a 
-00012740: 7465 6e73 6f72 2077 6974 6820 7468 6520  tensor with the 
-00012750: 7361 6d65 2073 697a 6520 6173 2069 6e70  same size as inp
-00012760: 7574 2074 6861 7420 6973 2066 696c 6c65  ut that is fille
-00012770: 6420 7769 7468 2072 616e 646f 6d0a 2020  d with random.  
-00012780: 6e75 6d62 6572 7320 6672 6f6d 2061 2075  numbers from a u
-00012790: 6e69 666f 726d 2064 6973 7472 6962 7574  niform distribut
-000127a0: 696f 6e20 6f6e 2074 6865 2069 6e74 6572  ion on the inter
-000127b0: 7661 6c20 6060 5b30 2c20 3129 6060 2e0a  val ``[0, 1)``..
-000127c0: 0a20 2041 7267 733a 0a20 2020 2069 6e70  .  Args:.    inp
-000127d0: 7574 3a20 2074 6865 2060 6073 697a 6560  ut:  the ``size`
-000127e0: 6020 6f66 2069 6e70 7574 2077 696c 6c20  ` of input will 
-000127f0: 6465 7465 726d 696e 6520 7369 7a65 206f  determine size o
-00012800: 6620 7468 6520 6f75 7470 7574 2074 656e  f the output ten
-00012810: 736f 722e 0a20 2020 2064 7479 7065 3a20  sor..    dtype: 
-00012820: 2074 6865 2064 6573 6972 6564 2064 6174   the desired dat
-00012830: 6120 7479 7065 206f 6620 7265 7475 726e  a type of return
-00012840: 6564 2054 656e 736f 722e 2044 6566 6175  ed Tensor. Defau
-00012850: 6c74 3a20 6966 2060 604e 6f6e 6560 602c  lt: if ``None``,
-00012860: 2064 6566 6175 6c74 7320 746f 2074 6865   defaults to the
-00012870: 2064 7479 7065 206f 6620 696e 7075 742e   dtype of input.
-00012880: 0a20 2020 206b 6579 3a20 7468 6520 7365  .    key: the se
-00012890: 6564 206f 7220 6b65 7920 666f 7220 7468  ed or key for th
-000128a0: 6520 7261 6e64 6f6d 2e0a 0a20 2052 6574  e random...  Ret
-000128b0: 7572 6e73 3a0a 2020 2020 5468 6520 7261  urns:.    The ra
-000128c0: 6e64 6f6d 2064 6174 612e 0a20 2022 2222  ndom data..  """
-000128d0: 0a20 2072 6574 7572 6e20 4445 4641 554c  .  return DEFAUL
-000128e0: 542e 7261 6e64 5f6c 696b 6528 696e 7075  T.rand_like(inpu
-000128f0: 742c 2064 7479 7065 3d64 7479 7065 2c20  t, dtype=dtype, 
-00012900: 6b65 793d 6b65 7929 0a0a 6465 6620 7261  key=key)..def ra
-00012910: 6e64 6e5f 6c69 6b65 2869 6e70 7574 2c20  ndn_like(input, 
-00012920: 2a2c 2064 7479 7065 3d4e 6f6e 652c 206b  *, dtype=None, k
-00012930: 6579 3d4e 6f6e 6529 3a0a 2020 2222 2253  ey=None):.  """S
-00012940: 696d 696c 6172 2074 6f20 6060 7261 6e64  imilar to ``rand
-00012950: 6e5f 6c69 6b65 6060 2069 6e20 746f 7263  n_like`` in torc
-00012960: 682e 200a 2020 0a20 2052 6574 7572 6e73  h. .  .  Returns
-00012970: 2061 2074 656e 736f 7220 7769 7468 2074   a tensor with t
-00012980: 6865 2073 616d 6520 7369 7a65 2061 7320  he same size as 
-00012990: 6060 696e 7075 7460 6020 7468 6174 2069  ``input`` that i
-000129a0: 7320 6669 6c6c 6564 2077 6974 680a 2020  s filled with.  
-000129b0: 7261 6e64 6f6d 206e 756d 6265 7273 2066  random numbers f
-000129c0: 726f 6d20 6120 6e6f 726d 616c 2064 6973  rom a normal dis
-000129d0: 7472 6962 7574 696f 6e20 7769 7468 206d  tribution with m
-000129e0: 6561 6e20 3020 616e 6420 7661 7269 616e  ean 0 and varian
-000129f0: 6365 2031 2e0a 0a20 2041 7267 733a 0a20  ce 1...  Args:. 
-00012a00: 2020 2069 6e70 7574 3a20 2074 6865 2060     input:  the `
-00012a10: 6073 697a 6560 6020 6f66 2069 6e70 7574  `size`` of input
-00012a20: 2077 696c 6c20 6465 7465 726d 696e 6520   will determine 
-00012a30: 7369 7a65 206f 6620 7468 6520 6f75 7470  size of the outp
-00012a40: 7574 2074 656e 736f 722e 0a20 2020 2064  ut tensor..    d
-00012a50: 7479 7065 3a20 2074 6865 2064 6573 6972  type:  the desir
-00012a60: 6564 2064 6174 6120 7479 7065 206f 6620  ed data type of 
-00012a70: 7265 7475 726e 6564 2054 656e 736f 722e  returned Tensor.
-00012a80: 2044 6566 6175 6c74 3a20 6966 2060 604e   Default: if ``N
-00012a90: 6f6e 6560 602c 2064 6566 6175 6c74 7320  one``, defaults 
-00012aa0: 746f 2074 6865 2064 7479 7065 206f 6620  to the dtype of 
-00012ab0: 696e 7075 742e 0a20 2020 206b 6579 3a20  input..    key: 
-00012ac0: 7468 6520 7365 6564 206f 7220 6b65 7920  the seed or key 
-00012ad0: 666f 7220 7468 6520 7261 6e64 6f6d 2e0a  for the random..
-00012ae0: 0a20 2052 6574 7572 6e73 3a0a 2020 2020  .  Returns:.    
-00012af0: 5468 6520 7261 6e64 6f6d 2064 6174 612e  The random data.
-00012b00: 0a20 2022 2222 0a20 2072 6574 7572 6e20  .  """.  return 
-00012b10: 4445 4641 554c 542e 7261 6e64 6e5f 6c69  DEFAULT.randn_li
-00012b20: 6b65 2869 6e70 7574 2c20 6474 7970 653d  ke(input, dtype=
-00012b30: 6474 7970 652c 206b 6579 3d6b 6579 290a  dtype, key=key).
-00012b40: 0a0a 6465 6620 7261 6e64 696e 745f 6c69  ..def randint_li
-00012b50: 6b65 2869 6e70 7574 2c20 6c6f 773d 302c  ke(input, low=0,
-00012b60: 2068 6967 683d 4e6f 6e65 2c20 2a2c 2064   high=None, *, d
-00012b70: 7479 7065 3d4e 6f6e 652c 206b 6579 3d4e  type=None, key=N
-00012b80: 6f6e 6529 3a0a 2020 2222 2253 696d 696c  one):.  """Simil
-00012b90: 6172 2074 6f20 6060 7261 6e64 696e 745f  ar to ``randint_
-00012ba0: 6c69 6b65 6060 2069 6e20 746f 7263 682e  like`` in torch.
-00012bb0: 200a 2020 0a20 2052 6574 7572 6e73 2061   .  .  Returns a
-00012bc0: 2074 656e 736f 7220 7769 7468 2074 6865   tensor with the
-00012bd0: 2073 616d 6520 7368 6170 6520 6173 2054   same shape as T
-00012be0: 656e 736f 7220 6060 696e 7075 7460 6020  ensor ``input`` 
-00012bf0: 6669 6c6c 6564 2077 6974 680a 2020 7261  filled with.  ra
-00012c00: 6e64 6f6d 2069 6e74 6567 6572 7320 6765  ndom integers ge
-00012c10: 6e65 7261 7465 6420 756e 6966 6f72 6d6c  nerated uniforml
-00012c20: 7920 6265 7477 6565 6e20 6060 6c6f 7760  y between ``low`
-00012c30: 6020 2869 6e63 6c75 7369 7665 2920 616e  ` (inclusive) an
-00012c40: 6420 6060 6869 6768 6060 2028 6578 636c  d ``high`` (excl
-00012c50: 7573 6976 6529 2e0a 0a20 2041 7267 733a  usive)...  Args:
-00012c60: 0a20 2020 2069 6e70 7574 3a20 2074 6865  .    input:  the
-00012c70: 2060 6073 697a 6560 6020 6f66 2069 6e70   ``size`` of inp
-00012c80: 7574 2077 696c 6c20 6465 7465 726d 696e  ut will determin
-00012c90: 6520 7369 7a65 206f 6620 7468 6520 6f75  e size of the ou
-00012ca0: 7470 7574 2074 656e 736f 722e 0a20 2020  tput tensor..   
-00012cb0: 206c 6f77 3a20 4c6f 7765 7374 2069 6e74   low: Lowest int
-00012cc0: 6567 6572 2074 6f20 6265 2064 7261 776e  eger to be drawn
-00012cd0: 2066 726f 6d20 7468 6520 6469 7374 7269   from the distri
-00012ce0: 6275 7469 6f6e 2e20 4465 6661 756c 743a  bution. Default:
-00012cf0: 2030 2e0a 2020 2020 6869 6768 3a20 4f6e   0..    high: On
-00012d00: 6520 6162 6f76 6520 7468 6520 6869 6768  e above the high
-00012d10: 6573 7420 696e 7465 6765 7220 746f 2062  est integer to b
-00012d20: 6520 6472 6177 6e20 6672 6f6d 2074 6865  e drawn from the
-00012d30: 2064 6973 7472 6962 7574 696f 6e2e 0a20   distribution.. 
-00012d40: 2020 2064 7479 7065 3a20 7468 6520 6465     dtype: the de
-00012d50: 7369 7265 6420 6461 7461 2074 7970 6520  sired data type 
-00012d60: 6f66 2072 6574 7572 6e65 6420 5465 6e73  of returned Tens
-00012d70: 6f72 2e20 4465 6661 756c 743a 2069 6620  or. Default: if 
-00012d80: 6060 4e6f 6e65 6060 2c20 6465 6661 756c  ``None``, defaul
-00012d90: 7473 2074 6f20 7468 6520 6474 7970 6520  ts to the dtype 
-00012da0: 6f66 2069 6e70 7574 2e0a 2020 2020 6b65  of input..    ke
-00012db0: 793a 2074 6865 2073 6565 6420 6f72 206b  y: the seed or k
-00012dc0: 6579 2066 6f72 2074 6865 2072 616e 646f  ey for the rando
-00012dd0: 6d2e 0a0a 2020 5265 7475 726e 733a 0a20  m...  Returns:. 
-00012de0: 2020 2054 6865 2072 616e 646f 6d20 6461     The random da
-00012df0: 7461 2e0a 2020 2222 220a 2020 7265 7475  ta..  """.  retu
-00012e00: 726e 2044 4546 4155 4c54 2e72 616e 6469  rn DEFAULT.randi
-00012e10: 6e74 5f6c 696b 6528 696e 7075 743d 696e  nt_like(input=in
-00012e20: 7075 742c 206c 6f77 3d6c 6f77 2c20 6869  put, low=low, hi
-00012e30: 6768 3d68 6967 682c 2064 7479 7065 3d64  gh=high, dtype=d
-00012e40: 7479 7065 2c20 6b65 793d 6b65 7929 0a0a  type, key=key)..
-00012e50: 0a66 6f72 205f 5f6b 2069 6e20 6469 7228  .for __k in dir(
-00012e60: 5261 6e64 6f6d 5374 6174 6529 3a0a 2020  RandomState):.  
-00012e70: 5f5f 7420 3d20 6765 7461 7474 7228 5261  __t = getattr(Ra
-00012e80: 6e64 6f6d 5374 6174 652c 205f 5f6b 290a  ndomState, __k).
-00012e90: 2020 6966 206e 6f74 205f 5f6b 2e73 7461    if not __k.sta
-00012ea0: 7274 7377 6974 6828 275f 5f27 2920 616e  rtswith('__') an
-00012eb0: 6420 6361 6c6c 6162 6c65 285f 5f74 2920  d callable(__t) 
-00012ec0: 616e 6420 286e 6f74 205f 5f74 2e5f 5f64  and (not __t.__d
-00012ed0: 6f63 5f5f 293a 0a20 2020 205f 5f72 203d  oc__):.    __r =
-00012ee0: 2067 6c6f 6261 6c73 2829 2e67 6574 285f   globals().get(_
-00012ef0: 5f6b 2c20 4e6f 6e65 290a 2020 2020 6966  _k, None).    if
-00012f00: 205f 5f72 2069 7320 6e6f 7420 4e6f 6e65   __r is not None
-00012f10: 2061 6e64 2063 616c 6c61 626c 6528 5f5f   and callable(__
-00012f20: 7229 3a0a 2020 2020 2020 5f5f 742e 5f5f  r):.      __t.__
-00012f30: 646f 635f 5f20 3d20 5f5f 722e 5f5f 646f  doc__ = __r.__do
-00012f40: 635f 5f0a 0a0a                           c__...
+0000a0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a0d0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000a0e0: 697a 653d 7369 7a65 292c 0a20 2020 2020  ize=size),.     
+0000a0f0: 2020 2020 2020 2020 642c 2072 6573 756c          d, resul
+0000a100: 745f 7368 6170 653d 6a61 782e 5368 6170  t_shape=jax.Shap
+0000a110: 6544 7479 7065 5374 7275 6374 2873 697a  eDtypeStruct(siz
+0000a120: 652c 206a 6e70 2e69 6e74 5f29 290a 2020  e, jnp.int_)).  
+0000a130: 2020 7265 7475 726e 205f 7265 7475 726e    return _return
+0000a140: 2872 290a 0a20 2064 6566 206c 6f67 7365  (r)..  def logse
+0000a150: 7269 6573 2873 656c 662c 2070 2c20 7369  ries(self, p, si
+0000a160: 7a65 3d4e 6f6e 652c 206b 6579 3d4e 6f6e  ze=None, key=Non
+0000a170: 6529 3a0a 2020 2020 7020 3d20 5f63 6865  e):.    p = _che
+0000a180: 636b 5f70 795f 7365 7128 5f61 735f 6a61  ck_py_seq(_as_ja
+0000a190: 785f 6172 7261 7928 7029 290a 2020 2020  x_array(p)).    
+0000a1a0: 6966 2073 697a 6520 6973 204e 6f6e 653a  if size is None:
+0000a1b0: 0a20 2020 2020 2073 697a 6520 3d20 6a6e  .      size = jn
+0000a1c0: 702e 7368 6170 6528 7029 0a20 2020 2073  p.shape(p).    s
+0000a1d0: 697a 6520 3d20 5f73 697a 6532 7368 6170  ize = _size2shap
+0000a1e0: 6528 7369 7a65 290a 2020 2020 7220 3d20  e(size).    r = 
+0000a1f0: 6361 6c6c 286c 616d 6264 6120 703a 206e  call(lambda p: n
+0000a200: 702e 7261 6e64 6f6d 2e6c 6f67 7365 7269  p.random.logseri
+0000a210: 6573 2870 3d70 2c20 7369 7a65 3d73 697a  es(p=p, size=siz
+0000a220: 6529 2c0a 2020 2020 2020 2020 2020 2020  e),.            
+0000a230: 2070 2c20 7265 7375 6c74 5f73 6861 7065   p, result_shape
+0000a240: 3d6a 6178 2e53 6861 7065 4474 7970 6553  =jax.ShapeDtypeS
+0000a250: 7472 7563 7428 7369 7a65 2c20 6a6e 702e  truct(size, jnp.
+0000a260: 696e 745f 2929 0a20 2020 2072 6574 7572  int_)).    retur
+0000a270: 6e20 5f72 6574 7572 6e28 7229 0a0a 2020  n _return(r)..  
+0000a280: 6465 6620 6e6f 6e63 656e 7472 616c 5f66  def noncentral_f
+0000a290: 2873 656c 662c 2064 666e 756d 2c20 6466  (self, dfnum, df
+0000a2a0: 6465 6e2c 206e 6f6e 632c 2073 697a 653d  den, nonc, size=
+0000a2b0: 4e6f 6e65 2c20 6b65 793d 4e6f 6e65 293a  None, key=None):
+0000a2c0: 0a20 2020 2064 666e 756d 203d 205f 6368  .    dfnum = _ch
+0000a2d0: 6563 6b5f 7079 5f73 6571 285f 6173 5f6a  eck_py_seq(_as_j
+0000a2e0: 6178 5f61 7272 6179 2864 666e 756d 2929  ax_array(dfnum))
+0000a2f0: 0a20 2020 2064 6664 656e 203d 205f 6368  .    dfden = _ch
+0000a300: 6563 6b5f 7079 5f73 6571 285f 6173 5f6a  eck_py_seq(_as_j
+0000a310: 6178 5f61 7272 6179 2864 6664 656e 2929  ax_array(dfden))
+0000a320: 0a20 2020 206e 6f6e 6320 3d20 5f63 6865  .    nonc = _che
+0000a330: 636b 5f70 795f 7365 7128 5f61 735f 6a61  ck_py_seq(_as_ja
+0000a340: 785f 6172 7261 7928 6e6f 6e63 2929 0a20  x_array(nonc)). 
+0000a350: 2020 2069 6620 7369 7a65 2069 7320 4e6f     if size is No
+0000a360: 6e65 3a0a 2020 2020 2020 7369 7a65 203d  ne:.      size =
+0000a370: 206c 6178 2e62 726f 6164 6361 7374 5f73   lax.broadcast_s
+0000a380: 6861 7065 7328 6a6e 702e 7368 6170 6528  hapes(jnp.shape(
+0000a390: 6466 6e75 6d29 2c0a 2020 2020 2020 2020  dfnum),.        
+0000a3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a3b0: 2020 2020 2020 2020 2020 6a6e 702e 7368            jnp.sh
+0000a3c0: 6170 6528 6466 6465 6e29 2c0a 2020 2020  ape(dfden),.    
+0000a3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a3e0: 2020 2020 2020 2020 2020 2020 2020 6a6e                jn
+0000a3f0: 702e 7368 6170 6528 6e6f 6e63 2929 0a20  p.shape(nonc)). 
+0000a400: 2020 2073 697a 6520 3d20 5f73 697a 6532     size = _size2
+0000a410: 7368 6170 6528 7369 7a65 290a 2020 2020  shape(size).    
+0000a420: 6420 3d20 7b27 6466 6e75 6d27 3a20 6466  d = {'dfnum': df
+0000a430: 6e75 6d2c 2027 6466 6465 6e27 3a20 6466  num, 'dfden': df
+0000a440: 6465 6e2c 2027 6e6f 6e63 273a 206e 6f6e  den, 'nonc': non
+0000a450: 637d 0a20 2020 2072 203d 2063 616c 6c28  c}.    r = call(
+0000a460: 6c61 6d62 6461 2078 3a20 6e70 2e72 616e  lambda x: np.ran
+0000a470: 646f 6d2e 6e6f 6e63 656e 7472 616c 5f66  dom.noncentral_f
+0000a480: 2864 666e 756d 3d78 5b27 6466 6e75 6d27  (dfnum=x['dfnum'
+0000a490: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0000a4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a4c0: 2064 6664 656e 3d78 5b27 6466 6465 6e27   dfden=x['dfden'
+0000a4d0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0000a4e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a500: 206e 6f6e 633d 785b 276e 6f6e 6327 5d2c   nonc=x['nonc'],
+0000a510: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a530: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000a540: 697a 653d 7369 7a65 292c 0a20 2020 2020  ize=size),.     
+0000a550: 2020 2020 2020 2020 642c 2072 6573 756c          d, resul
+0000a560: 745f 7368 6170 653d 6a61 782e 5368 6170  t_shape=jax.Shap
+0000a570: 6544 7479 7065 5374 7275 6374 2873 697a  eDtypeStruct(siz
+0000a580: 652c 206a 6e70 2e66 6c6f 6174 5f29 290a  e, jnp.float_)).
+0000a590: 2020 2020 7265 7475 726e 205f 7265 7475      return _retu
+0000a5a0: 726e 2872 290a 0a20 2023 2050 7954 6f72  rn(r)..  # PyTor
+0000a5b0: 6368 2063 6f6d 7061 7469 6269 6c69 7479  ch compatibility
+0000a5c0: 2023 0a20 2023 202d 2d2d 2d2d 2d2d 2d2d   #.  # ---------
+0000a5d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2023 0a0a  ------------ #..
+0000a5e0: 2020 6465 6620 7261 6e64 5f6c 696b 6528    def rand_like(
+0000a5f0: 7365 6c66 2c20 696e 7075 742c 202a 2c20  self, input, *, 
+0000a600: 6474 7970 653d 4e6f 6e65 2c20 6b65 793d  dtype=None, key=
+0000a610: 4e6f 6e65 293a 0a20 2020 2022 2222 5265  None):.    """Re
+0000a620: 7475 726e 7320 6120 7465 6e73 6f72 2077  turns a tensor w
+0000a630: 6974 6820 7468 6520 7361 6d65 2073 697a  ith the same siz
+0000a640: 6520 6173 2069 6e70 7574 2074 6861 7420  e as input that 
+0000a650: 6973 2066 696c 6c65 6420 7769 7468 2072  is filled with r
+0000a660: 616e 646f 6d0a 2020 2020 6e75 6d62 6572  andom.    number
+0000a670: 7320 6672 6f6d 2061 2075 6e69 666f 726d  s from a uniform
+0000a680: 2064 6973 7472 6962 7574 696f 6e20 6f6e   distribution on
+0000a690: 2074 6865 2069 6e74 6572 7661 6c20 6060   the interval ``
+0000a6a0: 5b30 2c20 3129 6060 2e0a 0a20 2020 2041  [0, 1)``...    A
+0000a6b0: 7267 733a 0a20 2020 2020 2069 6e70 7574  rgs:.      input
+0000a6c0: 3a20 2074 6865 2060 6073 697a 6560 6020  :  the ``size`` 
+0000a6d0: 6f66 2069 6e70 7574 2077 696c 6c20 6465  of input will de
+0000a6e0: 7465 726d 696e 6520 7369 7a65 206f 6620  termine size of 
+0000a6f0: 7468 6520 6f75 7470 7574 2074 656e 736f  the output tenso
+0000a700: 722e 0a20 2020 2020 2064 7479 7065 3a20  r..      dtype: 
+0000a710: 2074 6865 2064 6573 6972 6564 2064 6174   the desired dat
+0000a720: 6120 7479 7065 206f 6620 7265 7475 726e  a type of return
+0000a730: 6564 2054 656e 736f 722e 2044 6566 6175  ed Tensor. Defau
+0000a740: 6c74 3a20 6966 2060 604e 6f6e 6560 602c  lt: if ``None``,
+0000a750: 2064 6566 6175 6c74 7320 746f 2074 6865   defaults to the
+0000a760: 2064 7479 7065 206f 6620 696e 7075 742e   dtype of input.
+0000a770: 0a20 2020 2020 206b 6579 3a20 7468 6520  .      key: the 
+0000a780: 7365 6564 206f 7220 6b65 7920 666f 7220  seed or key for 
+0000a790: 7468 6520 7261 6e64 6f6d 2e0a 0a20 2020  the random...   
+0000a7a0: 2052 6574 7572 6e73 3a0a 2020 2020 2020   Returns:.      
+0000a7b0: 5468 6520 7261 6e64 6f6d 2064 6174 612e  The random data.
+0000a7c0: 0a20 2020 2022 2222 0a20 2020 2072 6574  .    """.    ret
+0000a7d0: 7572 6e20 7365 6c66 2e72 616e 646f 6d28  urn self.random(
+0000a7e0: 7368 6170 6528 696e 7075 7429 2c20 6b65  shape(input), ke
+0000a7f0: 793d 6b65 7929 2e61 7374 7970 6528 6474  y=key).astype(dt
+0000a800: 7970 6529 0a0a 2020 6465 6620 7261 6e64  ype)..  def rand
+0000a810: 6e5f 6c69 6b65 2873 656c 662c 2069 6e70  n_like(self, inp
+0000a820: 7574 2c20 2a2c 2064 7479 7065 3d4e 6f6e  ut, *, dtype=Non
+0000a830: 652c 206b 6579 3d4e 6f6e 6529 3a0a 2020  e, key=None):.  
+0000a840: 2020 2222 2252 6574 7572 6e73 2061 2074    """Returns a t
+0000a850: 656e 736f 7220 7769 7468 2074 6865 2073  ensor with the s
+0000a860: 616d 6520 7369 7a65 2061 7320 6060 696e  ame size as ``in
+0000a870: 7075 7460 6020 7468 6174 2069 7320 6669  put`` that is fi
+0000a880: 6c6c 6564 2077 6974 680a 2020 2020 7261  lled with.    ra
+0000a890: 6e64 6f6d 206e 756d 6265 7273 2066 726f  ndom numbers fro
+0000a8a0: 6d20 6120 6e6f 726d 616c 2064 6973 7472  m a normal distr
+0000a8b0: 6962 7574 696f 6e20 7769 7468 206d 6561  ibution with mea
+0000a8c0: 6e20 3020 616e 6420 7661 7269 616e 6365  n 0 and variance
+0000a8d0: 2031 2e0a 0a20 2020 2041 7267 733a 0a20   1...    Args:. 
+0000a8e0: 2020 2020 2069 6e70 7574 3a20 2074 6865       input:  the
+0000a8f0: 2060 6073 697a 6560 6020 6f66 2069 6e70   ``size`` of inp
+0000a900: 7574 2077 696c 6c20 6465 7465 726d 696e  ut will determin
+0000a910: 6520 7369 7a65 206f 6620 7468 6520 6f75  e size of the ou
+0000a920: 7470 7574 2074 656e 736f 722e 0a20 2020  tput tensor..   
+0000a930: 2020 2064 7479 7065 3a20 2074 6865 2064     dtype:  the d
+0000a940: 6573 6972 6564 2064 6174 6120 7479 7065  esired data type
+0000a950: 206f 6620 7265 7475 726e 6564 2054 656e   of returned Ten
+0000a960: 736f 722e 2044 6566 6175 6c74 3a20 6966  sor. Default: if
+0000a970: 2060 604e 6f6e 6560 602c 2064 6566 6175   ``None``, defau
+0000a980: 6c74 7320 746f 2074 6865 2064 7479 7065  lts to the dtype
+0000a990: 206f 6620 696e 7075 742e 0a20 2020 2020   of input..     
+0000a9a0: 206b 6579 3a20 7468 6520 7365 6564 206f   key: the seed o
+0000a9b0: 7220 6b65 7920 666f 7220 7468 6520 7261  r key for the ra
+0000a9c0: 6e64 6f6d 2e0a 0a20 2020 2052 6574 7572  ndom...    Retur
+0000a9d0: 6e73 3a0a 2020 2020 2020 5468 6520 7261  ns:.      The ra
+0000a9e0: 6e64 6f6d 2064 6174 612e 0a20 2020 2022  ndom data..    "
+0000a9f0: 2222 0a20 2020 2072 6574 7572 6e20 7365  "".    return se
+0000aa00: 6c66 2e72 616e 646e 282a 7368 6170 6528  lf.randn(*shape(
+0000aa10: 696e 7075 7429 2c20 6b65 793d 6b65 7929  input), key=key)
+0000aa20: 2e61 7374 7970 6528 6474 7970 6529 0a0a  .astype(dtype)..
+0000aa30: 2020 6465 6620 7261 6e64 696e 745f 6c69    def randint_li
+0000aa40: 6b65 2873 656c 662c 2069 6e70 7574 2c20  ke(self, input, 
+0000aa50: 6c6f 773d 302c 2068 6967 683d 4e6f 6e65  low=0, high=None
+0000aa60: 2c20 2a2c 2064 7479 7065 3d4e 6f6e 652c  , *, dtype=None,
+0000aa70: 206b 6579 3d4e 6f6e 6529 3a0a 2020 2020   key=None):.    
+0000aa80: 6966 2068 6967 6820 6973 204e 6f6e 653a  if high is None:
+0000aa90: 0a20 2020 2020 2068 6967 6820 3d20 6d61  .      high = ma
+0000aaa0: 7828 696e 7075 7429 0a20 2020 2072 6574  x(input).    ret
+0000aab0: 7572 6e20 7365 6c66 2e72 616e 6469 6e74  urn self.randint
+0000aac0: 286c 6f77 2c20 6869 6768 3d68 6967 682c  (low, high=high,
+0000aad0: 2073 697a 653d 7368 6170 6528 696e 7075   size=shape(inpu
+0000aae0: 7429 2c20 6474 7970 653d 6474 7970 652c  t), dtype=dtype,
+0000aaf0: 206b 6579 3d6b 6579 290a 0a0a 2320 616c   key=key)...# al
+0000ab00: 6961 730a 4765 6e65 7261 746f 7220 3d20  ias.Generator = 
+0000ab10: 5261 6e64 6f6d 5374 6174 650a 0a23 2064  RandomState..# d
+0000ab20: 6566 6175 6c74 2072 616e 646f 6d20 6765  efault random ge
+0000ab30: 6e65 7261 746f 720a 5f5f 6120 3d20 4172  nerator.__a = Ar
+0000ab40: 7261 7928 4e6f 6e65 290a 5f5f 612e 5f76  ray(None).__a._v
+0000ab50: 616c 7565 203d 206e 702e 7261 6e64 6f6d  alue = np.random
+0000ab60: 2e72 616e 6469 6e74 2830 2c20 3130 3030  .randint(0, 1000
+0000ab70: 302c 2073 697a 653d 322c 2064 7479 7065  0, size=2, dtype
+0000ab80: 3d6e 702e 7569 6e74 3332 290a 4445 4641  =np.uint32).DEFA
+0000ab90: 554c 5420 3d20 5261 6e64 6f6d 5374 6174  ULT = RandomStat
+0000aba0: 6528 5f5f 6129 0a64 656c 205f 5f61 0a0a  e(__a).del __a..
+0000abb0: 0a64 6566 2073 706c 6974 5f6b 6579 2829  .def split_key()
+0000abc0: 3a0a 2020 7265 7475 726e 2044 4546 4155  :.  return DEFAU
+0000abd0: 4c54 2e73 706c 6974 5f6b 6579 2829 0a0a  LT.split_key()..
+0000abe0: 0a64 6566 2063 6c6f 6e65 5f72 6e67 2873  .def clone_rng(s
+0000abf0: 6565 645f 6f72 5f6b 6579 3d4e 6f6e 652c  eed_or_key=None,
+0000ac00: 2063 6c6f 6e65 3a20 626f 6f6c 203d 2054   clone: bool = T
+0000ac10: 7275 6529 202d 3e20 5261 6e64 6f6d 5374  rue) -> RandomSt
+0000ac20: 6174 653a 0a20 2069 6620 7365 6564 5f6f  ate:.  if seed_o
+0000ac30: 725f 6b65 7920 6973 204e 6f6e 653a 0a20  r_key is None:. 
+0000ac40: 2020 2072 6574 7572 6e20 4445 4641 554c     return DEFAUL
+0000ac50: 542e 636c 6f6e 6528 2920 6966 2063 6c6f  T.clone() if clo
+0000ac60: 6e65 2065 6c73 6520 4445 4641 554c 540a  ne else DEFAULT.
+0000ac70: 2020 656c 7365 3a0a 2020 2020 7265 7475    else:.    retu
+0000ac80: 726e 2052 616e 646f 6d53 7461 7465 2873  rn RandomState(s
+0000ac90: 6565 645f 6f72 5f6b 6579 290a 0a0a 6465  eed_or_key)...de
+0000aca0: 6620 6465 6661 756c 745f 726e 6728 7365  f default_rng(se
+0000acb0: 6564 5f6f 725f 6b65 793d 4e6f 6e65 2c20  ed_or_key=None, 
+0000acc0: 636c 6f6e 653d 5472 7565 2920 2d3e 2052  clone=True) -> R
+0000acd0: 616e 646f 6d53 7461 7465 3a0a 2020 6966  andomState:.  if
+0000ace0: 2073 6565 645f 6f72 5f6b 6579 2069 7320   seed_or_key is 
+0000acf0: 4e6f 6e65 3a0a 2020 2020 7265 7475 726e  None:.    return
+0000ad00: 2044 4546 4155 4c54 2e63 6c6f 6e65 2829   DEFAULT.clone()
+0000ad10: 2069 6620 636c 6f6e 6520 656c 7365 2044   if clone else D
+0000ad20: 4546 4155 4c54 0a20 2065 6c73 653a 0a20  EFAULT.  else:. 
+0000ad30: 2020 2072 6574 7572 6e20 5261 6e64 6f6d     return Random
+0000ad40: 5374 6174 6528 7365 6564 5f6f 725f 6b65  State(seed_or_ke
+0000ad50: 7929 0a0a 0a64 6566 2073 6565 6428 7365  y)...def seed(se
+0000ad60: 6564 3a20 696e 7420 3d20 4e6f 6e65 293a  ed: int = None):
+0000ad70: 0a20 2022 2222 5365 7473 2061 206e 6577  .  """Sets a new
+0000ad80: 2072 616e 646f 6d20 7365 6564 2e0a 0a20   random seed... 
+0000ad90: 2050 6172 616d 6574 6572 730a 2020 2d2d   Parameters.  --
+0000ada0: 2d2d 2d2d 2d2d 2d2d 0a20 2073 6565 643a  --------.  seed:
+0000adb0: 2069 6e74 2c20 6f70 7469 6f6e 616c 0a20   int, optional. 
+0000adc0: 2020 2054 6865 2072 616e 646f 6d20 7365     The random se
+0000add0: 6564 2e0a 2020 2222 220a 2020 6966 2073  ed..  """.  if s
+0000ade0: 6565 6420 6973 204e 6f6e 653a 2073 6565  eed is None: see
+0000adf0: 6420 3d20 6e70 2e72 616e 646f 6d2e 7261  d = np.random.ra
+0000ae00: 6e64 696e 7428 302c 2031 3030 3030 3029  ndint(0, 100000)
+0000ae10: 0a20 2044 4546 4155 4c54 2e73 6565 6428  .  DEFAULT.seed(
+0000ae20: 7365 6564 290a 2020 6e70 2e72 616e 646f  seed).  np.rando
+0000ae30: 6d2e 7365 6564 2873 6565 6429 0a0a 0a64  m.seed(seed)...d
+0000ae40: 6566 2072 616e 6428 2a64 6e2c 206b 6579  ef rand(*dn, key
+0000ae50: 3d4e 6f6e 6529 3a0a 2020 7222 2222 5261  =None):.  r"""Ra
+0000ae60: 6e64 6f6d 2076 616c 7565 7320 696e 2061  ndom values in a
+0000ae70: 2067 6976 656e 2073 6861 7065 2e0a 0a20   given shape... 
+0000ae80: 202e 2e20 6e6f 7465 3a3a 0a20 2020 2020   .. note::.     
+0000ae90: 2054 6869 7320 6973 2061 2063 6f6e 7665   This is a conve
+0000aea0: 6e69 656e 6365 2066 756e 6374 696f 6e20  nience function 
+0000aeb0: 666f 7220 7573 6572 7320 706f 7274 696e  for users portin
+0000aec0: 6720 636f 6465 2066 726f 6d20 4d61 746c  g code from Matl
+0000aed0: 6162 2c0a 2020 2020 2020 616e 6420 7772  ab,.      and wr
+0000aee0: 6170 7320 6072 616e 646f 6d5f 7361 6d70  aps `random_samp
+0000aef0: 6c65 602e 2054 6861 7420 6675 6e63 7469  le`. That functi
+0000af00: 6f6e 2074 616b 6573 2061 0a20 2020 2020  on takes a.     
+0000af10: 2074 7570 6c65 2074 6f20 7370 6563 6966   tuple to specif
+0000af20: 7920 7468 6520 7369 7a65 206f 6620 7468  y the size of th
+0000af30: 6520 6f75 7470 7574 2c20 7768 6963 6820  e output, which 
+0000af40: 6973 2063 6f6e 7369 7374 656e 7420 7769  is consistent wi
+0000af50: 7468 0a20 2020 2020 206f 7468 6572 204e  th.      other N
+0000af60: 756d 5079 2066 756e 6374 696f 6e73 206c  umPy functions l
+0000af70: 696b 6520 606e 756d 7079 2e7a 6572 6f73  ike `numpy.zeros
+0000af80: 6020 616e 6420 606e 756d 7079 2e6f 6e65  ` and `numpy.one
+0000af90: 7360 2e0a 0a20 2043 7265 6174 6520 616e  s`...  Create an
+0000afa0: 2061 7272 6179 206f 6620 7468 6520 6769   array of the gi
+0000afb0: 7665 6e20 7368 6170 6520 616e 6420 706f  ven shape and po
+0000afc0: 7075 6c61 7465 2069 7420 7769 7468 0a20  pulate it with. 
+0000afd0: 2072 616e 646f 6d20 7361 6d70 6c65 7320   random samples 
+0000afe0: 6672 6f6d 2061 2075 6e69 666f 726d 2064  from a uniform d
+0000aff0: 6973 7472 6962 7574 696f 6e0a 2020 6f76  istribution.  ov
+0000b000: 6572 2060 605b 302c 2031 2960 602e 0a0a  er ``[0, 1)``...
+0000b010: 2020 5061 7261 6d65 7465 7273 0a20 202d    Parameters.  -
+0000b020: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 6430 2c20  ---------.  d0, 
+0000b030: 6431 2c20 2e2e 2e2c 2064 6e20 3a20 696e  d1, ..., dn : in
+0000b040: 742c 206f 7074 696f 6e61 6c0a 2020 2020  t, optional.    
+0000b050: 2020 5468 6520 6469 6d65 6e73 696f 6e73    The dimensions
+0000b060: 206f 6620 7468 6520 7265 7475 726e 6564   of the returned
+0000b070: 2061 7272 6179 2c20 6d75 7374 2062 6520   array, must be 
+0000b080: 6e6f 6e2d 6e65 6761 7469 7665 2e0a 2020  non-negative..  
+0000b090: 2020 2020 4966 206e 6f20 6172 6775 6d65      If no argume
+0000b0a0: 6e74 2069 7320 6769 7665 6e20 6120 7369  nt is given a si
+0000b0b0: 6e67 6c65 2050 7974 686f 6e20 666c 6f61  ngle Python floa
+0000b0c0: 7420 6973 2072 6574 7572 6e65 642e 0a0a  t is returned...
+0000b0d0: 2020 5265 7475 726e 730a 2020 2d2d 2d2d    Returns.  ----
+0000b0e0: 2d2d 2d0a 2020 6f75 7420 3a20 6e64 6172  ---.  out : ndar
+0000b0f0: 7261 792c 2073 6861 7065 2060 6028 6430  ray, shape ``(d0
+0000b100: 2c20 6431 2c20 2e2e 2e2c 2064 6e29 6060  , d1, ..., dn)``
+0000b110: 0a20 2020 2020 2052 616e 646f 6d20 7661  .      Random va
+0000b120: 6c75 6573 2e0a 0a20 2053 6565 2041 6c73  lues...  See Als
+0000b130: 6f0a 2020 2d2d 2d2d 2d2d 2d2d 0a20 2072  o.  --------.  r
+0000b140: 616e 646f 6d0a 0a20 2045 7861 6d70 6c65  andom..  Example
+0000b150: 730a 2020 2d2d 2d2d 2d2d 2d2d 0a20 203e  s.  --------.  >
+0000b160: 3e3e 2062 7261 696e 7079 2e6d 6174 682e  >> brainpy.math.
+0000b170: 7261 6e64 6f6d 2e72 616e 6428 332c 3229  random.rand(3,2)
+0000b180: 0a20 2061 7272 6179 285b 5b20 302e 3134  .  array([[ 0.14
+0000b190: 3032 3234 3731 2c20 2030 2e39 3633 3630  022471,  0.96360
+0000b1a0: 3631 385d 2c20 2023 7261 6e64 6f6d 0a20  618],  #random. 
+0000b1b0: 2020 2020 2020 2020 5b20 302e 3337 3630          [ 0.3760
+0000b1c0: 3130 3332 2c20 2030 2e32 3535 3238 3431  1032,  0.2552841
+0000b1d0: 315d 2c20 2023 7261 6e64 6f6d 0a20 2020  1],  #random.   
+0000b1e0: 2020 2020 2020 5b20 302e 3439 3331 3330        [ 0.493130
+0000b1f0: 3439 2c20 2030 2e39 3439 3039 3837 385d  49,  0.94909878]
+0000b200: 5d29 2023 7261 6e64 6f6d 0a20 2022 2222  ]) #random.  """
+0000b210: 0a20 2072 6574 7572 6e20 4445 4641 554c  .  return DEFAUL
+0000b220: 542e 7261 6e64 282a 646e 2c20 6b65 793d  T.rand(*dn, key=
+0000b230: 6b65 7929 0a0a 0a64 6566 2072 616e 6469  key)...def randi
+0000b240: 6e74 286c 6f77 2c20 6869 6768 3d4e 6f6e  nt(low, high=Non
+0000b250: 652c 2073 697a 653d 4e6f 6e65 2c20 6474  e, size=None, dt
+0000b260: 7970 653d 6a6e 702e 696e 745f 2c20 6b65  ype=jnp.int_, ke
+0000b270: 793d 4e6f 6e65 293a 0a20 2072 2222 2252  y=None):.  r"""R
+0000b280: 6574 7572 6e20 7261 6e64 6f6d 2069 6e74  eturn random int
+0000b290: 6567 6572 7320 6672 6f6d 2060 6c6f 7760  egers from `low`
+0000b2a0: 2028 696e 636c 7573 6976 6529 2074 6f20   (inclusive) to 
+0000b2b0: 6068 6967 6860 2028 6578 636c 7573 6976  `high` (exclusiv
+0000b2c0: 6529 2e0a 0a20 2052 6574 7572 6e20 7261  e)...  Return ra
+0000b2d0: 6e64 6f6d 2069 6e74 6567 6572 7320 6672  ndom integers fr
+0000b2e0: 6f6d 2074 6865 2022 6469 7363 7265 7465  om the "discrete
+0000b2f0: 2075 6e69 666f 726d 2220 6469 7374 7269   uniform" distri
+0000b300: 6275 7469 6f6e 206f 660a 2020 7468 6520  bution of.  the 
+0000b310: 7370 6563 6966 6965 6420 6474 7970 6520  specified dtype 
+0000b320: 696e 2074 6865 2022 6861 6c66 2d6f 7065  in the "half-ope
+0000b330: 6e22 2069 6e74 6572 7661 6c20 5b60 6c6f  n" interval [`lo
+0000b340: 7760 2c20 6068 6967 6860 292e 2049 660a  w`, `high`). If.
+0000b350: 2020 6068 6967 6860 2069 7320 4e6f 6e65    `high` is None
+0000b360: 2028 7468 6520 6465 6661 756c 7429 2c20   (the default), 
+0000b370: 7468 656e 2072 6573 756c 7473 2061 7265  then results are
+0000b380: 2066 726f 6d20 5b30 2c20 606c 6f77 6029   from [0, `low`)
+0000b390: 2e0a 0a20 2050 6172 616d 6574 6572 730a  ...  Parameters.
+0000b3a0: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 206c    ----------.  l
+0000b3b0: 6f77 203a 2069 6e74 206f 7220 6172 7261  ow : int or arra
+0000b3c0: 792d 6c69 6b65 206f 6620 696e 7473 0a20  y-like of ints. 
+0000b3d0: 2020 2020 204c 6f77 6573 7420 2873 6967       Lowest (sig
+0000b3e0: 6e65 6429 2069 6e74 6567 6572 7320 746f  ned) integers to
+0000b3f0: 2062 6520 6472 6177 6e20 6672 6f6d 2074   be drawn from t
+0000b400: 6865 2064 6973 7472 6962 7574 696f 6e20  he distribution 
+0000b410: 2875 6e6c 6573 730a 2020 2020 2020 6060  (unless.      ``
+0000b420: 6869 6768 3d4e 6f6e 6560 602c 2069 6e20  high=None``, in 
+0000b430: 7768 6963 6820 6361 7365 2074 6869 7320  which case this 
+0000b440: 7061 7261 6d65 7465 7220 6973 206f 6e65  parameter is one
+0000b450: 2061 626f 7665 2074 6865 0a20 2020 2020   above the.     
+0000b460: 202a 6869 6768 6573 742a 2073 7563 6820   *highest* such 
+0000b470: 696e 7465 6765 7229 2e0a 2020 6869 6768  integer)..  high
+0000b480: 203a 2069 6e74 206f 7220 6172 7261 792d   : int or array-
+0000b490: 6c69 6b65 206f 6620 696e 7473 2c20 6f70  like of ints, op
+0000b4a0: 7469 6f6e 616c 0a20 2020 2020 2049 6620  tional.      If 
+0000b4b0: 7072 6f76 6964 6564 2c20 6f6e 6520 6162  provided, one ab
+0000b4c0: 6f76 6520 7468 6520 6c61 7267 6573 7420  ove the largest 
+0000b4d0: 2873 6967 6e65 6429 2069 6e74 6567 6572  (signed) integer
+0000b4e0: 2074 6f20 6265 2064 7261 776e 0a20 2020   to be drawn.   
+0000b4f0: 2020 2066 726f 6d20 7468 6520 6469 7374     from the dist
+0000b500: 7269 6275 7469 6f6e 2028 7365 6520 6162  ribution (see ab
+0000b510: 6f76 6520 666f 7220 6265 6861 7669 6f72  ove for behavior
+0000b520: 2069 6620 6060 6869 6768 3d4e 6f6e 6560   if ``high=None`
+0000b530: 6029 2e0a 2020 2020 2020 4966 2061 7272  `)..      If arr
+0000b540: 6179 2d6c 696b 652c 206d 7573 7420 636f  ay-like, must co
+0000b550: 6e74 6169 6e20 696e 7465 6765 7220 7661  ntain integer va
+0000b560: 6c75 6573 0a20 2073 697a 6520 3a20 696e  lues.  size : in
+0000b570: 7420 6f72 2074 7570 6c65 206f 6620 696e  t or tuple of in
+0000b580: 7473 2c20 6f70 7469 6f6e 616c 0a20 2020  ts, optional.   
+0000b590: 2020 204f 7574 7075 7420 7368 6170 652e     Output shape.
+0000b5a0: 2020 4966 2074 6865 2067 6976 656e 2073    If the given s
+0000b5b0: 6861 7065 2069 732c 2065 2e67 2e2c 2060  hape is, e.g., `
+0000b5c0: 6028 6d2c 206e 2c20 6b29 6060 2c20 7468  `(m, n, k)``, th
+0000b5d0: 656e 0a20 2020 2020 2060 606d 202a 206e  en.      ``m * n
+0000b5e0: 202a 206b 6060 2073 616d 706c 6573 2061   * k`` samples a
+0000b5f0: 7265 2064 7261 776e 2e20 2044 6566 6175  re drawn.  Defau
+0000b600: 6c74 2069 7320 4e6f 6e65 2c20 696e 2077  lt is None, in w
+0000b610: 6869 6368 2063 6173 6520 610a 2020 2020  hich case a.    
+0000b620: 2020 7369 6e67 6c65 2076 616c 7565 2069    single value i
+0000b630: 7320 7265 7475 726e 6564 2e0a 2020 6474  s returned..  dt
+0000b640: 7970 6520 3a20 6474 7970 652c 206f 7074  ype : dtype, opt
+0000b650: 696f 6e61 6c0a 2020 2020 2020 4465 7369  ional.      Desi
+0000b660: 7265 6420 6474 7970 6520 6f66 2074 6865  red dtype of the
+0000b670: 2072 6573 756c 742e 2042 7974 656f 7264   result. Byteord
+0000b680: 6572 206d 7573 7420 6265 206e 6174 6976  er must be nativ
+0000b690: 652e 0a20 2020 2020 2054 6865 2064 6566  e..      The def
+0000b6a0: 6175 6c74 2076 616c 7565 2069 7320 696e  ault value is in
+0000b6b0: 742e 0a0a 2020 5265 7475 726e 730a 2020  t...  Returns.  
+0000b6c0: 2d2d 2d2d 2d2d 2d0a 2020 6f75 7420 3a20  -------.  out : 
+0000b6d0: 696e 7420 6f72 206e 6461 7272 6179 206f  int or ndarray o
+0000b6e0: 6620 696e 7473 0a20 2020 2020 2060 7369  f ints.      `si
+0000b6f0: 7a65 602d 7368 6170 6564 2061 7272 6179  ze`-shaped array
+0000b700: 206f 6620 7261 6e64 6f6d 2069 6e74 6567   of random integ
+0000b710: 6572 7320 6672 6f6d 2074 6865 2061 7070  ers from the app
+0000b720: 726f 7072 6961 7465 0a20 2020 2020 2064  ropriate.      d
+0000b730: 6973 7472 6962 7574 696f 6e2c 206f 7220  istribution, or 
+0000b740: 6120 7369 6e67 6c65 2073 7563 6820 7261  a single such ra
+0000b750: 6e64 6f6d 2069 6e74 2069 6620 6073 697a  ndom int if `siz
+0000b760: 6560 206e 6f74 2070 726f 7669 6465 642e  e` not provided.
+0000b770: 0a0a 2020 5365 6520 416c 736f 0a20 202d  ..  See Also.  -
+0000b780: 2d2d 2d2d 2d2d 2d0a 2020 7261 6e64 6f6d  -------.  random
+0000b790: 5f69 6e74 6567 6572 7320 3a20 7369 6d69  _integers : simi
+0000b7a0: 6c61 7220 746f 2060 7261 6e64 696e 7460  lar to `randint`
+0000b7b0: 2c20 6f6e 6c79 2066 6f72 2074 6865 2063  , only for the c
+0000b7c0: 6c6f 7365 640a 2020 2020 2020 696e 7465  losed.      inte
+0000b7d0: 7276 616c 205b 606c 6f77 602c 2060 6869  rval [`low`, `hi
+0000b7e0: 6768 605d 2c20 616e 6420 3120 6973 2074  gh`], and 1 is t
+0000b7f0: 6865 206c 6f77 6573 7420 7661 6c75 6520  he lowest value 
+0000b800: 6966 2060 6869 6768 6020 6973 0a20 2020  if `high` is.   
+0000b810: 2020 206f 6d69 7474 6564 2e0a 2020 4765     omitted..  Ge
+0000b820: 6e65 7261 746f 722e 696e 7465 6765 7273  nerator.integers
+0000b830: 3a20 7768 6963 6820 7368 6f75 6c64 2062  : which should b
+0000b840: 6520 7573 6564 2066 6f72 206e 6577 2063  e used for new c
+0000b850: 6f64 652e 0a0a 2020 4578 616d 706c 6573  ode...  Examples
+0000b860: 0a20 202d 2d2d 2d2d 2d2d 2d0a 2020 3e3e  .  --------.  >>
+0000b870: 3e20 696d 706f 7274 2062 7261 696e 7079  > import brainpy
+0000b880: 2e6d 6174 6820 6173 2062 6d0a 2020 3e3e  .math as bm.  >>
+0000b890: 3e20 626d 2e72 616e 646f 6d2e 7261 6e64  > bm.random.rand
+0000b8a0: 696e 7428 322c 2073 697a 653d 3130 290a  int(2, size=10).
+0000b8b0: 2020 6172 7261 7928 5b31 2c20 302c 2030    array([1, 0, 0
+0000b8c0: 2c20 302c 2031 2c20 312c 2030 2c20 302c  , 0, 1, 1, 0, 0,
+0000b8d0: 2031 2c20 305d 2920 2320 7261 6e64 6f6d   1, 0]) # random
+0000b8e0: 0a20 203e 3e3e 2062 6d2e 7261 6e64 6f6d  .  >>> bm.random
+0000b8f0: 2e72 616e 6469 6e74 2831 2c20 7369 7a65  .randint(1, size
+0000b900: 3d31 3029 0a20 2061 7272 6179 285b 302c  =10).  array([0,
+0000b910: 2030 2c20 302c 2030 2c20 302c 2030 2c20   0, 0, 0, 0, 0, 
+0000b920: 302c 2030 2c20 302c 2030 5d29 0a0a 2020  0, 0, 0, 0])..  
+0000b930: 4765 6e65 7261 7465 2061 2032 2078 2034  Generate a 2 x 4
+0000b940: 2061 7272 6179 206f 6620 696e 7473 2062   array of ints b
+0000b950: 6574 7765 656e 2030 2061 6e64 2034 2c20  etween 0 and 4, 
+0000b960: 696e 636c 7573 6976 653a 0a0a 2020 3e3e  inclusive:..  >>
+0000b970: 3e20 626d 2e72 616e 646f 6d2e 7261 6e64  > bm.random.rand
+0000b980: 696e 7428 352c 2073 697a 653d 2832 2c20  int(5, size=(2, 
+0000b990: 3429 290a 2020 6172 7261 7928 5b5b 342c  4)).  array([[4,
+0000b9a0: 2030 2c20 322c 2031 5d2c 2023 2072 616e   0, 2, 1], # ran
+0000b9b0: 646f 6d0a 2020 2020 2020 2020 205b 332c  dom.         [3,
+0000b9c0: 2032 2c20 322c 2030 5d5d 290a 0a20 2047   2, 2, 0]])..  G
+0000b9d0: 656e 6572 6174 6520 6120 3120 7820 3320  enerate a 1 x 3 
+0000b9e0: 6172 7261 7920 7769 7468 2033 2064 6966  array with 3 dif
+0000b9f0: 6665 7265 6e74 2075 7070 6572 2062 6f75  ferent upper bou
+0000ba00: 6e64 730a 0a20 203e 3e3e 2062 6d2e 7261  nds..  >>> bm.ra
+0000ba10: 6e64 6f6d 2e72 616e 6469 6e74 2831 2c20  ndom.randint(1, 
+0000ba20: 5b33 2c20 352c 2031 305d 290a 2020 6172  [3, 5, 10]).  ar
+0000ba30: 7261 7928 5b32 2c20 322c 2039 5d29 2023  ray([2, 2, 9]) #
+0000ba40: 2072 616e 646f 6d0a 0a20 2047 656e 6572   random..  Gener
+0000ba50: 6174 6520 6120 3120 6279 2033 2061 7272  ate a 1 by 3 arr
+0000ba60: 6179 2077 6974 6820 3320 6469 6666 6572  ay with 3 differ
+0000ba70: 656e 7420 6c6f 7765 7220 626f 756e 6473  ent lower bounds
+0000ba80: 0a0a 2020 3e3e 3e20 626d 2e72 616e 646f  ..  >>> bm.rando
+0000ba90: 6d2e 7261 6e64 696e 7428 5b31 2c20 352c  m.randint([1, 5,
+0000baa0: 2037 5d2c 2031 3029 0a20 2061 7272 6179   7], 10).  array
+0000bab0: 285b 392c 2038 2c20 375d 2920 2320 7261  ([9, 8, 7]) # ra
+0000bac0: 6e64 6f6d 0a0a 2020 4765 6e65 7261 7465  ndom..  Generate
+0000bad0: 2061 2032 2062 7920 3420 6172 7261 7920   a 2 by 4 array 
+0000bae0: 7573 696e 6720 6272 6f61 6463 6173 7469  using broadcasti
+0000baf0: 6e67 2077 6974 6820 6474 7970 6520 6f66  ng with dtype of
+0000bb00: 2075 696e 7438 0a0a 2020 3e3e 3e20 626d   uint8..  >>> bm
+0000bb10: 2e72 616e 646f 6d2e 7261 6e64 696e 7428  .random.randint(
+0000bb20: 5b31 2c20 332c 2035 2c20 375d 2c20 5b5b  [1, 3, 5, 7], [[
+0000bb30: 3130 5d2c 205b 3230 5d5d 2c20 6474 7970  10], [20]], dtyp
+0000bb40: 653d 6e70 2e75 696e 7438 290a 2020 6172  e=np.uint8).  ar
+0000bb50: 7261 7928 5b5b 2038 2c20 2036 2c20 2039  ray([[ 8,  6,  9
+0000bb60: 2c20 2037 5d2c 2023 2072 616e 646f 6d0a  ,  7], # random.
+0000bb70: 2020 2020 2020 2020 205b 2031 2c20 3136           [ 1, 16
+0000bb80: 2c20 2039 2c20 3132 5d5d 2c20 6474 7970  ,  9, 12]], dtyp
+0000bb90: 653d 7569 6e74 3829 0a20 2022 2222 0a0a  e=uint8).  """..
+0000bba0: 2020 7265 7475 726e 2044 4546 4155 4c54    return DEFAULT
+0000bbb0: 2e72 616e 6469 6e74 286c 6f77 2c20 6869  .randint(low, hi
+0000bbc0: 6768 3d68 6967 682c 2073 697a 653d 7369  gh=high, size=si
+0000bbd0: 7a65 2c20 6474 7970 653d 6474 7970 652c  ze, dtype=dtype,
+0000bbe0: 206b 6579 3d6b 6579 290a 0a0a 6465 6620   key=key)...def 
+0000bbf0: 7261 6e64 6f6d 5f69 6e74 6567 6572 7328  random_integers(
+0000bc00: 6c6f 772c 2068 6967 683d 4e6f 6e65 2c20  low, high=None, 
+0000bc10: 7369 7a65 3d4e 6f6e 652c 206b 6579 3d4e  size=None, key=N
+0000bc20: 6f6e 6529 3a0a 2020 7222 2222 0a20 2052  one):.  r""".  R
+0000bc30: 616e 646f 6d20 696e 7465 6765 7273 206f  andom integers o
+0000bc40: 6620 7479 7065 2060 6e70 2e69 6e74 5f60  f type `np.int_`
+0000bc50: 2062 6574 7765 656e 2060 6c6f 7760 2061   between `low` a
+0000bc60: 6e64 2060 6869 6768 602c 2069 6e63 6c75  nd `high`, inclu
+0000bc70: 7369 7665 2e0a 0a20 2052 6574 7572 6e20  sive...  Return 
+0000bc80: 7261 6e64 6f6d 2069 6e74 6567 6572 7320  random integers 
+0000bc90: 6f66 2074 7970 6520 606e 702e 696e 745f  of type `np.int_
+0000bca0: 6020 6672 6f6d 2074 6865 2022 6469 7363  ` from the "disc
+0000bcb0: 7265 7465 2075 6e69 666f 726d 220a 2020  rete uniform".  
+0000bcc0: 6469 7374 7269 6275 7469 6f6e 2069 6e20  distribution in 
+0000bcd0: 7468 6520 636c 6f73 6564 2069 6e74 6572  the closed inter
+0000bce0: 7661 6c20 5b60 6c6f 7760 2c20 6068 6967  val [`low`, `hig
+0000bcf0: 6860 5d2e 2020 4966 2060 6869 6768 6020  h`].  If `high` 
+0000bd00: 6973 0a20 204e 6f6e 6520 2874 6865 2064  is.  None (the d
+0000bd10: 6566 6175 6c74 292c 2074 6865 6e20 7265  efault), then re
+0000bd20: 7375 6c74 7320 6172 6520 6672 6f6d 205b  sults are from [
+0000bd30: 312c 2060 6c6f 7760 5d2e 2054 6865 2060  1, `low`]. The `
+0000bd40: 6e70 2e69 6e74 5f60 0a20 2074 7970 6520  np.int_`.  type 
+0000bd50: 7472 616e 736c 6174 6573 2074 6f20 7468  translates to th
+0000bd60: 6520 4320 6c6f 6e67 2069 6e74 6567 6572  e C long integer
+0000bd70: 2074 7970 6520 616e 6420 6974 7320 7072   type and its pr
+0000bd80: 6563 6973 696f 6e0a 2020 6973 2070 6c61  ecision.  is pla
+0000bd90: 7466 6f72 6d20 6465 7065 6e64 656e 742e  tform dependent.
+0000bda0: 0a0a 2020 5061 7261 6d65 7465 7273 0a20  ..  Parameters. 
+0000bdb0: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 6c6f   ----------.  lo
+0000bdc0: 7720 3a20 696e 740a 2020 2020 2020 4c6f  w : int.      Lo
+0000bdd0: 7765 7374 2028 7369 676e 6564 2920 696e  west (signed) in
+0000bde0: 7465 6765 7220 746f 2062 6520 6472 6177  teger to be draw
+0000bdf0: 6e20 6672 6f6d 2074 6865 2064 6973 7472  n from the distr
+0000be00: 6962 7574 696f 6e20 2875 6e6c 6573 730a  ibution (unless.
+0000be10: 2020 2020 2020 6060 6869 6768 3d4e 6f6e        ``high=Non
+0000be20: 6560 602c 2069 6e20 7768 6963 6820 6361  e``, in which ca
+0000be30: 7365 2074 6869 7320 7061 7261 6d65 7465  se this paramete
+0000be40: 7220 6973 2074 6865 202a 6869 6768 6573  r is the *highes
+0000be50: 742a 2073 7563 680a 2020 2020 2020 696e  t* such.      in
+0000be60: 7465 6765 7229 2e0a 2020 6869 6768 203a  teger)..  high :
+0000be70: 2069 6e74 2c20 6f70 7469 6f6e 616c 0a20   int, optional. 
+0000be80: 2020 2020 2049 6620 7072 6f76 6964 6564       If provided
+0000be90: 2c20 7468 6520 6c61 7267 6573 7420 2873  , the largest (s
+0000bea0: 6967 6e65 6429 2069 6e74 6567 6572 2074  igned) integer t
+0000beb0: 6f20 6265 2064 7261 776e 2066 726f 6d20  o be drawn from 
+0000bec0: 7468 650a 2020 2020 2020 6469 7374 7269  the.      distri
+0000bed0: 6275 7469 6f6e 2028 7365 6520 6162 6f76  bution (see abov
+0000bee0: 6520 666f 7220 6265 6861 7669 6f72 2069  e for behavior i
+0000bef0: 6620 6060 6869 6768 3d4e 6f6e 6560 6029  f ``high=None``)
+0000bf00: 2e0a 2020 7369 7a65 203a 2069 6e74 206f  ..  size : int o
+0000bf10: 7220 7475 706c 6520 6f66 2069 6e74 732c  r tuple of ints,
+0000bf20: 206f 7074 696f 6e61 6c0a 2020 2020 2020   optional.      
+0000bf30: 4f75 7470 7574 2073 6861 7065 2e20 2049  Output shape.  I
+0000bf40: 6620 7468 6520 6769 7665 6e20 7368 6170  f the given shap
+0000bf50: 6520 6973 2c20 652e 672e 2c20 6060 286d  e is, e.g., ``(m
+0000bf60: 2c20 6e2c 206b 2960 602c 2074 6865 6e0a  , n, k)``, then.
+0000bf70: 2020 2020 2020 6060 6d20 2a20 6e20 2a20        ``m * n * 
+0000bf80: 6b60 6020 7361 6d70 6c65 7320 6172 6520  k`` samples are 
+0000bf90: 6472 6177 6e2e 2020 4465 6661 756c 7420  drawn.  Default 
+0000bfa0: 6973 204e 6f6e 652c 2069 6e20 7768 6963  is None, in whic
+0000bfb0: 6820 6361 7365 2061 0a20 2020 2020 2073  h case a.      s
+0000bfc0: 696e 676c 6520 7661 6c75 6520 6973 2072  ingle value is r
+0000bfd0: 6574 7572 6e65 642e 0a0a 2020 5265 7475  eturned...  Retu
+0000bfe0: 726e 730a 2020 2d2d 2d2d 2d2d 2d0a 2020  rns.  -------.  
+0000bff0: 6f75 7420 3a20 696e 7420 6f72 206e 6461  out : int or nda
+0000c000: 7272 6179 206f 6620 696e 7473 0a20 2020  rray of ints.   
+0000c010: 2020 2060 7369 7a65 602d 7368 6170 6564     `size`-shaped
+0000c020: 2061 7272 6179 206f 6620 7261 6e64 6f6d   array of random
+0000c030: 2069 6e74 6567 6572 7320 6672 6f6d 2074   integers from t
+0000c040: 6865 2061 7070 726f 7072 6961 7465 0a20  he appropriate. 
+0000c050: 2020 2020 2064 6973 7472 6962 7574 696f       distributio
+0000c060: 6e2c 206f 7220 6120 7369 6e67 6c65 2073  n, or a single s
+0000c070: 7563 6820 7261 6e64 6f6d 2069 6e74 2069  uch random int i
+0000c080: 6620 6073 697a 6560 206e 6f74 2070 726f  f `size` not pro
+0000c090: 7669 6465 642e 0a0a 2020 5365 6520 416c  vided...  See Al
+0000c0a0: 736f 0a20 202d 2d2d 2d2d 2d2d 2d0a 2020  so.  --------.  
+0000c0b0: 7261 6e64 696e 7420 3a20 5369 6d69 6c61  randint : Simila
+0000c0c0: 7220 746f 2060 7261 6e64 6f6d 5f69 6e74  r to `random_int
+0000c0d0: 6567 6572 7360 2c20 6f6e 6c79 2066 6f72  egers`, only for
+0000c0e0: 2074 6865 2068 616c 662d 6f70 656e 0a20   the half-open. 
+0000c0f0: 2020 2020 2069 6e74 6572 7661 6c20 5b60       interval [`
+0000c100: 6c6f 7760 2c20 6068 6967 6860 292c 2061  low`, `high`), a
+0000c110: 6e64 2030 2069 7320 7468 6520 6c6f 7765  nd 0 is the lowe
+0000c120: 7374 2076 616c 7565 2069 6620 6068 6967  st value if `hig
+0000c130: 6860 2069 730a 2020 2020 2020 6f6d 6974  h` is.      omit
+0000c140: 7465 642e 0a0a 2020 4e6f 7465 730a 2020  ted...  Notes.  
+0000c150: 2d2d 2d2d 2d0a 2020 546f 2073 616d 706c  -----.  To sampl
+0000c160: 6520 6672 6f6d 204e 2065 7665 6e6c 7920  e from N evenly 
+0000c170: 7370 6163 6564 2066 6c6f 6174 696e 672d  spaced floating-
+0000c180: 706f 696e 7420 6e75 6d62 6572 7320 6265  point numbers be
+0000c190: 7477 6565 6e20 6120 616e 6420 622c 0a20  tween a and b,. 
+0000c1a0: 2075 7365 3a3a 0a0a 2020 2020 6120 2b20   use::..    a + 
+0000c1b0: 2862 202d 2061 2920 2a20 2862 6d2e 7261  (b - a) * (bm.ra
+0000c1c0: 6e64 6f6d 2e72 616e 646f 6d5f 696e 7465  ndom.random_inte
+0000c1d0: 6765 7273 284e 2920 2d20 3129 202f 2028  gers(N) - 1) / (
+0000c1e0: 4e20 2d20 312e 290a 0a20 2045 7861 6d70  N - 1.)..  Examp
+0000c1f0: 6c65 730a 2020 2d2d 2d2d 2d2d 2d2d 0a20  les.  --------. 
+0000c200: 203e 3e3e 2069 6d70 6f72 7420 6272 6169   >>> import brai
+0000c210: 6e70 792e 6d61 7468 2061 7320 626d 0a20  npy.math as bm. 
+0000c220: 203e 3e3e 2062 6d2e 7261 6e64 6f6d 2e72   >>> bm.random.r
+0000c230: 616e 646f 6d5f 696e 7465 6765 7273 2835  andom_integers(5
+0000c240: 290a 2020 3420 2320 7261 6e64 6f6d 0a20  ).  4 # random. 
+0000c250: 203e 3e3e 2074 7970 6528 626d 2e72 616e   >>> type(bm.ran
+0000c260: 646f 6d2e 7261 6e64 6f6d 5f69 6e74 6567  dom.random_integ
+0000c270: 6572 7328 3529 290a 2020 3c63 6c61 7373  ers(5)).  <class
+0000c280: 2027 6e75 6d70 792e 696e 7436 3427 3e0a   'numpy.int64'>.
+0000c290: 2020 3e3e 3e20 626d 2e72 616e 646f 6d2e    >>> bm.random.
+0000c2a0: 7261 6e64 6f6d 5f69 6e74 6567 6572 7328  random_integers(
+0000c2b0: 352c 2073 697a 653d 2833 2c32 2929 0a20  5, size=(3,2)). 
+0000c2c0: 2061 7272 6179 285b 5b35 2c20 345d 2c20   array([[5, 4], 
+0000c2d0: 2320 7261 6e64 6f6d 0a20 2020 2020 2020  # random.       
+0000c2e0: 2020 5b33 2c20 335d 2c0a 2020 2020 2020    [3, 3],.      
+0000c2f0: 2020 205b 342c 2035 5d5d 290a 0a20 2043     [4, 5]])..  C
+0000c300: 686f 6f73 6520 6669 7665 2072 616e 646f  hoose five rando
+0000c310: 6d20 6e75 6d62 6572 7320 6672 6f6d 2074  m numbers from t
+0000c320: 6865 2073 6574 206f 6620 6669 7665 2065  he set of five e
+0000c330: 7665 6e6c 792d 7370 6163 6564 0a20 206e  venly-spaced.  n
+0000c340: 756d 6265 7273 2062 6574 7765 656e 2030  umbers between 0
+0000c350: 2061 6e64 2032 2e35 2c20 696e 636c 7573   and 2.5, inclus
+0000c360: 6976 6520 282a 692e 652e 2a2c 2066 726f  ive (*i.e.*, fro
+0000c370: 6d20 7468 6520 7365 740a 2020 3a6d 6174  m the set.  :mat
+0000c380: 683a 607b 302c 2035 2f38 2c20 3130 2f38  h:`{0, 5/8, 10/8
+0000c390: 2c20 3135 2f38 2c20 3230 2f38 7d60 293a  , 15/8, 20/8}`):
+0000c3a0: 0a0a 2020 3e3e 3e20 322e 3520 2a20 2862  ..  >>> 2.5 * (b
+0000c3b0: 6d2e 7261 6e64 6f6d 2e72 616e 646f 6d5f  m.random.random_
+0000c3c0: 696e 7465 6765 7273 2835 2c20 7369 7a65  integers(5, size
+0000c3d0: 3d28 352c 2929 202d 2031 2920 2f20 342e  =(5,)) - 1) / 4.
+0000c3e0: 0a20 2061 7272 6179 285b 2030 2e36 3235  .  array([ 0.625
+0000c3f0: 2c20 2031 2e32 3520 2c20 2030 2e36 3235  ,  1.25 ,  0.625
+0000c400: 2c20 2030 2e36 3235 2c20 2032 2e35 2020  ,  0.625,  2.5  
+0000c410: 5d29 2023 2072 616e 646f 6d0a 0a20 2052  ]) # random..  R
+0000c420: 6f6c 6c20 7477 6f20 7369 7820 7369 6465  oll two six side
+0000c430: 6420 6469 6365 2031 3030 3020 7469 6d65  d dice 1000 time
+0000c440: 7320 616e 6420 7375 6d20 7468 6520 7265  s and sum the re
+0000c450: 7375 6c74 733a 0a0a 2020 3e3e 3e20 6431  sults:..  >>> d1
+0000c460: 203d 2062 6d2e 7261 6e64 6f6d 2e72 616e   = bm.random.ran
+0000c470: 646f 6d5f 696e 7465 6765 7273 2831 2c20  dom_integers(1, 
+0000c480: 362c 2031 3030 3029 0a20 203e 3e3e 2064  6, 1000).  >>> d
+0000c490: 3220 3d20 626d 2e72 616e 646f 6d2e 7261  2 = bm.random.ra
+0000c4a0: 6e64 6f6d 5f69 6e74 6567 6572 7328 312c  ndom_integers(1,
+0000c4b0: 2036 2c20 3130 3030 290a 2020 3e3e 3e20   6, 1000).  >>> 
+0000c4c0: 6473 756d 7320 3d20 6431 202b 2064 320a  dsums = d1 + d2.
+0000c4d0: 0a20 2044 6973 706c 6179 2072 6573 756c  .  Display resul
+0000c4e0: 7473 2061 7320 6120 6869 7374 6f67 7261  ts as a histogra
+0000c4f0: 6d3a 0a0a 2020 3e3e 3e20 696d 706f 7274  m:..  >>> import
+0000c500: 206d 6174 706c 6f74 6c69 622e 7079 706c   matplotlib.pypl
+0000c510: 6f74 2061 7320 706c 740a 2020 3e3e 3e20  ot as plt.  >>> 
+0000c520: 636f 756e 742c 2062 696e 732c 2069 676e  count, bins, ign
+0000c530: 6f72 6564 203d 2070 6c74 2e68 6973 7428  ored = plt.hist(
+0000c540: 6473 756d 732c 2031 312c 2064 656e 7369  dsums, 11, densi
+0000c550: 7479 3d54 7275 6529 0a20 203e 3e3e 2070  ty=True).  >>> p
+0000c560: 6c74 2e73 686f 7728 290a 2020 2222 220a  lt.show().  """.
+0000c570: 0a20 2072 6574 7572 6e20 4445 4641 554c  .  return DEFAUL
+0000c580: 542e 7261 6e64 6f6d 5f69 6e74 6567 6572  T.random_integer
+0000c590: 7328 6c6f 772c 2068 6967 683d 6869 6768  s(low, high=high
+0000c5a0: 2c20 7369 7a65 3d73 697a 652c 206b 6579  , size=size, key
+0000c5b0: 3d6b 6579 290a 0a0a 6465 6620 7261 6e64  =key)...def rand
+0000c5c0: 6e28 2a64 6e2c 206b 6579 3d4e 6f6e 6529  n(*dn, key=None)
+0000c5d0: 3a0a 2020 7222 2222 0a20 2052 6574 7572  :.  r""".  Retur
+0000c5e0: 6e20 6120 7361 6d70 6c65 2028 6f72 2073  n a sample (or s
+0000c5f0: 616d 706c 6573 2920 6672 6f6d 2074 6865  amples) from the
+0000c600: 2022 7374 616e 6461 7264 206e 6f72 6d61   "standard norma
+0000c610: 6c22 2064 6973 7472 6962 7574 696f 6e2e  l" distribution.
+0000c620: 0a0a 2020 2e2e 206e 6f74 653a 3a0a 2020  ..  .. note::.  
+0000c630: 2020 2020 5468 6973 2069 7320 6120 636f      This is a co
+0000c640: 6e76 656e 6965 6e63 6520 6675 6e63 7469  nvenience functi
+0000c650: 6f6e 2066 6f72 2075 7365 7273 2070 6f72  on for users por
+0000c660: 7469 6e67 2063 6f64 6520 6672 6f6d 204d  ting code from M
+0000c670: 6174 6c61 622c 0a20 2020 2020 2061 6e64  atlab,.      and
+0000c680: 2077 7261 7073 2060 7374 616e 6461 7264   wraps `standard
+0000c690: 5f6e 6f72 6d61 6c60 2e20 5468 6174 2066  _normal`. That f
+0000c6a0: 756e 6374 696f 6e20 7461 6b65 7320 610a  unction takes a.
+0000c6b0: 2020 2020 2020 7475 706c 6520 746f 2073        tuple to s
+0000c6c0: 7065 6369 6679 2074 6865 2073 697a 6520  pecify the size 
+0000c6d0: 6f66 2074 6865 206f 7574 7075 742c 2077  of the output, w
+0000c6e0: 6869 6368 2069 7320 636f 6e73 6973 7465  hich is consiste
+0000c6f0: 6e74 2077 6974 680a 2020 2020 2020 6f74  nt with.      ot
+0000c700: 6865 7220 4e75 6d50 7920 6675 6e63 7469  her NumPy functi
+0000c710: 6f6e 7320 6c69 6b65 2060 6e75 6d70 792e  ons like `numpy.
+0000c720: 7a65 726f 7360 2061 6e64 2060 6e75 6d70  zeros` and `nump
+0000c730: 792e 6f6e 6573 602e 0a0a 2020 2e2e 206e  y.ones`...  .. n
+0000c740: 6f74 653a 3a0a 2020 2020 2020 4e65 7720  ote::.      New 
+0000c750: 636f 6465 2073 686f 756c 6420 7573 6520  code should use 
+0000c760: 7468 6520 6060 7374 616e 6461 7264 5f6e  the ``standard_n
+0000c770: 6f72 6d61 6c60 6020 6d65 7468 6f64 206f  ormal`` method o
+0000c780: 6620 6120 6060 6465 6661 756c 745f 726e  f a ``default_rn
+0000c790: 6728 2960 600a 2020 2020 2020 696e 7374  g()``.      inst
+0000c7a0: 616e 6365 2069 6e73 7465 6164 3b20 706c  ance instead; pl
+0000c7b0: 6561 7365 2073 6565 2074 6865 203a 7265  ease see the :re
+0000c7c0: 663a 6072 616e 646f 6d2d 7175 6963 6b2d  f:`random-quick-
+0000c7d0: 7374 6172 7460 2e0a 0a20 2049 6620 706f  start`...  If po
+0000c7e0: 7369 7469 7665 2069 6e74 5f6c 696b 6520  sitive int_like 
+0000c7f0: 6172 6775 6d65 6e74 7320 6172 6520 7072  arguments are pr
+0000c800: 6f76 6964 6564 2c20 6072 616e 646e 6020  ovided, `randn` 
+0000c810: 6765 6e65 7261 7465 7320 616e 2061 7272  generates an arr
+0000c820: 6179 0a20 206f 6620 7368 6170 6520 6060  ay.  of shape ``
+0000c830: 2864 302c 2064 312c 202e 2e2e 2c20 646e  (d0, d1, ..., dn
+0000c840: 2960 602c 2066 696c 6c65 640a 2020 7769  )``, filled.  wi
+0000c850: 7468 2072 616e 646f 6d20 666c 6f61 7473  th random floats
+0000c860: 2073 616d 706c 6564 2066 726f 6d20 6120   sampled from a 
+0000c870: 756e 6976 6172 6961 7465 2022 6e6f 726d  univariate "norm
+0000c880: 616c 2220 2847 6175 7373 6961 6e29 0a20  al" (Gaussian). 
+0000c890: 2064 6973 7472 6962 7574 696f 6e20 6f66   distribution of
+0000c8a0: 206d 6561 6e20 3020 616e 6420 7661 7269   mean 0 and vari
+0000c8b0: 616e 6365 2031 2e20 4120 7369 6e67 6c65  ance 1. A single
+0000c8c0: 2066 6c6f 6174 2072 616e 646f 6d6c 7920   float randomly 
+0000c8d0: 7361 6d70 6c65 640a 2020 6672 6f6d 2074  sampled.  from t
+0000c8e0: 6865 2064 6973 7472 6962 7574 696f 6e20  he distribution 
+0000c8f0: 6973 2072 6574 7572 6e65 6420 6966 206e  is returned if n
+0000c900: 6f20 6172 6775 6d65 6e74 2069 7320 7072  o argument is pr
+0000c910: 6f76 6964 6564 2e0a 0a20 2050 6172 616d  ovided...  Param
+0000c920: 6574 6572 730a 2020 2d2d 2d2d 2d2d 2d2d  eters.  --------
+0000c930: 2d2d 0a20 2064 302c 2064 312c 202e 2e2e  --.  d0, d1, ...
+0000c940: 2c20 646e 203a 2069 6e74 2c20 6f70 7469  , dn : int, opti
+0000c950: 6f6e 616c 0a20 2020 2020 2054 6865 2064  onal.      The d
+0000c960: 696d 656e 7369 6f6e 7320 6f66 2074 6865  imensions of the
+0000c970: 2072 6574 7572 6e65 6420 6172 7261 792c   returned array,
+0000c980: 206d 7573 7420 6265 206e 6f6e 2d6e 6567   must be non-neg
+0000c990: 6174 6976 652e 0a20 2020 2020 2049 6620  ative..      If 
+0000c9a0: 6e6f 2061 7267 756d 656e 7420 6973 2067  no argument is g
+0000c9b0: 6976 656e 2061 2073 696e 676c 6520 5079  iven a single Py
+0000c9c0: 7468 6f6e 2066 6c6f 6174 2069 7320 7265  thon float is re
+0000c9d0: 7475 726e 6564 2e0a 0a20 2052 6574 7572  turned...  Retur
+0000c9e0: 6e73 0a20 202d 2d2d 2d2d 2d2d 0a20 205a  ns.  -------.  Z
+0000c9f0: 203a 206e 6461 7272 6179 206f 7220 666c   : ndarray or fl
+0000ca00: 6f61 740a 2020 2020 2020 4120 6060 2864  oat.      A ``(d
+0000ca10: 302c 2064 312c 202e 2e2e 2c20 646e 2960  0, d1, ..., dn)`
+0000ca20: 602d 7368 6170 6564 2061 7272 6179 206f  `-shaped array o
+0000ca30: 6620 666c 6f61 7469 6e67 2d70 6f69 6e74  f floating-point
+0000ca40: 2073 616d 706c 6573 2066 726f 6d0a 2020   samples from.  
+0000ca50: 2020 2020 7468 6520 7374 616e 6461 7264      the standard
+0000ca60: 206e 6f72 6d61 6c20 6469 7374 7269 6275   normal distribu
+0000ca70: 7469 6f6e 2c20 6f72 2061 2073 696e 676c  tion, or a singl
+0000ca80: 6520 7375 6368 2066 6c6f 6174 2069 660a  e such float if.
+0000ca90: 2020 2020 2020 6e6f 2070 6172 616d 6574        no paramet
+0000caa0: 6572 7320 7765 7265 2073 7570 706c 6965  ers were supplie
+0000cab0: 642e 0a0a 2020 5365 6520 416c 736f 0a20  d...  See Also. 
+0000cac0: 202d 2d2d 2d2d 2d2d 2d0a 2020 7374 616e   --------.  stan
+0000cad0: 6461 7264 5f6e 6f72 6d61 6c20 3a20 5369  dard_normal : Si
+0000cae0: 6d69 6c61 722c 2062 7574 2074 616b 6573  milar, but takes
+0000caf0: 2061 2074 7570 6c65 2061 7320 6974 7320   a tuple as its 
+0000cb00: 6172 6775 6d65 6e74 2e0a 2020 6e6f 726d  argument..  norm
+0000cb10: 616c 203a 2041 6c73 6f20 6163 6365 7074  al : Also accept
+0000cb20: 7320 6d75 2061 6e64 2073 6967 6d61 2061  s mu and sigma a
+0000cb30: 7267 756d 656e 7473 2e0a 2020 7261 6e64  rguments..  rand
+0000cb40: 6f6d 2e47 656e 6572 6174 6f72 2e73 7461  om.Generator.sta
+0000cb50: 6e64 6172 645f 6e6f 726d 616c 3a20 7768  ndard_normal: wh
+0000cb60: 6963 6820 7368 6f75 6c64 2062 6520 7573  ich should be us
+0000cb70: 6564 2066 6f72 206e 6577 2063 6f64 652e  ed for new code.
+0000cb80: 0a0a 2020 4e6f 7465 730a 2020 2d2d 2d2d  ..  Notes.  ----
+0000cb90: 2d0a 2020 466f 7220 7261 6e64 6f6d 2073  -.  For random s
+0000cba0: 616d 706c 6573 2066 726f 6d20 3a6d 6174  amples from :mat
+0000cbb0: 683a 604e 285c 6d75 2c20 5c73 6967 6d61  h:`N(\mu, \sigma
+0000cbc0: 5e32 2960 2c20 7573 653a 0a0a 2020 6060  ^2)`, use:..  ``
+0000cbd0: 7369 676d 6120 2a20 626d 2e72 616e 646f  sigma * bm.rando
+0000cbe0: 6d2e 7261 6e64 6e28 2e2e 2e29 202b 206d  m.randn(...) + m
+0000cbf0: 7560 600a 0a20 2045 7861 6d70 6c65 730a  u``..  Examples.
+0000cc00: 2020 2d2d 2d2d 2d2d 2d2d 0a20 203e 3e3e    --------.  >>>
+0000cc10: 2069 6d70 6f72 7420 6272 6169 6e70 792e   import brainpy.
+0000cc20: 6d61 7468 2061 7320 626d 0a20 203e 3e3e  math as bm.  >>>
+0000cc30: 2062 6d2e 7261 6e64 6f6d 2e72 616e 646e   bm.random.randn
+0000cc40: 2829 0a20 2032 2e31 3932 3338 3735 3333  ().  2.192387533
+0000cc50: 3535 3337 3331 3520 2023 2072 616e 646f  5537315  # rando
+0000cc60: 6d0a 0a20 2054 776f 2d62 792d 666f 7572  m..  Two-by-four
+0000cc70: 2061 7272 6179 206f 6620 7361 6d70 6c65   array of sample
+0000cc80: 7320 6672 6f6d 204e 2833 2c20 362e 3235  s from N(3, 6.25
+0000cc90: 293a 0a0a 2020 3e3e 3e20 3320 2b20 322e  ):..  >>> 3 + 2.
+0000cca0: 3520 2a20 626d 2e72 616e 646f 6d2e 7261  5 * bm.random.ra
+0000ccb0: 6e64 6e28 322c 2034 290a 2020 6172 7261  ndn(2, 4).  arra
+0000ccc0: 7928 5b5b 2d34 2e34 3934 3031 3530 312c  y([[-4.49401501,
+0000ccd0: 2020 342e 3030 3935 3030 3334 2c20 2d31    4.00950034, -1
+0000cce0: 2e38 3138 3134 3836 372c 2020 372e 3239  .81814867,  7.29
+0000ccf0: 3731 3836 3737 5d2c 2020 2023 2072 616e  718677],   # ran
+0000cd00: 646f 6d0a 2020 2020 2020 2020 205b 2030  dom.         [ 0
+0000cd10: 2e33 3939 3234 3830 342c 2020 342e 3638  .39924804,  4.68
+0000cd20: 3435 3633 3136 2c20 2034 2e39 3933 3934  456316,  4.99394
+0000cd30: 3532 392c 2020 342e 3834 3035 3732 3534  529,  4.84057254
+0000cd40: 5d5d 2920 2023 2072 616e 646f 6d0a 2020  ]])  # random.  
+0000cd50: 2222 220a 0a20 2072 6574 7572 6e20 4445  """..  return DE
+0000cd60: 4641 554c 542e 7261 6e64 6e28 2a64 6e2c  FAULT.randn(*dn,
+0000cd70: 206b 6579 3d6b 6579 290a 0a0a 6465 6620   key=key)...def 
+0000cd80: 7261 6e64 6f6d 2873 697a 653d 4e6f 6e65  random(size=None
+0000cd90: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2022  , key=None):.  "
+0000cda0: 2222 0a20 2052 6574 7572 6e20 7261 6e64  "".  Return rand
+0000cdb0: 6f6d 2066 6c6f 6174 7320 696e 2074 6865  om floats in the
+0000cdc0: 2068 616c 662d 6f70 656e 2069 6e74 6572   half-open inter
+0000cdd0: 7661 6c20 5b30 2e30 2c20 312e 3029 2e20  val [0.0, 1.0). 
+0000cde0: 416c 6961 7320 666f 720a 2020 6072 616e  Alias for.  `ran
+0000cdf0: 646f 6d5f 7361 6d70 6c65 6020 746f 2065  dom_sample` to e
+0000ce00: 6173 6520 666f 7277 6172 642d 706f 7274  ase forward-port
+0000ce10: 696e 6720 746f 2074 6865 206e 6577 2072  ing to the new r
+0000ce20: 616e 646f 6d20 4150 492e 0a20 2022 2222  andom API..  """
+0000ce30: 0a20 2072 6574 7572 6e20 4445 4641 554c  .  return DEFAUL
+0000ce40: 542e 7261 6e64 6f6d 2873 697a 652c 206b  T.random(size, k
+0000ce50: 6579 3d6b 6579 290a 0a0a 6465 6620 7261  ey=key)...def ra
+0000ce60: 6e64 6f6d 5f73 616d 706c 6528 7369 7a65  ndom_sample(size
+0000ce70: 3d4e 6f6e 652c 206b 6579 3d4e 6f6e 6529  =None, key=None)
+0000ce80: 3a0a 2020 7222 2222 0a20 2052 6574 7572  :.  r""".  Retur
+0000ce90: 6e20 7261 6e64 6f6d 2066 6c6f 6174 7320  n random floats 
+0000cea0: 696e 2074 6865 2068 616c 662d 6f70 656e  in the half-open
+0000ceb0: 2069 6e74 6572 7661 6c20 5b30 2e30 2c20   interval [0.0, 
+0000cec0: 312e 3029 2e0a 0a20 2052 6573 756c 7473  1.0)...  Results
+0000ced0: 2061 7265 2066 726f 6d20 7468 6520 2263   are from the "c
+0000cee0: 6f6e 7469 6e75 6f75 7320 756e 6966 6f72  ontinuous unifor
+0000cef0: 6d22 2064 6973 7472 6962 7574 696f 6e20  m" distribution 
+0000cf00: 6f76 6572 2074 6865 0a20 2073 7461 7465  over the.  state
+0000cf10: 6420 696e 7465 7276 616c 2e20 2054 6f20  d interval.  To 
+0000cf20: 7361 6d70 6c65 203a 6d61 7468 3a60 556e  sample :math:`Un
+0000cf30: 6966 5b61 2c20 6229 2c20 6220 3e20 6160  if[a, b), b > a`
+0000cf40: 206d 756c 7469 706c 790a 2020 7468 6520   multiply.  the 
+0000cf50: 6f75 7470 7574 206f 6620 6072 616e 646f  output of `rando
+0000cf60: 6d5f 7361 6d70 6c65 6020 6279 2060 2862  m_sample` by `(b
+0000cf70: 2d61 2960 2061 6e64 2061 6464 2060 6160  -a)` and add `a`
+0000cf80: 3a3a 0a0a 2020 2020 2862 202d 2061 2920  ::..    (b - a) 
+0000cf90: 2a20 7261 6e64 6f6d 5f73 616d 706c 6528  * random_sample(
+0000cfa0: 2920 2b20 610a 0a20 202e 2e20 6e6f 7465  ) + a..  .. note
+0000cfb0: 3a3a 0a20 2020 2020 204e 6577 2063 6f64  ::.      New cod
+0000cfc0: 6520 7368 6f75 6c64 2075 7365 2074 6865  e should use the
+0000cfd0: 2060 6072 616e 646f 6d60 6020 6d65 7468   ``random`` meth
+0000cfe0: 6f64 206f 6620 6120 6060 6465 6661 756c  od of a ``defaul
+0000cff0: 745f 726e 6728 2960 600a 2020 2020 2020  t_rng()``.      
+0000d000: 696e 7374 616e 6365 2069 6e73 7465 6164  instance instead
+0000d010: 3b20 706c 6561 7365 2073 6565 2074 6865  ; please see the
+0000d020: 203a 7265 663a 6072 616e 646f 6d2d 7175   :ref:`random-qu
+0000d030: 6963 6b2d 7374 6172 7460 2e0a 0a20 2050  ick-start`...  P
+0000d040: 6172 616d 6574 6572 730a 2020 2d2d 2d2d  arameters.  ----
+0000d050: 2d2d 2d2d 2d2d 0a20 2073 697a 6520 3a20  ------.  size : 
+0000d060: 696e 7420 6f72 2074 7570 6c65 206f 6620  int or tuple of 
+0000d070: 696e 7473 2c20 6f70 7469 6f6e 616c 0a20  ints, optional. 
+0000d080: 2020 2020 204f 7574 7075 7420 7368 6170       Output shap
+0000d090: 652e 2020 4966 2074 6865 2067 6976 656e  e.  If the given
+0000d0a0: 2073 6861 7065 2069 732c 2065 2e67 2e2c   shape is, e.g.,
+0000d0b0: 2060 6028 6d2c 206e 2c20 6b29 6060 2c20   ``(m, n, k)``, 
+0000d0c0: 7468 656e 0a20 2020 2020 2060 606d 202a  then.      ``m *
+0000d0d0: 206e 202a 206b 6060 2073 616d 706c 6573   n * k`` samples
+0000d0e0: 2061 7265 2064 7261 776e 2e20 2044 6566   are drawn.  Def
+0000d0f0: 6175 6c74 2069 7320 4e6f 6e65 2c20 696e  ault is None, in
+0000d100: 2077 6869 6368 2063 6173 6520 610a 2020   which case a.  
+0000d110: 2020 2020 7369 6e67 6c65 2076 616c 7565      single value
+0000d120: 2069 7320 7265 7475 726e 6564 2e0a 0a20   is returned... 
+0000d130: 2052 6574 7572 6e73 0a20 202d 2d2d 2d2d   Returns.  -----
+0000d140: 2d2d 0a20 206f 7574 203a 2066 6c6f 6174  --.  out : float
+0000d150: 206f 7220 6e64 6172 7261 7920 6f66 2066   or ndarray of f
+0000d160: 6c6f 6174 730a 2020 2020 2020 4172 7261  loats.      Arra
+0000d170: 7920 6f66 2072 616e 646f 6d20 666c 6f61  y of random floa
+0000d180: 7473 206f 6620 7368 6170 6520 6073 697a  ts of shape `siz
+0000d190: 6560 2028 756e 6c65 7373 2060 6073 697a  e` (unless ``siz
+0000d1a0: 653d 4e6f 6e65 6060 2c20 696e 2077 6869  e=None``, in whi
+0000d1b0: 6368 0a20 2020 2020 2063 6173 6520 6120  ch.      case a 
+0000d1c0: 7369 6e67 6c65 2066 6c6f 6174 2069 7320  single float is 
+0000d1d0: 7265 7475 726e 6564 292e 0a0a 2020 5365  returned)...  Se
+0000d1e0: 6520 416c 736f 0a20 202d 2d2d 2d2d 2d2d  e Also.  -------
+0000d1f0: 2d0a 2020 4765 6e65 7261 746f 722e 7261  -.  Generator.ra
+0000d200: 6e64 6f6d 3a20 7768 6963 6820 7368 6f75  ndom: which shou
+0000d210: 6c64 2062 6520 7573 6564 2066 6f72 206e  ld be used for n
+0000d220: 6577 2063 6f64 652e 0a0a 2020 4578 616d  ew code...  Exam
+0000d230: 706c 6573 0a20 202d 2d2d 2d2d 2d2d 2d0a  ples.  --------.
+0000d240: 2020 3e3e 3e20 696d 706f 7274 2062 7261    >>> import bra
+0000d250: 696e 7079 2e6d 6174 6820 6173 2062 6d0a  inpy.math as bm.
+0000d260: 2020 3e3e 3e20 626d 2e72 616e 646f 6d2e    >>> bm.random.
+0000d270: 7261 6e64 6f6d 5f73 616d 706c 6528 290a  random_sample().
+0000d280: 2020 302e 3437 3130 3835 3437 3939 3533    0.471085479953
+0000d290: 3536 3039 3820 2320 7261 6e64 6f6d 0a20  56098 # random. 
+0000d2a0: 203e 3e3e 2074 7970 6528 626d 2e72 616e   >>> type(bm.ran
+0000d2b0: 646f 6d2e 7261 6e64 6f6d 5f73 616d 706c  dom.random_sampl
+0000d2c0: 6528 2929 0a20 203c 636c 6173 7320 2766  e()).  <class 'f
+0000d2d0: 6c6f 6174 273e 0a20 203e 3e3e 2062 6d2e  loat'>.  >>> bm.
+0000d2e0: 7261 6e64 6f6d 2e72 616e 646f 6d5f 7361  random.random_sa
+0000d2f0: 6d70 6c65 2828 352c 2929 0a20 2061 7272  mple((5,)).  arr
+0000d300: 6179 285b 2030 2e33 3032 3230 3438 322c  ay([ 0.30220482,
+0000d310: 2020 302e 3836 3832 3034 3031 2c20 2030    0.86820401,  0
+0000d320: 2e31 3635 3435 3033 202c 2020 302e 3131  .1654503 ,  0.11
+0000d330: 3635 3931 3439 2c20 2030 2e35 3433 3233  659149,  0.54323
+0000d340: 3432 385d 2920 2320 7261 6e64 6f6d 0a0a  428]) # random..
+0000d350: 2020 5468 7265 652d 6279 2d74 776f 2061    Three-by-two a
+0000d360: 7272 6179 206f 6620 7261 6e64 6f6d 206e  rray of random n
+0000d370: 756d 6265 7273 2066 726f 6d20 5b2d 352c  umbers from [-5,
+0000d380: 2030 293a 0a0a 2020 3e3e 3e20 3520 2a20   0):..  >>> 5 * 
+0000d390: 626d 2e72 616e 646f 6d2e 7261 6e64 6f6d  bm.random.random
+0000d3a0: 5f73 616d 706c 6528 2833 2c20 3229 2920  _sample((3, 2)) 
+0000d3b0: 2d20 350a 2020 6172 7261 7928 5b5b 2d33  - 5.  array([[-3
+0000d3c0: 2e39 3931 3439 3938 392c 202d 302e 3532  .99149989, -0.52
+0000d3d0: 3333 3839 3834 5d2c 2023 2072 616e 646f  338984], # rando
+0000d3e0: 6d0a 2020 2020 2020 2020 205b 2d32 2e39  m.         [-2.9
+0000d3f0: 3930 3931 3835 382c 202d 302e 3739 3437  9091858, -0.7947
+0000d400: 3935 3038 5d2c 0a20 2020 2020 2020 2020  9508],.         
+0000d410: 5b2d 312e 3233 3230 3433 3435 2c20 2d31  [-1.23204345, -1
+0000d420: 2e37 3532 3234 3439 345d 5d29 0a20 2022  .75224494]]).  "
+0000d430: 2222 0a20 2072 6574 7572 6e20 4445 4641  "".  return DEFA
+0000d440: 554c 542e 7261 6e64 6f6d 5f73 616d 706c  ULT.random_sampl
+0000d450: 6528 7369 7a65 2c20 6b65 793d 6b65 7929  e(size, key=key)
+0000d460: 0a0a 0a64 6566 2072 616e 6628 7369 7a65  ...def ranf(size
+0000d470: 3d4e 6f6e 652c 206b 6579 3d4e 6f6e 6529  =None, key=None)
+0000d480: 3a0a 2020 2222 220a 2020 5468 6973 2069  :.  """.  This i
+0000d490: 7320 616e 2061 6c69 6173 206f 6620 6072  s an alias of `r
+0000d4a0: 616e 646f 6d5f 7361 6d70 6c65 602e 2053  andom_sample`. S
+0000d4b0: 6565 2060 7261 6e64 6f6d 5f73 616d 706c  ee `random_sampl
+0000d4c0: 6560 2020 666f 7220 7468 6520 636f 6d70  e`  for the comp
+0000d4d0: 6c65 7465 0a20 2020 2020 2064 6f63 756d  lete.      docum
+0000d4e0: 656e 7461 7469 6f6e 2e0a 2020 2222 220a  entation..  """.
+0000d4f0: 2020 7265 7475 726e 2044 4546 4155 4c54    return DEFAULT
+0000d500: 2e72 616e 6628 7369 7a65 2c20 6b65 793d  .ranf(size, key=
+0000d510: 6b65 7929 0a0a 0a64 6566 2073 616d 706c  key)...def sampl
+0000d520: 6528 7369 7a65 3d4e 6f6e 652c 206b 6579  e(size=None, key
+0000d530: 3d4e 6f6e 6529 3a0a 2020 2222 220a 2020  =None):.  """.  
+0000d540: 5468 6973 2069 7320 616e 2061 6c69 6173  This is an alias
+0000d550: 206f 6620 6072 616e 646f 6d5f 7361 6d70   of `random_samp
+0000d560: 6c65 602e 2053 6565 2060 7261 6e64 6f6d  le`. See `random
+0000d570: 5f73 616d 706c 6560 2020 666f 7220 7468  _sample`  for th
+0000d580: 6520 636f 6d70 6c65 7465 0a20 2020 2020  e complete.     
+0000d590: 2064 6f63 756d 656e 7461 7469 6f6e 2e0a   documentation..
+0000d5a0: 2020 2222 220a 2020 7265 7475 726e 2044    """.  return D
+0000d5b0: 4546 4155 4c54 2e73 616d 706c 6528 7369  EFAULT.sample(si
+0000d5c0: 7a65 2c20 6b65 793d 6b65 7929 0a0a 0a64  ze, key=key)...d
+0000d5d0: 6566 2063 686f 6963 6528 612c 2073 697a  ef choice(a, siz
+0000d5e0: 653d 4e6f 6e65 2c20 7265 706c 6163 653d  e=None, replace=
+0000d5f0: 5472 7565 2c20 703d 4e6f 6e65 2c20 6b65  True, p=None, ke
+0000d600: 793d 4e6f 6e65 293a 0a20 2072 2222 220a  y=None):.  r""".
+0000d610: 2020 4765 6e65 7261 7465 7320 6120 7261    Generates a ra
+0000d620: 6e64 6f6d 2073 616d 706c 6520 6672 6f6d  ndom sample from
+0000d630: 2061 2067 6976 656e 2031 2d44 2061 7272   a given 1-D arr
+0000d640: 6179 0a0a 2020 5061 7261 6d65 7465 7273  ay..  Parameters
+0000d650: 0a20 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020  .  ----------.  
+0000d660: 6120 3a20 312d 4420 6172 7261 792d 6c69  a : 1-D array-li
+0000d670: 6b65 206f 7220 696e 740a 2020 2020 2020  ke or int.      
+0000d680: 4966 2061 6e20 6e64 6172 7261 792c 2061  If an ndarray, a
+0000d690: 2072 616e 646f 6d20 7361 6d70 6c65 2069   random sample i
+0000d6a0: 7320 6765 6e65 7261 7465 6420 6672 6f6d  s generated from
+0000d6b0: 2069 7473 2065 6c65 6d65 6e74 732e 0a20   its elements.. 
+0000d6c0: 2020 2020 2049 6620 616e 2069 6e74 2c20       If an int, 
+0000d6d0: 7468 6520 7261 6e64 6f6d 2073 616d 706c  the random sampl
+0000d6e0: 6520 6973 2067 656e 6572 6174 6564 2061  e is generated a
+0000d6f0: 7320 6966 2069 7420 7765 7265 2060 606e  s if it were ``n
+0000d700: 702e 6172 616e 6765 2861 2960 600a 2020  p.arange(a)``.  
+0000d710: 7369 7a65 203a 2069 6e74 206f 7220 7475  size : int or tu
+0000d720: 706c 6520 6f66 2069 6e74 732c 206f 7074  ple of ints, opt
+0000d730: 696f 6e61 6c0a 2020 2020 2020 4f75 7470  ional.      Outp
+0000d740: 7574 2073 6861 7065 2e20 2049 6620 7468  ut shape.  If th
+0000d750: 6520 6769 7665 6e20 7368 6170 6520 6973  e given shape is
+0000d760: 2c20 652e 672e 2c20 6060 286d 2c20 6e2c  , e.g., ``(m, n,
+0000d770: 206b 2960 602c 2074 6865 6e0a 2020 2020   k)``, then.    
+0000d780: 2020 6060 6d20 2a20 6e20 2a20 6b60 6020    ``m * n * k`` 
+0000d790: 7361 6d70 6c65 7320 6172 6520 6472 6177  samples are draw
+0000d7a0: 6e2e 2020 4465 6661 756c 7420 6973 204e  n.  Default is N
+0000d7b0: 6f6e 652c 2069 6e20 7768 6963 6820 6361  one, in which ca
+0000d7c0: 7365 2061 0a20 2020 2020 2073 696e 676c  se a.      singl
+0000d7d0: 6520 7661 6c75 6520 6973 2072 6574 7572  e value is retur
+0000d7e0: 6e65 642e 0a20 2072 6570 6c61 6365 203a  ned..  replace :
+0000d7f0: 2062 6f6f 6c65 616e 2c20 6f70 7469 6f6e   boolean, option
+0000d800: 616c 0a20 2020 2020 2057 6865 7468 6572  al.      Whether
+0000d810: 2074 6865 2073 616d 706c 6520 6973 2077   the sample is w
+0000d820: 6974 6820 6f72 2077 6974 686f 7574 2072  ith or without r
+0000d830: 6570 6c61 6365 6d65 6e74 2e20 4465 6661  eplacement. Defa
+0000d840: 756c 7420 6973 2054 7275 652c 0a20 2020  ult is True,.   
+0000d850: 2020 206d 6561 6e69 6e67 2074 6861 7420     meaning that 
+0000d860: 6120 7661 6c75 6520 6f66 2060 6061 6060  a value of ``a``
+0000d870: 2063 616e 2062 6520 7365 6c65 6374 6564   can be selected
+0000d880: 206d 756c 7469 706c 6520 7469 6d65 732e   multiple times.
+0000d890: 0a20 2070 203a 2031 2d44 2061 7272 6179  .  p : 1-D array
+0000d8a0: 2d6c 696b 652c 206f 7074 696f 6e61 6c0a  -like, optional.
+0000d8b0: 2020 2020 2020 5468 6520 7072 6f62 6162        The probab
+0000d8c0: 696c 6974 6965 7320 6173 736f 6369 6174  ilities associat
+0000d8d0: 6564 2077 6974 6820 6561 6368 2065 6e74  ed with each ent
+0000d8e0: 7279 2069 6e20 612e 0a20 2020 2020 2049  ry in a..      I
+0000d8f0: 6620 6e6f 7420 6769 7665 6e2c 2074 6865  f not given, the
+0000d900: 2073 616d 706c 6520 6173 7375 6d65 7320   sample assumes 
+0000d910: 6120 756e 6966 6f72 6d20 6469 7374 7269  a uniform distri
+0000d920: 6275 7469 6f6e 206f 7665 7220 616c 6c0a  bution over all.
+0000d930: 2020 2020 2020 656e 7472 6965 7320 696e        entries in
+0000d940: 2060 6061 6060 2e0a 0a20 2052 6574 7572   ``a``...  Retur
+0000d950: 6e73 0a20 202d 2d2d 2d2d 2d2d 0a20 2073  ns.  -------.  s
+0000d960: 616d 706c 6573 203a 2073 696e 676c 6520  amples : single 
+0000d970: 6974 656d 206f 7220 6e64 6172 7261 790a  item or ndarray.
+0000d980: 2020 2020 2020 5468 6520 6765 6e65 7261        The genera
+0000d990: 7465 6420 7261 6e64 6f6d 2073 616d 706c  ted random sampl
+0000d9a0: 6573 0a0a 2020 5261 6973 6573 0a20 202d  es..  Raises.  -
+0000d9b0: 2d2d 2d2d 2d0a 2020 5661 6c75 6545 7272  -----.  ValueErr
+0000d9c0: 6f72 0a20 2020 2020 2049 6620 6120 6973  or.      If a is
+0000d9d0: 2061 6e20 696e 7420 616e 6420 6c65 7373   an int and less
+0000d9e0: 2074 6861 6e20 7a65 726f 2c20 6966 2061   than zero, if a
+0000d9f0: 206f 7220 7020 6172 6520 6e6f 7420 312d   or p are not 1-
+0000da00: 6469 6d65 6e73 696f 6e61 6c2c 0a20 2020  dimensional,.   
+0000da10: 2020 2069 6620 6120 6973 2061 6e20 6172     if a is an ar
+0000da20: 7261 792d 6c69 6b65 206f 6620 7369 7a65  ray-like of size
+0000da30: 2030 2c20 6966 2070 2069 7320 6e6f 7420   0, if p is not 
+0000da40: 6120 7665 6374 6f72 206f 660a 2020 2020  a vector of.    
+0000da50: 2020 7072 6f62 6162 696c 6974 6965 732c    probabilities,
+0000da60: 2069 6620 6120 616e 6420 7020 6861 7665   if a and p have
+0000da70: 2064 6966 6665 7265 6e74 206c 656e 6774   different lengt
+0000da80: 6873 2c20 6f72 2069 660a 2020 2020 2020  hs, or if.      
+0000da90: 7265 706c 6163 653d 4661 6c73 6520 616e  replace=False an
+0000daa0: 6420 7468 6520 7361 6d70 6c65 2073 697a  d the sample siz
+0000dab0: 6520 6973 2067 7265 6174 6572 2074 6861  e is greater tha
+0000dac0: 6e20 7468 6520 706f 7075 6c61 7469 6f6e  n the population
+0000dad0: 0a20 2020 2020 2073 697a 650a 0a20 2053  .      size..  S
+0000dae0: 6565 2041 6c73 6f0a 2020 2d2d 2d2d 2d2d  ee Also.  ------
+0000daf0: 2d2d 0a20 2072 616e 6469 6e74 2c20 7368  --.  randint, sh
+0000db00: 7566 666c 652c 2070 6572 6d75 7461 7469  uffle, permutati
+0000db10: 6f6e 0a20 2047 656e 6572 6174 6f72 2e63  on.  Generator.c
+0000db20: 686f 6963 653a 2077 6869 6368 2073 686f  hoice: which sho
+0000db30: 756c 6420 6265 2075 7365 6420 696e 206e  uld be used in n
+0000db40: 6577 2063 6f64 650a 0a20 204e 6f74 6573  ew code..  Notes
+0000db50: 0a20 202d 2d2d 2d2d 0a20 2053 6574 7469  .  -----.  Setti
+0000db60: 6e67 2075 7365 722d 7370 6563 6966 6965  ng user-specifie
+0000db70: 6420 7072 6f62 6162 696c 6974 6965 7320  d probabilities 
+0000db80: 7468 726f 7567 6820 6060 7060 6020 7573  through ``p`` us
+0000db90: 6573 2061 206d 6f72 6520 6765 6e65 7261  es a more genera
+0000dba0: 6c20 6275 7420 6c65 7373 0a20 2065 6666  l but less.  eff
+0000dbb0: 6963 6965 6e74 2073 616d 706c 6572 2074  icient sampler t
+0000dbc0: 6861 6e20 7468 6520 6465 6661 756c 742e  han the default.
+0000dbd0: 2054 6865 2067 656e 6572 616c 2073 616d   The general sam
+0000dbe0: 706c 6572 2070 726f 6475 6365 7320 6120  pler produces a 
+0000dbf0: 6469 6666 6572 656e 7420 7361 6d70 6c65  different sample
+0000dc00: 0a20 2074 6861 6e20 7468 6520 6f70 7469  .  than the opti
+0000dc10: 6d69 7a65 6420 7361 6d70 6c65 7220 6576  mized sampler ev
+0000dc20: 656e 2069 6620 6561 6368 2065 6c65 6d65  en if each eleme
+0000dc30: 6e74 206f 6620 6060 7060 6020 6973 2031  nt of ``p`` is 1
+0000dc40: 202f 206c 656e 2861 292e 0a0a 2020 5361   / len(a)...  Sa
+0000dc50: 6d70 6c69 6e67 2072 616e 646f 6d20 726f  mpling random ro
+0000dc60: 7773 2066 726f 6d20 6120 322d 4420 6172  ws from a 2-D ar
+0000dc70: 7261 7920 6973 206e 6f74 2070 6f73 7369  ray is not possi
+0000dc80: 626c 6520 7769 7468 2074 6869 7320 6675  ble with this fu
+0000dc90: 6e63 7469 6f6e 2c0a 2020 6275 7420 6973  nction,.  but is
+0000dca0: 2070 6f73 7369 626c 6520 7769 7468 2060   possible with `
+0000dcb0: 4765 6e65 7261 746f 722e 6368 6f69 6365  Generator.choice
+0000dcc0: 6020 7468 726f 7567 6820 6974 7320 6060  ` through its ``
+0000dcd0: 6178 6973 6060 206b 6579 776f 7264 2e0a  axis`` keyword..
+0000dce0: 0a20 2045 7861 6d70 6c65 730a 2020 2d2d  .  Examples.  --
+0000dcf0: 2d2d 2d2d 2d2d 0a20 2047 656e 6572 6174  ------.  Generat
+0000dd00: 6520 6120 756e 6966 6f72 6d20 7261 6e64  e a uniform rand
+0000dd10: 6f6d 2073 616d 706c 6520 6672 6f6d 206e  om sample from n
+0000dd20: 702e 6172 616e 6765 2835 2920 6f66 2073  p.arange(5) of s
+0000dd30: 697a 6520 333a 0a0a 2020 3e3e 3e20 696d  ize 3:..  >>> im
+0000dd40: 706f 7274 2062 7261 696e 7079 2e6d 6174  port brainpy.mat
+0000dd50: 6820 6173 2062 6d0a 2020 3e3e 3e20 626d  h as bm.  >>> bm
+0000dd60: 2e72 616e 646f 6d2e 6368 6f69 6365 2835  .random.choice(5
+0000dd70: 2c20 3329 0a20 2061 7272 6179 285b 302c  , 3).  array([0,
+0000dd80: 2033 2c20 345d 2920 2320 7261 6e64 6f6d   3, 4]) # random
+0000dd90: 0a20 203e 3e3e 2023 5468 6973 2069 7320  .  >>> #This is 
+0000dda0: 6571 7569 7661 6c65 6e74 2074 6f20 6272  equivalent to br
+0000ddb0: 6169 6e70 792e 6d61 7468 2e72 616e 646f  ainpy.math.rando
+0000ddc0: 6d2e 7261 6e64 696e 7428 302c 352c 3329  m.randint(0,5,3)
+0000ddd0: 0a0a 2020 4765 6e65 7261 7465 2061 206e  ..  Generate a n
+0000dde0: 6f6e 2d75 6e69 666f 726d 2072 616e 646f  on-uniform rando
+0000ddf0: 6d20 7361 6d70 6c65 2066 726f 6d20 6e70  m sample from np
+0000de00: 2e61 7261 6e67 6528 3529 206f 6620 7369  .arange(5) of si
+0000de10: 7a65 2033 3a0a 0a20 203e 3e3e 2062 6d2e  ze 3:..  >>> bm.
+0000de20: 7261 6e64 6f6d 2e63 686f 6963 6528 352c  random.choice(5,
+0000de30: 2033 2c20 703d 5b30 2e31 2c20 302c 2030   3, p=[0.1, 0, 0
+0000de40: 2e33 2c20 302e 362c 2030 5d29 0a20 2061  .3, 0.6, 0]).  a
+0000de50: 7272 6179 285b 332c 2033 2c20 305d 2920  rray([3, 3, 0]) 
+0000de60: 2320 7261 6e64 6f6d 0a0a 2020 4765 6e65  # random..  Gene
+0000de70: 7261 7465 2061 2075 6e69 666f 726d 2072  rate a uniform r
+0000de80: 616e 646f 6d20 7361 6d70 6c65 2066 726f  andom sample fro
+0000de90: 6d20 6e70 2e61 7261 6e67 6528 3529 206f  m np.arange(5) o
+0000dea0: 6620 7369 7a65 2033 2077 6974 686f 7574  f size 3 without
+0000deb0: 0a20 2072 6570 6c61 6365 6d65 6e74 3a0a  .  replacement:.
+0000dec0: 0a20 203e 3e3e 2062 6d2e 7261 6e64 6f6d  .  >>> bm.random
+0000ded0: 2e63 686f 6963 6528 352c 2033 2c20 7265  .choice(5, 3, re
+0000dee0: 706c 6163 653d 4661 6c73 6529 0a20 2061  place=False).  a
+0000def0: 7272 6179 285b 332c 312c 305d 2920 2320  rray([3,1,0]) # 
+0000df00: 7261 6e64 6f6d 0a20 203e 3e3e 2023 5468  random.  >>> #Th
+0000df10: 6973 2069 7320 6571 7569 7661 6c65 6e74  is is equivalent
+0000df20: 2074 6f20 6272 6169 6e70 792e 6d61 7468   to brainpy.math
+0000df30: 2e72 616e 646f 6d2e 7065 726d 7574 6174  .random.permutat
+0000df40: 696f 6e28 6e70 2e61 7261 6e67 6528 3529  ion(np.arange(5)
+0000df50: 295b 3a33 5d0a 0a20 2047 656e 6572 6174  )[:3]..  Generat
+0000df60: 6520 6120 6e6f 6e2d 756e 6966 6f72 6d20  e a non-uniform 
+0000df70: 7261 6e64 6f6d 2073 616d 706c 6520 6672  random sample fr
+0000df80: 6f6d 206e 702e 6172 616e 6765 2835 2920  om np.arange(5) 
+0000df90: 6f66 2073 697a 650a 2020 3320 7769 7468  of size.  3 with
+0000dfa0: 6f75 7420 7265 706c 6163 656d 656e 743a  out replacement:
+0000dfb0: 0a0a 2020 3e3e 3e20 626d 2e72 616e 646f  ..  >>> bm.rando
+0000dfc0: 6d2e 6368 6f69 6365 2835 2c20 332c 2072  m.choice(5, 3, r
+0000dfd0: 6570 6c61 6365 3d46 616c 7365 2c20 703d  eplace=False, p=
+0000dfe0: 5b30 2e31 2c20 302c 2030 2e33 2c20 302e  [0.1, 0, 0.3, 0.
+0000dff0: 362c 2030 5d29 0a20 2061 7272 6179 285b  6, 0]).  array([
+0000e000: 322c 2033 2c20 305d 2920 2320 7261 6e64  2, 3, 0]) # rand
+0000e010: 6f6d 0a0a 2020 416e 7920 6f66 2074 6865  om..  Any of the
+0000e020: 2061 626f 7665 2063 616e 2062 6520 7265   above can be re
+0000e030: 7065 6174 6564 2077 6974 6820 616e 2061  peated with an a
+0000e040: 7262 6974 7261 7279 2061 7272 6179 2d6c  rbitrary array-l
+0000e050: 696b 650a 2020 696e 7374 6561 6420 6f66  ike.  instead of
+0000e060: 206a 7573 7420 696e 7465 6765 7273 2e20   just integers. 
+0000e070: 466f 7220 696e 7374 616e 6365 3a0a 0a20  For instance:.. 
+0000e080: 203e 3e3e 2061 615f 6d69 6c6e 655f 6172   >>> aa_milne_ar
+0000e090: 7220 3d20 5b27 706f 6f68 272c 2027 7261  r = ['pooh', 'ra
+0000e0a0: 6262 6974 272c 2027 7069 676c 6574 272c  bbit', 'piglet',
+0000e0b0: 2027 4368 7269 7374 6f70 6865 7227 5d0a   'Christopher'].
+0000e0c0: 2020 3e3e 3e20 626d 2e72 616e 646f 6d2e    >>> bm.random.
+0000e0d0: 6368 6f69 6365 2861 615f 6d69 6c6e 655f  choice(aa_milne_
+0000e0e0: 6172 722c 2035 2c20 703d 5b30 2e35 2c20  arr, 5, p=[0.5, 
+0000e0f0: 302e 312c 2030 2e31 2c20 302e 335d 290a  0.1, 0.1, 0.3]).
+0000e100: 2020 6172 7261 7928 5b27 706f 6f68 272c    array(['pooh',
+0000e110: 2027 706f 6f68 272c 2027 706f 6f68 272c   'pooh', 'pooh',
+0000e120: 2027 4368 7269 7374 6f70 6865 7227 2c20   'Christopher', 
+0000e130: 2770 6967 6c65 7427 5d2c 2023 2072 616e  'piglet'], # ran
+0000e140: 646f 6d0a 2020 2020 2020 2020 6474 7970  dom.        dtyp
+0000e150: 653d 273c 5531 3127 290a 2020 2222 220a  e='<U11').  """.
+0000e160: 2020 6120 3d20 5f61 735f 6a61 785f 6172    a = _as_jax_ar
+0000e170: 7261 7928 6129 0a20 2072 6574 7572 6e20  ray(a).  return 
+0000e180: 4445 4641 554c 542e 6368 6f69 6365 2861  DEFAULT.choice(a
+0000e190: 3d61 2c20 7369 7a65 3d73 697a 652c 2072  =a, size=size, r
+0000e1a0: 6570 6c61 6365 3d72 6570 6c61 6365 2c20  eplace=replace, 
+0000e1b0: 703d 702c 206b 6579 3d6b 6579 290a 0a0a  p=p, key=key)...
+0000e1c0: 6465 6620 7065 726d 7574 6174 696f 6e28  def permutation(
+0000e1d0: 782c 2061 7869 733a 2069 6e74 203d 2030  x, axis: int = 0
+0000e1e0: 2c20 696e 6465 7065 6e64 656e 743a 2062  , independent: b
+0000e1f0: 6f6f 6c20 3d20 4661 6c73 652c 206b 6579  ool = False, key
+0000e200: 3d4e 6f6e 6529 3a0a 2020 7222 2222 0a20  =None):.  r""". 
+0000e210: 2052 616e 646f 6d6c 7920 7065 726d 7574   Randomly permut
+0000e220: 6520 6120 7365 7175 656e 6365 2c20 6f72  e a sequence, or
+0000e230: 2072 6574 7572 6e20 6120 7065 726d 7574   return a permut
+0000e240: 6564 2072 616e 6765 2e0a 0a20 2049 6620  ed range...  If 
+0000e250: 6078 6020 6973 2061 206d 756c 7469 2d64  `x` is a multi-d
+0000e260: 696d 656e 7369 6f6e 616c 2061 7272 6179  imensional array
+0000e270: 2c20 6974 2069 7320 6f6e 6c79 2073 6875  , it is only shu
+0000e280: 6666 6c65 6420 616c 6f6e 6720 6974 730a  ffled along its.
+0000e290: 2020 6669 7273 7420 696e 6465 782e 0a0a    first index...
+0000e2a0: 2020 5061 7261 6d65 7465 7273 0a20 202d    Parameters.  -
+0000e2b0: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 7820 3a20  ---------.  x : 
+0000e2c0: 696e 7420 6f72 2061 7272 6179 5f6c 696b  int or array_lik
+0000e2d0: 650a 2020 2020 2020 4966 2060 7860 2069  e.      If `x` i
+0000e2e0: 7320 616e 2069 6e74 6567 6572 2c20 7261  s an integer, ra
+0000e2f0: 6e64 6f6d 6c79 2070 6572 6d75 7465 2060  ndomly permute `
+0000e300: 606e 702e 6172 616e 6765 2878 2960 602e  `np.arange(x)``.
+0000e310: 0a20 2020 2020 2049 6620 6078 6020 6973  .      If `x` is
+0000e320: 2061 6e20 6172 7261 792c 206d 616b 6520   an array, make 
+0000e330: 6120 636f 7079 2061 6e64 2073 6875 6666  a copy and shuff
+0000e340: 6c65 2074 6865 2065 6c65 6d65 6e74 730a  le the elements.
+0000e350: 2020 2020 2020 7261 6e64 6f6d 6c79 2e0a        randomly..
+0000e360: 0a20 2052 6574 7572 6e73 0a20 202d 2d2d  .  Returns.  ---
+0000e370: 2d2d 2d2d 0a20 206f 7574 203a 206e 6461  ----.  out : nda
+0000e380: 7272 6179 0a20 2020 2020 2050 6572 6d75  rray.      Permu
+0000e390: 7465 6420 7365 7175 656e 6365 206f 7220  ted sequence or 
+0000e3a0: 6172 7261 7920 7261 6e67 652e 0a0a 2020  array range...  
+0000e3b0: 5365 6520 416c 736f 0a20 202d 2d2d 2d2d  See Also.  -----
+0000e3c0: 2d2d 2d0a 2020 7261 6e64 6f6d 2e47 656e  ---.  random.Gen
+0000e3d0: 6572 6174 6f72 2e70 6572 6d75 7461 7469  erator.permutati
+0000e3e0: 6f6e 3a20 7768 6963 6820 7368 6f75 6c64  on: which should
+0000e3f0: 2062 6520 7573 6564 2066 6f72 206e 6577   be used for new
+0000e400: 2063 6f64 652e 0a0a 2020 4578 616d 706c   code...  Exampl
+0000e410: 6573 0a20 202d 2d2d 2d2d 2d2d 2d0a 2020  es.  --------.  
+0000e420: 3e3e 3e20 696d 706f 7274 2062 7261 696e  >>> import brain
+0000e430: 7079 2e6d 6174 6820 6173 2062 6d0a 2020  py.math as bm.  
+0000e440: 3e3e 3e20 626d 2e72 616e 646f 6d2e 7065  >>> bm.random.pe
+0000e450: 726d 7574 6174 696f 6e28 3130 290a 2020  rmutation(10).  
+0000e460: 6172 7261 7928 5b31 2c20 372c 2034 2c20  array([1, 7, 4, 
+0000e470: 332c 2030 2c20 392c 2032 2c20 352c 2038  3, 0, 9, 2, 5, 8
+0000e480: 2c20 365d 2920 2320 7261 6e64 6f6d 0a0a  , 6]) # random..
+0000e490: 2020 3e3e 3e20 626d 2e72 616e 646f 6d2e    >>> bm.random.
+0000e4a0: 7065 726d 7574 6174 696f 6e28 5b31 2c20  permutation([1, 
+0000e4b0: 342c 2039 2c20 3132 2c20 3135 5d29 0a20  4, 9, 12, 15]). 
+0000e4c0: 2061 7272 6179 285b 3135 2c20 2031 2c20   array([15,  1, 
+0000e4d0: 2039 2c20 2034 2c20 3132 5d29 2023 2072   9,  4, 12]) # r
+0000e4e0: 616e 646f 6d0a 0a20 203e 3e3e 2061 7272  andom..  >>> arr
+0000e4f0: 203d 206e 702e 6172 616e 6765 2839 292e   = np.arange(9).
+0000e500: 7265 7368 6170 6528 2833 2c20 3329 290a  reshape((3, 3)).
+0000e510: 2020 3e3e 3e20 626d 2e72 616e 646f 6d2e    >>> bm.random.
+0000e520: 7065 726d 7574 6174 696f 6e28 6172 7229  permutation(arr)
+0000e530: 0a20 2061 7272 6179 285b 5b36 2c20 372c  .  array([[6, 7,
+0000e540: 2038 5d2c 2023 2072 616e 646f 6d0a 2020   8], # random.  
+0000e550: 2020 2020 2020 205b 302c 2031 2c20 325d         [0, 1, 2]
+0000e560: 2c0a 2020 2020 2020 2020 205b 332c 2034  ,.         [3, 4
+0000e570: 2c20 355d 5d29 0a20 2022 2222 0a20 2072  , 5]]).  """.  r
+0000e580: 6574 7572 6e20 4445 4641 554c 542e 7065  eturn DEFAULT.pe
+0000e590: 726d 7574 6174 696f 6e28 782c 2061 7869  rmutation(x, axi
+0000e5a0: 733d 6178 6973 2c20 696e 6465 7065 6e64  s=axis, independ
+0000e5b0: 656e 743d 696e 6465 7065 6e64 656e 742c  ent=independent,
+0000e5c0: 206b 6579 3d6b 6579 290a 0a0a 6465 6620   key=key)...def 
+0000e5d0: 7368 7566 666c 6528 782c 2061 7869 733d  shuffle(x, axis=
+0000e5e0: 302c 206b 6579 3d4e 6f6e 6529 3a0a 2020  0, key=None):.  
+0000e5f0: 7222 2222 0a20 204d 6f64 6966 7920 6120  r""".  Modify a 
+0000e600: 7365 7175 656e 6365 2069 6e2d 706c 6163  sequence in-plac
+0000e610: 6520 6279 2073 6875 6666 6c69 6e67 2069  e by shuffling i
+0000e620: 7473 2063 6f6e 7465 6e74 732e 0a0a 2020  ts contents...  
+0000e630: 5468 6973 2066 756e 6374 696f 6e20 6f6e  This function on
+0000e640: 6c79 2073 6875 6666 6c65 7320 7468 6520  ly shuffles the 
+0000e650: 6172 7261 7920 616c 6f6e 6720 7468 6520  array along the 
+0000e660: 6669 7273 7420 6178 6973 206f 6620 610a  first axis of a.
+0000e670: 2020 6d75 6c74 692d 6469 6d65 6e73 696f    multi-dimensio
+0000e680: 6e61 6c20 6172 7261 792e 2054 6865 206f  nal array. The o
+0000e690: 7264 6572 206f 6620 7375 622d 6172 7261  rder of sub-arra
+0000e6a0: 7973 2069 7320 6368 616e 6765 6420 6275  ys is changed bu
+0000e6b0: 740a 2020 7468 6569 7220 636f 6e74 656e  t.  their conten
+0000e6c0: 7473 2072 656d 6169 6e73 2074 6865 2073  ts remains the s
+0000e6d0: 616d 652e 0a0a 2020 5061 7261 6d65 7465  ame...  Paramete
+0000e6e0: 7273 0a20 202d 2d2d 2d2d 2d2d 2d2d 2d0a  rs.  ----------.
+0000e6f0: 2020 7820 3a20 6e64 6172 7261 7920 6f72    x : ndarray or
+0000e700: 204d 7574 6162 6c65 5365 7175 656e 6365   MutableSequence
+0000e710: 0a20 2020 2020 2054 6865 2061 7272 6179  .      The array
+0000e720: 2c20 6c69 7374 206f 7220 6d75 7461 626c  , list or mutabl
+0000e730: 6520 7365 7175 656e 6365 2074 6f20 6265  e sequence to be
+0000e740: 2073 6875 6666 6c65 642e 0a0a 2020 5265   shuffled...  Re
+0000e750: 7475 726e 730a 2020 2d2d 2d2d 2d2d 2d0a  turns.  -------.
+0000e760: 2020 4e6f 6e65 0a0a 2020 5365 6520 416c    None..  See Al
+0000e770: 736f 0a20 202d 2d2d 2d2d 2d2d 2d0a 2020  so.  --------.  
+0000e780: 7261 6e64 6f6d 2e47 656e 6572 6174 6f72  random.Generator
+0000e790: 2e73 6875 6666 6c65 3a20 7768 6963 6820  .shuffle: which 
+0000e7a0: 7368 6f75 6c64 2062 6520 7573 6564 2066  should be used f
+0000e7b0: 6f72 206e 6577 2063 6f64 652e 0a0a 2020  or new code...  
+0000e7c0: 4578 616d 706c 6573 0a20 202d 2d2d 2d2d  Examples.  -----
+0000e7d0: 2d2d 2d0a 2020 3e3e 3e20 696d 706f 7274  ---.  >>> import
+0000e7e0: 2062 7261 696e 7079 2e6d 6174 6820 6173   brainpy.math as
+0000e7f0: 2062 6d0a 2020 3e3e 3e20 6172 7220 3d20   bm.  >>> arr = 
+0000e800: 6e70 2e61 7261 6e67 6528 3130 290a 2020  np.arange(10).  
+0000e810: 3e3e 3e20 626d 2e72 616e 646f 6d2e 7368  >>> bm.random.sh
+0000e820: 7566 666c 6528 6172 7229 0a20 203e 3e3e  uffle(arr).  >>>
+0000e830: 2061 7272 0a20 205b 3120 3720 3520 3220   arr.  [1 7 5 2 
+0000e840: 3920 3420 3320 3620 3020 385d 2023 2072  9 4 3 6 0 8] # r
+0000e850: 616e 646f 6d0a 0a20 204d 756c 7469 2d64  andom..  Multi-d
+0000e860: 696d 656e 7369 6f6e 616c 2061 7272 6179  imensional array
+0000e870: 7320 6172 6520 6f6e 6c79 2073 6875 6666  s are only shuff
+0000e880: 6c65 6420 616c 6f6e 6720 7468 6520 6669  led along the fi
+0000e890: 7273 7420 6178 6973 3a0a 0a20 203e 3e3e  rst axis:..  >>>
+0000e8a0: 2061 7272 203d 206e 702e 6172 616e 6765   arr = np.arange
+0000e8b0: 2839 292e 7265 7368 6170 6528 2833 2c20  (9).reshape((3, 
+0000e8c0: 3329 290a 2020 3e3e 3e20 626d 2e72 616e  3)).  >>> bm.ran
+0000e8d0: 646f 6d2e 7368 7566 666c 6528 6172 7229  dom.shuffle(arr)
+0000e8e0: 0a20 203e 3e3e 2061 7272 0a20 2061 7272  .  >>> arr.  arr
+0000e8f0: 6179 285b 5b33 2c20 342c 2035 5d2c 2023  ay([[3, 4, 5], #
+0000e900: 2072 616e 646f 6d0a 2020 2020 2020 2020   random.        
+0000e910: 205b 362c 2037 2c20 385d 2c0a 2020 2020   [6, 7, 8],.    
+0000e920: 2020 2020 205b 302c 2031 2c20 325d 5d29       [0, 1, 2]])
+0000e930: 0a20 2022 2222 0a20 2044 4546 4155 4c54  .  """.  DEFAULT
+0000e940: 2e73 6875 6666 6c65 2878 2c20 6178 6973  .shuffle(x, axis
+0000e950: 2c20 6b65 793d 6b65 7929 0a0a 0a64 6566  , key=key)...def
+0000e960: 2062 6574 6128 612c 2062 2c20 7369 7a65   beta(a, b, size
+0000e970: 3d4e 6f6e 652c 206b 6579 3d4e 6f6e 6529  =None, key=None)
+0000e980: 3a0a 2020 7222 2222 0a20 2044 7261 7720  :.  r""".  Draw 
+0000e990: 7361 6d70 6c65 7320 6672 6f6d 2061 2042  samples from a B
+0000e9a0: 6574 6120 6469 7374 7269 6275 7469 6f6e  eta distribution
+0000e9b0: 2e0a 0a20 2054 6865 2042 6574 6120 6469  ...  The Beta di
+0000e9c0: 7374 7269 6275 7469 6f6e 2069 7320 6120  stribution is a 
+0000e9d0: 7370 6563 6961 6c20 6361 7365 206f 6620  special case of 
+0000e9e0: 7468 6520 4469 7269 6368 6c65 7420 6469  the Dirichlet di
+0000e9f0: 7374 7269 6275 7469 6f6e 2c0a 2020 616e  stribution,.  an
+0000ea00: 6420 6973 2072 656c 6174 6564 2074 6f20  d is related to 
+0000ea10: 7468 6520 4761 6d6d 6120 6469 7374 7269  the Gamma distri
+0000ea20: 6275 7469 6f6e 2e20 2049 7420 6861 7320  bution.  It has 
+0000ea30: 7468 6520 7072 6f62 6162 696c 6974 790a  the probability.
+0000ea40: 2020 6469 7374 7269 6275 7469 6f6e 2066    distribution f
+0000ea50: 756e 6374 696f 6e0a 0a20 202e 2e20 6d61  unction..  .. ma
+0000ea60: 7468 3a3a 2066 2878 3b20 612c 6229 203d  th:: f(x; a,b) =
+0000ea70: 205c 6672 6163 7b31 7d7b 4228 5c61 6c70   \frac{1}{B(\alp
+0000ea80: 6861 2c20 5c62 6574 6129 7d20 785e 7b5c  ha, \beta)} x^{\
+0000ea90: 616c 7068 6120 2d20 317d 0a20 2020 2020  alpha - 1}.     
+0000eaa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eac0: 2020 2020 2020 2020 2020 2020 2020 2831                (1
+0000ead0: 202d 2078 295e 7b5c 6265 7461 202d 2031   - x)^{\beta - 1
+0000eae0: 7d2c 0a0a 2020 7768 6572 6520 7468 6520  },..  where the 
+0000eaf0: 6e6f 726d 616c 697a 6174 696f 6e2c 2042  normalization, B
+0000eb00: 2c20 6973 2074 6865 2062 6574 6120 6675  , is the beta fu
+0000eb10: 6e63 7469 6f6e 2c0a 0a20 202e 2e20 6d61  nction,..  .. ma
+0000eb20: 7468 3a3a 2042 285c 616c 7068 612c 205c  th:: B(\alpha, \
+0000eb30: 6265 7461 2920 3d20 5c69 6e74 5f30 5e31  beta) = \int_0^1
+0000eb40: 2074 5e7b 5c61 6c70 6861 202d 2031 7d0a   t^{\alpha - 1}.
+0000eb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eb60: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+0000eb70: 3120 2d20 7429 5e7b 5c62 6574 6120 2d20  1 - t)^{\beta - 
+0000eb80: 317d 2064 742e 0a0a 2020 4974 2069 7320  1} dt...  It is 
+0000eb90: 6f66 7465 6e20 7365 656e 2069 6e20 4261  often seen in Ba
+0000eba0: 7965 7369 616e 2069 6e66 6572 656e 6365  yesian inference
+0000ebb0: 2061 6e64 206f 7264 6572 2073 7461 7469   and order stati
+0000ebc0: 7374 6963 732e 0a0a 2020 5061 7261 6d65  stics...  Parame
+0000ebd0: 7465 7273 0a20 202d 2d2d 2d2d 2d2d 2d2d  ters.  ---------
+0000ebe0: 2d0a 2020 6120 3a20 666c 6f61 7420 6f72  -.  a : float or
+0000ebf0: 2061 7272 6179 5f6c 696b 6520 6f66 2066   array_like of f
+0000ec00: 6c6f 6174 730a 2020 2020 2020 416c 7068  loats.      Alph
+0000ec10: 612c 2070 6f73 6974 6976 6520 283e 3029  a, positive (>0)
+0000ec20: 2e0a 2020 6220 3a20 666c 6f61 7420 6f72  ..  b : float or
+0000ec30: 2061 7272 6179 5f6c 696b 6520 6f66 2066   array_like of f
+0000ec40: 6c6f 6174 730a 2020 2020 2020 4265 7461  loats.      Beta
+0000ec50: 2c20 706f 7369 7469 7665 2028 3e30 292e  , positive (>0).
+0000ec60: 0a20 2073 697a 6520 3a20 696e 7420 6f72  .  size : int or
+0000ec70: 2074 7570 6c65 206f 6620 696e 7473 2c20   tuple of ints, 
+0000ec80: 6f70 7469 6f6e 616c 0a20 2020 2020 204f  optional.      O
+0000ec90: 7574 7075 7420 7368 6170 652e 2020 4966  utput shape.  If
+0000eca0: 2074 6865 2067 6976 656e 2073 6861 7065   the given shape
+0000ecb0: 2069 732c 2065 2e67 2e2c 2060 6028 6d2c   is, e.g., ``(m,
+0000ecc0: 206e 2c20 6b29 6060 2c20 7468 656e 0a20   n, k)``, then. 
+0000ecd0: 2020 2020 2060 606d 202a 206e 202a 206b       ``m * n * k
+0000ece0: 6060 2073 616d 706c 6573 2061 7265 2064  `` samples are d
+0000ecf0: 7261 776e 2e20 2049 6620 7369 7a65 2069  rawn.  If size i
+0000ed00: 7320 6060 4e6f 6e65 6060 2028 6465 6661  s ``None`` (defa
+0000ed10: 756c 7429 2c0a 2020 2020 2020 6120 7369  ult),.      a si
+0000ed20: 6e67 6c65 2076 616c 7565 2069 7320 7265  ngle value is re
+0000ed30: 7475 726e 6564 2069 6620 6060 6160 6020  turned if ``a`` 
+0000ed40: 616e 6420 6060 6260 6020 6172 6520 626f  and ``b`` are bo
+0000ed50: 7468 2073 6361 6c61 7273 2e0a 2020 2020  th scalars..    
+0000ed60: 2020 4f74 6865 7277 6973 652c 2060 606e    Otherwise, ``n
+0000ed70: 702e 6272 6f61 6463 6173 7428 612c 2062  p.broadcast(a, b
+0000ed80: 292e 7369 7a65 6060 2073 616d 706c 6573  ).size`` samples
+0000ed90: 2061 7265 2064 7261 776e 2e0a 0a20 2052   are drawn...  R
+0000eda0: 6574 7572 6e73 0a20 202d 2d2d 2d2d 2d2d  eturns.  -------
+0000edb0: 0a20 206f 7574 203a 206e 6461 7272 6179  .  out : ndarray
+0000edc0: 206f 7220 7363 616c 6172 0a20 2020 2020   or scalar.     
+0000edd0: 2044 7261 776e 2073 616d 706c 6573 2066   Drawn samples f
+0000ede0: 726f 6d20 7468 6520 7061 7261 6d65 7465  rom the paramete
+0000edf0: 7269 7a65 6420 6265 7461 2064 6973 7472  rized beta distr
+0000ee00: 6962 7574 696f 6e2e 0a0a 2020 5365 6520  ibution...  See 
+0000ee10: 416c 736f 0a20 202d 2d2d 2d2d 2d2d 2d0a  Also.  --------.
+0000ee20: 2020 7261 6e64 6f6d 2e47 656e 6572 6174    random.Generat
+0000ee30: 6f72 2e62 6574 613a 2077 6869 6368 2073  or.beta: which s
+0000ee40: 686f 756c 6420 6265 2075 7365 6420 666f  hould be used fo
+0000ee50: 7220 6e65 7720 636f 6465 2e0a 2020 2222  r new code..  ""
+0000ee60: 220a 2020 7265 7475 726e 2044 4546 4155  ".  return DEFAU
+0000ee70: 4c54 2e62 6574 6128 612c 2062 2c20 7369  LT.beta(a, b, si
+0000ee80: 7a65 3d73 697a 652c 206b 6579 3d6b 6579  ze=size, key=key
+0000ee90: 290a 0a0a 2320 4077 7261 7073 286e 702e  )...# @wraps(np.
+0000eea0: 7261 6e64 6f6d 2e65 7870 6f6e 656e 7469  random.exponenti
+0000eeb0: 616c 290a 6465 6620 6578 706f 6e65 6e74  al).def exponent
+0000eec0: 6961 6c28 7363 616c 653d 4e6f 6e65 2c20  ial(scale=None, 
+0000eed0: 7369 7a65 3d4e 6f6e 652c 206b 6579 3d4e  size=None, key=N
+0000eee0: 6f6e 6529 3a0a 2020 7265 7475 726e 2044  one):.  return D
+0000eef0: 4546 4155 4c54 2e65 7870 6f6e 656e 7469  EFAULT.exponenti
+0000ef00: 616c 2873 6361 6c65 2c20 7369 7a65 2c20  al(scale, size, 
+0000ef10: 6b65 793d 6b65 7929 0a0a 0a23 2040 7772  key=key)...# @wr
+0000ef20: 6170 7328 6e70 2e72 616e 646f 6d2e 6761  aps(np.random.ga
+0000ef30: 6d6d 6129 0a64 6566 2067 616d 6d61 2873  mma).def gamma(s
+0000ef40: 6861 7065 2c20 7363 616c 653d 4e6f 6e65  hape, scale=None
+0000ef50: 2c20 7369 7a65 3d4e 6f6e 652c 206b 6579  , size=None, key
+0000ef60: 3d4e 6f6e 6529 3a0a 2020 7265 7475 726e  =None):.  return
+0000ef70: 2044 4546 4155 4c54 2e67 616d 6d61 2873   DEFAULT.gamma(s
+0000ef80: 6861 7065 2c20 7363 616c 652c 2073 697a  hape, scale, siz
+0000ef90: 653d 7369 7a65 2c20 6b65 793d 6b65 7929  e=size, key=key)
+0000efa0: 0a0a 0a23 2040 7772 6170 7328 6e70 2e72  ...# @wraps(np.r
+0000efb0: 616e 646f 6d2e 6775 6d62 656c 290a 6465  andom.gumbel).de
+0000efc0: 6620 6775 6d62 656c 286c 6f63 3d4e 6f6e  f gumbel(loc=Non
+0000efd0: 652c 2073 6361 6c65 3d4e 6f6e 652c 2073  e, scale=None, s
+0000efe0: 697a 653d 4e6f 6e65 2c20 6b65 793d 4e6f  ize=None, key=No
+0000eff0: 6e65 293a 0a20 2072 6574 7572 6e20 4445  ne):.  return DE
+0000f000: 4641 554c 542e 6775 6d62 656c 286c 6f63  FAULT.gumbel(loc
+0000f010: 2c20 7363 616c 652c 2073 697a 653d 7369  , scale, size=si
+0000f020: 7a65 2c20 6b65 793d 6b65 7929 0a0a 0a23  ze, key=key)...#
+0000f030: 2040 7772 6170 7328 6e70 2e72 616e 646f   @wraps(np.rando
+0000f040: 6d2e 6c61 706c 6163 6529 0a64 6566 206c  m.laplace).def l
+0000f050: 6170 6c61 6365 286c 6f63 3d4e 6f6e 652c  aplace(loc=None,
+0000f060: 2073 6361 6c65 3d4e 6f6e 652c 2073 697a   scale=None, siz
+0000f070: 653d 4e6f 6e65 2c20 6b65 793d 4e6f 6e65  e=None, key=None
+0000f080: 293a 0a20 2072 6574 7572 6e20 4445 4641  ):.  return DEFA
+0000f090: 554c 542e 6c61 706c 6163 6528 6c6f 632c  ULT.laplace(loc,
+0000f0a0: 2073 6361 6c65 2c20 7369 7a65 2c20 6b65   scale, size, ke
+0000f0b0: 793d 6b65 7929 0a0a 0a23 2040 7772 6170  y=key)...# @wrap
+0000f0c0: 7328 6e70 2e72 616e 646f 6d2e 6c6f 6769  s(np.random.logi
+0000f0d0: 7374 6963 290a 6465 6620 6c6f 6769 7374  stic).def logist
+0000f0e0: 6963 286c 6f63 3d4e 6f6e 652c 2073 6361  ic(loc=None, sca
+0000f0f0: 6c65 3d4e 6f6e 652c 2073 697a 653d 4e6f  le=None, size=No
+0000f100: 6e65 2c20 6b65 793d 4e6f 6e65 293a 0a20  ne, key=None):. 
+0000f110: 2072 6574 7572 6e20 4445 4641 554c 542e   return DEFAULT.
+0000f120: 6c6f 6769 7374 6963 286c 6f63 2c20 7363  logistic(loc, sc
+0000f130: 616c 652c 2073 697a 652c 206b 6579 3d6b  ale, size, key=k
+0000f140: 6579 290a 0a0a 2320 4077 7261 7073 286e  ey)...# @wraps(n
+0000f150: 702e 7261 6e64 6f6d 2e6e 6f72 6d61 6c29  p.random.normal)
+0000f160: 0a64 6566 206e 6f72 6d61 6c28 6c6f 633d  .def normal(loc=
+0000f170: 4e6f 6e65 2c20 7363 616c 653d 4e6f 6e65  None, scale=None
+0000f180: 2c20 7369 7a65 3d4e 6f6e 652c 206b 6579  , size=None, key
+0000f190: 3d4e 6f6e 6529 3a0a 2020 7265 7475 726e  =None):.  return
+0000f1a0: 2044 4546 4155 4c54 2e6e 6f72 6d61 6c28   DEFAULT.normal(
+0000f1b0: 6c6f 632c 2073 6361 6c65 2c20 7369 7a65  loc, scale, size
+0000f1c0: 2c20 6b65 793d 6b65 7929 0a0a 0a23 2040  , key=key)...# @
+0000f1d0: 7772 6170 7328 6e70 2e72 616e 646f 6d2e  wraps(np.random.
+0000f1e0: 7061 7265 746f 290a 6465 6620 7061 7265  pareto).def pare
+0000f1f0: 746f 2861 2c20 7369 7a65 3d4e 6f6e 652c  to(a, size=None,
+0000f200: 206b 6579 3d4e 6f6e 6529 3a0a 2020 7265   key=None):.  re
+0000f210: 7475 726e 2044 4546 4155 4c54 2e70 6172  turn DEFAULT.par
+0000f220: 6574 6f28 612c 2073 697a 652c 206b 6579  eto(a, size, key
+0000f230: 3d6b 6579 290a 0a0a 2320 4077 7261 7073  =key)...# @wraps
+0000f240: 286e 702e 7261 6e64 6f6d 2e70 6f69 7373  (np.random.poiss
+0000f250: 6f6e 290a 6465 6620 706f 6973 736f 6e28  on).def poisson(
+0000f260: 6c61 6d3d 312e 302c 2073 697a 653d 4e6f  lam=1.0, size=No
+0000f270: 6e65 2c20 6b65 793d 4e6f 6e65 293a 0a20  ne, key=None):. 
+0000f280: 2072 6574 7572 6e20 4445 4641 554c 542e   return DEFAULT.
+0000f290: 706f 6973 736f 6e28 6c61 6d2c 2073 697a  poisson(lam, siz
+0000f2a0: 652c 206b 6579 3d6b 6579 290a 0a0a 2320  e, key=key)...# 
+0000f2b0: 4077 7261 7073 286e 702e 7261 6e64 6f6d  @wraps(np.random
+0000f2c0: 2e73 7461 6e64 6172 645f 6361 7563 6879  .standard_cauchy
+0000f2d0: 290a 6465 6620 7374 616e 6461 7264 5f63  ).def standard_c
+0000f2e0: 6175 6368 7928 7369 7a65 3d4e 6f6e 652c  auchy(size=None,
+0000f2f0: 206b 6579 3d4e 6f6e 6529 3a0a 2020 7265   key=None):.  re
+0000f300: 7475 726e 2044 4546 4155 4c54 2e73 7461  turn DEFAULT.sta
+0000f310: 6e64 6172 645f 6361 7563 6879 2873 697a  ndard_cauchy(siz
+0000f320: 652c 206b 6579 3d6b 6579 290a 0a0a 2320  e, key=key)...# 
+0000f330: 4077 7261 7073 286e 702e 7261 6e64 6f6d  @wraps(np.random
+0000f340: 2e73 7461 6e64 6172 645f 6578 706f 6e65  .standard_expone
+0000f350: 6e74 6961 6c29 0a64 6566 2073 7461 6e64  ntial).def stand
+0000f360: 6172 645f 6578 706f 6e65 6e74 6961 6c28  ard_exponential(
+0000f370: 7369 7a65 3d4e 6f6e 652c 206b 6579 3d4e  size=None, key=N
+0000f380: 6f6e 6529 3a0a 2020 7265 7475 726e 2044  one):.  return D
+0000f390: 4546 4155 4c54 2e73 7461 6e64 6172 645f  EFAULT.standard_
+0000f3a0: 6578 706f 6e65 6e74 6961 6c28 7369 7a65  exponential(size
+0000f3b0: 2c20 6b65 793d 6b65 7929 0a0a 0a23 2040  , key=key)...# @
+0000f3c0: 7772 6170 7328 6e70 2e72 616e 646f 6d2e  wraps(np.random.
+0000f3d0: 7374 616e 6461 7264 5f67 616d 6d61 290a  standard_gamma).
+0000f3e0: 6465 6620 7374 616e 6461 7264 5f67 616d  def standard_gam
+0000f3f0: 6d61 2873 6861 7065 2c20 7369 7a65 3d4e  ma(shape, size=N
+0000f400: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
+0000f410: 2020 7265 7475 726e 2044 4546 4155 4c54    return DEFAULT
+0000f420: 2e73 7461 6e64 6172 645f 6761 6d6d 6128  .standard_gamma(
+0000f430: 7368 6170 652c 2073 697a 652c 206b 6579  shape, size, key
+0000f440: 3d6b 6579 290a 0a0a 2320 4077 7261 7073  =key)...# @wraps
+0000f450: 286e 702e 7261 6e64 6f6d 2e73 7461 6e64  (np.random.stand
+0000f460: 6172 645f 6e6f 726d 616c 290a 6465 6620  ard_normal).def 
+0000f470: 7374 616e 6461 7264 5f6e 6f72 6d61 6c28  standard_normal(
+0000f480: 7369 7a65 3d4e 6f6e 652c 206b 6579 3d4e  size=None, key=N
+0000f490: 6f6e 6529 3a0a 2020 7265 7475 726e 2044  one):.  return D
+0000f4a0: 4546 4155 4c54 2e73 7461 6e64 6172 645f  EFAULT.standard_
+0000f4b0: 6e6f 726d 616c 2873 697a 652c 206b 6579  normal(size, key
+0000f4c0: 3d6b 6579 290a 0a0a 2320 4077 7261 7073  =key)...# @wraps
+0000f4d0: 286e 702e 7261 6e64 6f6d 2e73 7461 6e64  (np.random.stand
+0000f4e0: 6172 645f 7429 0a64 6566 2073 7461 6e64  ard_t).def stand
+0000f4f0: 6172 645f 7428 6466 2c20 7369 7a65 3d4e  ard_t(df, size=N
+0000f500: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
+0000f510: 2020 7265 7475 726e 2044 4546 4155 4c54    return DEFAULT
+0000f520: 2e73 7461 6e64 6172 645f 7428 6466 2c20  .standard_t(df, 
+0000f530: 7369 7a65 2c20 6b65 793d 6b65 7929 0a0a  size, key=key)..
+0000f540: 0a23 2040 7772 6170 7328 6e70 2e72 616e  .# @wraps(np.ran
+0000f550: 646f 6d2e 756e 6966 6f72 6d29 0a64 6566  dom.uniform).def
+0000f560: 2075 6e69 666f 726d 286c 6f77 3d30 2e30   uniform(low=0.0
+0000f570: 2c20 6869 6768 3d31 2e30 2c20 7369 7a65  , high=1.0, size
+0000f580: 3d4e 6f6e 652c 206b 6579 3d4e 6f6e 6529  =None, key=None)
+0000f590: 3a0a 2020 7265 7475 726e 2044 4546 4155  :.  return DEFAU
+0000f5a0: 4c54 2e75 6e69 666f 726d 286c 6f77 2c20  LT.uniform(low, 
+0000f5b0: 6869 6768 2c20 7369 7a65 2c20 6b65 793d  high, size, key=
+0000f5c0: 6b65 7929 0a0a 0a64 6566 2074 7275 6e63  key)...def trunc
+0000f5d0: 6174 6564 5f6e 6f72 6d61 6c28 6c6f 7765  ated_normal(lowe
+0000f5e0: 722c 2075 7070 6572 2c20 7369 7a65 3d4e  r, upper, size=N
+0000f5f0: 6f6e 652c 2073 6361 6c65 3d4e 6f6e 652c  one, scale=None,
+0000f600: 206b 6579 3d4e 6f6e 6529 3a0a 2020 2222   key=None):.  ""
+0000f610: 2253 616d 706c 6520 7472 756e 6361 7465  "Sample truncate
+0000f620: 6420 7374 616e 6461 7264 206e 6f72 6d61  d standard norma
+0000f630: 6c20 7261 6e64 6f6d 2076 616c 7565 7320  l random values 
+0000f640: 7769 7468 2067 6976 656e 2073 6861 7065  with given shape
+0000f650: 2061 6e64 2064 7479 7065 2e0a 0a20 2050   and dtype...  P
+0000f660: 6172 616d 6574 6572 730a 2020 2d2d 2d2d  arameters.  ----
+0000f670: 2d2d 2d2d 2d2d 0a20 206c 6f77 6572 203a  ------.  lower :
+0000f680: 2066 6c6f 6174 2c20 6e64 6172 7261 790a   float, ndarray.
+0000f690: 2020 2020 4120 666c 6f61 7420 6f72 2061      A float or a
+0000f6a0: 7272 6179 206f 6620 666c 6f61 7473 2072  rray of floats r
+0000f6b0: 6570 7265 7365 6e74 696e 6720 7468 6520  epresenting the 
+0000f6c0: 6c6f 7765 7220 626f 756e 6420 666f 720a  lower bound for.
+0000f6d0: 2020 2020 7472 756e 6361 7469 6f6e 2e20      truncation. 
+0000f6e0: 4d75 7374 2062 6520 6272 6f61 6463 6173  Must be broadcas
+0000f6f0: 742d 636f 6d70 6174 6962 6c65 2077 6974  t-compatible wit
+0000f700: 6820 6060 7570 7065 7260 602e 0a20 2075  h ``upper``..  u
+0000f710: 7070 6572 203a 2066 6c6f 6174 2c20 6e64  pper : float, nd
+0000f720: 6172 7261 790a 2020 2020 4120 666c 6f61  array.    A floa
+0000f730: 7420 6f72 2061 7272 6179 206f 6620 666c  t or array of fl
+0000f740: 6f61 7473 2072 6570 7265 7365 6e74 696e  oats representin
+0000f750: 6720 7468 6520 2075 7070 6572 2062 6f75  g the  upper bou
+0000f760: 6e64 2066 6f72 0a20 2020 2074 7275 6e63  nd for.    trunc
+0000f770: 6174 696f 6e2e 204d 7573 7420 6265 2062  ation. Must be b
+0000f780: 726f 6164 6361 7374 2d63 6f6d 7061 7469  roadcast-compati
+0000f790: 626c 6520 7769 7468 2060 606c 6f77 6572  ble with ``lower
+0000f7a0: 6060 2e0a 2020 7369 7a65 203a 206f 7074  ``..  size : opt
+0000f7b0: 696f 6e61 6c2c 206c 6973 7420 6f66 2069  ional, list of i
+0000f7c0: 6e74 2c20 7475 706c 6520 6f66 2069 6e74  nt, tuple of int
+0000f7d0: 0a20 2020 2041 2074 7570 6c65 206f 6620  .    A tuple of 
+0000f7e0: 6e6f 6e6e 6567 6174 6976 6520 696e 7465  nonnegative inte
+0000f7f0: 6765 7273 2073 7065 6369 6679 696e 6720  gers specifying 
+0000f800: 7468 6520 7265 7375 6c74 0a20 2020 2073  the result.    s
+0000f810: 6861 7065 2e20 4d75 7374 2062 6520 6272  hape. Must be br
+0000f820: 6f61 6463 6173 742d 636f 6d70 6174 6962  oadcast-compatib
+0000f830: 6c65 2077 6974 6820 6060 6c6f 7765 7260  le with ``lower`
+0000f840: 6020 616e 6420 6060 7570 7065 7260 602e  ` and ``upper``.
+0000f850: 2054 6865 0a20 2020 2064 6566 6175 6c74   The.    default
+0000f860: 2028 4e6f 6e65 2920 7072 6f64 7563 6573   (None) produces
+0000f870: 2061 2072 6573 756c 7420 7368 6170 6520   a result shape 
+0000f880: 6279 2062 726f 6164 6361 7374 696e 6720  by broadcasting 
+0000f890: 6060 6c6f 7765 7260 6020 616e 640a 2020  ``lower`` and.  
+0000f8a0: 2020 6060 7570 7065 7260 602e 0a20 2073    ``upper``..  s
+0000f8b0: 6361 6c65 203a 2066 6c6f 6174 2c20 6e64  cale : float, nd
+0000f8c0: 6172 7261 790a 2020 2020 5374 616e 6461  array.    Standa
+0000f8d0: 7264 2064 6576 6961 7469 6f6e 2028 7370  rd deviation (sp
+0000f8e0: 7265 6164 206f 7220 2277 6964 7468 2229  read or "width")
+0000f8f0: 206f 6620 7468 6520 6469 7374 7269 6275   of the distribu
+0000f900: 7469 6f6e 2e20 4d75 7374 2062 650a 2020  tion. Must be.  
+0000f910: 2020 6e6f 6e2d 6e65 6761 7469 7665 2e0a    non-negative..
+0000f920: 0a20 2052 6574 7572 6e73 0a20 202d 2d2d  .  Returns.  ---
+0000f930: 2d2d 2d2d 0a20 206f 7574 203a 2041 7272  ----.  out : Arr
+0000f940: 6179 0a20 2020 2041 2072 616e 646f 6d20  ay.    A random 
+0000f950: 6172 7261 7920 7769 7468 2074 6865 2073  array with the s
+0000f960: 7065 6369 6669 6564 2064 7479 7065 2061  pecified dtype a
+0000f970: 6e64 2073 6861 7065 2067 6976 656e 2062  nd shape given b
+0000f980: 7920 6060 7368 6170 6560 6020 6966 0a20  y ``shape`` if. 
+0000f990: 2020 2060 6073 6861 7065 6060 2069 7320     ``shape`` is 
+0000f9a0: 6e6f 7420 4e6f 6e65 2c20 6f72 2065 6c73  not None, or els
+0000f9b0: 6520 6279 2062 726f 6164 6361 7374 696e  e by broadcastin
+0000f9c0: 6720 6060 6c6f 7765 7260 6020 616e 6420  g ``lower`` and 
+0000f9d0: 6060 7570 7065 7260 602e 0a20 2020 2052  ``upper``..    R
+0000f9e0: 6574 7572 6e73 2076 616c 7565 7320 696e  eturns values in
+0000f9f0: 2074 6865 206f 7065 6e20 696e 7465 7276   the open interv
+0000fa00: 616c 2060 6028 6c6f 7765 722c 2075 7070  al ``(lower, upp
+0000fa10: 6572 2960 602e 0a20 2022 2222 0a20 2072  er)``..  """.  r
+0000fa20: 6574 7572 6e20 4445 4641 554c 542e 7472  eturn DEFAULT.tr
+0000fa30: 756e 6361 7465 645f 6e6f 726d 616c 286c  uncated_normal(l
+0000fa40: 6f77 6572 2c20 7570 7065 722c 2073 697a  ower, upper, siz
+0000fa50: 652c 2073 6361 6c65 2c20 6b65 793d 6b65  e, scale, key=ke
+0000fa60: 7929 0a0a 0a64 6566 2062 6572 6e6f 756c  y)...def bernoul
+0000fa70: 6c69 2870 3d30 2e35 2c20 7369 7a65 3d4e  li(p=0.5, size=N
+0000fa80: 6f6e 652c 206b 6579 3d4e 6f6e 6529 3a0a  one, key=None):.
+0000fa90: 2020 2222 2253 616d 706c 6520 4265 726e    """Sample Bern
+0000faa0: 6f75 6c6c 6920 7261 6e64 6f6d 2076 616c  oulli random val
+0000fab0: 7565 7320 7769 7468 2067 6976 656e 2073  ues with given s
+0000fac0: 6861 7065 2061 6e64 206d 6561 6e2e 0a0a  hape and mean...
+0000fad0: 2020 5061 7261 6d65 7465 7273 0a20 202d    Parameters.  -
+0000fae0: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 703a 2066  ---------.  p: f
+0000faf0: 6c6f 6174 2c20 6172 7261 795f 6c69 6b65  loat, array_like
+0000fb00: 2c20 6f70 7469 6f6e 616c 0a20 2020 2041  , optional.    A
+0000fb10: 2066 6c6f 6174 206f 7220 6172 7261 7920   float or array 
+0000fb20: 6f66 2066 6c6f 6174 7320 666f 7220 7468  of floats for th
+0000fb30: 6520 6d65 616e 206f 6620 7468 6520 7261  e mean of the ra
+0000fb40: 6e64 6f6d 0a20 2020 2076 6172 6961 626c  ndom.    variabl
+0000fb50: 6573 2e20 4d75 7374 2062 6520 6272 6f61  es. Must be broa
+0000fb60: 6463 6173 742d 636f 6d70 6174 6962 6c65  dcast-compatible
+0000fb70: 2077 6974 6820 6060 7368 6170 6560 6020   with ``shape`` 
+0000fb80: 616e 6420 7468 6520 7661 6c75 6573 0a20  and the values. 
+0000fb90: 2020 2073 686f 756c 6420 6265 2077 6974     should be wit
+0000fba0: 6869 6e20 5b30 2c20 315d 2e20 4465 6661  hin [0, 1]. Defa
+0000fbb0: 756c 7420 302e 352e 0a20 2073 697a 653a  ult 0.5..  size:
+0000fbc0: 206f 7074 696f 6e61 6c2c 2074 7570 6c65   optional, tuple
+0000fbd0: 206f 6620 696e 742c 2069 6e74 0a20 2020   of int, int.   
+0000fbe0: 2041 2074 7570 6c65 206f 6620 6e6f 6e6e   A tuple of nonn
+0000fbf0: 6567 6174 6976 6520 696e 7465 6765 7273  egative integers
+0000fc00: 2072 6570 7265 7365 6e74 696e 6720 7468   representing th
+0000fc10: 6520 7265 7375 6c74 0a20 2020 2073 6861  e result.    sha
+0000fc20: 7065 2e20 4d75 7374 2062 6520 6272 6f61  pe. Must be broa
+0000fc30: 6463 6173 742d 636f 6d70 6174 6962 6c65  dcast-compatible
+0000fc40: 2077 6974 6820 6060 702e 7368 6170 6560   with ``p.shape`
+0000fc50: 602e 2054 6865 2064 6566 6175 6c74 2028  `. The default (
+0000fc60: 4e6f 6e65 290a 2020 2020 7072 6f64 7563  None).    produc
+0000fc70: 6573 2061 2072 6573 756c 7420 7368 6170  es a result shap
+0000fc80: 6520 6571 7561 6c20 746f 2060 6070 2e73  e equal to ``p.s
+0000fc90: 6861 7065 6060 2e0a 0a20 2052 6574 7572  hape``...  Retur
+0000fca0: 6e73 0a20 202d 2d2d 2d2d 2d2d 0a20 206f  ns.  -------.  o
+0000fcb0: 7574 3a20 6172 7261 795f 6c69 6b65 0a20  ut: array_like. 
+0000fcc0: 2020 2041 2072 616e 646f 6d20 6172 7261     A random arra
+0000fcd0: 7920 7769 7468 2062 6f6f 6c65 616e 2064  y with boolean d
+0000fce0: 7479 7065 2061 6e64 2073 6861 7065 2067  type and shape g
+0000fcf0: 6976 656e 2062 7920 6060 7368 6170 6560  iven by ``shape`
+0000fd00: 6020 6966 2060 6073 6861 7065 6060 0a20  ` if ``shape``. 
+0000fd10: 2020 2069 7320 6e6f 7420 4e6f 6e65 2c20     is not None, 
+0000fd20: 6f72 2065 6c73 6520 6060 702e 7368 6170  or else ``p.shap
+0000fd30: 6560 602e 0a20 2022 2222 0a20 2072 6574  e``..  """.  ret
+0000fd40: 7572 6e20 4445 4641 554c 542e 6265 726e  urn DEFAULT.bern
+0000fd50: 6f75 6c6c 6928 702c 2073 697a 652c 206b  oulli(p, size, k
+0000fd60: 6579 3d6b 6579 290a 0a0a 2320 4077 7261  ey=key)...# @wra
+0000fd70: 7073 286e 702e 7261 6e64 6f6d 2e6c 6f67  ps(np.random.log
+0000fd80: 6e6f 726d 616c 290a 6465 6620 6c6f 676e  normal).def logn
+0000fd90: 6f72 6d61 6c28 6d65 616e 3d4e 6f6e 652c  ormal(mean=None,
+0000fda0: 2073 6967 6d61 3d4e 6f6e 652c 2073 697a   sigma=None, siz
+0000fdb0: 653d 4e6f 6e65 2c20 6b65 793d 4e6f 6e65  e=None, key=None
+0000fdc0: 293a 0a20 2072 6574 7572 6e20 4445 4641  ):.  return DEFA
+0000fdd0: 554c 542e 6c6f 676e 6f72 6d61 6c28 6d65  ULT.lognormal(me
+0000fde0: 616e 2c20 7369 676d 612c 2073 697a 652c  an, sigma, size,
+0000fdf0: 206b 6579 3d6b 6579 290a 0a0a 2320 4077   key=key)...# @w
+0000fe00: 7261 7073 286e 702e 7261 6e64 6f6d 2e62  raps(np.random.b
+0000fe10: 696e 6f6d 6961 6c29 0a64 6566 2062 696e  inomial).def bin
+0000fe20: 6f6d 6961 6c28 6e2c 2070 2c20 7369 7a65  omial(n, p, size
+0000fe30: 3d4e 6f6e 652c 206b 6579 3d4e 6f6e 6529  =None, key=None)
+0000fe40: 3a0a 2020 7265 7475 726e 2044 4546 4155  :.  return DEFAU
+0000fe50: 4c54 2e62 696e 6f6d 6961 6c28 6e2c 2070  LT.binomial(n, p
+0000fe60: 2c20 7369 7a65 2c20 6b65 793d 6b65 7929  , size, key=key)
+0000fe70: 0a0a 0a23 2040 7772 6170 7328 6e70 2e72  ...# @wraps(np.r
+0000fe80: 616e 646f 6d2e 6368 6973 7175 6172 6529  andom.chisquare)
+0000fe90: 0a64 6566 2063 6869 7371 7561 7265 2864  .def chisquare(d
+0000fea0: 662c 2073 697a 653d 4e6f 6e65 2c20 6b65  f, size=None, ke
+0000feb0: 793d 4e6f 6e65 293a 0a20 2072 6574 7572  y=None):.  retur
+0000fec0: 6e20 4445 4641 554c 542e 6368 6973 7175  n DEFAULT.chisqu
+0000fed0: 6172 6528 6466 2c20 7369 7a65 2c20 6b65  are(df, size, ke
+0000fee0: 793d 6b65 7929 0a0a 0a23 2040 7772 6170  y=key)...# @wrap
+0000fef0: 7328 6e70 2e72 616e 646f 6d2e 6469 7269  s(np.random.diri
+0000ff00: 6368 6c65 7429 0a64 6566 2064 6972 6963  chlet).def diric
+0000ff10: 686c 6574 2861 6c70 6861 2c20 7369 7a65  hlet(alpha, size
+0000ff20: 3d4e 6f6e 652c 206b 6579 3d4e 6f6e 6529  =None, key=None)
+0000ff30: 3a0a 2020 7265 7475 726e 2044 4546 4155  :.  return DEFAU
+0000ff40: 4c54 2e64 6972 6963 686c 6574 2861 6c70  LT.dirichlet(alp
+0000ff50: 6861 2c20 7369 7a65 2c20 6b65 793d 6b65  ha, size, key=ke
+0000ff60: 7929 0a0a 0a23 2040 7772 6170 7328 6e70  y)...# @wraps(np
+0000ff70: 2e72 616e 646f 6d2e 6765 6f6d 6574 7269  .random.geometri
+0000ff80: 6329 0a64 6566 2067 656f 6d65 7472 6963  c).def geometric
+0000ff90: 2870 2c20 7369 7a65 3d4e 6f6e 652c 206b  (p, size=None, k
+0000ffa0: 6579 3d4e 6f6e 6529 3a0a 2020 7265 7475  ey=None):.  retu
+0000ffb0: 726e 2044 4546 4155 4c54 2e67 656f 6d65  rn DEFAULT.geome
+0000ffc0: 7472 6963 2870 2c20 7369 7a65 2c20 6b65  tric(p, size, ke
+0000ffd0: 793d 6b65 7929 0a0a 0a23 2040 7772 6170  y=key)...# @wrap
+0000ffe0: 7328 6e70 2e72 616e 646f 6d2e 6629 0a64  s(np.random.f).d
+0000fff0: 6566 2066 2864 666e 756d 2c20 6466 6465  ef f(dfnum, dfde
+00010000: 6e2c 2073 697a 653d 4e6f 6e65 2c20 6b65  n, size=None, ke
+00010010: 793d 4e6f 6e65 293a 0a20 2072 6574 7572  y=None):.  retur
+00010020: 6e20 4445 4641 554c 542e 6628 6466 6e75  n DEFAULT.f(dfnu
+00010030: 6d2c 2064 6664 656e 2c20 7369 7a65 2c20  m, dfden, size, 
+00010040: 6b65 793d 6b65 7929 0a0a 0a23 2040 7772  key=key)...# @wr
+00010050: 6170 7328 6e70 2e72 616e 646f 6d2e 6879  aps(np.random.hy
+00010060: 7065 7267 656f 6d65 7472 6963 290a 6465  pergeometric).de
+00010070: 6620 6879 7065 7267 656f 6d65 7472 6963  f hypergeometric
+00010080: 286e 676f 6f64 2c20 6e62 6164 2c20 6e73  (ngood, nbad, ns
+00010090: 616d 706c 652c 2073 697a 653d 4e6f 6e65  ample, size=None
+000100a0: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2072  , key=None):.  r
+000100b0: 6574 7572 6e20 4445 4641 554c 542e 6879  eturn DEFAULT.hy
+000100c0: 7065 7267 656f 6d65 7472 6963 286e 676f  pergeometric(ngo
+000100d0: 6f64 2c20 6e62 6164 2c20 6e73 616d 706c  od, nbad, nsampl
+000100e0: 652c 2073 697a 652c 206b 6579 3d6b 6579  e, size, key=key
+000100f0: 290a 0a0a 2320 4077 7261 7073 286e 702e  )...# @wraps(np.
+00010100: 7261 6e64 6f6d 2e6c 6f67 7365 7269 6573  random.logseries
+00010110: 290a 6465 6620 6c6f 6773 6572 6965 7328  ).def logseries(
+00010120: 702c 2073 697a 653d 4e6f 6e65 2c20 6b65  p, size=None, ke
+00010130: 793d 4e6f 6e65 293a 0a20 2072 6574 7572  y=None):.  retur
+00010140: 6e20 4445 4641 554c 542e 6c6f 6773 6572  n DEFAULT.logser
+00010150: 6965 7328 702c 2073 697a 652c 206b 6579  ies(p, size, key
+00010160: 3d6b 6579 290a 0a0a 2320 4077 7261 7073  =key)...# @wraps
+00010170: 286e 702e 7261 6e64 6f6d 2e6d 756c 7469  (np.random.multi
+00010180: 6e6f 6d69 616c 290a 6465 6620 6d75 6c74  nomial).def mult
+00010190: 696e 6f6d 6961 6c28 6e2c 2070 7661 6c73  inomial(n, pvals
+000101a0: 2c20 7369 7a65 3d4e 6f6e 652c 206b 6579  , size=None, key
+000101b0: 3d4e 6f6e 6529 3a0a 2020 7265 7475 726e  =None):.  return
+000101c0: 2044 4546 4155 4c54 2e6d 756c 7469 6e6f   DEFAULT.multino
+000101d0: 6d69 616c 286e 2c20 7076 616c 732c 2073  mial(n, pvals, s
+000101e0: 697a 652c 206b 6579 3d6b 6579 290a 0a0a  ize, key=key)...
+000101f0: 2320 4077 7261 7073 286e 702e 7261 6e64  # @wraps(np.rand
+00010200: 6f6d 2e6d 756c 7469 7661 7269 6174 655f  om.multivariate_
+00010210: 6e6f 726d 616c 290a 6465 6620 6d75 6c74  normal).def mult
+00010220: 6976 6172 6961 7465 5f6e 6f72 6d61 6c28  ivariate_normal(
+00010230: 6d65 616e 2c20 636f 762c 2073 697a 653d  mean, cov, size=
+00010240: 4e6f 6e65 2c20 6d65 7468 6f64 3a20 7374  None, method: st
+00010250: 7220 3d20 2763 686f 6c65 736b 7927 2c20  r = 'cholesky', 
+00010260: 6b65 793d 4e6f 6e65 293a 0a20 2072 6574  key=None):.  ret
+00010270: 7572 6e20 4445 4641 554c 542e 6d75 6c74  urn DEFAULT.mult
+00010280: 6976 6172 6961 7465 5f6e 6f72 6d61 6c28  ivariate_normal(
+00010290: 6d65 616e 2c20 636f 762c 2073 697a 652c  mean, cov, size,
+000102a0: 206d 6574 686f 642c 206b 6579 3d6b 6579   method, key=key
+000102b0: 290a 0a0a 2320 4077 7261 7073 286e 702e  )...# @wraps(np.
+000102c0: 7261 6e64 6f6d 2e6e 6567 6174 6976 655f  random.negative_
+000102d0: 6269 6e6f 6d69 616c 290a 6465 6620 6e65  binomial).def ne
+000102e0: 6761 7469 7665 5f62 696e 6f6d 6961 6c28  gative_binomial(
+000102f0: 6e2c 2070 2c20 7369 7a65 3d4e 6f6e 652c  n, p, size=None,
+00010300: 206b 6579 3d4e 6f6e 6529 3a0a 2020 7265   key=None):.  re
+00010310: 7475 726e 2044 4546 4155 4c54 2e6e 6567  turn DEFAULT.neg
+00010320: 6174 6976 655f 6269 6e6f 6d69 616c 286e  ative_binomial(n
+00010330: 2c20 702c 2073 697a 652c 206b 6579 3d6b  , p, size, key=k
+00010340: 6579 290a 0a0a 2320 4077 7261 7073 286e  ey)...# @wraps(n
+00010350: 702e 7261 6e64 6f6d 2e6e 6f6e 6365 6e74  p.random.noncent
+00010360: 7261 6c5f 6368 6973 7175 6172 6529 0a64  ral_chisquare).d
+00010370: 6566 206e 6f6e 6365 6e74 7261 6c5f 6368  ef noncentral_ch
+00010380: 6973 7175 6172 6528 6466 2c20 6e6f 6e63  isquare(df, nonc
+00010390: 2c20 7369 7a65 3d4e 6f6e 652c 206b 6579  , size=None, key
+000103a0: 3d4e 6f6e 6529 3a0a 2020 7265 7475 726e  =None):.  return
+000103b0: 2044 4546 4155 4c54 2e6e 6f6e 6365 6e74   DEFAULT.noncent
+000103c0: 7261 6c5f 6368 6973 7175 6172 6528 6466  ral_chisquare(df
+000103d0: 2c20 6e6f 6e63 2c20 7369 7a65 2c20 6b65  , nonc, size, ke
+000103e0: 793d 6b65 7929 0a0a 0a23 2040 7772 6170  y=key)...# @wrap
+000103f0: 7328 6e70 2e72 616e 646f 6d2e 6e6f 6e63  s(np.random.nonc
+00010400: 656e 7472 616c 5f66 290a 6465 6620 6e6f  entral_f).def no
+00010410: 6e63 656e 7472 616c 5f66 2864 666e 756d  ncentral_f(dfnum
+00010420: 2c20 6466 6465 6e2c 206e 6f6e 632c 2073  , dfden, nonc, s
+00010430: 697a 653d 4e6f 6e65 2c20 6b65 793d 4e6f  ize=None, key=No
+00010440: 6e65 293a 0a20 2072 6574 7572 6e20 4445  ne):.  return DE
+00010450: 4641 554c 542e 6e6f 6e63 656e 7472 616c  FAULT.noncentral
+00010460: 5f66 2864 666e 756d 2c20 6466 6465 6e2c  _f(dfnum, dfden,
+00010470: 206e 6f6e 632c 2073 697a 652c 206b 6579   nonc, size, key
+00010480: 3d6b 6579 290a 0a0a 2320 4077 7261 7073  =key)...# @wraps
+00010490: 286e 702e 7261 6e64 6f6d 2e70 6f77 6572  (np.random.power
+000104a0: 290a 6465 6620 706f 7765 7228 612c 2073  ).def power(a, s
+000104b0: 697a 653d 4e6f 6e65 2c20 6b65 793d 4e6f  ize=None, key=No
+000104c0: 6e65 293a 0a20 2072 6574 7572 6e20 4445  ne):.  return DE
+000104d0: 4641 554c 542e 706f 7765 7228 612c 2073  FAULT.power(a, s
+000104e0: 697a 652c 206b 6579 3d6b 6579 290a 0a0a  ize, key=key)...
+000104f0: 2320 4077 7261 7073 286e 702e 7261 6e64  # @wraps(np.rand
+00010500: 6f6d 2e72 6179 6c65 6967 6829 0a64 6566  om.rayleigh).def
+00010510: 2072 6179 6c65 6967 6828 7363 616c 653d   rayleigh(scale=
+00010520: 312e 302c 2073 697a 653d 4e6f 6e65 2c20  1.0, size=None, 
+00010530: 6b65 793d 4e6f 6e65 293a 0a20 2072 6574  key=None):.  ret
+00010540: 7572 6e20 4445 4641 554c 542e 7261 796c  urn DEFAULT.rayl
+00010550: 6569 6768 2873 6361 6c65 2c20 7369 7a65  eigh(scale, size
+00010560: 2c20 6b65 793d 6b65 7929 0a0a 0a23 2040  , key=key)...# @
+00010570: 7772 6170 7328 6e70 2e72 616e 646f 6d2e  wraps(np.random.
+00010580: 7472 6961 6e67 756c 6172 290a 6465 6620  triangular).def 
+00010590: 7472 6961 6e67 756c 6172 2873 697a 653d  triangular(size=
+000105a0: 4e6f 6e65 2c20 6b65 793d 4e6f 6e65 293a  None, key=None):
+000105b0: 0a20 2072 6574 7572 6e20 4445 4641 554c  .  return DEFAUL
+000105c0: 542e 7472 6961 6e67 756c 6172 2873 697a  T.triangular(siz
+000105d0: 652c 206b 6579 3d6b 6579 290a 0a0a 2320  e, key=key)...# 
+000105e0: 4077 7261 7073 286e 702e 7261 6e64 6f6d  @wraps(np.random
+000105f0: 2e76 6f6e 6d69 7365 7329 0a64 6566 2076  .vonmises).def v
+00010600: 6f6e 6d69 7365 7328 6d75 2c20 6b61 7070  onmises(mu, kapp
+00010610: 612c 2073 697a 653d 4e6f 6e65 2c20 6b65  a, size=None, ke
+00010620: 793d 4e6f 6e65 293a 0a20 2072 6574 7572  y=None):.  retur
+00010630: 6e20 4445 4641 554c 542e 766f 6e6d 6973  n DEFAULT.vonmis
+00010640: 6573 286d 752c 206b 6170 7061 2c20 7369  es(mu, kappa, si
+00010650: 7a65 2c20 6b65 793d 6b65 7929 0a0a 0a23  ze, key=key)...#
+00010660: 2040 7772 6170 7328 6e70 2e72 616e 646f   @wraps(np.rando
+00010670: 6d2e 7761 6c64 290a 6465 6620 7761 6c64  m.wald).def wald
+00010680: 286d 6561 6e2c 2073 6361 6c65 2c20 7369  (mean, scale, si
+00010690: 7a65 3d4e 6f6e 652c 206b 6579 3d4e 6f6e  ze=None, key=Non
+000106a0: 6529 3a0a 2020 7265 7475 726e 2044 4546  e):.  return DEF
+000106b0: 4155 4c54 2e77 616c 6428 6d65 616e 2c20  AULT.wald(mean, 
+000106c0: 7363 616c 652c 2073 697a 652c 206b 6579  scale, size, key
+000106d0: 3d6b 6579 290a 0a0a 6465 6620 7765 6962  =key)...def weib
+000106e0: 756c 6c28 612c 2073 697a 653d 4e6f 6e65  ull(a, size=None
+000106f0: 2c20 6b65 793d 4e6f 6e65 293a 0a20 2072  , key=None):.  r
+00010700: 2222 220a 2020 4472 6177 2073 616d 706c  """.  Draw sampl
+00010710: 6573 2066 726f 6d20 6120 5765 6962 756c  es from a Weibul
+00010720: 6c20 6469 7374 7269 6275 7469 6f6e 2e0a  l distribution..
+00010730: 2020 2020 0a20 2044 7261 7720 7361 6d70      .  Draw samp
+00010740: 6c65 7320 6672 6f6d 2061 2031 2d70 6172  les from a 1-par
+00010750: 616d 6574 6572 2057 6569 6275 6c6c 2064  ameter Weibull d
+00010760: 6973 7472 6962 7574 696f 6e20 7769 7468  istribution with
+00010770: 2074 6865 2067 6976 656e 0a20 2073 6861   the given.  sha
+00010780: 7065 2070 6172 616d 6574 6572 2060 6160  pe parameter `a`
+00010790: 2e0a 0a20 202e 2e20 6d61 7468 3a3a 2058  ...  .. math:: X
+000107a0: 203d 2028 2d6c 6e28 5529 295e 7b31 2f61   = (-ln(U))^{1/a
+000107b0: 7d0a 0a20 2048 6572 652c 2055 2069 7320  }..  Here, U is 
+000107c0: 6472 6177 6e20 6672 6f6d 2074 6865 2075  drawn from the u
+000107d0: 6e69 666f 726d 2064 6973 7472 6962 7574  niform distribut
+000107e0: 696f 6e20 6f76 6572 2028 302c 315d 2e0a  ion over (0,1]..
+000107f0: 0a20 2054 6865 206d 6f72 6520 636f 6d6d  .  The more comm
+00010800: 6f6e 2032 2d70 6172 616d 6574 6572 2057  on 2-parameter W
+00010810: 6569 6275 6c6c 2c20 696e 636c 7564 696e  eibull, includin
+00010820: 6720 6120 7363 616c 6520 7061 7261 6d65  g a scale parame
+00010830: 7465 720a 2020 3a6d 6174 683a 605c 6c61  ter.  :math:`\la
+00010840: 6d62 6461 6020 6973 206a 7573 7420 3a6d  mbda` is just :m
+00010850: 6174 683a 6058 203d 205c 6c61 6d62 6461  ath:`X = \lambda
+00010860: 282d 6c6e 2855 2929 5e7b 312f 617d 602e  (-ln(U))^{1/a}`.
+00010870: 0a0a 2020 2e2e 206e 6f74 653a 3a0a 2020  ..  .. note::.  
+00010880: 2020 2020 4e65 7720 636f 6465 2073 686f      New code sho
+00010890: 756c 6420 7573 6520 7468 6520 6060 7765  uld use the ``we
+000108a0: 6962 756c 6c60 6020 6d65 7468 6f64 206f  ibull`` method o
+000108b0: 6620 6120 6060 6465 6661 756c 745f 726e  f a ``default_rn
+000108c0: 6728 2960 600a 2020 2020 2020 696e 7374  g()``.      inst
+000108d0: 616e 6365 2069 6e73 7465 6164 3b20 706c  ance instead; pl
+000108e0: 6561 7365 2073 6565 2074 6865 203a 7265  ease see the :re
+000108f0: 663a 6072 616e 646f 6d2d 7175 6963 6b2d  f:`random-quick-
+00010900: 7374 6172 7460 2e0a 0a20 2050 6172 616d  start`...  Param
+00010910: 6574 6572 730a 2020 2d2d 2d2d 2d2d 2d2d  eters.  --------
+00010920: 2d2d 0a20 2061 203a 2066 6c6f 6174 206f  --.  a : float o
+00010930: 7220 6172 7261 795f 6c69 6b65 206f 6620  r array_like of 
+00010940: 666c 6f61 7473 0a20 2020 2020 2053 6861  floats.      Sha
+00010950: 7065 2070 6172 616d 6574 6572 206f 6620  pe parameter of 
+00010960: 7468 6520 6469 7374 7269 6275 7469 6f6e  the distribution
+00010970: 2e20 204d 7573 7420 6265 206e 6f6e 6e65  .  Must be nonne
+00010980: 6761 7469 7665 2e0a 2020 7369 7a65 203a  gative..  size :
+00010990: 2069 6e74 206f 7220 7475 706c 6520 6f66   int or tuple of
+000109a0: 2069 6e74 732c 206f 7074 696f 6e61 6c0a   ints, optional.
+000109b0: 2020 2020 2020 4f75 7470 7574 2073 6861        Output sha
+000109c0: 7065 2e20 2049 6620 7468 6520 6769 7665  pe.  If the give
+000109d0: 6e20 7368 6170 6520 6973 2c20 652e 672e  n shape is, e.g.
+000109e0: 2c20 6060 286d 2c20 6e2c 206b 2960 602c  , ``(m, n, k)``,
+000109f0: 2074 6865 6e0a 2020 2020 2020 6060 6d20   then.      ``m 
+00010a00: 2a20 6e20 2a20 6b60 6020 7361 6d70 6c65  * n * k`` sample
+00010a10: 7320 6172 6520 6472 6177 6e2e 2020 4966  s are drawn.  If
+00010a20: 2073 697a 6520 6973 2060 604e 6f6e 6560   size is ``None`
+00010a30: 6020 2864 6566 6175 6c74 292c 0a20 2020  ` (default),.   
+00010a40: 2020 2061 2073 696e 676c 6520 7661 6c75     a single valu
+00010a50: 6520 6973 2072 6574 7572 6e65 6420 6966  e is returned if
+00010a60: 2060 6061 6060 2069 7320 6120 7363 616c   ``a`` is a scal
+00010a70: 6172 2e20 204f 7468 6572 7769 7365 2c0a  ar.  Otherwise,.
+00010a80: 2020 2020 2020 6060 6e70 2e61 7272 6179        ``np.array
+00010a90: 2861 292e 7369 7a65 6060 2073 616d 706c  (a).size`` sampl
+00010aa0: 6573 2061 7265 2064 7261 776e 2e0a 0a20  es are drawn... 
+00010ab0: 2052 6574 7572 6e73 0a20 202d 2d2d 2d2d   Returns.  -----
+00010ac0: 2d2d 0a20 206f 7574 203a 206e 6461 7272  --.  out : ndarr
+00010ad0: 6179 206f 7220 7363 616c 6172 0a20 2020  ay or scalar.   
+00010ae0: 2020 2044 7261 776e 2073 616d 706c 6573     Drawn samples
+00010af0: 2066 726f 6d20 7468 6520 7061 7261 6d65   from the parame
+00010b00: 7465 7269 7a65 6420 5765 6962 756c 6c20  terized Weibull 
+00010b10: 6469 7374 7269 6275 7469 6f6e 2e0a 0a20  distribution... 
+00010b20: 2053 6565 2041 6c73 6f0a 2020 2d2d 2d2d   See Also.  ----
+00010b30: 2d2d 2d2d 0a20 2073 6369 7079 2e73 7461  ----.  scipy.sta
+00010b40: 7473 2e77 6569 6275 6c6c 5f6d 6178 0a20  ts.weibull_max. 
+00010b50: 2073 6369 7079 2e73 7461 7473 2e77 6569   scipy.stats.wei
+00010b60: 6275 6c6c 5f6d 696e 0a20 2073 6369 7079  bull_min.  scipy
+00010b70: 2e73 7461 7473 2e67 656e 6578 7472 656d  .stats.genextrem
+00010b80: 650a 2020 6775 6d62 656c 0a20 2072 616e  e.  gumbel.  ran
+00010b90: 646f 6d2e 4765 6e65 7261 746f 722e 7765  dom.Generator.we
+00010ba0: 6962 756c 6c3a 2077 6869 6368 2073 686f  ibull: which sho
+00010bb0: 756c 6420 6265 2075 7365 6420 666f 7220  uld be used for 
+00010bc0: 6e65 7720 636f 6465 2e0a 0a20 204e 6f74  new code...  Not
+00010bd0: 6573 0a20 202d 2d2d 2d2d 0a20 2054 6865  es.  -----.  The
+00010be0: 2057 6569 6275 6c6c 2028 6f72 2054 7970   Weibull (or Typ
+00010bf0: 6520 4949 4920 6173 796d 7074 6f74 6963  e III asymptotic
+00010c00: 2065 7874 7265 6d65 2076 616c 7565 2064   extreme value d
+00010c10: 6973 7472 6962 7574 696f 6e0a 2020 666f  istribution.  fo
+00010c20: 7220 736d 616c 6c65 7374 2076 616c 7565  r smallest value
+00010c30: 732c 2053 4556 2054 7970 6520 4949 492c  s, SEV Type III,
+00010c40: 206f 7220 526f 7369 6e2d 5261 6d6d 6c65   or Rosin-Rammle
+00010c50: 720a 2020 6469 7374 7269 6275 7469 6f6e  r.  distribution
+00010c60: 2920 6973 206f 6e65 206f 6620 6120 636c  ) is one of a cl
+00010c70: 6173 7320 6f66 2047 656e 6572 616c 697a  ass of Generaliz
+00010c80: 6564 2045 7874 7265 6d65 2056 616c 7565  ed Extreme Value
+00010c90: 0a20 2028 4745 5629 2064 6973 7472 6962  .  (GEV) distrib
+00010ca0: 7574 696f 6e73 2075 7365 6420 696e 206d  utions used in m
+00010cb0: 6f64 656c 696e 6720 6578 7472 656d 6520  odeling extreme 
+00010cc0: 7661 6c75 6520 7072 6f62 6c65 6d73 2e0a  value problems..
+00010cd0: 2020 5468 6973 2063 6c61 7373 2069 6e63    This class inc
+00010ce0: 6c75 6465 7320 7468 6520 4775 6d62 656c  ludes the Gumbel
+00010cf0: 2061 6e64 2046 7265 6368 6574 2064 6973   and Frechet dis
+00010d00: 7472 6962 7574 696f 6e73 2e0a 0a20 2054  tributions...  T
+00010d10: 6865 2070 726f 6261 6269 6c69 7479 2064  he probability d
+00010d20: 656e 7369 7479 2066 6f72 2074 6865 2057  ensity for the W
+00010d30: 6569 6275 6c6c 2064 6973 7472 6962 7574  eibull distribut
+00010d40: 696f 6e20 6973 0a0a 2020 2e2e 206d 6174  ion is..  .. mat
+00010d50: 683a 3a20 7028 7829 203d 205c 6672 6163  h:: p(x) = \frac
+00010d60: 7b61 7d0a 2020 2020 2020 2020 2020 2020  {a}.            
+00010d70: 2020 2020 2020 207b 5c6c 616d 6264 617d         {\lambda}
+00010d80: 285c 6672 6163 7b78 7d7b 5c6c 616d 6264  (\frac{x}{\lambd
+00010d90: 617d 295e 7b61 2d31 7d65 5e7b 2d28 782f  a})^{a-1}e^{-(x/
+00010da0: 5c6c 616d 6264 6129 5e61 7d2c 0a0a 2020  \lambda)^a},..  
+00010db0: 7768 6572 6520 3a6d 6174 683a 6061 6020  where :math:`a` 
+00010dc0: 6973 2074 6865 2073 6861 7065 2061 6e64  is the shape and
+00010dd0: 203a 6d61 7468 3a60 5c6c 616d 6264 6160   :math:`\lambda`
+00010de0: 2074 6865 2073 6361 6c65 2e0a 0a20 2054   the scale...  T
+00010df0: 6865 2066 756e 6374 696f 6e20 6861 7320  he function has 
+00010e00: 6974 7320 7065 616b 2028 7468 6520 6d6f  its peak (the mo
+00010e10: 6465 2920 6174 0a20 203a 6d61 7468 3a60  de) at.  :math:`
+00010e20: 5c6c 616d 6264 6128 5c66 7261 637b 612d  \lambda(\frac{a-
+00010e30: 317d 7b61 7d29 5e7b 312f 617d 602e 0a0a  1}{a})^{1/a}`...
+00010e40: 2020 5768 656e 2060 6061 203d 2031 6060    When ``a = 1``
+00010e50: 2c20 7468 6520 5765 6962 756c 6c20 6469  , the Weibull di
+00010e60: 7374 7269 6275 7469 6f6e 2072 6564 7563  stribution reduc
+00010e70: 6573 2074 6f20 7468 6520 6578 706f 6e65  es to the expone
+00010e80: 6e74 6961 6c0a 2020 6469 7374 7269 6275  ntial.  distribu
+00010e90: 7469 6f6e 2e0a 0a20 2052 6566 6572 656e  tion...  Referen
+00010ea0: 6365 730a 2020 2d2d 2d2d 2d2d 2d2d 2d2d  ces.  ----------
+00010eb0: 0a20 202e 2e20 5b31 5d20 5761 6c6f 6464  .  .. [1] Walodd
+00010ec0: 6920 5765 6962 756c 6c2c 2052 6f79 616c  i Weibull, Royal
+00010ed0: 2054 6563 686e 6963 616c 2055 6e69 7665   Technical Unive
+00010ee0: 7273 6974 792c 2053 746f 636b 686f 6c6d  rsity, Stockholm
+00010ef0: 2c0a 2020 2020 2020 2020 2031 3933 3920  ,.         1939 
+00010f00: 2241 2053 7461 7469 7374 6963 616c 2054  "A Statistical T
+00010f10: 6865 6f72 7920 4f66 2054 6865 2053 7472  heory Of The Str
+00010f20: 656e 6774 6820 4f66 204d 6174 6572 6961  ength Of Materia
+00010f30: 6c73 222c 0a20 2020 2020 2020 2020 496e  ls",.         In
+00010f40: 6765 6e69 6f72 7376 6574 656e 736b 6170  geniorsvetenskap
+00010f50: 7361 6b61 6465 6d69 656e 7320 4861 6e64  sakademiens Hand
+00010f60: 6c69 6e67 6172 204e 7220 3135 312c 2031  lingar Nr 151, 1
+00010f70: 3933 392c 0a20 2020 2020 2020 2020 4765  939,.         Ge
+00010f80: 6e65 7261 6c73 7461 6265 6e73 204c 6974  neralstabens Lit
+00010f90: 6f67 7261 6669 736b 6120 416e 7374 616c  ografiska Anstal
+00010fa0: 7473 2046 6f72 6c61 672c 2053 746f 636b  ts Forlag, Stock
+00010fb0: 686f 6c6d 2e0a 2020 2e2e 205b 325d 2057  holm..  .. [2] W
+00010fc0: 616c 6f64 6469 2057 6569 6275 6c6c 2c20  aloddi Weibull, 
+00010fd0: 2241 2053 7461 7469 7374 6963 616c 2044  "A Statistical D
+00010fe0: 6973 7472 6962 7574 696f 6e20 4675 6e63  istribution Func
+00010ff0: 7469 6f6e 206f 660a 2020 2020 2020 2020  tion of.        
+00011000: 2057 6964 6520 4170 706c 6963 6162 696c   Wide Applicabil
+00011010: 6974 7922 2c20 4a6f 7572 6e61 6c20 4f66  ity", Journal Of
+00011020: 2041 7070 6c69 6564 204d 6563 6861 6e69   Applied Mechani
+00011030: 6373 2041 534d 4520 5061 7065 720a 2020  cs ASME Paper.  
+00011040: 2020 2020 2020 2031 3935 312e 0a20 202e         1951..  .
+00011050: 2e20 5b33 5d20 5769 6b69 7065 6469 612c  . [3] Wikipedia,
+00011060: 2022 5765 6962 756c 6c20 6469 7374 7269   "Weibull distri
+00011070: 6275 7469 6f6e 222c 0a20 2020 2020 2020  bution",.       
+00011080: 2020 6874 7470 733a 2f2f 656e 2e77 696b    https://en.wik
+00011090: 6970 6564 6961 2e6f 7267 2f77 696b 692f  ipedia.org/wiki/
+000110a0: 5765 6962 756c 6c5f 6469 7374 7269 6275  Weibull_distribu
+000110b0: 7469 6f6e 0a0a 2020 4578 616d 706c 6573  tion..  Examples
+000110c0: 0a20 202d 2d2d 2d2d 2d2d 2d0a 2020 4472  .  --------.  Dr
+000110d0: 6177 2073 616d 706c 6573 2066 726f 6d20  aw samples from 
+000110e0: 7468 6520 6469 7374 7269 6275 7469 6f6e  the distribution
+000110f0: 3a0a 0a20 203e 3e3e 2061 203d 2035 2e20  :..  >>> a = 5. 
+00011100: 2320 7368 6170 650a 2020 3e3e 3e20 7320  # shape.  >>> s 
+00011110: 3d20 6272 6169 6e70 792e 6d61 7468 2e72  = brainpy.math.r
+00011120: 616e 646f 6d2e 7765 6962 756c 6c28 612c  andom.weibull(a,
+00011130: 2031 3030 3029 0a0a 2020 4469 7370 6c61   1000)..  Displa
+00011140: 7920 7468 6520 6869 7374 6f67 7261 6d20  y the histogram 
+00011150: 6f66 2074 6865 2073 616d 706c 6573 2c20  of the samples, 
+00011160: 616c 6f6e 6720 7769 7468 0a20 2074 6865  along with.  the
+00011170: 2070 726f 6261 6269 6c69 7479 2064 656e   probability den
+00011180: 7369 7479 2066 756e 6374 696f 6e3a 0a0a  sity function:..
+00011190: 2020 3e3e 3e20 696d 706f 7274 206d 6174    >>> import mat
+000111a0: 706c 6f74 6c69 622e 7079 706c 6f74 2061  plotlib.pyplot a
+000111b0: 7320 706c 740a 2020 3e3e 3e20 7820 3d20  s plt.  >>> x = 
+000111c0: 6e70 2e61 7261 6e67 6528 312c 3130 302e  np.arange(1,100.
+000111d0: 292f 3530 2e0a 2020 3e3e 3e20 6465 6620  )/50..  >>> def 
+000111e0: 7765 6962 2878 2c6e 2c61 293a 0a20 202e  weib(x,n,a):.  .
+000111f0: 2e2e 2020 2020 2072 6574 7572 6e20 2861  ..     return (a
+00011200: 202f 206e 2920 2a20 2878 202f 206e 292a   / n) * (x / n)*
+00011210: 2a28 6120 2d20 3129 202a 206e 702e 6578  *(a - 1) * np.ex
+00011220: 7028 2d28 7820 2f20 6e29 2a2a 6129 0a0a  p(-(x / n)**a)..
+00011230: 2020 3e3e 3e20 636f 756e 742c 2062 696e    >>> count, bin
+00011240: 732c 2069 676e 6f72 6564 203d 2070 6c74  s, ignored = plt
+00011250: 2e68 6973 7428 6272 6169 6e70 792e 6d61  .hist(brainpy.ma
+00011260: 7468 2e72 616e 646f 6d2e 7765 6962 756c  th.random.weibul
+00011270: 6c28 352e 2c31 3030 3029 290a 2020 3e3e  l(5.,1000)).  >>
+00011280: 3e20 7820 3d20 6e70 2e61 7261 6e67 6528  > x = np.arange(
+00011290: 312c 3130 302e 292f 3530 2e0a 2020 3e3e  1,100.)/50..  >>
+000112a0: 3e20 7363 616c 6520 3d20 636f 756e 742e  > scale = count.
+000112b0: 6d61 7828 292f 7765 6962 2878 2c20 312e  max()/weib(x, 1.
+000112c0: 2c20 352e 292e 6d61 7828 290a 2020 3e3e  , 5.).max().  >>
+000112d0: 3e20 706c 742e 706c 6f74 2878 2c20 7765  > plt.plot(x, we
+000112e0: 6962 2878 2c20 312e 2c20 352e 292a 7363  ib(x, 1., 5.)*sc
+000112f0: 616c 6529 0a20 203e 3e3e 2070 6c74 2e73  ale).  >>> plt.s
+00011300: 686f 7728 290a 0a20 2022 2222 0a20 2072  how()..  """.  r
+00011310: 6574 7572 6e20 4445 4641 554c 542e 7765  eturn DEFAULT.we
+00011320: 6962 756c 6c28 612c 2073 697a 652c 206b  ibull(a, size, k
+00011330: 6579 3d6b 6579 290a 0a0a 6465 6620 7765  ey=key)...def we
+00011340: 6962 756c 6c5f 6d69 6e28 612c 2073 6361  ibull_min(a, sca
+00011350: 6c65 3d4e 6f6e 652c 2073 697a 653d 4e6f  le=None, size=No
+00011360: 6e65 2c20 6b65 793d 4e6f 6e65 293a 0a20  ne, key=None):. 
+00011370: 2022 2222 5361 6d70 6c65 2066 726f 6d20   """Sample from 
+00011380: 6120 5765 6962 756c 6c20 6469 7374 7269  a Weibull distri
+00011390: 6275 7469 6f6e 2e0a 0a20 2054 6865 2073  bution...  The s
+000113a0: 6369 7079 2063 6f75 6e74 6572 7061 7274  cipy counterpart
+000113b0: 2069 7320 6073 6369 7079 2e73 7461 7473   is `scipy.stats
+000113c0: 2e77 6569 6275 6c6c 5f6d 696e 602e 0a0a  .weibull_min`...
+000113d0: 2020 4172 6773 3a0a 2020 2020 7363 616c    Args:.    scal
+000113e0: 653a 2054 6865 2073 6361 6c65 2070 6172  e: The scale par
+000113f0: 616d 6574 6572 206f 6620 7468 6520 6469  ameter of the di
+00011400: 7374 7269 6275 7469 6f6e 2e0a 2020 2020  stribution..    
+00011410: 636f 6e63 656e 7472 6174 696f 6e3a 2054  concentration: T
+00011420: 6865 2063 6f6e 6365 6e74 7261 7469 6f6e  he concentration
+00011430: 2070 6172 616d 6574 6572 206f 6620 7468   parameter of th
+00011440: 6520 6469 7374 7269 6275 7469 6f6e 2e0a  e distribution..
+00011450: 2020 2020 7368 6170 653a 2054 6865 2073      shape: The s
+00011460: 6861 7065 2061 6464 6564 2074 6f20 7468  hape added to th
+00011470: 6520 7061 7261 6d65 7465 7273 206c 6f63  e parameters loc
+00011480: 2061 6e64 2073 6361 6c65 2062 726f 6164   and scale broad
+00011490: 6361 7374 6162 6c65 2073 6861 7065 2e0a  castable shape..
+000114a0: 2020 2020 6474 7970 653a 2054 6865 2074      dtype: The t
+000114b0: 7970 6520 7573 6564 2066 6f72 2073 616d  ype used for sam
+000114c0: 706c 6573 2e0a 2020 2020 6b65 793a 2061  ples..    key: a
+000114d0: 2050 524e 4720 6b65 7920 6f72 2061 2073   PRNG key or a s
+000114e0: 6565 642e 0a0a 2020 5265 7475 726e 733a  eed...  Returns:
+000114f0: 0a20 2020 2041 206a 6e70 2e61 7272 6179  .    A jnp.array
+00011500: 206f 6620 7361 6d70 6c65 732e 0a0a 2020   of samples...  
+00011510: 2222 220a 2020 7265 7475 726e 2044 4546  """.  return DEF
+00011520: 4155 4c54 2e77 6569 6275 6c6c 5f6d 696e  AULT.weibull_min
+00011530: 2861 2c20 7363 616c 652c 2073 697a 652c  (a, scale, size,
+00011540: 206b 6579 3d6b 6579 290a 0a0a 6465 6620   key=key)...def 
+00011550: 7a69 7066 2861 2c20 7369 7a65 3d4e 6f6e  zipf(a, size=Non
+00011560: 652c 206b 6579 3d4e 6f6e 6529 3a0a 2020  e, key=None):.  
+00011570: 7222 2222 0a20 2044 7261 7720 7361 6d70  r""".  Draw samp
+00011580: 6c65 7320 6672 6f6d 2061 205a 6970 6620  les from a Zipf 
+00011590: 6469 7374 7269 6275 7469 6f6e 2e0a 0a20  distribution... 
+000115a0: 2053 616d 706c 6573 2061 7265 2064 7261   Samples are dra
+000115b0: 776e 2066 726f 6d20 6120 5a69 7066 2064  wn from a Zipf d
+000115c0: 6973 7472 6962 7574 696f 6e20 7769 7468  istribution with
+000115d0: 2073 7065 6369 6669 6564 2070 6172 616d   specified param
+000115e0: 6574 6572 0a20 2060 6160 203e 2031 2e0a  eter.  `a` > 1..
+000115f0: 0a20 2054 6865 205a 6970 6620 6469 7374  .  The Zipf dist
+00011600: 7269 6275 7469 6f6e 2028 616c 736f 206b  ribution (also k
+00011610: 6e6f 776e 2061 7320 7468 6520 7a65 7461  nown as the zeta
+00011620: 2064 6973 7472 6962 7574 696f 6e29 2069   distribution) i
+00011630: 7320 610a 2020 6469 7363 7265 7465 2070  s a.  discrete p
+00011640: 726f 6261 6269 6c69 7479 2064 6973 7472  robability distr
+00011650: 6962 7574 696f 6e20 7468 6174 2073 6174  ibution that sat
+00011660: 6973 6669 6573 205a 6970 6627 7320 6c61  isfies Zipf's la
+00011670: 773a 2074 6865 0a20 2066 7265 7175 656e  w: the.  frequen
+00011680: 6379 206f 6620 616e 2069 7465 6d20 6973  cy of an item is
+00011690: 2069 6e76 6572 7365 6c79 2070 726f 706f   inversely propo
+000116a0: 7274 696f 6e61 6c20 746f 2069 7473 2072  rtional to its r
+000116b0: 616e 6b20 696e 2061 0a20 2066 7265 7175  ank in a.  frequ
+000116c0: 656e 6379 2074 6162 6c65 2e0a 0a20 202e  ency table...  .
+000116d0: 2e20 6e6f 7465 3a3a 0a20 2020 2020 204e  . note::.      N
+000116e0: 6577 2063 6f64 6520 7368 6f75 6c64 2075  ew code should u
+000116f0: 7365 2074 6865 2060 607a 6970 6660 6020  se the ``zipf`` 
+00011700: 6d65 7468 6f64 206f 6620 6120 6060 6465  method of a ``de
+00011710: 6661 756c 745f 726e 6728 2960 600a 2020  fault_rng()``.  
+00011720: 2020 2020 696e 7374 616e 6365 2069 6e73      instance ins
+00011730: 7465 6164 3b20 706c 6561 7365 2073 6565  tead; please see
+00011740: 2074 6865 203a 7265 663a 6072 616e 646f   the :ref:`rando
+00011750: 6d2d 7175 6963 6b2d 7374 6172 7460 2e0a  m-quick-start`..
+00011760: 0a20 2050 6172 616d 6574 6572 730a 2020  .  Parameters.  
+00011770: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2061 203a  ----------.  a :
+00011780: 2066 6c6f 6174 206f 7220 6172 7261 795f   float or array_
+00011790: 6c69 6b65 206f 6620 666c 6f61 7473 0a20  like of floats. 
+000117a0: 2020 2020 2044 6973 7472 6962 7574 696f       Distributio
+000117b0: 6e20 7061 7261 6d65 7465 722e 204d 7573  n parameter. Mus
+000117c0: 7420 6265 2067 7265 6174 6572 2074 6861  t be greater tha
+000117d0: 6e20 312e 0a20 2073 697a 6520 3a20 696e  n 1..  size : in
+000117e0: 7420 6f72 2074 7570 6c65 206f 6620 696e  t or tuple of in
+000117f0: 7473 2c20 6f70 7469 6f6e 616c 0a20 2020  ts, optional.   
+00011800: 2020 204f 7574 7075 7420 7368 6170 652e     Output shape.
+00011810: 2020 4966 2074 6865 2067 6976 656e 2073    If the given s
+00011820: 6861 7065 2069 732c 2065 2e67 2e2c 2060  hape is, e.g., `
+00011830: 6028 6d2c 206e 2c20 6b29 6060 2c20 7468  `(m, n, k)``, th
+00011840: 656e 0a20 2020 2020 2060 606d 202a 206e  en.      ``m * n
+00011850: 202a 206b 6060 2073 616d 706c 6573 2061   * k`` samples a
+00011860: 7265 2064 7261 776e 2e20 2049 6620 7369  re drawn.  If si
+00011870: 7a65 2069 7320 6060 4e6f 6e65 6060 2028  ze is ``None`` (
+00011880: 6465 6661 756c 7429 2c0a 2020 2020 2020  default),.      
+00011890: 6120 7369 6e67 6c65 2076 616c 7565 2069  a single value i
+000118a0: 7320 7265 7475 726e 6564 2069 6620 6060  s returned if ``
+000118b0: 6160 6020 6973 2061 2073 6361 6c61 722e  a`` is a scalar.
+000118c0: 204f 7468 6572 7769 7365 2c0a 2020 2020   Otherwise,.    
+000118d0: 2020 6060 6e70 2e61 7272 6179 2861 292e    ``np.array(a).
+000118e0: 7369 7a65 6060 2073 616d 706c 6573 2061  size`` samples a
+000118f0: 7265 2064 7261 776e 2e0a 0a20 2052 6574  re drawn...  Ret
+00011900: 7572 6e73 0a20 202d 2d2d 2d2d 2d2d 0a20  urns.  -------. 
+00011910: 206f 7574 203a 206e 6461 7272 6179 206f   out : ndarray o
+00011920: 7220 7363 616c 6172 0a20 2020 2020 2044  r scalar.      D
+00011930: 7261 776e 2073 616d 706c 6573 2066 726f  rawn samples fro
+00011940: 6d20 7468 6520 7061 7261 6d65 7465 7269  m the parameteri
+00011950: 7a65 6420 5a69 7066 2064 6973 7472 6962  zed Zipf distrib
+00011960: 7574 696f 6e2e 0a0a 2020 5365 6520 416c  ution...  See Al
+00011970: 736f 0a20 202d 2d2d 2d2d 2d2d 2d0a 2020  so.  --------.  
+00011980: 7363 6970 792e 7374 6174 732e 7a69 7066  scipy.stats.zipf
+00011990: 203a 2070 726f 6261 6269 6c69 7479 2064   : probability d
+000119a0: 656e 7369 7479 2066 756e 6374 696f 6e2c  ensity function,
+000119b0: 2064 6973 7472 6962 7574 696f 6e2c 206f   distribution, o
+000119c0: 720a 2020 2020 2020 6375 6d75 6c61 7469  r.      cumulati
+000119d0: 7665 2064 656e 7369 7479 2066 756e 6374  ve density funct
+000119e0: 696f 6e2c 2065 7463 2e0a 2020 7261 6e64  ion, etc..  rand
+000119f0: 6f6d 2e47 656e 6572 6174 6f72 2e7a 6970  om.Generator.zip
+00011a00: 663a 2077 6869 6368 2073 686f 756c 6420  f: which should 
+00011a10: 6265 2075 7365 6420 666f 7220 6e65 7720  be used for new 
+00011a20: 636f 6465 2e0a 0a20 204e 6f74 6573 0a20  code...  Notes. 
+00011a30: 202d 2d2d 2d2d 0a20 2054 6865 2070 726f   -----.  The pro
+00011a40: 6261 6269 6c69 7479 2064 656e 7369 7479  bability density
+00011a50: 2066 6f72 2074 6865 205a 6970 6620 6469   for the Zipf di
+00011a60: 7374 7269 6275 7469 6f6e 2069 730a 0a20  stribution is.. 
+00011a70: 202e 2e20 6d61 7468 3a3a 2070 286b 2920   .. math:: p(k) 
+00011a80: 3d20 5c66 7261 637b 6b5e 7b2d 617d 7d7b  = \frac{k^{-a}}{
+00011a90: 5c7a 6574 6128 6129 7d2c 0a0a 2020 666f  \zeta(a)},..  fo
+00011aa0: 7220 696e 7465 6765 7273 203a 6d61 7468  r integers :math
+00011ab0: 3a60 6b20 5c67 6571 2031 602c 2077 6865  :`k \geq 1`, whe
+00011ac0: 7265 203a 6d61 7468 3a60 5c7a 6574 6160  re :math:`\zeta`
+00011ad0: 2069 7320 7468 6520 5269 656d 616e 6e20   is the Riemann 
+00011ae0: 5a65 7461 0a20 2066 756e 6374 696f 6e2e  Zeta.  function.
+00011af0: 0a0a 2020 4974 2069 7320 6e61 6d65 6420  ..  It is named 
+00011b00: 666f 7220 7468 6520 416d 6572 6963 616e  for the American
+00011b10: 206c 696e 6775 6973 7420 4765 6f72 6765   linguist George
+00011b20: 204b 696e 6773 6c65 7920 5a69 7066 2c20   Kingsley Zipf, 
+00011b30: 7768 6f20 6e6f 7465 640a 2020 7468 6174  who noted.  that
+00011b40: 2074 6865 2066 7265 7175 656e 6379 206f   the frequency o
+00011b50: 6620 616e 7920 776f 7264 2069 6e20 6120  f any word in a 
+00011b60: 7361 6d70 6c65 206f 6620 6120 6c61 6e67  sample of a lang
+00011b70: 7561 6765 2069 7320 696e 7665 7273 656c  uage is inversel
+00011b80: 790a 2020 7072 6f70 6f72 7469 6f6e 616c  y.  proportional
+00011b90: 2074 6f20 6974 7320 7261 6e6b 2069 6e20   to its rank in 
+00011ba0: 7468 6520 6672 6571 7565 6e63 7920 7461  the frequency ta
+00011bb0: 626c 652e 0a0a 2020 5265 6665 7265 6e63  ble...  Referenc
+00011bc0: 6573 0a20 202d 2d2d 2d2d 2d2d 2d2d 2d0a  es.  ----------.
+00011bd0: 2020 2e2e 205b 315d 205a 6970 662c 2047    .. [1] Zipf, G
+00011be0: 2e20 4b2e 2c20 2253 656c 6563 7465 6420  . K., "Selected 
+00011bf0: 5374 7564 6965 7320 6f66 2074 6865 2050  Studies of the P
+00011c00: 7269 6e63 6970 6c65 206f 6620 5265 6c61  rinciple of Rela
+00011c10: 7469 7665 0a20 2020 2020 2020 2020 4672  tive.         Fr
+00011c20: 6571 7565 6e63 7920 696e 204c 616e 6775  equency in Langu
+00011c30: 6167 652c 2220 4361 6d62 7269 6467 652c  age," Cambridge,
+00011c40: 204d 413a 2048 6172 7661 7264 2055 6e69   MA: Harvard Uni
+00011c50: 762e 2050 7265 7373 2c0a 2020 2020 2020  v. Press,.      
+00011c60: 2020 2031 3933 322e 0a0a 2020 4578 616d     1932...  Exam
+00011c70: 706c 6573 0a20 202d 2d2d 2d2d 2d2d 2d0a  ples.  --------.
+00011c80: 2020 4472 6177 2073 616d 706c 6573 2066    Draw samples f
+00011c90: 726f 6d20 7468 6520 6469 7374 7269 6275  rom the distribu
+00011ca0: 7469 6f6e 3a0a 0a20 203e 3e3e 2061 203d  tion:..  >>> a =
+00011cb0: 2034 2e30 0a20 203e 3e3e 206e 203d 2032   4.0.  >>> n = 2
+00011cc0: 3030 3030 0a20 203e 3e3e 2073 203d 2062  0000.  >>> s = b
+00011cd0: 7261 696e 7079 2e6d 6174 682e 7261 6e64  rainpy.math.rand
+00011ce0: 6f6d 2e7a 6970 6628 612c 206e 290a 0a20  om.zipf(a, n).. 
+00011cf0: 2044 6973 706c 6179 2074 6865 2068 6973   Display the his
+00011d00: 746f 6772 616d 206f 6620 7468 6520 7361  togram of the sa
+00011d10: 6d70 6c65 732c 2061 6c6f 6e67 2077 6974  mples, along wit
+00011d20: 680a 2020 7468 6520 6578 7065 6374 6564  h.  the expected
+00011d30: 2068 6973 746f 6772 616d 2062 6173 6564   histogram based
+00011d40: 206f 6e20 7468 6520 7072 6f62 6162 696c   on the probabil
+00011d50: 6974 790a 2020 6465 6e73 6974 7920 6675  ity.  density fu
+00011d60: 6e63 7469 6f6e 3a0a 0a20 203e 3e3e 2069  nction:..  >>> i
+00011d70: 6d70 6f72 7420 6d61 7470 6c6f 746c 6962  mport matplotlib
+00011d80: 2e70 7970 6c6f 7420 6173 2070 6c74 0a20  .pyplot as plt. 
+00011d90: 203e 3e3e 2066 726f 6d20 7363 6970 792e   >>> from scipy.
+00011da0: 7370 6563 6961 6c20 696d 706f 7274 207a  special import z
+00011db0: 6574 6120 2023 2064 6f63 7465 7374 3a20  eta  # doctest: 
+00011dc0: 2b53 4b49 500a 0a20 2060 6269 6e63 6f75  +SKIP..  `bincou
+00011dd0: 6e74 6020 7072 6f76 6964 6573 2061 2066  nt` provides a f
+00011de0: 6173 7420 6869 7374 6f67 7261 6d20 666f  ast histogram fo
+00011df0: 7220 736d 616c 6c20 696e 7465 6765 7273  r small integers
+00011e00: 2e0a 0a20 203e 3e3e 2063 6f75 6e74 203d  ...  >>> count =
+00011e10: 206e 702e 6269 6e63 6f75 6e74 2873 290a   np.bincount(s).
+00011e20: 2020 3e3e 3e20 6b20 3d20 6e70 2e61 7261    >>> k = np.ara
+00011e30: 6e67 6528 312c 2073 2e6d 6178 2829 202b  nge(1, s.max() +
+00011e40: 2031 290a 0a20 203e 3e3e 2070 6c74 2e62   1)..  >>> plt.b
+00011e50: 6172 286b 2c20 636f 756e 745b 313a 5d2c  ar(k, count[1:],
+00011e60: 2061 6c70 6861 3d30 2e35 2c20 6c61 6265   alpha=0.5, labe
+00011e70: 6c3d 2773 616d 706c 6520 636f 756e 7427  l='sample count'
+00011e80: 290a 2020 3e3e 3e20 706c 742e 706c 6f74  ).  >>> plt.plot
+00011e90: 286b 2c20 6e2a 286b 2a2a 2d61 292f 7a65  (k, n*(k**-a)/ze
+00011ea0: 7461 2861 292c 2027 6b2e 2d27 2c20 616c  ta(a), 'k.-', al
+00011eb0: 7068 613d 302e 352c 0a20 202e 2e2e 2020  pha=0.5,.  ...  
+00011ec0: 2020 2020 2020 2020 6c61 6265 6c3d 2765          label='e
+00011ed0: 7870 6563 7465 6420 636f 756e 7427 2920  xpected count') 
+00011ee0: 2020 2320 646f 6374 6573 743a 202b 534b    # doctest: +SK
+00011ef0: 4950 0a20 203e 3e3e 2070 6c74 2e73 656d  IP.  >>> plt.sem
+00011f00: 696c 6f67 7928 290a 2020 3e3e 3e20 706c  ilogy().  >>> pl
+00011f10: 742e 6772 6964 2861 6c70 6861 3d30 2e34  t.grid(alpha=0.4
+00011f20: 290a 2020 3e3e 3e20 706c 742e 6c65 6765  ).  >>> plt.lege
+00011f30: 6e64 2829 0a20 203e 3e3e 2070 6c74 2e74  nd().  >>> plt.t
+00011f40: 6974 6c65 2866 275a 6970 6620 7361 6d70  itle(f'Zipf samp
+00011f50: 6c65 2c20 613d 7b61 7d2c 2073 697a 653d  le, a={a}, size=
+00011f60: 7b6e 7d27 290a 2020 3e3e 3e20 706c 742e  {n}').  >>> plt.
+00011f70: 7368 6f77 2829 0a20 2022 2222 0a20 2072  show().  """.  r
+00011f80: 6574 7572 6e20 4445 4641 554c 542e 7a69  eturn DEFAULT.zi
+00011f90: 7066 2861 2c20 7369 7a65 2c20 6b65 793d  pf(a, size, key=
+00011fa0: 6b65 7929 0a0a 0a64 6566 206d 6178 7765  key)...def maxwe
+00011fb0: 6c6c 2873 697a 653d 4e6f 6e65 2c20 6b65  ll(size=None, ke
+00011fc0: 793d 4e6f 6e65 293a 0a20 2022 2222 5361  y=None):.  """Sa
+00011fd0: 6d70 6c65 2066 726f 6d20 6120 6f6e 6520  mple from a one 
+00011fe0: 7369 6465 6420 4d61 7877 656c 6c20 6469  sided Maxwell di
+00011ff0: 7374 7269 6275 7469 6f6e 2e0a 0a20 2054  stribution...  T
+00012000: 6865 2073 6369 7079 2063 6f75 6e74 6572  he scipy counter
+00012010: 7061 7274 2069 7320 6073 6369 7079 2e73  part is `scipy.s
+00012020: 7461 7473 2e6d 6178 7765 6c6c 602e 0a0a  tats.maxwell`...
+00012030: 2020 4172 6773 3a0a 2020 2020 6b65 793a    Args:.    key:
+00012040: 2061 2050 524e 4720 6b65 792e 0a20 2020   a PRNG key..   
+00012050: 2073 697a 653a 2054 6865 2073 6861 7065   size: The shape
+00012060: 206f 6620 7468 6520 7265 7475 726e 6564   of the returned
+00012070: 2073 616d 706c 6573 2e0a 2020 2020 6474   samples..    dt
+00012080: 7970 653a 2054 6865 2074 7970 6520 7573  ype: The type us
+00012090: 6564 2066 6f72 2073 616d 706c 6573 2e0a  ed for samples..
+000120a0: 0a20 2052 6574 7572 6e73 3a0a 2020 2020  .  Returns:.    
+000120b0: 4120 6a6e 702e 6172 7261 7920 6f66 2073  A jnp.array of s
+000120c0: 616d 706c 6573 2c20 6f66 2073 6861 7065  amples, of shape
+000120d0: 2060 7368 6170 6560 2e0a 0a20 2022 2222   `shape`...  """
+000120e0: 0a20 2072 6574 7572 6e20 4445 4641 554c  .  return DEFAUL
+000120f0: 542e 6d61 7877 656c 6c28 7369 7a65 2c20  T.maxwell(size, 
+00012100: 6b65 793d 6b65 7929 0a0a 0a64 6566 2074  key=key)...def t
+00012110: 2864 662c 2073 697a 653d 4e6f 6e65 2c20  (df, size=None, 
+00012120: 6b65 793d 4e6f 6e65 293a 0a20 2022 2222  key=None):.  """
+00012130: 5361 6d70 6c65 2053 7475 6465 6e74 e280  Sample Student..
+00012140: 9973 2074 2072 616e 646f 6d20 7661 6c75  .s t random valu
+00012150: 6573 2e0a 0a20 2050 6172 616d 6574 6572  es...  Parameter
+00012160: 730a 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  s.  ----------. 
+00012170: 2064 663a 2066 6c6f 6174 2c20 6172 7261   df: float, arra
+00012180: 795f 6c69 6b65 0a20 2020 2041 2066 6c6f  y_like.    A flo
+00012190: 6174 206f 7220 6172 7261 7920 6f66 2066  at or array of f
+000121a0: 6c6f 6174 7320 6272 6f61 6463 6173 742d  loats broadcast-
+000121b0: 636f 6d70 6174 6962 6c65 2077 6974 6820  compatible with 
+000121c0: 7368 6170 6520 7265 7072 6573 656e 7469  shape representi
+000121d0: 6e67 2074 6865 2070 6172 616d 6574 6572  ng the parameter
+000121e0: 206f 6620 7468 6520 6469 7374 7269 6275   of the distribu
+000121f0: 7469 6f6e 2e0a 2020 7369 7a65 3a20 6f70  tion..  size: op
+00012200: 7469 6f6e 616c 2c20 696e 742c 2074 7570  tional, int, tup
+00012210: 6c65 206f 6620 696e 740a 2020 2020 4120  le of int.    A 
+00012220: 7475 706c 6520 6f66 206e 6f6e 2d6e 6567  tuple of non-neg
+00012230: 6174 6976 6520 696e 7465 6765 7273 2073  ative integers s
+00012240: 7065 6369 6679 696e 6720 7468 6520 7265  pecifying the re
+00012250: 7375 6c74 2073 6861 7065 2e0a 2020 2020  sult shape..    
+00012260: 4d75 7374 2062 6520 6272 6f61 6463 6173  Must be broadcas
+00012270: 742d 636f 6d70 6174 6962 6c65 2077 6974  t-compatible wit
+00012280: 6820 6064 6660 2e20 5468 6520 6465 6661  h `df`. The defa
+00012290: 756c 7420 284e 6f6e 6529 2070 726f 6475  ult (None) produ
+000122a0: 6365 7320 6120 7265 7375 6c74 2073 6861  ces a result sha
+000122b0: 7065 2065 7175 616c 2074 6f20 6064 662e  pe equal to `df.
+000122c0: 7368 6170 6560 2e0a 0a20 2052 6574 7572  shape`...  Retur
+000122d0: 6e73 0a20 202d 2d2d 2d2d 2d2d 0a20 206f  ns.  -------.  o
+000122e0: 7574 3a20 6172 7261 795f 6c69 6b65 0a20  ut: array_like. 
+000122f0: 2020 2054 6865 2073 616d 706c 6564 2076     The sampled v
+00012300: 616c 7565 2e0a 2020 2222 220a 2020 7265  alue..  """.  re
+00012310: 7475 726e 2044 4546 4155 4c54 2e74 2864  turn DEFAULT.t(d
+00012320: 662c 2073 697a 652c 206b 6579 3d6b 6579  f, size, key=key
+00012330: 290a 0a0a 6465 6620 6f72 7468 6f67 6f6e  )...def orthogon
+00012340: 616c 286e 3a20 696e 742c 2073 697a 653d  al(n: int, size=
+00012350: 4e6f 6e65 2c20 6b65 793d 4e6f 6e65 293a  None, key=None):
+00012360: 0a20 2022 2222 5361 6d70 6c65 2075 6e69  .  """Sample uni
+00012370: 666f 726d 6c79 2066 726f 6d20 7468 6520  formly from the 
+00012380: 6f72 7468 6f67 6f6e 616c 2067 726f 7570  orthogonal group
+00012390: 2060 4f28 6e29 602e 0a0a 2020 5061 7261   `O(n)`...  Para
+000123a0: 6d65 7465 7273 0a20 202d 2d2d 2d2d 2d2d  meters.  -------
+000123b0: 2d2d 2d0a 2020 6e3a 2069 6e74 0a20 2020  ---.  n: int.   
+000123c0: 2020 416e 2069 6e74 6567 6572 2069 6e64    An integer ind
+000123d0: 6963 6174 696e 6720 7468 6520 7265 7375  icating the resu
+000123e0: 6c74 696e 6720 6469 6d65 6e73 696f 6e2e  lting dimension.
+000123f0: 0a20 2073 697a 653a 206f 7074 696f 6e61  .  size: optiona
+00012400: 6c2c 2069 6e74 2c20 7475 706c 6520 6f66  l, int, tuple of
+00012410: 2069 6e74 0a20 2020 2054 6865 2062 6174   int.    The bat
+00012420: 6368 2064 696d 656e 7369 6f6e 7320 6f66  ch dimensions of
+00012430: 2074 6865 2072 6573 756c 742e 0a0a 2020   the result...  
+00012440: 5265 7475 726e 730a 2020 2d2d 2d2d 2d2d  Returns.  ------
+00012450: 2d0a 2020 6f75 743a 2041 7272 6179 0a20  -.  out: Array. 
+00012460: 2020 2054 6865 2073 616d 706c 6564 2072     The sampled r
+00012470: 6573 756c 7473 2e0a 2020 2222 220a 2020  esults..  """.  
+00012480: 7265 7475 726e 2044 4546 4155 4c54 2e6f  return DEFAULT.o
+00012490: 7274 686f 676f 6e61 6c28 6e2c 2073 697a  rthogonal(n, siz
+000124a0: 652c 206b 6579 3d6b 6579 290a 0a0a 6465  e, key=key)...de
+000124b0: 6620 6c6f 6767 616d 6d61 2861 2c20 7369  f loggamma(a, si
+000124c0: 7a65 3d4e 6f6e 652c 206b 6579 3d4e 6f6e  ze=None, key=Non
+000124d0: 6529 3a0a 2020 2222 2253 616d 706c 6520  e):.  """Sample 
+000124e0: 6c6f 672d 6761 6d6d 6120 7261 6e64 6f6d  log-gamma random
+000124f0: 2076 616c 7565 732e 0a0a 2020 5061 7261   values...  Para
+00012500: 6d65 7465 7273 0a20 202d 2d2d 2d2d 2d2d  meters.  -------
+00012510: 2d2d 2d0a 2020 613a 2066 6c6f 6174 2c20  ---.  a: float, 
+00012520: 6172 7261 795f 6c69 6b65 0a20 2020 2041  array_like.    A
+00012530: 2066 6c6f 6174 206f 7220 6172 7261 7920   float or array 
+00012540: 6f66 2066 6c6f 6174 7320 6272 6f61 6463  of floats broadc
+00012550: 6173 742d 636f 6d70 6174 6962 6c65 2077  ast-compatible w
+00012560: 6974 6820 7368 6170 6520 7265 7072 6573  ith shape repres
+00012570: 656e 7469 6e67 2074 6865 2070 6172 616d  enting the param
+00012580: 6574 6572 206f 6620 7468 6520 6469 7374  eter of the dist
+00012590: 7269 6275 7469 6f6e 2e0a 2020 7369 7a65  ribution..  size
+000125a0: 3a20 6f70 7469 6f6e 616c 2c20 696e 742c  : optional, int,
+000125b0: 2074 7570 6c65 206f 6620 696e 740a 2020   tuple of int.  
+000125c0: 2020 4120 7475 706c 6520 6f66 206e 6f6e    A tuple of non
+000125d0: 6e65 6761 7469 7665 2069 6e74 6567 6572  negative integer
+000125e0: 7320 7370 6563 6966 7969 6e67 2074 6865  s specifying the
+000125f0: 2072 6573 756c 7420 7368 6170 652e 0a20   result shape.. 
+00012600: 2020 204d 7573 7420 6265 2062 726f 6164     Must be broad
+00012610: 6361 7374 2d63 6f6d 7061 7469 626c 6520  cast-compatible 
+00012620: 7769 7468 2060 6160 2e20 5468 6520 6465  with `a`. The de
+00012630: 6661 756c 7420 284e 6f6e 6529 2070 726f  fault (None) pro
+00012640: 6475 6365 7320 6120 7265 7375 6c74 2073  duces a result s
+00012650: 6861 7065 2065 7175 616c 2074 6f20 6061  hape equal to `a
+00012660: 2e73 6861 7065 602e 0a0a 2020 5265 7475  .shape`...  Retu
+00012670: 726e 730a 2020 2d2d 2d2d 2d2d 2d0a 2020  rns.  -------.  
+00012680: 6f75 743a 2061 7272 6179 5f6c 696b 650a  out: array_like.
+00012690: 2020 2020 5468 6520 7361 6d70 6c65 6420      The sampled 
+000126a0: 7265 7375 6c74 732e 0a20 2022 2222 0a20  results..  """. 
+000126b0: 2072 6574 7572 6e20 4445 4641 554c 542e   return DEFAULT.
+000126c0: 6c6f 6767 616d 6d61 2861 2c20 7369 7a65  loggamma(a, size
+000126d0: 290a 0a0a 6465 6620 6361 7465 676f 7269  )...def categori
+000126e0: 6361 6c28 6c6f 6769 7473 2c20 6178 6973  cal(logits, axis
+000126f0: 3a20 696e 7420 3d20 2d31 2c20 7369 7a65  : int = -1, size
+00012700: 3d4e 6f6e 652c 206b 6579 3d4e 6f6e 6529  =None, key=None)
+00012710: 3a0a 2020 2222 2253 616d 706c 6520 7261  :.  """Sample ra
+00012720: 6e64 6f6d 2076 616c 7565 7320 6672 6f6d  ndom values from
+00012730: 2063 6174 6567 6f72 6963 616c 2064 6973   categorical dis
+00012740: 7472 6962 7574 696f 6e73 2e0a 0a20 2041  tributions...  A
+00012750: 7267 733a 0a20 2020 206c 6f67 6974 733a  rgs:.    logits:
+00012760: 2055 6e6e 6f72 6d61 6c69 7a65 6420 6c6f   Unnormalized lo
+00012770: 6720 7072 6f62 6162 696c 6974 6965 7320  g probabilities 
+00012780: 6f66 2074 6865 2063 6174 6567 6f72 6963  of the categoric
+00012790: 616c 2064 6973 7472 6962 7574 696f 6e28  al distribution(
+000127a0: 7329 2074 6f20 7361 6d70 6c65 2066 726f  s) to sample fro
+000127b0: 6d2c 0a20 2020 2020 2073 6f20 7468 6174  m,.      so that
+000127c0: 2060 736f 6674 6d61 7828 6c6f 6769 7473   `softmax(logits
+000127d0: 2c20 6178 6973 2960 2067 6976 6573 2074  , axis)` gives t
+000127e0: 6865 2063 6f72 7265 7370 6f6e 6469 6e67  he corresponding
+000127f0: 2070 726f 6261 6269 6c69 7469 6573 2e0a   probabilities..
+00012800: 2020 2020 6178 6973 3a20 4178 6973 2061      axis: Axis a
+00012810: 6c6f 6e67 2077 6869 6368 206c 6f67 6974  long which logit
+00012820: 7320 6265 6c6f 6e67 2074 6f20 7468 6520  s belong to the 
+00012830: 7361 6d65 2063 6174 6567 6f72 6963 616c  same categorical
+00012840: 2064 6973 7472 6962 7574 696f 6e2e 0a20   distribution.. 
+00012850: 2020 2073 6861 7065 3a20 4f70 7469 6f6e     shape: Option
+00012860: 616c 2c20 6120 7475 706c 6520 6f66 206e  al, a tuple of n
+00012870: 6f6e 6e65 6761 7469 7665 2069 6e74 6567  onnegative integ
+00012880: 6572 7320 7265 7072 6573 656e 7469 6e67  ers representing
+00012890: 2074 6865 2072 6573 756c 7420 7368 6170   the result shap
+000128a0: 652e 0a20 2020 2020 204d 7573 7420 6265  e..      Must be
+000128b0: 2062 726f 6164 6361 7374 2d63 6f6d 7061   broadcast-compa
+000128c0: 7469 626c 6520 7769 7468 2060 606e 702e  tible with ``np.
+000128d0: 6465 6c65 7465 286c 6f67 6974 732e 7368  delete(logits.sh
+000128e0: 6170 652c 2061 7869 7329 6060 2e0a 2020  ape, axis)``..  
+000128f0: 2020 2020 5468 6520 6465 6661 756c 7420      The default 
+00012900: 284e 6f6e 6529 2070 726f 6475 6365 7320  (None) produces 
+00012910: 6120 7265 7375 6c74 2073 6861 7065 2065  a result shape e
+00012920: 7175 616c 2074 6f20 6060 6e70 2e64 656c  qual to ``np.del
+00012930: 6574 6528 6c6f 6769 7473 2e73 6861 7065  ete(logits.shape
+00012940: 2c20 6178 6973 2960 602e 0a20 2020 206b  , axis)``..    k
+00012950: 6579 3a20 6120 5052 4e47 206b 6579 2075  ey: a PRNG key u
+00012960: 7365 6420 6173 2074 6865 2072 616e 646f  sed as the rando
+00012970: 6d20 6b65 792e 0a0a 2020 5265 7475 726e  m key...  Return
+00012980: 733a 0a20 2020 2041 2072 616e 646f 6d20  s:.    A random 
+00012990: 6172 7261 7920 7769 7468 2069 6e74 2064  array with int d
+000129a0: 7479 7065 2061 6e64 2073 6861 7065 2067  type and shape g
+000129b0: 6976 656e 2062 7920 6060 7368 6170 6560  iven by ``shape`
+000129c0: 6020 6966 2060 6073 6861 7065 6060 0a20  ` if ``shape``. 
+000129d0: 2020 2069 7320 6e6f 7420 4e6f 6e65 2c20     is not None, 
+000129e0: 6f72 2065 6c73 6520 6060 6e70 2e64 656c  or else ``np.del
+000129f0: 6574 6528 6c6f 6769 7473 2e73 6861 7065  ete(logits.shape
+00012a00: 2c20 6178 6973 2960 602e 0a20 2022 2222  , axis)``..  """
+00012a10: 0a20 2072 6574 7572 6e20 4445 4641 554c  .  return DEFAUL
+00012a20: 542e 6361 7465 676f 7269 6361 6c28 6c6f  T.categorical(lo
+00012a30: 6769 7473 2c20 6178 6973 2c20 7369 7a65  gits, axis, size
+00012a40: 2c20 6b65 793d 6b65 7929 0a0a 0a64 6566  , key=key)...def
+00012a50: 2072 616e 645f 6c69 6b65 2869 6e70 7574   rand_like(input
+00012a60: 2c20 2a2c 2064 7479 7065 3d4e 6f6e 652c  , *, dtype=None,
+00012a70: 206b 6579 3d4e 6f6e 6529 3a0a 2020 2222   key=None):.  ""
+00012a80: 2253 696d 696c 6172 2074 6f20 6060 7261  "Similar to ``ra
+00012a90: 6e64 5f6c 696b 6560 6020 696e 2074 6f72  nd_like`` in tor
+00012aa0: 6368 2e20 0a20 200a 2020 5265 7475 726e  ch. .  .  Return
+00012ab0: 7320 6120 7465 6e73 6f72 2077 6974 6820  s a tensor with 
+00012ac0: 7468 6520 7361 6d65 2073 697a 6520 6173  the same size as
+00012ad0: 2069 6e70 7574 2074 6861 7420 6973 2066   input that is f
+00012ae0: 696c 6c65 6420 7769 7468 2072 616e 646f  illed with rando
+00012af0: 6d0a 2020 6e75 6d62 6572 7320 6672 6f6d  m.  numbers from
+00012b00: 2061 2075 6e69 666f 726d 2064 6973 7472   a uniform distr
+00012b10: 6962 7574 696f 6e20 6f6e 2074 6865 2069  ibution on the i
+00012b20: 6e74 6572 7661 6c20 6060 5b30 2c20 3129  nterval ``[0, 1)
+00012b30: 6060 2e0a 0a20 2041 7267 733a 0a20 2020  ``...  Args:.   
+00012b40: 2069 6e70 7574 3a20 2074 6865 2060 6073   input:  the ``s
+00012b50: 697a 6560 6020 6f66 2069 6e70 7574 2077  ize`` of input w
+00012b60: 696c 6c20 6465 7465 726d 696e 6520 7369  ill determine si
+00012b70: 7a65 206f 6620 7468 6520 6f75 7470 7574  ze of the output
+00012b80: 2074 656e 736f 722e 0a20 2020 2064 7479   tensor..    dty
+00012b90: 7065 3a20 2074 6865 2064 6573 6972 6564  pe:  the desired
+00012ba0: 2064 6174 6120 7479 7065 206f 6620 7265   data type of re
+00012bb0: 7475 726e 6564 2054 656e 736f 722e 2044  turned Tensor. D
+00012bc0: 6566 6175 6c74 3a20 6966 2060 604e 6f6e  efault: if ``Non
+00012bd0: 6560 602c 2064 6566 6175 6c74 7320 746f  e``, defaults to
+00012be0: 2074 6865 2064 7479 7065 206f 6620 696e   the dtype of in
+00012bf0: 7075 742e 0a20 2020 206b 6579 3a20 7468  put..    key: th
+00012c00: 6520 7365 6564 206f 7220 6b65 7920 666f  e seed or key fo
+00012c10: 7220 7468 6520 7261 6e64 6f6d 2e0a 0a20  r the random... 
+00012c20: 2052 6574 7572 6e73 3a0a 2020 2020 5468   Returns:.    Th
+00012c30: 6520 7261 6e64 6f6d 2064 6174 612e 0a20  e random data.. 
+00012c40: 2022 2222 0a20 2072 6574 7572 6e20 4445   """.  return DE
+00012c50: 4641 554c 542e 7261 6e64 5f6c 696b 6528  FAULT.rand_like(
+00012c60: 696e 7075 742c 2064 7479 7065 3d64 7479  input, dtype=dty
+00012c70: 7065 2c20 6b65 793d 6b65 7929 0a0a 0a64  pe, key=key)...d
+00012c80: 6566 2072 616e 646e 5f6c 696b 6528 696e  ef randn_like(in
+00012c90: 7075 742c 202a 2c20 6474 7970 653d 4e6f  put, *, dtype=No
+00012ca0: 6e65 2c20 6b65 793d 4e6f 6e65 293a 0a20  ne, key=None):. 
+00012cb0: 2022 2222 5369 6d69 6c61 7220 746f 2060   """Similar to `
+00012cc0: 6072 616e 646e 5f6c 696b 6560 6020 696e  `randn_like`` in
+00012cd0: 2074 6f72 6368 2e20 0a20 200a 2020 5265   torch. .  .  Re
+00012ce0: 7475 726e 7320 6120 7465 6e73 6f72 2077  turns a tensor w
+00012cf0: 6974 6820 7468 6520 7361 6d65 2073 697a  ith the same siz
+00012d00: 6520 6173 2060 6069 6e70 7574 6060 2074  e as ``input`` t
+00012d10: 6861 7420 6973 2066 696c 6c65 6420 7769  hat is filled wi
+00012d20: 7468 0a20 2072 616e 646f 6d20 6e75 6d62  th.  random numb
+00012d30: 6572 7320 6672 6f6d 2061 206e 6f72 6d61  ers from a norma
+00012d40: 6c20 6469 7374 7269 6275 7469 6f6e 2077  l distribution w
+00012d50: 6974 6820 6d65 616e 2030 2061 6e64 2076  ith mean 0 and v
+00012d60: 6172 6961 6e63 6520 312e 0a0a 2020 4172  ariance 1...  Ar
+00012d70: 6773 3a0a 2020 2020 696e 7075 743a 2020  gs:.    input:  
+00012d80: 7468 6520 6060 7369 7a65 6060 206f 6620  the ``size`` of 
+00012d90: 696e 7075 7420 7769 6c6c 2064 6574 6572  input will deter
+00012da0: 6d69 6e65 2073 697a 6520 6f66 2074 6865  mine size of the
+00012db0: 206f 7574 7075 7420 7465 6e73 6f72 2e0a   output tensor..
+00012dc0: 2020 2020 6474 7970 653a 2020 7468 6520      dtype:  the 
+00012dd0: 6465 7369 7265 6420 6461 7461 2074 7970  desired data typ
+00012de0: 6520 6f66 2072 6574 7572 6e65 6420 5465  e of returned Te
+00012df0: 6e73 6f72 2e20 4465 6661 756c 743a 2069  nsor. Default: i
+00012e00: 6620 6060 4e6f 6e65 6060 2c20 6465 6661  f ``None``, defa
+00012e10: 756c 7473 2074 6f20 7468 6520 6474 7970  ults to the dtyp
+00012e20: 6520 6f66 2069 6e70 7574 2e0a 2020 2020  e of input..    
+00012e30: 6b65 793a 2074 6865 2073 6565 6420 6f72  key: the seed or
+00012e40: 206b 6579 2066 6f72 2074 6865 2072 616e   key for the ran
+00012e50: 646f 6d2e 0a0a 2020 5265 7475 726e 733a  dom...  Returns:
+00012e60: 0a20 2020 2054 6865 2072 616e 646f 6d20  .    The random 
+00012e70: 6461 7461 2e0a 2020 2222 220a 2020 7265  data..  """.  re
+00012e80: 7475 726e 2044 4546 4155 4c54 2e72 616e  turn DEFAULT.ran
+00012e90: 646e 5f6c 696b 6528 696e 7075 742c 2064  dn_like(input, d
+00012ea0: 7479 7065 3d64 7479 7065 2c20 6b65 793d  type=dtype, key=
+00012eb0: 6b65 7929 0a0a 0a64 6566 2072 616e 6469  key)...def randi
+00012ec0: 6e74 5f6c 696b 6528 696e 7075 742c 206c  nt_like(input, l
+00012ed0: 6f77 3d30 2c20 6869 6768 3d4e 6f6e 652c  ow=0, high=None,
+00012ee0: 202a 2c20 6474 7970 653d 4e6f 6e65 2c20   *, dtype=None, 
+00012ef0: 6b65 793d 4e6f 6e65 293a 0a20 2022 2222  key=None):.  """
+00012f00: 5369 6d69 6c61 7220 746f 2060 6072 616e  Similar to ``ran
+00012f10: 6469 6e74 5f6c 696b 6560 6020 696e 2074  dint_like`` in t
+00012f20: 6f72 6368 2e20 0a20 200a 2020 5265 7475  orch. .  .  Retu
+00012f30: 726e 7320 6120 7465 6e73 6f72 2077 6974  rns a tensor wit
+00012f40: 6820 7468 6520 7361 6d65 2073 6861 7065  h the same shape
+00012f50: 2061 7320 5465 6e73 6f72 2060 6069 6e70   as Tensor ``inp
+00012f60: 7574 6060 2066 696c 6c65 6420 7769 7468  ut`` filled with
+00012f70: 0a20 2072 616e 646f 6d20 696e 7465 6765  .  random intege
+00012f80: 7273 2067 656e 6572 6174 6564 2075 6e69  rs generated uni
+00012f90: 666f 726d 6c79 2062 6574 7765 656e 2060  formly between `
+00012fa0: 606c 6f77 6060 2028 696e 636c 7573 6976  `low`` (inclusiv
+00012fb0: 6529 2061 6e64 2060 6068 6967 6860 6020  e) and ``high`` 
+00012fc0: 2865 7863 6c75 7369 7665 292e 0a0a 2020  (exclusive)...  
+00012fd0: 4172 6773 3a0a 2020 2020 696e 7075 743a  Args:.    input:
+00012fe0: 2020 7468 6520 6060 7369 7a65 6060 206f    the ``size`` o
+00012ff0: 6620 696e 7075 7420 7769 6c6c 2064 6574  f input will det
+00013000: 6572 6d69 6e65 2073 697a 6520 6f66 2074  ermine size of t
+00013010: 6865 206f 7574 7075 7420 7465 6e73 6f72  he output tensor
+00013020: 2e0a 2020 2020 6c6f 773a 204c 6f77 6573  ..    low: Lowes
+00013030: 7420 696e 7465 6765 7220 746f 2062 6520  t integer to be 
+00013040: 6472 6177 6e20 6672 6f6d 2074 6865 2064  drawn from the d
+00013050: 6973 7472 6962 7574 696f 6e2e 2044 6566  istribution. Def
+00013060: 6175 6c74 3a20 302e 0a20 2020 2068 6967  ault: 0..    hig
+00013070: 683a 204f 6e65 2061 626f 7665 2074 6865  h: One above the
+00013080: 2068 6967 6865 7374 2069 6e74 6567 6572   highest integer
+00013090: 2074 6f20 6265 2064 7261 776e 2066 726f   to be drawn fro
+000130a0: 6d20 7468 6520 6469 7374 7269 6275 7469  m the distributi
+000130b0: 6f6e 2e0a 2020 2020 6474 7970 653a 2074  on..    dtype: t
+000130c0: 6865 2064 6573 6972 6564 2064 6174 6120  he desired data 
+000130d0: 7479 7065 206f 6620 7265 7475 726e 6564  type of returned
+000130e0: 2054 656e 736f 722e 2044 6566 6175 6c74   Tensor. Default
+000130f0: 3a20 6966 2060 604e 6f6e 6560 602c 2064  : if ``None``, d
+00013100: 6566 6175 6c74 7320 746f 2074 6865 2064  efaults to the d
+00013110: 7479 7065 206f 6620 696e 7075 742e 0a20  type of input.. 
+00013120: 2020 206b 6579 3a20 7468 6520 7365 6564     key: the seed
+00013130: 206f 7220 6b65 7920 666f 7220 7468 6520   or key for the 
+00013140: 7261 6e64 6f6d 2e0a 0a20 2052 6574 7572  random...  Retur
+00013150: 6e73 3a0a 2020 2020 5468 6520 7261 6e64  ns:.    The rand
+00013160: 6f6d 2064 6174 612e 0a20 2022 2222 0a20  om data..  """. 
+00013170: 2072 6574 7572 6e20 4445 4641 554c 542e   return DEFAULT.
+00013180: 7261 6e64 696e 745f 6c69 6b65 2869 6e70  randint_like(inp
+00013190: 7574 3d69 6e70 7574 2c20 6c6f 773d 6c6f  ut=input, low=lo
+000131a0: 772c 2068 6967 683d 6869 6768 2c20 6474  w, high=high, dt
+000131b0: 7970 653d 6474 7970 652c 206b 6579 3d6b  ype=dtype, key=k
+000131c0: 6579 290a 0a0a 666f 7220 5f5f 6b20 696e  ey)...for __k in
+000131d0: 2064 6972 2852 616e 646f 6d53 7461 7465   dir(RandomState
+000131e0: 293a 0a20 205f 5f74 203d 2067 6574 6174  ):.  __t = getat
+000131f0: 7472 2852 616e 646f 6d53 7461 7465 2c20  tr(RandomState, 
+00013200: 5f5f 6b29 0a20 2069 6620 6e6f 7420 5f5f  __k).  if not __
+00013210: 6b2e 7374 6172 7473 7769 7468 2827 5f5f  k.startswith('__
+00013220: 2729 2061 6e64 2063 616c 6c61 626c 6528  ') and callable(
+00013230: 5f5f 7429 2061 6e64 2028 6e6f 7420 5f5f  __t) and (not __
+00013240: 742e 5f5f 646f 635f 5f29 3a0a 2020 2020  t.__doc__):.    
+00013250: 5f5f 7220 3d20 676c 6f62 616c 7328 292e  __r = globals().
+00013260: 6765 7428 5f5f 6b2c 204e 6f6e 6529 0a20  get(__k, None). 
+00013270: 2020 2069 6620 5f5f 7220 6973 206e 6f74     if __r is not
+00013280: 204e 6f6e 6520 616e 6420 6361 6c6c 6162   None and callab
+00013290: 6c65 285f 5f72 293a 0a20 2020 2020 205f  le(__r):.      _
+000132a0: 5f74 2e5f 5f64 6f63 5f5f 203d 205f 5f72  _t.__doc__ = __r
+000132b0: 2e5f 5f64 6f63 5f5f 0a                   .__doc__.
```

## brainpy/_src/math/object_transform/__init__.py

```diff
@@ -11,31 +11,19 @@
   users can initialize a ``FunAsObject`` by providing the nodes used
   in the function. Unfortunately, ``FunAsObject`` class does not have
   the ability to gather nodes automatically.
 
 Details please see the following.
 """
 
-from . import (
-  base,
-  abstract,
-  autograd,
-  controls,
-  jit,
-  function,
-)
-
-__all__ = (
-    autograd.__all__
-    + controls.__all__
-    + jit.__all__
-    + function.__all__
-    + base.__all__
-    + abstract.__all__
-)
+from .base import *
+
+from .variables import *
+from .collectors import *
 
 from .autograd import *
 from .controls import *
 from .jit import *
 from .function import *
-from .base import *
-from .abstract import *
+from .naming import *
+
+
```

## brainpy/_src/math/object_transform/_utils.py

```diff
@@ -1,25 +1,25 @@
 # -*- coding: utf-8 -*-
 
 from typing import Dict
-from .base import BrainPyObject, DynVarCollector
+from .base import BrainPyObject, ArrayCollector
 
 __all__ = [
   'infer_dyn_vars',
   'get_brainpy_object',
 ]
 
 
 def infer_dyn_vars(target):
   if isinstance(target, BrainPyObject):
     dyn_vars = target.vars().unique()
   elif hasattr(target, '__self__') and isinstance(target.__self__, BrainPyObject):
     dyn_vars = target.__self__.vars().unique()
   else:
-    dyn_vars = DynVarCollector()
+    dyn_vars = ArrayCollector()
   return dyn_vars
 
 
 def get_brainpy_object(target) -> Dict[str, BrainPyObject]:
   if isinstance(target, BrainPyObject):
     return {target.name: target}
   elif hasattr(target, '__self__') and isinstance(target.__self__, BrainPyObject):
```

## brainpy/_src/math/object_transform/autograd.py

```diff
@@ -5,25 +5,27 @@
 from typing import Union, Callable, Dict, Sequence, Any, Optional
 
 import jax
 import numpy as np
 from jax import linear_util, dtypes, vmap, numpy as jnp, core
 from jax._src.api import (_vjp, _jvp)
 from jax.api_util import argnums_partial
-from jax.errors import UnexpectedTracerError
 from jax.interpreters import xla
 from jax.tree_util import (tree_flatten, tree_unflatten,
                            tree_map, tree_transpose,
                            tree_structure)
 from jax.util import safe_map
 
-from brainpy import errors, tools, check
-from brainpy._src.math.ndarray import Array, Variable, add_context, del_context
-from brainpy._src.math.object_transform.abstract import ObjectTransform
-from brainpy._src.math.object_transform.base import BrainPyObject
+from brainpy import tools, check
+from brainpy._src.math.ndarray import Array
+from .variables import Variable
+from .base import BrainPyObject, ObjectTransform
+from ._tools import (dynvar_deprecation,
+                     node_deprecation,
+                     evaluate_dyn_vars)
 
 __all__ = [
   'grad',  # gradient of scalar function
   'vector_grad',  # gradient of vector/matrix/...
   'jacobian', 'jacrev', 'jacfwd',  # gradient of jacobian
   'hessian',  # gradient of hessian
 ]
@@ -71,127 +73,138 @@
       _argnums = (0, argnums + 2) if len(self._grad_vars) > 0 else (argnums + 2)
     else:
       _argnums = check.is_sequence(argnums, elem_type=int, allow_none=False)
       _argnums = tuple(a + 2 for a in _argnums)
       if len(self._grad_vars) > 0:
         _argnums = (0,) + _argnums
     self._nonvar_argnums = argnums
-    self.return_value = return_value
-    self.has_aux = has_aux
+    self._argnums = _argnums
+    self._return_value = return_value
+    self._has_aux = has_aux
 
-    # target and transform
+    # target
     self.target = target
-    self.transform = transform
-    self._dyn_vars = tuple((self.vars().unique() - self._grad_vars).values())
 
-    # settings
-    transform_setting = dict() if transform_setting is None else transform_setting
-    if self.has_aux:
-      self._call = transform(self._f_grad_with_aux_to_transform,
-                             argnums=_argnums,
-                             has_aux=True,
-                             **transform_setting)
-    else:
-      self._call = transform(self._f_grad_without_aux_to_transform,
-                             argnums=_argnums,
-                             has_aux=True,
-                             **transform_setting)
-
-  def _f_grad_with_aux_to_transform(self, grad_values, dyn_values, *args, **kwargs):
-    for v, d in zip(self._dyn_vars, dyn_values): v._value = d
-    for v, d in zip(self._grad_vars, grad_values): v._value = d
+    # transform
+    self._grad_transform = transform
+    self._dyn_vars = None
+    self._transform = None
+    self._grad_setting = dict() if transform_setting is None else transform_setting
+
+  def _f_grad_with_aux_to_transform(self,
+                                    grad_values: tuple,
+                                    dyn_values: dict,
+                                    *args,
+                                    **kwargs):
+    for k in self._dyn_vars.keys():
+      self._dyn_vars[k]._value = dyn_values[k]
+    for v, d in zip(self._grad_vars, grad_values):
+      v._value = d
     # Users should return the auxiliary data like::
     # >>> # 1. example of return one data
     # >>> return scalar_loss, data
     # >>> # 2. example of return multiple data
     # >>> return scalar_loss, (data1, data2, ...)
     outputs = self.target(*args, **kwargs)
     # outputs: [0] is the value for gradient,
     #          [1] is other values for return
     output0 = tree_map(lambda a: (a.value if isinstance(a, Array) else a), outputs[0])
-    return output0, (outputs, [v.value for v in self._grad_vars], [v.value for v in self._dyn_vars])
+    return output0, (outputs, [v.value for v in self._grad_vars], self._dyn_vars.dict_data())
 
-  def _f_grad_without_aux_to_transform(self, grad_values, dyn_values, *args, **kwargs):
-    for v, d in zip(self._dyn_vars, dyn_values): v._value = d
-    for v, d in zip(self._grad_vars, grad_values): v._value = d
+  def _f_grad_without_aux_to_transform(self,
+                                       grad_values: tuple,
+                                       dyn_values: dict,
+                                       *args,
+                                       **kwargs):
+    for k in self._dyn_vars.keys():
+      self._dyn_vars[k]._value = dyn_values[k]
+    for v, d in zip(self._grad_vars, grad_values):
+      v._value = d
     # Users should return the scalar value like this::
     # >>> return scalar_loss
     output = self.target(*args, **kwargs)
     output0 = tree_map(lambda a: (a.value if isinstance(a, Array) else a), output)
-    return output0, (output, [v.value for v in self._grad_vars], [v.value for v in self._dyn_vars])
+    return output0, (output, [v.value for v in self._grad_vars], self._dyn_vars.dict_data())
 
   def __repr__(self):
     name = self.__class__.__name__
     f = tools.repr_object(self.target)
     f = tools.repr_context(f, " " * (len(name) + 6))
     format_ref = (f'{name}(target={f}, \n' +
                   f'{" " * len(name)} num_of_grad_vars={len(self._grad_vars)}, \n'
                   f'{" " * len(name)} num_of_dyn_vars={len(self._dyn_vars)})')
     return format_ref
 
   def __call__(self, *args, **kwargs):
-    # old_grad_vs = [v.value for v in self._grad_vars]
-    # old_dyn_vs = [v.value for v in self._dyn_vars]
-    try:
-      add_context(self.name)
-      grads, (outputs, new_grad_vs, new_dyn_vs) = self._call(
-        [v.value for v in self._grad_vars],
-        [v.value for v in self._dyn_vars],
-        *args,
-        **kwargs
-      )
-      del_context(self._name)
-    except UnexpectedTracerError as e:
-      del_context(self._name)
-      # for v, d in zip(self._grad_vars, old_grad_vs): v._value = d
-      # for v, d in zip(self._dyn_vars, old_dyn_vs): v._value = d
-      raise errors.JaxTracerError() from e
-    except Exception as e:
-      del_context(self._name)
-      # for v, d in zip(self._grad_vars, old_grad_vs): v._value = d
-      # for v, d in zip(self._dyn_vars, old_dyn_vs): v._value = d
-      raise e
-    else:
-      for v, d in zip(self._grad_vars, new_grad_vs): v._value = d
-      for v, d in zip(self._dyn_vars, new_dyn_vs): v._value = d
+    if self._transform is None:
+      self._dyn_vars = evaluate_dyn_vars(self.target, *args, **kwargs)
+      self._dyn_vars.remove_var_by_id(*[id(v) for v in self._grad_vars])
+      if self._has_aux:
+        self._transform = self._grad_transform(
+          self._f_grad_with_aux_to_transform,
+          argnums=self._argnums,
+          has_aux=True,
+          **self._grad_setting
+        )
+      else:
+        self._transform = self._grad_transform(
+          self._f_grad_without_aux_to_transform,
+          argnums=self._argnums,
+          has_aux=True,
+          **self._grad_setting
+        )
+
+    grads, (outputs, new_grad_vs, new_dyn_vs) = self._transform(
+      [v.value for v in self._grad_vars],  # gradient variables
+      self._dyn_vars.dict_data(),  # dynamical variables
+      *args,
+      **kwargs
+    )
+    for v, d in zip(self._grad_vars, new_grad_vs):
+      v._value = d
+    for k in self._dyn_vars.keys():
+      self._dyn_vars[k]._value = new_dyn_vs[k]
 
     # check returned grads
     if len(self._grad_vars) > 0:
       if self._nonvar_argnums is None:
         grads = self._grad_tree.unflatten(grads)
       else:
         var_grads = self._grad_tree.unflatten(grads[0])
         arg_grads = grads[1] if isinstance(self._nonvar_argnums, int) else grads[1:]
         grads = (var_grads, arg_grads)
 
     # check returned value
-    if self.return_value:
+    if self._return_value:
       # check aux
-      if self.has_aux:
+      if self._has_aux:
         return grads, outputs[0], outputs[1]
       else:
         return grads, outputs
     else:
       # check aux
-      if self.has_aux:
+      if self._has_aux:
         return grads, outputs[1]
       else:
         return grads
 
 
-def _make_grad(func: Callable,
-               grad_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-               dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-               child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
-               argnums: Optional[Union[int, Sequence[int]]] = None,
-               holomorphic: Optional[bool] = False,
-               allow_int: Optional[bool] = False,
-               reduce_axes: Optional[Sequence[str]] = (),
-               has_aux: Optional[bool] = None,
-               return_value: Optional[bool] = False, ):
+def _make_grad(
+    func: Callable,
+    grad_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
+    argnums: Optional[Union[int, Sequence[int]]] = None,
+    holomorphic: Optional[bool] = False,
+    allow_int: Optional[bool] = False,
+    reduce_axes: Optional[Sequence[str]] = (),
+    has_aux: Optional[bool] = None,
+    return_value: Optional[bool] = False,
+    # deprecated
+    dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
+    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
+):
   child_objs = check.is_all_objs(child_objs, out_as='dict')
   dyn_vars = check.is_all_vars(dyn_vars, out_as='dict')
 
   return GradientTransform(target=func,
                            transform=jax.grad,
                            grad_vars=grad_vars,
                            dyn_vars=dyn_vars,
@@ -203,22 +216,24 @@
                                                   allow_int=allow_int,
                                                   reduce_axes=reduce_axes))
 
 
 def grad(
     func: Callable = None,
     grad_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-    dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
     argnums: Optional[Union[int, Sequence[int]]] = None,
     holomorphic: Optional[bool] = False,
     allow_int: Optional[bool] = False,
     reduce_axes: Optional[Sequence[str]] = (),
     has_aux: Optional[bool] = None,
     return_value: Optional[bool] = False,
+
+    # deprecated
+    dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
+    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
 ) -> GradientTransform:
   """Automatic gradient computation for functions or class objects.
 
   This gradient function only support scalar return. It creates a function
   which evaluates the gradient of ``func``.
 
   It's worthy to note that the returns are different for different argument settings (where ``arg_grads`` refers
@@ -292,19 +307,14 @@
   ----------
   func : callable, function, BrainPyObject
     Function to be differentiated. Its arguments at positions specified by
     ``argnums`` should be arrays, scalars, or standard Python containers.
     Argument arrays in the positions specified by ``argnums`` must be of
     inexact (i.e., floating-point or complex) type. It should return a scalar
     (which includes arrays with shape ``()`` but not arrays with shape ``(1,)`` etc.)
-  dyn_vars : optional, ArrayType, sequence of ArrayType, dict
-    The dynamically changed variables used in ``func``.
-  child_objs: optional, BrainPyObject, sequnce, dict
-
-    .. versionadded:: 2.3.1
   grad_vars : optional, ArrayType, sequence of ArrayType, dict
     The variables in ``func`` to take their gradients.
   argnums : optional, integer or sequence of integers
     Specifies which positional argument(s) to differentiate with respect to (default 0).
   has_aux: optional, bool
     Indicates whether ``fun`` returns a pair where the
     first element is considered the output of the mathematical function to be
@@ -322,25 +332,41 @@
     tuple of axis names. If an axis is listed here, and
     ``fun`` implicitly broadcasts a value over that axis, the backward pass
     will perform a ``psum`` of the corresponding gradient. Otherwise, the
     gradient will be per-example over named axes. For example, if ``'batch'``
     is a named batch axis, ``grad(f, reduce_axes=('batch',))`` will create a
     function that computes the total gradient while ``grad(f)`` will create
     one that computes the per-example gradient.
+  dyn_vars : optional, ArrayType, sequence of ArrayType, dict
+    The dynamically changed variables used in ``func``.
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``dyn_vars``. This function is capable of automatically
+       collecting the dynamical variables used in the target ``func``.
+  child_objs: optional, BrainPyObject, sequnce, dict
+
+    .. versionadded:: 2.3.1
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``child_objs``. This function is capable of automatically
+       collecting the children objects used in the target ``func``.
 
   Returns
   -------
   func : GradientTransform
     A function with the same arguments as ``fun``, that evaluates the gradient
     of ``fun``. If ``argnums`` is an integer then the gradient has the same
     shape and type as the positional argument indicated by that integer. If
     argnums is a tuple of integers, the gradient is a tuple of values with the
     same shapes and types as the corresponding arguments. If ``has_aux`` is True
     then a pair of (gradient, auxiliary_data) is returned.
   """
+  dynvar_deprecation(dyn_vars)
+  node_deprecation(child_objs)
+
   if func is None:
     return lambda f: _make_grad(f,
                                 grad_vars=grad_vars,
                                 dyn_vars=dyn_vars,
                                 child_objs=child_objs,
                                 argnums=argnums,
                                 holomorphic=holomorphic,
@@ -406,21 +432,23 @@
 
   return jacfun
 
 
 def jacrev(
     func: Callable,
     grad_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-    dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
     argnums: Optional[Union[int, Sequence[int]]] = None,
     has_aux: Optional[bool] = None,
     return_value: bool = False,
     holomorphic: bool = False,
     allow_int: bool = False,
+
+    # deprecated
+    dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
+    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
 ) -> ObjectTransform:
   """Extending automatic Jacobian (reverse-mode) of ``func`` to classes.
 
   This function extends the JAX official ``jacrev`` to make automatic jacobian
   computation on functions and class functions. Moreover, it supports returning
   value ("return_value") and returning auxiliary data ("has_aux").
 
@@ -443,21 +471,16 @@
     - "has_aux=False" + "return_value=True" => ``((var_grads, arg_grads), loss_value)``.
     - "has_aux=True" + "return_value=True" => ``((var_grads, arg_grads), loss_value, aux_data)``.
 
 
   Parameters
   ----------
   func: Function whose Jacobian is to be computed.
-  dyn_vars : optional, ArrayType, sequence of ArrayType, dict
-    The dynamically changed variables used in ``func``.
   grad_vars : optional, ArrayType, sequence of ArrayType, dict
     The variables in ``func`` to take their gradients.
-  child_objs: optional, BrainPyObject, sequence, dict
-
-    .. versionadded:: 2.3.1
   has_aux: optional, bool
     Indicates whether ``fun`` returns a pair where the
     first element is considered the output of the mathematical function to be
     differentiated and the second element is auxiliary data. Default False.
   return_value : bool
     Whether return the loss value.
   argnums: Optional, integer or sequence of integers.
@@ -466,14 +489,27 @@
   holomorphic: Optional, bool.
     Indicates whether ``fun`` is promised to be
     holomorphic. Default False.
   allow_int: Optional, bool.
     Whether to allow differentiating with
     respect to integer valued inputs. The gradient of an integer input will
     have a trivial vector-space dtype (float0). Default False.
+  dyn_vars : optional, ArrayType, sequence of ArrayType, dict
+    The dynamically changed variables used in ``func``.
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``dyn_vars``. This function is capable of automatically
+       collecting the dynamical variables used in the target ``func``.
+  child_objs: optional, BrainPyObject, sequnce, dict
+
+    .. versionadded:: 2.3.1
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``child_objs``. This function is capable of automatically
+       collecting the children objects used in the target ``func``.
 
   Returns
   -------
   fun: GradientTransform
     The transformed object.
   """
   child_objs = check.is_all_objs(child_objs, out_as='dict')
@@ -521,20 +557,22 @@
 
   return jacfun
 
 
 def jacfwd(
     func: Callable,
     grad_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-    dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
     argnums: Optional[Union[int, Sequence[int]]] = None,
     has_aux: Optional[bool] = None,
     return_value: bool = False,
     holomorphic: bool = False,
+
+    # deprecated
+    dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
+    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
 ) -> ObjectTransform:
   """Extending automatic Jacobian (forward-mode) of ``func`` to classes.
 
   This function extends the JAX official ``jacfwd`` to make automatic jacobian
   computation on functions and class functions. Moreover, it supports returning
   value ("return_value") and returning auxiliary data ("has_aux").
 
@@ -556,31 +594,39 @@
     - "has_aux=True" + "return_value=False" => ``((var_grads, arg_grads), aux_data)``.
     - "has_aux=False" + "return_value=True" => ``((var_grads, arg_grads), loss_value)``.
     - "has_aux=True" + "return_value=True" => ``((var_grads, arg_grads), loss_value, aux_data)``.
 
   Parameters
   ----------
   func: Function whose Jacobian is to be computed.
-  dyn_vars : optional, ArrayType, sequence of ArrayType, dict
-    The dynamically changed variables used in ``func``.
   grad_vars : optional, ArrayType, sequence of ArrayType, dict
     The variables in ``func`` to take their gradients.
-  child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
-
-    .. versionadded:: 2.3.1
   has_aux: optional, bool
     Indicates whether ``fun`` returns a pair where the
     first element is considered the output of the mathematical function to be
     differentiated and the second element is auxiliary data. Default False.
   return_value : bool
     Whether return the loss value.
   argnums: Optional, integer or sequence of integers. Specifies which
     positional argument(s) to differentiate with respect to (default ``0``).
   holomorphic: Optional, bool. Indicates whether ``fun`` is promised to be
     holomorphic. Default False.
+  dyn_vars : optional, ArrayType, sequence of ArrayType, dict
+    The dynamically changed variables used in ``func``.
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``dyn_vars``. This function is capable of automatically
+       collecting the dynamical variables used in the target ``func``.
+  child_objs: optional, BrainPyObject, sequnce, dict
+
+    .. versionadded:: 2.3.1
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``child_objs``. This function is capable of automatically
+       collecting the children objects used in the target ``func``.
 
   Returns
   -------
   obj: GradientTransform
     The transformed object.
   """
   child_objs = check.is_all_objs(child_objs, out_as='dict')
@@ -596,42 +642,52 @@
                            has_aux=False if has_aux is None else has_aux,
                            transform_setting=dict(holomorphic=holomorphic))
 
 
 def hessian(
     func: Callable,
     grad_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-    dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
     argnums: Optional[Union[int, Sequence[int]]] = None,
     return_value: bool = False,
     holomorphic=False,
+
+    # deprecated
+    dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
+    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
 ) -> ObjectTransform:
   """Hessian of ``func`` as a dense array.
 
   Parameters
   ----------
   func : callable, function
     Function whose Hessian is to be computed.  Its arguments at positions
     specified by ``argnums`` should be arrays, scalars, or standard Python
     containers thereof. It should return arrays, scalars, or standard Python
     containers thereof.
-  dyn_vars : optional, ArrayCollector, sequence of ArrayType
-    The dynamical changed variables.
-  child_objs: optional, BrainPyObject, sequnce, dict
-
-    .. versionadded:: 2.3.1
   grad_vars : optional, ArrayCollector, sequence of ArrayType
     The variables required to compute their gradients.
   argnums: Optional, integer or sequence of integers
     Specifies which positional argument(s) to differentiate with respect to (default ``0``).
   holomorphic : bool
     Indicates whether ``fun`` is promised to be holomorphic. Default False.
   return_value : bool
     Whether return the hessian values.
+  dyn_vars : optional, ArrayType, sequence of ArrayType, dict
+    The dynamically changed variables used in ``func``.
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``dyn_vars``. This function is capable of automatically
+       collecting the dynamical variables used in the target ``func``.
+  child_objs: optional, BrainPyObject, sequnce, dict
+
+    .. versionadded:: 2.3.1
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``child_objs``. This function is capable of automatically
+       collecting the children objects used in the target ``func``.
 
   Returns
   -------
   obj: ObjectTransform
     The transformed object.
   """
   child_objs = check.is_all_objs(child_objs, out_as='dict')
@@ -674,19 +730,21 @@
 
   return grad_fun
 
 
 def vector_grad(
     func: Callable,
     grad_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-    dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
     argnums: Optional[Union[int, Sequence[int]]] = None,
     return_value: bool = False,
     has_aux: Optional[bool] = None,
+
+    # deprecated
+    dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
+    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
 ) -> ObjectTransform:
   """Take vector-valued gradients for function ``func``.
 
   Same as `brainpy.math.grad <./brainpy.math.autograd.grad.html>`_,
   `brainpy.math.jacrev <./brainpy.math.autograd.jacrev.html>`_ and
   `brainpy.math.jacfwd <./brainpy.math.autograd.jacfwd.html>`_,
   the returns in this function are different for different argument settings.
@@ -708,29 +766,37 @@
     - "has_aux=True" + "return_value=True" => ``((var_grads, arg_grads), loss_value, aux_data)``.
 
 
   Parameters
   ----------
   func: Callable
     Function whose gradient is to be computed.
-  dyn_vars : optional, ArrayType, sequence of ArrayType, dict
-    The dynamically changed variables used in ``func``.
-  child_objs: optional, BrainPyObject, sequnce, dict
-
-    .. versionadded:: 2.3.1
   grad_vars : optional, ArrayType, sequence of ArrayType, dict
     The variables in ``func`` to take their gradients.
   has_aux: optional, bool
     Indicates whether ``fun`` returns a pair where the
     first element is considered the output of the mathematical function to be
     differentiated and the second element is auxiliary data. Default False.
   return_value : bool
     Whether return the loss value.
   argnums: Optional, integer or sequence of integers. Specifies which
     positional argument(s) to differentiate with respect to (default ``0``).
+  dyn_vars : optional, ArrayType, sequence of ArrayType, dict
+    The dynamically changed variables used in ``func``.
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``dyn_vars``. This function is capable of automatically
+       collecting the dynamical variables used in the target ``func``.
+  child_objs: optional, BrainPyObject, sequnce, dict
+
+    .. versionadded:: 2.3.1
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``child_objs``. This function is capable of automatically
+       collecting the children objects used in the target ``func``.
 
   Returns
   -------
   func : GradientTransform
     The vector gradient function.
   """
   child_objs = check.is_all_objs(child_objs, out_as='dict')
```

## brainpy/_src/math/object_transform/base.py

```diff
@@ -9,73 +9,95 @@
 import os
 import warnings
 from collections import namedtuple
 from typing import Any, Tuple, Callable, Sequence, Dict, Union, Optional
 
 import jax
 import numpy as np
-from jax._src.tree_util import _registry
-from jax.tree_util import register_pytree_node
-from jax.tree_util import register_pytree_node_class
-from jax.util import safe_zip
 
 from brainpy import errors
-from brainpy._src.math.ndarray import (Array, Variable, VariableView, TrainVar)
-from brainpy._src.tools.naming import (get_unique_name, check_name_uniqueness)
+from brainpy._src.math.ndarray import (Array, )
+from brainpy._src.math.object_transform.collectors import (ArrayCollector, Collector)
+from brainpy._src.math.object_transform.naming import (get_unique_name,
+                                                       check_name_uniqueness)
+from brainpy._src.math.object_transform.variables import (Variable, VariableView, TrainVar,
+                                                          VarList, VarDict)
 
 StateLoadResult = namedtuple('StateLoadResult', ['missing_keys', 'unexpected_keys'])
 
 __all__ = [
-  # objects
-  'BrainPyObject', 'Base', 'FunAsObject',
+  'BrainPyObject', 'Base', 'FunAsObject', 'ObjectTransform',
 
-  # dynamical containers
-  'NodeList', 'NodeDict', 'ListVar', 'DictVar',
-  'Collector', 'DynVarCollector', 'TensorCollector', 'ArrayCollector',
+  'NodeDict', 'NodeList',
 ]
 
-_register_pytree = True
-
-
-def register_object_as_pytree(mode: bool):
-  global _register_pytree
-  _register_pytree = mode
-
 
 class BrainPyObject(object):
-  """The BrainPyObject class for whole BrainPy ecosystem.
+  """The BrainPyObject class for the whole BrainPy ecosystem.
 
-  The subclass of BrainPyObject includes:
+  The subclass of BrainPyObject includes but not limited to:
 
   - ``DynamicalSystem`` in *brainpy.dyn.base.py*
   - ``Integrator`` in *brainpy.integrators.base.py*
-  - ``FunAsObject`` in *brainpy.brainpy_object.function.py*
   - ``Optimizer`` in *brainpy.optimizers.py*
   - ``Scheduler`` in *brainpy.optimizers.py*
-  - and others.
+
+  .. note::
+    Note a variable created in the ``BrainPyObject`` will never be replaced.
+
+    For example, if here we create an object which has an attribute ``a``:
+
+    >>> import brainpy as bp
+    >>> import brainpy.math as bm
+    >>>
+    >>> class MyObj(bp.BrainPyObject):
+    >>>   def __init__(self):
+    >>>     super().__init__()
+    >>>     self.a = bm.Variable(bm.ones(1))
+    >>>
+    >>>   def reset1(self):
+    >>>     self.a = bm.asarray([10.])
+    >>>
+    >>>   def reset2(self):
+    >>>     self.a = 1.
+    >>>
+    >>> ob = MyObj()
+    >>> id(ob.a)
+    2643434845056
+
+    After we call ``ob.reset1()`` function, ``ob.a`` is still the original Variable.
+    what's change is its value.
+
+    >>> ob.reset1()
+    >>> id(ob.a)
+    2643434845056
+
+    What's really happend when we call ``self.a = bm.asarray([10.])`` is
+    ``self.a.value = bm.asarray([10.])``.  Therefore we when call ``ob.reset2()``,
+    there will be an error.
+
+    >>> ob.reset2()
+    brainpy.errors.MathError: The shape of the original data is (1,), while we got () with batch_axis=None.
+
+
   """
 
   _excluded_vars = ()
 
   def __init__(self, name=None):
     super().__init__()
 
-    if _register_pytree:
-      cls = self.__class__
-      if cls not in _registry:
-        register_pytree_node_class(cls)
-
     # check whether the object has a unique name.
     self._name = None
     self._name = self.unique_name(name=name)
     check_name_uniqueness(name=self._name, obj=self)
 
     # Used to wrap the implicit variables
     # which cannot be accessed by self.xxx
-    self.implicit_vars: DynVarCollector = DynVarCollector()
+    self.implicit_vars: ArrayCollector = ArrayCollector()
 
     # Used to wrap the implicit children nodes
     # which cannot be accessed by self.xxx
     self.implicit_nodes: Collector = Collector()
 
   def __setattr__(self, key: str, value: Any) -> None:
     """Overwrite `__setattr__` method for change Variable values.
@@ -109,15 +131,16 @@
       A tuple of dynamical values and static values.
     """
     dynamic_names = []
     dynamic_values = []
     static_names = []
     static_values = []
     for k, v in self.__dict__.items():
-      if isinstance(v, (BrainPyObject, Variable, NodeList, NodeDict, ListVar, DictVar)):
+      # if isinstance(v, (BrainPyObject, Variable, NodeList, NodeDict, VarList, VarDict)):
+      if isinstance(v, (BrainPyObject, Variable)):
         dynamic_names.append(k)
         dynamic_values.append(v)
       else:
         static_values.append(v)
         static_names.append(k)
     return tuple(dynamic_values), (tuple(dynamic_names), tuple(static_names), tuple(static_values))
 
@@ -143,15 +166,15 @@
   @name.setter
   def name(self, name: str = None):
     self._name = self.unique_name(name=name)
     check_name_uniqueness(name=self._name, obj=self)
 
   def register_implicit_vars(self, *variables, var_cls: type = None, **named_variables):
     if var_cls is None:
-      var_cls = (Variable, ListVar, DictVar)
+      var_cls = (Variable, VarList, VarDict)
 
     for variable in variables:
       if isinstance(variable, var_cls):
         self.implicit_vars[f'var{id(variable)}'] = variable
       elif isinstance(variable, (tuple, list)):
         for v in variable:
           if not isinstance(v, var_cls):
@@ -209,32 +232,36 @@
     include_self: bool
       Whether include the variables in the self.
     exclude_types: tuple of type
       The type to exclude.
 
     Returns
     -------
-    gather : DynVarCollector
+    gather : ArrayCollector
       The collection contained (the path, the variable).
     """
     if exclude_types is None:
       exclude_types = (VariableView,)
     nodes = self.nodes(method=method, level=level, include_self=include_self)
-    gather = DynVarCollector()
+    gather = ArrayCollector()
     for node_path, node in nodes.items():
       for k in dir(node):
+        if k in node._excluded_vars:
+          continue
         v = getattr(node, k)
-        include = False
-        if isinstance(v, (Variable, ListVar, DictVar)):
-          include = True
-          if isinstance(v, exclude_types):
-            include = False
-        if include and (k not in node._excluded_vars):
-          gather[f'{node_path}.{k}' if node_path else k] = v
-
+        if isinstance(v, Variable) and not isinstance(v, exclude_types):
+            gather[f'{node_path}.{k}' if node_path else k] = v
+        elif isinstance(v, VarList):
+          for i, vv in enumerate(v):
+            if not isinstance(vv, exclude_types):
+              gather[f'{node_path}.{k}-{i}' if node_path else k] = vv
+        elif isinstance(v, VarDict):
+          for kk, vv in v.items():
+            if not isinstance(vv, exclude_types):
+              gather[f'{node_path}.{k}-{kk}' if node_path else k] = vv
       # implicit vars
       gather.update({f'{node_path}.{k}': v for k, v in node.implicit_vars.items()})
     return gather
 
   def train_vars(self, method='absolute', level=-1, include_self=True):
     """The shortcut for retrieving all trainable variables.
 
@@ -245,15 +272,15 @@
     level: int
       The hierarchy level to find TrainVar instances.
     include_self: bool
       Whether include the TrainVar instances in the self.
 
     Returns
     -------
-    gather : DynVarCollector
+    gather : ArrayCollector
       The collection contained (the path, the trainable variable).
     """
     return self.vars(method=method, level=level, include_self=include_self).subset(TrainVar)
 
   def _find_nodes(self, method='absolute', level=-1, include_self=True, _lid=0, _paths=None):
     if _paths is None:
       _paths = set()
@@ -296,15 +323,15 @@
       nodes = []
       for k, v in self.__dict__.items():
         if isinstance(v, BrainPyObject):
           _add_node1(self, k, v, _paths, gather, nodes)
         elif isinstance(v, NodeList):
           for i, v2 in enumerate(v):
             _add_node1(self, k + '-' + str(i), v2, _paths, gather, nodes)
-        elif isinstance(v, NodeDict) and k != 'implicit_nodes':
+        elif isinstance(v, NodeDict):
           for k2, v2 in v.items():
             if isinstance(v2, BrainPyObject):
               _add_node1(self, k + '.' + k2, v2, _paths, gather, nodes)
 
       # implicit nodes
       for key, node in self.implicit_nodes.items():
         _add_node1(self, key, node, _paths, gather, nodes)
@@ -561,15 +588,15 @@
     if dyn_vars is not None:
       self.register_implicit_vars(dyn_vars)
 
   def __call__(self, *args, **kwargs):
     return self.target(*args, **kwargs)
 
   def __repr__(self) -> str:
-    from brainpy.tools import repr_context
+    from brainpy._src.tools import repr_context
     name = self.__class__.__name__
     indent = " " * (len(name) + 1)
     indent2 = indent + " " * len('nodes=')
     nodes = [repr_context(str(n), indent2) for n in self.implicit_nodes.values()]
     node_string = ", \n".join(nodes)
     return (f'{name}(nodes=[{node_string}],\n' +
             " " * (len(name) + 1) + f'num_of_vars={len(self.implicit_vars)})')
@@ -589,402 +616,73 @@
 
 def _check_obj_elem(elem):
   if not isinstance(elem, BrainPyObject):
     raise TypeError(f'Element should be a {BrainPyObject.__class__.__name__}.')
   return elem
 
 
-class _dyn_seq(object):
-  __slots__ = ('_value',)
-
-  _value: list
-  _supported_types = ()
-
-  def __init__(self, value):
-    self._value = list(value)
-
-  @property
-  def value(self):
-    return self._value
-
-  @value.setter
-  def value(self, value):
-    if len(value) != self.value:
-      raise ValueError
-    self._value = list(value)
-
-  def _check_elem_type(self, elem):
-    if not isinstance(elem, self._supported_types):
-      raise TypeError(f'Element should be {self._supported_types}, but got {type(elem)}.')
-    return elem
-
-  def append(self, element) -> '_dyn_seq':
-    self._value.append(self._check_elem_type(element))
-    return self
-
-  def extend(self, iterable) -> '_dyn_seq':
-    for element in iterable:
-      self.append(element)
-    return self
-
-  def insert(self, index, obj) -> '_dyn_seq':
-    self._value.insert(index, self._check_elem_type(obj))
-    return self
-
-  def pop(self, index=-1):
-    return self._value.pop(index)
-
-  def reverse(self):
-    return type(self)(self._value.reverse())
-
-  def __setitem__(self, key, value) -> '_dyn_seq':
-    self._value.__setitem__(key, self._check_elem_type(value))
-    return self
-
-  def __getitem__(self, item):
-    return self._value[item]
-
-  def __len__(self):
-    return len(self._value)
-
-  def __iter__(self):
-    for v in self._value:
-      yield v
+class ObjectTransform(BrainPyObject):
+  """Object-oriented JAX transformation for BrainPy computation.
+  """
 
-  def __add__(self, other):
-    return type(self)(self.value + (other.value if isinstance(other, _dyn_seq) else other))
+  def __init__(self, name: str = None):
+    super().__init__(name=name)
 
-  def __delitem__(self, item):
-    del self._value[item]
+  def __call__(self, *args, **kwargs):
+    raise NotImplementedError
 
   def __repr__(self):
-    return repr(self._value)
-
+    return self.__class__.__name__
 
-class ListVar(_dyn_seq):
-  """A sequence variable, whose contents can be changed during JIT compilation.
 
-  It is a variable, which is similar to :py:class:`~.Variable`.
-
-  .. note::
-     The element must be a numerical number, like ``bool``, ``int``, ``float``,
-     ``jax.Array``, ``numpy.ndarray``, :py:class:`~.Array`.
+class NodeList(list):
+  """A sequence of :py:class:`~.BrainPyObject`, which is compatible with
+  :py:func:`.vars()` operation in a :py:class:`~.BrainPyObject`.
   """
 
-  _supported_types = (numbers.Number, jax.Array, Array, np.ndarray)
+  def __init__(self, seq=()):
+    super().__init__()
+    self.extend(seq)
 
+  def append(self, element) -> 'NodeList':
+    if not isinstance(element, BrainPyObject):
+      raise TypeError(f'element must be an instance of {BrainPyObject.__name__}.')
+    super().append(element)
+    return self
 
-register_pytree_node(ListVar, lambda x: (tuple(x.value), ()), lambda _, values: ListVar(values))
+  def extend(self, iterable) -> 'NodeList':
+    for element in iterable:
+      self.append(element)
+    return self
 
 
-class NodeList(_dyn_seq):
-  """A list to represent a dynamically changed numerical
-  sequence in which its element can be changed during JIT compilation.
 
-  .. note::
-     The element must be a brainpy object, like :py:class:`~.BrainPyObject`.
+class NodeDict(dict):
+  """A dictionary of :py:class:`~.BrainPyObject`, which is compatible with
+  :py:func:`.vars()` operation in a :py:class:`~.BrainPyObject`.
   """
 
-  _supported_types = BrainPyObject
-
-
-register_pytree_node(NodeList, lambda x: (tuple(x.value), ()), lambda _, values: NodeList(values))
-
-
-class _dyn_dict(object):
-  __slots__ = ('_value',)
-
-  _value: dict
-  _supported_types = ()
+  def _check_elem(self, elem):
+    if not isinstance(elem, BrainPyObject):
+      raise TypeError(f'Element should be {BrainPyObject.__name__}, but got {type(elem)}.')
+    return elem
 
   def __init__(self, *args, **kwargs):
-    self._value = dict(*args, **kwargs)
-
-  @property
-  def value(self):
-    return self._value
-
-  @value.setter
-  def value(self, value):
-    if len(value) != self.value:
-      raise ValueError
-    self._value = dict(value)
-
-  def _check_elem_type(self, elem):
-    if not isinstance(elem, self._supported_types):
-      raise TypeError(f'Element should be {self._supported_types}, but got {type(elem)}.')
-    return elem
+    super().__init__()
+    self.update(*args, **kwargs)
 
-  def update(self, *args, **kwargs) -> '_dyn_dict':
+  def update(self, *args, **kwargs) -> 'VarDict':
     for arg in args:
       if isinstance(arg, dict):
         for k, v in arg.items():
-          self._value[k] = v
+          self[k] = v
       elif isinstance(arg, tuple):
         assert len(arg) == 2
-        self._value[arg[0]] = args[1]
+        self[arg[0]] = args[1]
     for k, v in kwargs.items():
-      self._value[k] = v
+      self[k] = v
     return self
 
-  def __setitem__(self, key, value) -> '_dyn_dict':
-    self._value[key] = self._check_elem_type(value)
-    return self
-
-  def __getitem__(self, item):
-    return self._value[item]
-
-  def __delitem__(self, item):
-    del self._value[item]
-
-  def __len__(self):
-    return len(self._value)
-
-  def __iter__(self):
-    for k in self._value:
-      yield k
-
-  def keys(self):
-    return self._value.keys()
-
-  def values(self):
-    return self._value.values()
-
-  def items(self):
-    return self._value.items()
-
-  def clear(self):
-    return self._value.clear()
-
-  def copy(self):
-    return type(self)(self._value.copy())
-
-  def get(self, *args, **kwargs):
-    return self._value.get(*args, **kwargs)
-
-  def has_key(self, key):
-    return (key in self._value)
-
-  def pop(self, *args, **kwargs):
-    return self._value.pop(*args, **kwargs)
-
-  def __repr__(self):
-    return repr(self._value)
-
-
-class DictVar(_dyn_dict):
-  """A dict variable, in which its element can be changed during JIT compilation.
-
-  It is a variable, which is similar to :py:class:`~.Variable`.
-
-  .. note::
-     The element must be a numerical number, like ``bool``, ``int``, ``float``,
-     ``jax.Array``, ``numpy.ndarray``, :py:class:`~.Array`.
-  """
-
-  _supported_types = (numbers.Number, jax.Array, Array, np.ndarray)
-
-
-register_pytree_node(DictVar,
-                     lambda x: (tuple(x.values()), tuple(x.keys())),
-                     lambda keys, values: DictVar(safe_zip(keys, values)))
-
-
-class NodeDict(_dyn_dict):
-  """An object to represent a dict of node in which its element can be changed during JIT compilation.
-
-  .. note::
-     The element must be a brainpy object, like :py:class:`~.BrainPyObject`.
-  """
-
-  _supported_types = BrainPyObject
-
-
-register_pytree_node(NodeDict,
-                     lambda x: (tuple(x.values()), tuple(x.keys())),
-                     lambda keys, values: NodeDict(safe_zip(keys, values)))
-
-
-class Collector(dict):
-  """A Collector is a dictionary (name, var) with some additional methods to make manipulation
-  of collections of variables easy. A Collector is ordered by insertion order. It is the object
-  returned by BrainPyObject.vars() and used as input in many Collector instance: optimizers, jit, etc..."""
-
-  def __setitem__(self, key, value):
-    """Overload bracket assignment to catch potential conflicts during assignment."""
-    if key in self:
-      if id(self[key]) != id(value):
-        raise ValueError(f'Name "{key}" conflicts: same name for {value} and {self[key]}.')
-    dict.__setitem__(self, key, value)
-
-  def replace(self, key, new_value):
-    """Replace the original key with the new value."""
-    self.pop(key)
-    self[key] = new_value
-
-  def update(self, other, **kwargs):
-    assert isinstance(other, (dict, list, tuple))
-    if isinstance(other, dict):
-      for key, value in other.items():
-        self[key] = value
-    elif isinstance(other, (tuple, list)):
-      num = len(self)
-      for i, value in enumerate(other):
-        self[f'_var{i + num}'] = value
-    else:
-      raise ValueError(f'Only supports dict/list/tuple, but we got {type(other)}')
-    for key, value in kwargs.items():
-      self[key] = value
+  def __setitem__(self, key, value) -> 'VarDict':
+    super().__setitem__(key, self._check_elem(value))
     return self
 
-  def __add__(self, other):
-    """Merging two dicts.
-
-    Parameters
-    ----------
-    other: dict
-      The other dict instance.
-
-    Returns
-    -------
-    gather: Collector
-      The new collector.
-    """
-    gather = type(self)(self)
-    gather.update(other)
-    return gather
-
-  def __sub__(self, other: Union[Dict, Sequence]):
-    """Remove other item in the collector.
-
-    Parameters
-    ----------
-    other: dict, sequence
-      The items to remove.
-
-    Returns
-    -------
-    gather: Collector
-      The new collector.
-    """
-    if not isinstance(other, (dict, tuple, list)):
-      raise ValueError(f'Only support dict/tuple/list, but we got {type(other)}.')
-    gather = type(self)(self)
-    if isinstance(other, dict):
-      for key, val in other.items():
-        if key in gather:
-          if id(val) != id(gather[key]):
-            raise ValueError(f'Cannot remove {key}, because we got two different values: '
-                             f'{val} != {gather[key]}')
-          gather.pop(key)
-        else:
-          raise ValueError(f'Cannot remove {key}, because we do not find it '
-                           f'in {self.keys()}.')
-    elif isinstance(other, (list, tuple)):
-      id_to_keys = {}
-      for k, v in self.items():
-        id_ = id(v)
-        if id_ not in id_to_keys:
-          id_to_keys[id_] = []
-        id_to_keys[id_].append(k)
-
-      keys_to_remove = []
-      for key in other:
-        if isinstance(key, str):
-          keys_to_remove.append(key)
-        else:
-          keys_to_remove.extend(id_to_keys[id(key)])
-
-      for key in set(keys_to_remove):
-        if key in gather:
-          gather.pop(key)
-        else:
-          raise ValueError(f'Cannot remove {key}, because we do not find it '
-                           f'in {self.keys()}.')
-    else:
-      raise KeyError(f'Unknown type of "other". Only support dict/tuple/list, but we got {type(other)}')
-    return gather
-
-  def subset(self, var_type):
-    """Get the subset of the (key, value) pair.
-
-    ``subset()`` can be used to get a subset of some class:
-
-    >>> import brainpy as bp
-    >>>
-    >>> some_collector = Collector()
-    >>>
-    >>> # get all trainable variables
-    >>> some_collector.subset(bp.math.TrainVar)
-    >>>
-    >>> # get all Variable
-    >>> some_collector.subset(bp.math.Variable)
-
-    or, it can be used to get a subset of integrators:
-
-    >>> # get all ODE integrators
-    >>> some_collector.subset(bp.ode.ODEIntegrator)
-
-    Parameters
-    ----------
-    var_type : type
-      The type/class to match.
-    """
-    gather = type(self)()
-    for key, value in self.items():
-      if isinstance(value, var_type):
-        gather[key] = value
-    return gather
-
-  def not_subset(self, var_type):
-    gather = type(self)()
-    for key, value in self.items():
-      if not isinstance(value, var_type):
-        gather[key] = value
-    return gather
-
-  def unique(self):
-    """Get a new type of collector with unique values.
-
-    If one value is assigned to two or more keys,
-    then only one pair of (key, value) will be returned.
-    """
-    gather = type(self)()
-    seen = set()
-    for k, v in self.items():
-      if id(v) not in seen:
-        seen.add(id(v))
-        gather[k] = v
-    return gather
-
-
-class DynVarCollector(Collector):
-  def __setitem__(self, key, value):
-    """Overload bracket assignment to catch potential conflicts during assignment."""
-
-    assert isinstance(value, (Variable, NodeList, NodeDict, ListVar, DictVar)), type(value)
-    if key in self:
-      if id(self[key]) != id(value):
-        raise ValueError(f'Name "{key}" conflicts: same name for {value} and {self[key]}.')
-    dict.__setitem__(self, key, value)
-
-  def dict(self):
-    """Get a dict with the key and the value data.
-    """
-    gather = dict()
-    for k, v in self.items():
-      gather[k] = v.value
-    return gather
-
-  def data(self):
-    """Get all data in each value."""
-    return [x.value for x in self.values()]
-
-
-ArrayCollector = DynVarCollector
-TensorCollector = DynVarCollector
-
-register_pytree_node(
-  DynVarCollector,
-  lambda x: (x.values(), x.keys()),
-  lambda keys, values: DynVarCollector(safe_zip(keys, values))
-)
```

## brainpy/_src/math/object_transform/controls.py

```diff
@@ -2,27 +2,29 @@
 
 
 from typing import Union, Sequence, Any, Dict, Callable, Optional
 
 import jax
 import jax.numpy as jnp
 from jax import lax
-from jax.tree_util import tree_flatten, tree_unflatten
 from jax.errors import UnexpectedTracerError
+from jax.tree_util import tree_flatten, tree_unflatten
 
-from brainpy import errors, tools, check
-from brainpy._src.math.ndarray import (Array,
-                                       Variable,
-                                       add_context,
-                                       del_context)
-from brainpy._src.math.arrayinterporate import as_jax
-from brainpy._src.tools.naming import get_unique_name
-from .base import BrainPyObject, DynVarCollector
-from ._utils import infer_dyn_vars
-from .abstract import ObjectTransform
+from brainpy import errors, tools
+from brainpy._src.math.interoperability import as_jax
+from brainpy._src.math.ndarray import (Array, )
+from ._tools import (evaluate_dyn_vars,
+                     dynvar_deprecation,
+                     node_deprecation,
+                     abstract)
+from .base import BrainPyObject, ObjectTransform
+from .naming import (get_unique_name,
+                     get_stack_cache,
+                     cache_stack)
+from .variables import (Variable, VariableStack)
 
 __all__ = [
   'make_loop',
   'make_while',
   'make_cond',
 
   'cond',
@@ -191,46 +193,37 @@
   """
 
   fun2scan, dyn_vars, tree = _get_scan_info(f=body_fun,
                                             dyn_vars=dyn_vars,
                                             out_vars=out_vars,
                                             has_return=has_return)
 
-  name = get_unique_name('_brainpy_object_oriented_make_loop_')
-
   # functions
   if has_return:
     def call(xs=None, length=None):
       init_values = [v.value for v in dyn_vars]
       try:
-        add_context(name)
         dyn_values, (out_values, results) = lax.scan(
           f=fun2scan, init=init_values, xs=xs, length=length
         )
-        del_context(name)
       except UnexpectedTracerError as e:
-        del_context(name)
         for v, d in zip(dyn_vars, init_values): v._value = d
         raise errors.JaxTracerError(variables=dyn_vars) from e
       for v, d in zip(dyn_vars, dyn_values): v._value = d
       return tree_unflatten(tree, out_values), results
 
   else:
     def call(xs):
       init_values = [v.value for v in dyn_vars]
       try:
-        add_context(name)
         dyn_values, out_values = lax.scan(f=fun2scan, init=init_values, xs=xs)
-        del_context(name)
       except UnexpectedTracerError as e:
-        del_context(name)
         for v, d in zip(dyn_vars, init_values): v._value = d
         raise errors.JaxTracerError(variables=dyn_vars) from e
       except Exception as e:
-        del_context(name)
         for v, d in zip(dyn_vars, init_values): v._value = d
         raise e
       for v, d in zip(dyn_vars, dyn_values): v._value = d
       return tree_unflatten(tree, out_values)
 
   return ControlObject(call, dyn_vars=dyn_vars, repr_fun={'body_fun': body_fun})
 
@@ -300,25 +293,21 @@
     return as_jax(cond_fun(static_values))
 
   name = get_unique_name('_brainpy_object_oriented_make_while_')
 
   def call(x=None):
     dyn_init = [v.value for v in dyn_vars]
     try:
-      add_context(name)
       dyn_values, _ = lax.while_loop(cond_fun=_cond_fun,
                                      body_fun=_body_fun,
                                      init_val=(dyn_init, x))
-      del_context(name)
     except UnexpectedTracerError as e:
-      del_context(name)
       for v, d in zip(dyn_vars, dyn_init): v._value = d
       raise errors.JaxTracerError(variables=dyn_vars) from e
     except Exception as e:
-      del_context(name)
       for v, d in zip(dyn_vars, dyn_init): v._value = d
       raise e
     for v, d in zip(dyn_vars, dyn_values): v._value = d
 
   return ControlObject(call=call,
                        dyn_vars=dyn_vars,
                        repr_fun={'cond_fun': cond_fun, 'body_fun': body_fun},
@@ -399,33 +388,27 @@
       res = false_fun(static_vals)
       dyn_vals = [v.value for v in dyn_vars]
       return dyn_vals, res
 
     def call(pred, x=None):
       old_values = [v.value for v in dyn_vars]
       try:
-        add_context(name)
         dyn_values, res = lax.cond(pred, _true_fun, _false_fun, (old_values, x))
-        del_context(name)
       except UnexpectedTracerError as e:
-        del_context(name)
         for v, d in zip(dyn_vars, old_values): v._value = d
         raise errors.JaxTracerError(variables=dyn_vars) from e
       except Exception as e:
-        del_context(name)
         for v, d in zip(dyn_vars, old_values): v._value = d
         raise e
       for v, d in zip(dyn_vars, dyn_values): v._value = d
       return res
 
   else:
     def call(pred, x=None):
-      add_context(name)
       res = lax.cond(pred, true_fun, false_fun, x)
-      del_context(name)
       return res
 
   return ControlObject(call, dyn_vars, repr_fun={'true_fun': true_fun, 'false_fun': false_fun})
 
 
 def _check_f(f):
   if callable(f):
@@ -439,30 +422,32 @@
 
 
 def cond(
     pred: bool,
     true_fun: Union[Callable, jnp.ndarray, Array, float, int, bool],
     false_fun: Union[Callable, jnp.ndarray, Array, float, int, bool],
     operands: Any,
+
+    # deprecated
     dyn_vars: Union[Variable, Sequence[Variable], Dict[str, Variable]] = None,
     child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
 ):
   """Simple conditional statement (if-else) with instance of :py:class:`~.Variable`.
 
   >>> import brainpy.math as bm
   >>> a = bm.Variable(bm.zeros(2))
   >>> b = bm.Variable(bm.ones(2))
   >>> def true_f(_):  a.value += 1
   >>> def false_f(_): b.value -= 1
   >>>
-  >>> bm.cond(True, true_f, false_f, dyn_vars=[a, b])
+  >>> bm.cond(True, true_f, false_f)
   >>> a, b
   Variable([1., 1.], dtype=float32), Variable([1., 1.], dtype=float32)
   >>>
-  >>> bm.cond(False, true_f, false_f, dyn_vars=[a, b])
+  >>> bm.cond(False, true_f, false_f)
   >>> a, b
   Variable([1., 1.], dtype=float32), Variable([0., 0.], dtype=float32)
 
   Parameters
   ----------
   pred: bool
     Boolean scalar type, indicating which branch function to apply.
@@ -483,75 +468,66 @@
     .. versionadded:: 2.3.1
 
   Returns
   -------
   res: Any
     The conditional results.
   """
-  # checking
+
+  # functions
   true_fun = _check_f(true_fun)
   false_fun = _check_f(false_fun)
-  dyn_vars = check.is_all_vars(dyn_vars, out_as='dict')
-  dyn_vars = DynVarCollector(dyn_vars)
-  dyn_vars.update(infer_dyn_vars(true_fun))
-  dyn_vars.update(infer_dyn_vars(false_fun))
-  for obj in check.is_all_objs(child_objs, out_as='tuple'):
-    dyn_vars.update(obj.vars().unique())
-  dyn_vars = list(DynVarCollector(dyn_vars).unique().values())
 
-  name = get_unique_name('_brainpy_object_oriented_cond_')
+  # operands
+  if not isinstance(operands, (tuple, list)):
+    operands = (operands,)
 
-  # calling the model
-  if len(dyn_vars) > 0:
-    def _true_fun(op):
-      dyn_vals, static_vals = op
-      for v, d in zip(dyn_vars, dyn_vals): v._value = d
-      res = true_fun(static_vals)
-      dyn_vals = [v.value for v in dyn_vars]
-      return dyn_vals, res
+  # dyn vars
+  dynvar_deprecation(dyn_vars)
+  node_deprecation(child_objs)
 
-    def _false_fun(op):
-      dyn_vals, static_vals = op
-      for v, d in zip(dyn_vars, dyn_vals): v._value = d
-      res = false_fun(static_vals)
-      dyn_vals = [v.value for v in dyn_vars]
-      return dyn_vals, res
+  if jax.config.jax_disable_jit:
+    dyn_vars = VariableStack()
 
-    old_values = [v.value for v in dyn_vars]
-    try:
-      add_context(name)
-      dyn_values, res = lax.cond(pred=pred,
-                                 true_fun=_true_fun,
-                                 false_fun=_false_fun,
-                                 operand=(old_values, operands))
-      del_context(name)
-    except UnexpectedTracerError as e:
-      del_context(name)
-      for v, d in zip(dyn_vars, old_values): v._value = d
-      raise errors.JaxTracerError(variables=dyn_vars) from e
-    except Exception as e:
-      del_context(name)
-      for v, d in zip(dyn_vars, old_values): v._value = d
-      raise e
-    else:
-      for v, d in zip(dyn_vars, dyn_values): v._value = d
   else:
-    add_context(name)
-    res = lax.cond(pred, true_fun, false_fun, operands)
-    del_context(name)
+    dyn_vars = evaluate_dyn_vars(true_fun, *operands)
+    dyn_vars += evaluate_dyn_vars(false_fun, *operands)
+
+  # TODO: cache mechanism?
+  if len(dyn_vars) > 0:
+    def _true_fun(dyn_vals, *static_vals):
+      for k, v in dyn_vars.items():
+        v._value = dyn_vals[k]
+      r = true_fun(*static_vals)
+      return {k: v.value for k, v in dyn_vars.items()}, r
+
+    def _false_fun(dyn_vals, *static_vals):
+      for k, v in dyn_vars.items():
+        v._value = dyn_vals[k]
+      r = false_fun(*static_vals)
+      return {k: v.value for k, v in dyn_vars.items()}, r
+
+    old_values = {k: v.value for k, v in dyn_vars.items()}
+    dyn_values, res = lax.cond(pred, _true_fun, _false_fun, old_values, *operands)
+    for k, v in dyn_vars.items():
+      v._value = dyn_values[k]
+  else:
+    res = lax.cond(pred, true_fun, false_fun, *operands)
   return res
 
 
 def ifelse(
     conditions: Union[bool, Sequence[bool]],
     branches: Sequence[Any],
     operands: Any = None,
+    show_code: bool = False,
+
+    # deprecated
     dyn_vars: Union[Variable, Sequence[Variable], Dict[str, Variable]] = None,
     child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
-    show_code: bool = False,
 ):
   """``If-else`` control flows looks like native Pythonic programming.
 
   Examples
   --------
 
   >>> import brainpy.math as bm
@@ -606,70 +582,57 @@
     raise ValueError(f'"branches" must be a tuple/list. '
                      f'But we got {type(branches)}.')
   branches = [_check_f(b) for b in branches]
   if len(branches) != len(conditions) + 1:
     raise ValueError(f'The numbers of branches and conditions do not match. '
                      f'Got len(conditions)={len(conditions)} and len(branches)={len(branches)}. '
                      f'We expect len(conditions) + 1 == len(branches). ')
-  dyn_vars = check.is_all_vars(dyn_vars, out_as='dict')
-  dyn_vars = DynVarCollector(dyn_vars)
-  for f in branches:
-    dyn_vars += infer_dyn_vars(f)
-  for obj in check.is_all_objs(child_objs, out_as='tuple'):
-    dyn_vars.update(obj.vars().unique())
-  dyn_vars = tuple(dyn_vars.unique().values())
+
+  dynvar_deprecation(dyn_vars)
+  node_deprecation(child_objs)
 
   # format new codes
   if len(conditions) == 1:
-    if len(dyn_vars) > 0:
-      return cond(conditions[0],
-                  branches[0],
-                  branches[1],
-                  operands,
-                  dyn_vars)
-    else:
-      return lax.cond(conditions[0], branches[0], branches[1], operands)
+    return cond(conditions[0],
+                branches[0],
+                branches[1],
+                operands)
   else:
     code_scope = {'conditions': conditions, 'branches': branches}
     codes = ['def f(operands):',
              f'  f0 = branches[{len(conditions)}]']
     num_cond = len(conditions) - 1
-    if len(dyn_vars) > 0:
-      code_scope['_cond'] = cond
-      code_scope['dyn_vars'] = dyn_vars
-      for i in range(len(conditions) - 1):
-        codes.append(f'  f{i + 1} = lambda r: _cond(conditions[{num_cond - i}], '
-                     f'branches[{num_cond - i}], f{i}, r, dyn_vars)')
-      codes.append(f'  return _cond(conditions[0], branches[0], f{len(conditions) - 1}, operands, dyn_vars)')
-    else:
-      code_scope['_cond'] = lax.cond
-      for i in range(len(conditions) - 1):
-        codes.append(f'  f{i + 1} = lambda r: _cond(conditions[{num_cond - i}], branches[{num_cond - i}], f{i}, r)')
-      codes.append(f'  return _cond(conditions[0], branches[0], f{len(conditions) - 1}, operands)')
+    code_scope['_cond'] = cond
+    for i in range(len(conditions) - 1):
+      codes.append(f'  f{i + 1} = lambda r: _cond(conditions[{num_cond - i}], branches[{num_cond - i}], f{i}, r)')
+    codes.append(f'  return _cond(conditions[0], branches[0], f{len(conditions) - 1}, operands)')
     codes = '\n'.join(codes)
     if show_code: print(codes)
     exec(compile(codes.strip(), '', 'exec'), code_scope)
     f = code_scope['f']
-    name = get_unique_name('_brainpy_object_oriented_ifelse_')
-    add_context(name)
     r = f(operands)
-    del_context(name)
     return r
 
 
+def _loop_abstractify(x):
+  x = abstract(x)
+  return jax.core.mapped_aval(x.shape[0], 0, x)
+
+
 def for_loop(
     body_fun: Callable,
     operands: Any,
-    dyn_vars: Union[Variable, Sequence[Variable], Dict[str, Variable]] = None,
-    out_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
     reverse: bool = False,
     unroll: int = 1,
     remat: bool = False,
     jit: bool = True,
+
+    # deprecated
+    dyn_vars: Union[Variable, Sequence[Variable], Dict[str, Variable]] = None,
+    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
 ):
   """``for-loop`` control flow with :py:class:`~.Variable`.
 
   .. versionchanged:: 2.3.0
      ``dyn_vars`` has been changed into a default argument.
      Please change your call from ``for_loop(fun, dyn_vars, operands)``
      to ``for_loop(fun, operands, dyn_vars)``.
@@ -682,15 +645,15 @@
   >>> a = bm.Variable(bm.zeros(1))
   >>> b = bm.Variable(bm.ones(1))
   >>> # first example
   >>> def body(x):
   >>>    a.value += x
   >>>    b.value *= x
   >>>    return a.value
-  >>> a_hist = bm.for_loop(body, dyn_vars=[a, b], operands=bm.arange(1, 5))
+  >>> a_hist = bm.for_loop(body, operands=bm.arange(1, 5))
   >>> a_hist
   DeviceArray([[ 1.],
                [ 3.],
                [ 6.],
                [10.]], dtype=float32)
   >>> a
   Variable([10.], dtype=float32)
@@ -698,17 +661,15 @@
   Variable([24.], dtype=float32)
   >>>
   >>> # another example
   >>> def body(x, y):
   >>>   a.value += x
   >>>   b.value *= y
   >>>   return a.value
-  >>> a_hist = bm.for_loop(body,
-  >>>                      dyn_vars=[a, b],
-  >>>                      operands=(bm.arange(1, 5), bm.arange(2, 6)))
+  >>> a_hist = bm.for_loop(body, operands=(bm.arange(1, 5), bm.arange(2, 6)))
   >>> a_hist
   [[11.]
    [13.]
    [16.]
    [20.]]
 
   .. versionadded:: 2.1.11
@@ -722,94 +683,97 @@
   operands: Any
     The value over which to scan along the leading axis,
     where ``operands`` can be an array or any pytree (nested Python
     tuple/list/dict) thereof with consistent leading axis sizes.
     If body function `body_func` receives multiple arguments,
     `operands` should be a tuple/list whose length is equal to the
     number of arguments.
-  dyn_vars: Variable, sequence of Variable, dict
-    The instances of :py:class:`~.Variable`.
-  out_vars: PyTree, Optional
-    The variables to output in each step.
-
-    .. versionadded:: 2.3.1
-       Support to return outputs with the specification of `out_vars`,
-       which means no longer need to accumulate values through the
-       function returns.
-
+  remat: bool
+    Make ``fun`` recompute internal linearization points when differentiated.
+  jit: bool
+    Whether to just-in-time compile the function.
   reverse: bool
     Optional boolean specifying whether to run the scan iteration
     forward (the default) or in reverse, equivalent to reversing the leading
     axes of the arrays in both ``xs`` and in ``ys``.
   unroll: int
     Optional positive int specifying, in the underlying operation of the
     scan primitive, how many scan iterations to unroll within a single
     iteration of a loop.
+
+  dyn_vars: Variable, sequence of Variable, dict
+    The instances of :py:class:`~.Variable`.
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``dyn_vars``. This function is capable of automatically
+       collecting the dynamical variables used in the target ``func``.
   child_objs: optional, dict, sequence of BrainPyObject, BrainPyObject
     The children objects used in the target function.
 
     .. versionadded:: 2.3.1
 
+    .. deprecated:: 2.4.0
+       No longer need to provide ``child_objs``. This function is capable of automatically
+       collecting the children objects used in the target ``func``.
+
   Returns
   -------
   outs: Any
     The stacked outputs of ``body_fun`` when scanned over the leading axis of the inputs.
   """
-  dyn_vars = check.is_all_vars(dyn_vars, out_as='dict')
-  dyn_vars = DynVarCollector(dyn_vars)
-  dyn_vars.update(infer_dyn_vars(body_fun))
-  for obj in check.is_all_objs(child_objs, out_as='tuple'):
-    dyn_vars.update(obj.vars().unique())
-  dyn_vars = list(DynVarCollector(dyn_vars).unique().values())
-  outs, _ = tree_flatten(out_vars, lambda s: isinstance(s, Variable))
+
+  dynvar_deprecation(dyn_vars)
+  node_deprecation(child_objs)
+
+  if not isinstance(operands, (list, tuple)):
+    operands = (operands,)
+
+  dyn_vars = get_stack_cache(body_fun)
+  if not jit:
+    if dyn_vars is None:
+      dyn_vars = VariableStack()
+
+  else:
+    # TODO: better cache mechanism?
+    if dyn_vars is None:
+      with jax.ensure_compile_time_eval():
+        op_vals = jax.tree_util.tree_map(_loop_abstractify, operands)
+        with VariableStack() as dyn_vars:
+          _ = jax.eval_shape(body_fun, *op_vals)
+        cache_stack(body_fun, dyn_vars)  # cache
+        del op_vals
 
   # functions
   def fun2scan(carry, x):
-    for v, d in zip(dyn_vars, carry): v._value = d
-    if not isinstance(x, (tuple, list)):
-      x = (x,)
+    for k in dyn_vars.keys():
+      dyn_vars[k]._value = carry[k]
     results = body_fun(*x)
-    if results is None:
-      if out_vars is not None:
-        results = out_vars
-    else:
-      if out_vars is not None:
-        results = (results, out_vars)
-    return [v.value for v in dyn_vars], results
+    return dyn_vars.dict_data(), results
 
   if remat:
     fun2scan = jax.checkpoint(fun2scan)
 
-  name = get_unique_name('_brainpy_object_oriented_for_loop_')
-
-  # functions
-  try:
-    add_context(name)
-    with jax.disable_jit(not jit):
-      dyn_vals, out_vals = lax.scan(f=fun2scan,
-                                    init=[v.value for v in dyn_vars],
-                                    xs=operands,
-                                    reverse=reverse,
-                                    unroll=unroll)
-    del_context(name)
-  except UnexpectedTracerError as e:
-    del_context(name)
-    raise errors.JaxTracerError() from e
-  except Exception as e:
-    del_context(name)
-    raise e
-  else:
-    for v, d in zip(dyn_vars, dyn_vals): v._value = d
+  # TODO: cache mechanism?
+  with jax.disable_jit(not jit):
+    dyn_vals, out_vals = lax.scan(f=fun2scan,
+                                  init=dyn_vars.dict_data(),
+                                  xs=operands,
+                                  reverse=reverse,
+                                  unroll=unroll)
+  for key in dyn_vars.keys():
+    dyn_vars[key]._value = dyn_vals[key]
   return out_vals
 
 
 def while_loop(
     body_fun: Callable,
     cond_fun: Callable,
     operands: Any,
+
+    # deprecated
     dyn_vars: Union[Variable, Sequence[Variable], Dict[str, Variable]] = None,
     child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
 ):
   """``while-loop`` control flow with :py:class:`~.Variable`.
 
   .. versionchanged:: 2.3.0
      ``dyn_vars`` has been changed into a default argument.
@@ -833,77 +797,77 @@
   >>>    return x < 6.
   >>>
   >>> def body(x, y):
   >>>    a.value += x
   >>>    b.value *= y
   >>>    return x + b[0], y + 1.
   >>>
-  >>> res = bm.while_loop(body, cond, dyn_vars=[a, b], operands=(1., 1.))
+  >>> res = bm.while_loop(body, cond, operands=(1., 1.))
   >>> res
   (10.0, 4.0)
 
   .. versionadded:: 2.1.11
 
   Parameters
   ----------
   body_fun: callable
     A function which define the updating logic. It receives one argument for ``operands``, without returns.
   cond_fun: callable
     A function which define the stop condition. It receives one argument for ``operands``,
     with one boolean value return.
-  dyn_vars: Variable, sequence of Variable, dict
-    The dynamically changed variables.
   operands: Any
     The operands for ``body_fun`` and ``cond_fun`` functions.
+  dyn_vars: Variable, sequence of Variable, dict
+    The dynamically changed variables.
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``dyn_vars``. This function is capable of automatically
+       collecting the dynamical variables used in the target ``func``.
   child_objs: optional, dict, sequence of BrainPyObject, BrainPyObject
     The children objects used in the target function.
 
     .. versionadded:: 2.3.1
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``child_objs``. This function is capable of automatically
+       collecting the children objects used in the target ``func``.
+
+
   """
-  # iterable variables
-  dyn_vars = check.is_all_vars(dyn_vars, out_as='dict')
-  dyn_vars = DynVarCollector(dyn_vars)
-  dyn_vars.update(infer_dyn_vars(body_fun))
-  dyn_vars.update(infer_dyn_vars(cond_fun))
-  for obj in check.is_all_objs(child_objs, out_as='tuple'):
-    dyn_vars.update(obj.vars().unique())
-  dyn_vars = tuple(dyn_vars.values())
+  dynvar_deprecation(dyn_vars)
+  node_deprecation(child_objs)
+
   if not isinstance(operands, (list, tuple)):
     operands = (operands,)
 
+  if jax.config.jax_disable_jit:
+    dyn_vars = VariableStack()
+
+  else:
+    dyn_vars = evaluate_dyn_vars(body_fun, *operands)
+    dyn_vars += evaluate_dyn_vars(cond_fun, *operands)
+
   def _body_fun(op):
-    dyn_vals, static_vals = op
-    for v, d in zip(dyn_vars, dyn_vals): v._value = d
-    if not isinstance(static_vals, (tuple, list)):
-      static_vals = (static_vals,)
-    new_vals = body_fun(*static_vals)
+    dyn_vals, old_vals = op
+    for k, v in dyn_vars.items():
+      v._value = dyn_vals[k]
+    new_vals = body_fun(*old_vals)
     if new_vals is None:
       new_vals = tuple()
     if not isinstance(new_vals, tuple):
       new_vals = (new_vals,)
-    return [v.value for v in dyn_vars], new_vals
+    return dyn_vars.dict_data(), new_vals
 
   def _cond_fun(op):
-    dyn_vals, static_vals = op
-    for v, d in zip(dyn_vars, dyn_vals): v._value = d
-    r = cond_fun(*static_vals)
+    dyn_vals, old_vals = op
+    for k, v in dyn_vars.items():
+      v._value = dyn_vals[k]
+    r = cond_fun(*old_vals)
     return r if isinstance(r, Array) else r
 
-  name = get_unique_name('_brainpy_object_oriented_while_loop_')
-  dyn_init = [v.value for v in dyn_vars]
-  try:
-    add_context(name)
-    dyn_values, out = lax.while_loop(cond_fun=_cond_fun,
-                                     body_fun=_body_fun,
-                                     init_val=(dyn_init, operands))
-    del_context(name)
-  except UnexpectedTracerError as e:
-    del_context(name)
-    for v, d in zip(dyn_vars, dyn_init): v._value = d
-    raise errors.JaxTracerError(variables=dyn_vars) from e
-  except Exception as e:
-    del_context(name)
-    for v, d in zip(dyn_vars, dyn_init): v._value = d
-    raise e
-  else:
-    for v, d in zip(dyn_vars, dyn_values): v._value = d
+  # TODO: cache mechanism?
+  dyn_values, out = lax.while_loop(cond_fun=_cond_fun,
+                                   body_fun=_body_fun,
+                                   init_val=(dyn_vars.dict_data(), operands))
+  for k, v in dyn_vars.items():
+    v._value = dyn_values[k]
   return out
```

## brainpy/_src/math/object_transform/function.py

```diff
@@ -1,13 +1,13 @@
 # -*- coding: utf-8 -*-
 
 import warnings
 from typing import Union, Sequence, Dict, Callable
 
-from brainpy._src.math.ndarray import Variable
+from .variables import Variable
 from .base import FunAsObject, BrainPyObject
 
 __all__ = [
   'Partial',
   'to_object',
   'function',
 ]
```

## brainpy/_src/math/object_transform/jit.py

```diff
@@ -3,270 +3,432 @@
 """
 The JIT compilation tools for JAX backend.
 
 1. Just-In-Time compilation is implemented by the 'jit()' function
 
 """
 
+from functools import partial, wraps
 from typing import Callable, Union, Optional, Sequence, Dict, Any, Iterable
 
 import jax
-from jax.errors import UnexpectedTracerError, ConcretizationTypeError
 
-from brainpy import errors, tools, check
-from brainpy._src.math.ndarray import Variable, add_context, del_context
-from .abstract import ObjectTransform
-from .base import BrainPyObject
+from brainpy import tools, check
+from ._tools import dynvar_deprecation, node_deprecation, evaluate_dyn_vars, _partial_fun
+from .base import BrainPyObject, ObjectTransform
+from .naming import get_stack_cache, cache_stack
+from .variables import Variable, VariableStack
 
 __all__ = [
   'jit',
 ]
 
 
+def _seq_of_int(static_argnums):
+  if static_argnums is None:
+    static_argnums = ()
+  elif isinstance(static_argnums, int):
+    static_argnums = (static_argnums,)
+  elif isinstance(static_argnums, (tuple, list)):
+    pass
+  else:
+    raise TypeError('static_argnums must be None, int, or sequence of int.')
+  return static_argnums
+
+
+def _seq_of_str(static_argnames):
+  if static_argnames is None:
+    static_argnames = ()
+  elif isinstance(static_argnames, str):
+    static_argnames = (static_argnames,)
+  elif isinstance(static_argnames, (tuple, list)):
+    pass
+  else:
+    raise TypeError('static_argnums must be None, str, or sequence of str.')
+  return static_argnames
+
+
 class JITTransform(ObjectTransform):
   """Object-oriented JIT transformation in BrainPy."""
 
   def __init__(
       self,
-      target: callable,
-      dyn_vars: Dict[str, Variable],
-      child_objs: Dict[str, BrainPyObject],
+      fun: Callable,
       static_argnums: Union[int, Iterable[int], None] = None,
       static_argnames: Union[str, Iterable[str], None] = None,
+      donate_argnums: Union[int, Iterable[int]] = (),
       device: Optional[Any] = None,
-      name: Optional[str] = None,
       inline: bool = False,
       keep_unused: bool = False,
       abstracted_axes: Optional[Any] = None,
+      name: Optional[str] = None,
+      backend: Optional[str] = None,
+
+      # deprecated
+      dyn_vars: Dict[str, Variable] = None,
+      child_objs: Dict[str, BrainPyObject] = None,
+
+      # others
+      **kwargs
   ):
     super().__init__(name=name)
 
-    self.register_implicit_vars(dyn_vars)
-    self.register_implicit_nodes(child_objs)
-    if hasattr(target, '__self__') and isinstance(getattr(target, '__self__'), BrainPyObject):
-      self.register_implicit_nodes(getattr(target, '__self__'))
-    self.target = target
-    self._all_vars = self.vars().unique()
-
-    # transformation
-    self._f = jax.jit(self._transform_function,
-                      static_argnums=jax.tree_util.tree_map(lambda a: a + 1, static_argnums),
-                      static_argnames=static_argnames,
-                      device=device,
-                      inline=inline,
-                      keep_unused=keep_unused,
-                      abstracted_axes=abstracted_axes)
+    # variables and nodes
+    if dyn_vars is not None:
+      self.register_implicit_vars(dyn_vars)
+    if child_objs is not None:
+      self.register_implicit_nodes(child_objs)
+
+    # target
+    if hasattr(fun, '__self__') and isinstance(getattr(fun, '__self__'), BrainPyObject):
+      self.register_implicit_nodes(getattr(fun, '__self__'))
+    self.fun = fun
+
+    # parameters
+    self._backend = backend
+    self._static_argnums = _seq_of_int(static_argnums)
+    self._static_argnames = _seq_of_str(static_argnames)
+    self._donate_argnums = donate_argnums
+    self._device = device
+    self._inline = inline
+    self._keep_unused = keep_unused
+    self._abstracted_axes = abstracted_axes
+    self._kwargs = kwargs
+
+    # transformation function
+    self._transform = None
+    self._dyn_vars = None
 
   def _transform_function(self, variable_data: Dict, *args, **kwargs):
-    for key, v in self._all_vars.items():
+    for key, v in self._dyn_vars.items():
       v._value = variable_data[key]
-    out = self.target(*args, **kwargs)
-    changes = self._all_vars.dict()
+    out = self.fun(*args, **kwargs)
+    changes = self._dyn_vars.dict_data()
     return out, changes
 
   def __call__(self, *args, **kwargs):
-    # variable_data = self._all_vars.dict()
-    try:
-      add_context(self.name)
-      out, changes = self._f(self._all_vars.dict(), *args, **kwargs)
-      del_context(self.name)
-    except UnexpectedTracerError as e:
-      del_context(self.name)
-      # for key, v in self._all_vars.items(): v._value = variable_data[key]
-      raise errors.JaxTracerError(variables=self._all_vars) from e
-    except ConcretizationTypeError as e:
-      del_context(self.name)
-      # for key, v in self._all_vars.items(): v._value = variable_data[key]
-      raise errors.ConcretizationTypeError() from e
-    except Exception as e:
-      del_context(self.name)
-      # for key, v in self._all_vars.items(): v._value = variable_data[key]
-      raise e
-    else:
-      for key, v in self._all_vars.items(): v._value = changes[key]
+    if jax.config.jax_disable_jit:
+      return self.fun(*args, **kwargs)
+
+    if self._transform is None:
+      self._dyn_vars = evaluate_dyn_vars(self.fun,
+                                         *args,
+                                         static_argnums=self._static_argnums,
+                                         static_argnames=self._static_argnames,
+                                         **kwargs)
+      self._transform = jax.jit(
+        self._transform_function,
+        static_argnums=jax.tree_util.tree_map(lambda a: a + 1, self._static_argnums),
+        static_argnames=self._static_argnames,
+        donate_argnums=self._donate_argnums,
+        device=self._device,
+        inline=self._inline,
+        keep_unused=self._keep_unused,
+        abstracted_axes=self._abstracted_axes,
+        backend=self._backend,
+        **self._kwargs
+      )
+    out, changes = self._transform(self._dyn_vars.dict_data(), *args, **kwargs)
+    for key, v in self._dyn_vars.items():
+      v._value = changes[key]
     return out
 
   def __repr__(self):
     name = self.__class__.__name__
-    f = tools.repr_object(self.target)
+    f = tools.repr_object(self.fun)
     f = tools.repr_context(f, " " * (len(name) + 6))
     format_ref = (f'{name}(target={f}, \n' +
                   f'{" " * len(name)} num_of_vars={len(self.vars().unique())})')
     return format_ref
 
 
-def _jit(func: Callable = None,
-         dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-         child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
-         static_argnums: Union[int, Iterable[int], None] = None,
-         static_argnames: Union[str, Iterable[str], None] = None,
-         device: Optional[Any] = None,
-         inline: bool = False,
-         keep_unused: bool = False,
-         abstracted_axes: Optional[Any] = None, ) -> JITTransform:
-  if callable(func):
-    dyn_vars = check.is_all_vars(dyn_vars, out_as='dict')
-    child_objs = check.is_all_objs(child_objs, out_as='dict')
-
-    # BrainPyObject object which implements __call__,
-    # or bounded method of BrainPyObject object
-    return JITTransform(target=func,
-                        dyn_vars=dyn_vars,
-                        child_objs=child_objs,
-                        static_argnums=static_argnums,
-                        static_argnames=static_argnames,
-                        device=device,
-                        inline=inline,
-                        keep_unused=keep_unused,
-                        abstracted_axes=abstracted_axes)
-
-  else:
-    raise errors.BrainPyError(f'Only support instance of {BrainPyObject.__name__}, or a callable '
-                              f'function, but we got {type(func)}.')
+_jit_par = '''
+  func : BrainPyObject, function, callable
+    The instance of Base or a function.
+  static_argnums: optional, int, sequence of int
+    An optional int or collection of ints that specify which
+    positional arguments to treat as static (compile-time constant).
+    Operations that only depend on static arguments will be constant-folded in
+    Python (during tracing), and so the corresponding argument values can be
+    any Python object.
+  static_argnames : optional, str, list, tuple, dict
+    An optional string or collection of strings specifying which named arguments to treat
+    as static (compile-time constant). See the comment on ``static_argnums`` for details.
+    If not provided but ``static_argnums`` is set, the default is based on calling
+    ``inspect.signature(fun)`` to find corresponding named arguments.
+  donate_argnums: int, sequence of int
+    Specify which positional argument buffers are "donated" to
+    the computation. It is safe to donate argument buffers if you no longer
+    need them once the computation has finished. In some cases XLA can make
+    use of donated buffers to reduce the amount of memory needed to perform a
+    computation, for example recycling one of your input buffers to store a
+    result. You should not reuse buffers that you donate to a computation, JAX
+    will raise an error if you try to. By default, no argument buffers are
+    donated. Note that donate_argnums only work for positional arguments, and keyword
+    arguments will not be donated.
+  device: optional, Any
+    This is an experimental feature and the API is likely to change.
+    Optional, the Device the jitted function will run on. (Available devices
+    can be retrieved via :py:func:`jax.devices`.) The default is inherited
+    from XLA's DeviceAssignment logic and is usually to use
+    ``jax.devices()[0]``.
+  keep_unused: bool
+    If `False` (the default), arguments that JAX determines to be
+    unused by `fun` *may* be dropped from resulting compiled XLA executables.
+    Such arguments will not be transferred to the device nor provided to the
+    underlying executable. If `True`, unused arguments will not be pruned.
+  backend: optional, str
+    This is an experimental feature and the API is likely to change.
+    Optional, a string representing the XLA backend: ``'cpu'``, ``'gpu'``, or
+    ``'tpu'``.
+  inline: bool
+    Specify whether this function should be inlined into enclosing
+    jaxprs (rather than being represented as an application of the xla_call
+    primitive with its own subjaxpr). Default False.
+'''
 
 
 def jit(
     func: Callable = None,
-    dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
-    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
+
+    # original jax.jit parameters
     static_argnums: Union[int, Iterable[int], None] = None,
     static_argnames: Union[str, Iterable[str], None] = None,
+    donate_argnums: Union[int, Sequence[int]] = (),
     device: Optional[Any] = None,
     inline: bool = False,
     keep_unused: bool = False,
+    backend: Optional[str] = None,
     abstracted_axes: Optional[Any] = None,
-) -> JITTransform:
-  """JIT (Just-In-Time) compilation for class objects.
 
-  This function has the same ability to Just-In-Time compile a pure function,
-  but it can also JIT compile a :py:class:`brainpy.DynamicalSystem`, or a
-  :py:class:`brainpy.Base` object, or a bounded method for a
-  :py:class:`brainpy.Base` object.
 
-  .. note::
-    There are several notes when using JIT compilation.
+    # deprecated
+    dyn_vars: Optional[Union[Variable, Sequence[Variable], Dict[str, Variable]]] = None,
+    child_objs: Optional[Union[BrainPyObject, Sequence[BrainPyObject], Dict[str, BrainPyObject]]] = None,
 
-    1. Avoid using scalar in a Variable, TrainVar, etc.
+    # others
+    **kwargs,
+) -> JITTransform:
+  """
+  JIT (Just-In-Time) compilation for BrainPy computation.
 
-    For example,
-
-    >>> import brainpy as bp
-    >>> import brainpy.math as bm
-    >>>
-    >>> class Test(bp.BrainPyObject):
-    >>>   def __init__(self):
-    >>>     super(Test, self).__init__()
-    >>>     self.a = bm.Variable(1.)  # Avoid! DO NOT USE!
-    >>>   def __call__(self, *args, **kwargs):
-    >>>     self.a += 1.
-
-    The above usage is deprecated, because it may cause several errors.
-    Instead, we recommend you define the scalar value variable as:
-
-    >>> class Test(bp.BrainPyObject):
-    >>>   def __init__(self):
-    >>>     super(Test, self).__init__()
-    >>>     self.a = bm.Variable(bm.array([1.]))  # use array to wrap a scalar is recommended
-    >>>   def __call__(self, *args, **kwargs):
-    >>>     self.a += 1.
-
-    Here, a ndarray is recommended to used to update the variable ``a``.
-
-    2. ``jit`` compilation in ``brainpy.math`` does not support `static_argnums`.
-       Instead, users should use `static_argnames`, and call the jitted function with
-       keywords like ``jitted_func(arg1=var1, arg2=var2)``. For example,
-
-    >>> def f(a, b, c=1.):
-    >>>   if c > 0.: return a + b
-    >>>   else: return a * b
-    >>>
-    >>> # ERROR! https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#python-control-flow-jit
-    >>> bm.jit(f)(1, 2, 0)
-    jax._src.errors.ConcretizationTypeError: Abstract tracer value encountered where
-    concrete value is expected: Traced<ShapedArray(bool[], weak_type=True)
-    >>> # this is right
-    >>> bm.jit(f, static_argnames='c')(1, 2, 0)
-    DeviceArray(2, dtype=int32, weak_type=True)
+  This function has the same ability to just-in-time compile a pure function,
+  but it can also JIT compile a :py:class:`brainpy.DynamicalSystem`, or a
+  :py:class:`brainpy.BrainPyObject` object.
 
   Examples
   --------
 
-  You can JIT a :py:class:`brainpy.DynamicalSystem`
+  You can JIT any object in which all dynamical variables are defined as :py:class:`~.Variable`.  
 
   >>> import brainpy as bp
-  >>>
-  >>> class LIF(bp.NeuGroup):
-  >>>   pass
-  >>> lif = bp.math.jit(LIF(10))
-
-  You can JIT a :py:class:`brainpy.Base` object with ``__call__()`` implementation.
-
-  >>> mlp = bp.layers.GRU(100, 200)
-  >>> jit_mlp = bp.math.jit(mlp)
-
-  You can also JIT a bounded method of a :py:class:`brainpy.Base` object.
-
   >>> class Hello(bp.BrainPyObject):
   >>>   def __init__(self):
   >>>     super(Hello, self).__init__()
   >>>     self.a = bp.math.Variable(bp.math.array(10.))
   >>>     self.b = bp.math.Variable(bp.math.array(2.))
   >>>   def transform(self):
-  >>>     return self.a ** self.b
+  >>>     self.a *= self.b
   >>>
   >>> test = Hello()
   >>> bp.math.jit(test.transform)
 
   Further, you can JIT a normal function, just used like in JAX.
 
   >>> @bp.math.jit
   >>> def selu(x, alpha=1.67, lmbda=1.05):
   >>>   return lmbda * bp.math.where(x > 0, x, alpha * bp.math.exp(x) - alpha)
 
 
   Parameters
   ----------
-  func : Base, function, callable
-    The instance of Base or a function.
+  {jit_par}
   dyn_vars : optional, dict, sequence of Variable, Variable
     These variables will be changed in the function, or needed in the computation.
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``dyn_vars``. This function is capable of automatically
+       collecting the dynamical variables used in the target ``func``.
   child_objs: optional, dict, sequence of BrainPyObject, BrainPyObject
     The children objects used in the target function.
 
     .. versionadded:: 2.3.1
-  static_argnames : optional, str, list, tuple, dict
-    An optional string or collection of strings specifying which named arguments to treat
-    as static (compile-time constant). See the comment on ``static_argnums`` for details.
-    If not provided but ``static_argnums`` is set, the default is based on calling
-    ``inspect.signature(fun)`` to find corresponding named arguments.
-  device: optional, Any
-    This is an experimental feature and the API is likely to change.
-    Optional, the Device the jitted function will run on. (Available devices
-    can be retrieved via :py:func:`jax.devices`.) The default is inherited
-    from XLA's DeviceAssignment logic and is usually to use
-    ``jax.devices()[0]``.
+
+    .. deprecated:: 2.4.0
+       No longer need to provide ``child_objs``. This function is capable of automatically
+       collecting the children objects used in the target ``func``.
 
   Returns
   -------
-  func : callable
+  func : JITTransform
     A callable jitted function, set up for just-in-time compilation.
   """
+
+  dynvar_deprecation(dyn_vars)
+  node_deprecation(child_objs)
+  if dyn_vars is not None:
+    dyn_vars = check.is_all_vars(dyn_vars, out_as='dict')
+  if child_objs is not None:
+    child_objs = check.is_all_objs(child_objs, out_as='dict')
+
   if func is None:
-    return lambda f: _jit(func=f,
-                          dyn_vars=dyn_vars,
-                          child_objs=child_objs,
-                          static_argnums=static_argnums,
-                          static_argnames=static_argnames,
-                          device=device,
-                          inline=inline,
-                          keep_unused=keep_unused,
-                          abstracted_axes=abstracted_axes)
+    return lambda f: JITTransform(fun=f,
+                                  dyn_vars=dyn_vars,
+                                  child_objs=child_objs,
+                                  static_argnums=static_argnums,
+                                  static_argnames=static_argnames,
+                                  donate_argnums=donate_argnums,
+                                  device=device,
+                                  inline=inline,
+                                  keep_unused=keep_unused,
+                                  backend=backend,
+                                  abstracted_axes=abstracted_axes,
+                                  **kwargs)
   else:
-    return _jit(func=func,
-                dyn_vars=dyn_vars,
-                child_objs=child_objs,
-                static_argnums=static_argnums,
-                static_argnames=static_argnames,
-                device=device,
-                inline=inline,
-                keep_unused=keep_unused,
-                abstracted_axes=abstracted_axes)
+    return JITTransform(fun=func,
+                        dyn_vars=dyn_vars,
+                        child_objs=child_objs,
+                        static_argnums=static_argnums,
+                        static_argnames=static_argnames,
+                        donate_argnums=donate_argnums,
+                        device=device,
+                        inline=inline,
+                        keep_unused=keep_unused,
+                        backend=backend,
+                        abstracted_axes=abstracted_axes,
+                        **kwargs)
+
+
+jit.__doc__ = jit.__doc__.format(jit_par=_jit_par.strip())
+
+
+def cls_jit(
+    func: Callable = None,
+    static_argnums: Union[int, Iterable[int], None] = None,
+    static_argnames: Union[str, Iterable[str], None] = None,
+    device: Optional[Any] = None,
+    inline: bool = False,
+    keep_unused: bool = False,
+    abstracted_axes: Optional[Any] = None,
+    **kwargs
+) -> Callable:
+  """Just-in-time compile a function and then the jitted function as the bound method for a class.
+  
+  Examples
+  --------
+  
+  This transformation can be put on any class function. For example,
+  
+  >>> import brainpy as bp
+  >>> import brainpy.math as bm
+  >>>
+  >>> class SomeProgram(bp.BrainPyObject):
+  >>>   def __init__(self):
+  >>>      super(SomeProgram, self).__init__()
+  >>>      self.a = bm.zeros(2)
+  >>>      self.b = bm.Variable(bm.ones(2))
+  >>> 
+  >>>   @bm.cls_jit(inline=True)
+  >>>   def __call__(self, *args, **kwargs):
+  >>>      a = bm.random.uniform(size=2)
+  >>>      a = a.at[0].set(1.)
+  >>>      self.b += a
+  >>>
+  >>> program = SomeProgram()
+  >>> program()
+  
+  Parameters
+  ----------
+  {jit_pars}
+
+  Returns
+  -------
+  func : JITTransform
+    A callable jitted function, set up for just-in-time compilation.
+  """
+  if func is None:
+    return lambda f: _make_jit_fun(fun=f,
+                                   static_argnums=static_argnums,
+                                   static_argnames=static_argnames,
+                                   device=device,
+                                   inline=inline,
+                                   keep_unused=keep_unused,
+                                   abstracted_axes=abstracted_axes,
+                                   **kwargs)
+  else:
+    return _make_jit_fun(fun=func,
+                         static_argnums=static_argnums,
+                         static_argnames=static_argnames,
+                         device=device,
+                         inline=inline,
+                         keep_unused=keep_unused,
+                         abstracted_axes=abstracted_axes,
+                         **kwargs)
+
+
+cls_jit.__doc__ = cls_jit.__doc__.format(jit_pars=_jit_par)
+
+
+def _make_jit_fun(
+    fun: Callable,
+    static_argnums: Union[int, Iterable[int], None] = None,
+    static_argnames: Union[str, Iterable[str], None] = None,
+    device: Optional[Any] = None,
+    inline: bool = False,
+    keep_unused: bool = False,
+    abstracted_axes: Optional[Any] = None,
+    **jit_kwargs
+):
+  static_argnums = _seq_of_int(static_argnums)
+  static_argnames = _seq_of_int(static_argnames)
+
+  @wraps(fun)
+  def call_fun(self, *args, **kwargs):
+    fun2 = partial(fun, self)
+    if jax.config.jax_disable_jit:
+      return fun2(*args, **kwargs)
+
+    hash_v = hash(fun) + hash(self)
+    cache = get_stack_cache(hash_v)  # TODO: better cache mechanism
+    if cache is None:
+      with jax.ensure_compile_time_eval():
+        if len(static_argnums) or len(static_argnames):
+          fun3, args_, kwargs_ = _partial_fun(fun2, args, kwargs, static_argnums, static_argnames)
+        else:
+          args_, kwargs_, fun3 = args, kwargs, fun2
+        with VariableStack() as stack:
+          _ = jax.eval_shape(fun3, *args_, **kwargs_)
+        del args_, kwargs_
+      _transform = jax.jit(
+        _make_transform(fun2, stack),
+        static_argnums=jax.tree_util.tree_map(lambda a: a + 1, static_argnums),
+        static_argnames=static_argnames,
+        device=device,
+        inline=inline,
+        keep_unused=keep_unused,
+        abstracted_axes=abstracted_axes,
+        **jit_kwargs
+      )
+      cache_stack(hash_v, (stack, _transform))  # cache "variable stack" and "transform function"
+
+    else:
+      stack, _transform = cache
+    del cache
+    out, changes = _transform(stack.dict_data(), *args, **kwargs)
+    for key, v in stack.items():
+      v._value = changes[key]
+    return out
+
+  return call_fun
+
+
+def _make_transform(fun, stack):
+
+  @wraps(fun)
+  def _transform_function(variable_data: dict, *args, **kwargs):
+    for key, v in stack.items():
+      v._value = variable_data[key]
+    out = fun(*args, **kwargs)
+    changes = stack.dict_data()
+    return out, changes
+
+  return _transform_function
```

## brainpy/_src/math/object_transform/parallels.py

```diff
@@ -23,15 +23,15 @@
 except ImportError:
   from jax.core import UnexpectedTracerError
 
 from brainpy import errors
 from brainpy._src.math.random import RandomState
 from brainpy._src.math.ndarray import Array
 from brainpy.tools import change_func_name
-from .base import BrainPyObject, DynVarCollector
+from .base import BrainPyObject, ArrayCollector
 
 __all__ = [
   'vmap',
   'pmap',
 ]
 
 
@@ -212,15 +212,15 @@
       if isinstance(dyn_vars, Array):
         dyn_vars = [dyn_vars]
       if isinstance(dyn_vars, (tuple, list)):
         dyn_vars = {f'_vmap_v{i}': v for i, v in enumerate(dyn_vars)}
       assert isinstance(dyn_vars, dict)
 
       # dynamical variables
-      _dyn_vars, _rand_vars = DynVarCollector(), DynVarCollector()
+      _dyn_vars, _rand_vars = ArrayCollector(), ArrayCollector()
       for key, val in dyn_vars.items():
         if isinstance(val, RandomState):
           _rand_vars[key] = val
         else:
           _dyn_vars[key] = val
 
       # in axes
@@ -414,16 +414,16 @@
                       devices=devices,
                       backend=backend,
                       axis_size=axis_size,
                       donate_argnums=donate_argnums,
                       global_arg_shapes=global_arg_shapes)
     else:
       # dynamical variables
-      dyn_vars = DynVarCollector()
-      rand_vars = DynVarCollector()
+      dyn_vars = ArrayCollector()
+      rand_vars = ArrayCollector()
       for key, val in dyn_vars.items():
         if isinstance(val, RandomState):
           rand_vars[key] = val
         else:
           dyn_vars[key] = val
 
       # static broadcast-ed arguments
```

## brainpy/_src/math/operators/pre_syn_post.py

```diff
@@ -1,14 +1,14 @@
 # -*- coding: utf-8 -*-
 
 
 import jax.numpy as jnp
 from jax import vmap, jit, ops as jops
 
-from brainpy._src.math.arrayinterporate import as_jax
+from brainpy._src.math.interoperability import as_jax
 from brainpy._src.math.operators import event_ops
 from brainpy.errors import MathError
 from brainpy._src import tools
 
 __all__ = [
   # pre-to-post
   'pre2post_sum',
```

## brainpy/_src/math/operators/sparse_ops.py

```diff
@@ -4,15 +4,15 @@
 from typing import Tuple
 from typing import Union, Dict
 
 import jax.numpy as jnp
 from jax import ops
 
 from brainpy._src import tools
-from brainpy._src.math.arrayinterporate import as_jax
+from brainpy._src.math.interoperability import as_jax
 from brainpy._src.math.ndarray import Array
 
 __all__ = [
   'cusparse_csr_matvec',
   'cusparse_coo_matvec',
   'csr_matvec',
   'sparse_matmul',
```

## brainpy/_src/math/surrogate/compt.py

```diff
@@ -1,15 +1,15 @@
 # -*- coding: utf-8 -*-
 
 import warnings
 
 from jax import custom_gradient, numpy as jnp
 
 from brainpy._src.math.compat_numpy import asarray
-from brainpy._src.math.arrayinterporate import as_jax
+from brainpy._src.math.interoperability import as_jax
 from brainpy._src.math.environment import get_float
 from brainpy._src.math.ndarray import Array
 
 __all__ = [
   'spike_with_sigmoid_grad',
   'spike_with_linear_grad',
   'spike_with_gaussian_grad',
```

## brainpy/_src/math/surrogate/one_input.py

```diff
@@ -4,15 +4,15 @@
 import math
 from typing import Union
 
 import jax
 import jax.numpy as jnp
 import jax.scipy as sci
 
-from brainpy._src.math.arrayinterporate import as_jax
+from brainpy._src.math.interoperability import as_jax
 from brainpy._src.math.ndarray import Array
 from ._utils import vjp_custom
 
 __all__ = [
   'sigmoid',
   'piecewise_quadratic',
   'piecewise_exp',
```

## brainpy/_src/math/surrogate/two_inputs.py

```diff
@@ -2,15 +2,15 @@
 
 
 from typing import Union
 
 import jax
 import jax.numpy as jnp
 
-from brainpy._src.math.arrayinterporate import as_jax
+from brainpy._src.math.interoperability import as_jax
 from brainpy._src.math.ndarray import Array
 from ._utils import vjp_custom
 
 __all__ = [
   'inv_square_grad2',
   'relu_grad2',
 ]
```

## brainpy/_src/measure/correlation.py

```diff
@@ -85,15 +85,15 @@
   if method == 'loop':
     def _f(i, j):
       sqrt_ij = jnp.sqrt(jnp.sum(states[i]) * jnp.sum(states[j]))
       return lax.cond(sqrt_ij == 0.,
                       lambda _: 0.,
                       lambda _: jnp.sum(states[i] * states[j]) / sqrt_ij,
                       None)
-    res = bm.for_loop(_f, dyn_vars=[], operands=indices)
+    res = bm.for_loop(_f, operands=indices)
 
   elif method == 'vmap':
     @vmap
     def _cc(i, j):
       sqrt_ij = jnp.sqrt(jnp.sum(states[i]) * jnp.sum(states[j]))
       return lax.cond(sqrt_ij == 0.,
                       lambda _: 0.,
@@ -174,15 +174,14 @@
 
   potentials = bm.as_jax(potentials)
   avg = jnp.mean(potentials, axis=1)
   avg_var = jnp.mean(avg * avg) - jnp.mean(avg) ** 2
 
   if method == 'loop':
     _var = lambda aa: bm.for_loop(lambda signal: jnp.mean(signal * signal) - jnp.mean(signal) ** 2,
-                                  dyn_vars=(),
                                   operands=jnp.moveaxis(aa, 0, 1))
 
   elif method == 'vmap':
     _var = vmap(lambda signal: jnp.mean(signal * signal) - jnp.mean(signal) ** 2, in_axes=1)
   else:
     raise UnsupportedError(f'Do not support {method}. We only support "loop" or "vmap".')
```

## brainpy/_src/optimizers/optimizer.py

```diff
@@ -4,15 +4,15 @@
 from typing import Union, Sequence, Dict, Optional, Tuple
 
 import jax.numpy as jnp
 from jax.lax import cond
 
 import brainpy.math as bm
 from brainpy import check
-from brainpy._src.math.object_transform.base import BrainPyObject, DynVarCollector
+from brainpy._src.math.object_transform.base import BrainPyObject, ArrayCollector
 from brainpy.errors import MathError
 from .scheduler import make_schedule, Scheduler
 
 __all__ = [
   'Optimizer',
   'SGD',
   'Momentum',
@@ -35,26 +35,26 @@
   lr: float, Scheduler
     learning rate.
   """
 
   lr: Scheduler  # learning rate
   '''Learning rate'''
 
-  vars_to_train: DynVarCollector  # variables to train
+  vars_to_train: ArrayCollector  # variables to train
   '''Variables to train.'''
 
   def __init__(
       self,
       lr: Union[float, Scheduler],
       train_vars: Union[Sequence[bm.Variable], Dict[str, bm.Variable]] = None,
       name: Optional[str] = None
   ):
     super(Optimizer, self).__init__(name=name)
     self.lr: Scheduler = make_schedule(lr)
-    self.vars_to_train = DynVarCollector()
+    self.vars_to_train = ArrayCollector()
     self.register_train_vars(train_vars)
 
   def register_vars(self, train_vars: Optional[Dict[str, bm.Variable]] = None):
     warnings.warn('Using "register_train_vars()" instead.', UserWarning)
     self.register_train_vars(train_vars)
 
   def register_train_vars(self, train_vars: Optional[Dict[str, bm.Variable]] = None):
@@ -78,15 +78,15 @@
       lr: Union[float, Scheduler],
       train_vars: Union[Sequence[bm.Variable], Dict[str, bm.Variable]] = None,
       weight_decay: Optional[float] = None,
       name: Optional[str] = None
   ):
     super(Optimizer, self).__init__(name=name)
     self.lr: Scheduler = make_schedule(lr)
-    self.vars_to_train = DynVarCollector()
+    self.vars_to_train = ArrayCollector()
     self.register_train_vars(train_vars)
     self.weight_decay = check.is_float(weight_decay, min_bound=0., max_bound=1., allow_none=True)
 
 
 class SGD(CommonOpt):
   r"""Stochastic gradient descent optimizer.
```

## brainpy/_src/optimizers/scheduler.py

```diff
@@ -134,15 +134,15 @@
       last_epoch: int = -1
   ):
     super().__init__(lr=lr, last_epoch=last_epoch)
 
     self.milestones = check.is_sequence(milestones, elem_type=int, allow_none=False)
     self.gamma = check.is_float(gamma, min_bound=0., max_bound=1., allow_int=False)
 
-  @partial(jax.jit, inline=True)
+  @bm.cls_jit(inline=True)
   def __call__(self, i=None):
     i = (self.last_epoch.value + 1) if i is None else i
     p = bm.ifelse([i < m for m in self.milestones],
                   list(range(0, len(self.milestones))) + [len(self.milestones)])
     return self.lr * self.gamma ** p
 
   def __repr__(self):
@@ -201,15 +201,15 @@
                last_epoch: int = -1, ):
     super().__init__(lr=lr, last_epoch=last_epoch)
 
     self._init_epoch = last_epoch
     self.T_max = check.is_integer(T_max, min_bound=1)
     self.eta_min = eta_min
 
-  @jax.jit
+  @bm.cls_jit(inline=True)
   def __call__(self, i=None):
     i = (self.last_epoch + 1) if i is None else i
     return (self.eta_min + (self.lr - self.eta_min) *
             (1 + jnp.cos(jnp.pi * i / self.T_max)) / 2)
 
 
 class CosineAnnealingWarmRestarts(CallBasedScheduler):
@@ -276,25 +276,25 @@
       T_cur = epoch - self.T_0 * (self.T_mult ** n - 1) / (self.T_mult - 1)
       T_i = self.T_0 * self.T_mult ** n
     return T_cur, T_i
 
   def _cond2(self, epoch):
     return epoch, self.T_0
 
-  @partial(jax.jit, inline=True)
+  @bm.cls_jit(inline=True)
   def __call__(self, i=None):
     i = (self.last_call + 1) if i is None else i
     epoch = i / self.num_call_per_epoch
     T_cur, T_i = jax.lax.cond(epoch >= self.T_0,
                               self._cond1,
                               self._cond2,
                               epoch)
     return self.eta_min + (self.lr - self.eta_min) * (1 + jnp.cos(jnp.pi * T_cur / T_i)) / 2
 
-  @jax.jit
+  @bm.cls_jit(inline=True)
   def current_epoch(self, i=None):
     i = (self.last_call + 1) if i is None else i
     return jnp.floor(i / self.num_call_per_epoch)
 
 
 class ExponentialLR(Scheduler):
   """Decays the learning rate of each parameter group by gamma every epoch.
```

## brainpy/_src/tools/__init__.py

```diff
@@ -2,8 +2,7 @@
 
 from .codes import *
 from .others import *
 from .dicts import *
 from .others import *
 from .package import *
 from .math_util import *
-from .naming import *
```

## brainpy/_src/train/back_propagation.py

```diff
@@ -432,32 +432,26 @@
       shared_args = dict()
     shared_args2 = {k: v for k, v in shared_args.items()}
     shared_args2['_local_jit_'] = jit
     shared_args_str = serialize_kwargs(shared_args2)
     if shared_args_str not in self._f_loss_compiled:
       self._f_loss_compiled[shared_args_str] = partial(self._step_func_loss, shared_args)
       if self.jit[c.LOSS_PHASE] and jit:
-        dyn_vars = self.target.vars()
-        dyn_vars.update(self._dyn_vars)
-        dyn_vars.update(self.vars(level=0))
-        self._f_loss_compiled[shared_args_str] = bm.jit(self._f_loss_compiled[shared_args_str],
-                                                        dyn_vars=dyn_vars.unique())
+        self._f_loss_compiled[shared_args_str] = bm.jit(self._f_loss_compiled[shared_args_str])
     return self._f_loss_compiled[shared_args_str]
 
   def _get_f_grad(self, shared_args=None) -> Callable:
     """Get gradient function."""
     shared_args_str = serialize_kwargs(shared_args)
     if shared_args_str not in self._f_grad_compiled:
       _f_loss_internal = self._get_f_loss(shared_args, jit=False)
       dyn_vars = self.target.vars()
       dyn_vars.update(self._dyn_vars)
-      dyn_vars = dyn_vars.unique()
-      tran_vars = dyn_vars.subset(bm.TrainVar)
+      tran_vars = dyn_vars.subset(bm.TrainVar).unique()
       grad_f = bm.grad(_f_loss_internal,
-                       dyn_vars=dyn_vars,
                        grad_vars=tran_vars,
                        return_value=True,
                        has_aux=self.loss_has_aux)
       self._f_grad_compiled[shared_args_str] = grad_f
     return self._f_grad_compiled[shared_args_str]
 
   def _get_f_train(self, shared_args=None) -> Callable:
@@ -474,16 +468,15 @@
         dyn_vars = self.target.vars()
         dyn_vars.update(self.optimizer.vars())
         if isinstance(self._loss_func, BrainPyObject):
           dyn_vars.update(self._loss_func)
         dyn_vars.update(self._dyn_vars)
         dyn_vars.update(self.vars(level=0))
         dyn_vars = dyn_vars.unique()
-        self._f_fit_compiled[shared_args_str] = bm.jit(self._f_fit_compiled[shared_args_str],
-                                                       dyn_vars=dyn_vars)
+        self._f_fit_compiled[shared_args_str] = bm.jit(self._f_fit_compiled[shared_args_str])
     return self._f_fit_compiled[shared_args_str]
 
   def _step_func_loss(self, shared_args, inputs, targets):
     raise NotImplementedError
 
   def _step_func_fit(self, shared_args, inputs, targets):
     raise NotImplementedError
@@ -598,19 +591,15 @@
     shared_args2 = {k: v for k, v in shared_args.items()}
     shared_args2['_local_jit_'] = jit
     shared_args_str = serialize_kwargs(shared_args)
     if shared_args_str not in self._f_predict_compiled:
 
       self._f_predict_compiled[shared_args_str] = partial(self._step_func_predict, shared_args)
       if self.jit[c.PREDICT_PHASE] and jit:
-        dyn_vars = self.target.vars()
-        dyn_vars.update(self._dyn_vars)
-        dyn_vars = dyn_vars - dyn_vars.subset(bm.VariableView)
-        self._f_predict_compiled[shared_args_str] = bm.jit(self._f_predict_compiled[shared_args_str],
-                                                           dyn_vars=dyn_vars.unique())
+        self._f_predict_compiled[shared_args_str] = bm.jit(self._f_predict_compiled[shared_args_str])
     return self._f_predict_compiled[shared_args_str]
 
   def predict(
       self,
       inputs: Union[ArrayType, Sequence[ArrayType], Dict[str, ArrayType]],
       reset_state: bool = True,
       shared_args: Dict = None,
```

## brainpy/_src/train/offline.py

```diff
@@ -203,15 +203,15 @@
     """Get training function."""
     shared_args = dict() if shared_args is None else shared_args
     shared_kwargs_str = serialize_kwargs(shared_args)
     if shared_kwargs_str not in self._f_fit_compiled:
       self._f_fit_compiled[shared_kwargs_str] = (
         self._fun_train
         if self.jit['fit'] else
-        bm.jit(self._fun_train, dyn_vars=self.vars().unique())
+        bm.jit(self._fun_train)
       )
     return self._f_fit_compiled[shared_kwargs_str]
 
   def _fun_train(self, monitor_data: Dict[str, ArrayType], target_data: Dict[str, ArrayType]):
     for node in self.train_nodes:
       fit_record = monitor_data[f'{node.name}-fit_record']
       targets = target_data[node.name]
```

## brainpy/_src/train/online.py

```diff
@@ -235,22 +235,19 @@
                      is_leaf=lambda x: isinstance(x, bm.Array))
     return hists
 
   def _get_fit_func(self, shared_args: Dict = None):
     if shared_args is None: shared_args = dict()
     shared_kwargs_str = serialize_kwargs(shared_args)
     if shared_kwargs_str not in self._f_fit_compiled:
-      dyn_vars = self.vars().unique()
-      dyn_vars = dyn_vars - dyn_vars.subset(bm.VariableView)
-
+      @bm.jit
       def run_func(all_inputs):
-        with jax.disable_jit(not self.jit['fit']):
-          return bm.for_loop(partial(self._step_func_fit, shared_args),
-                             all_inputs,
-                             dyn_vars=dyn_vars)
+        return bm.for_loop(partial(self._step_func_fit, shared_args),
+                           all_inputs,
+                           jit=self.jit['fit'])
 
       self._f_fit_compiled[shared_kwargs_str] = run_func
     return self._f_fit_compiled[shared_kwargs_str]
 
   def _step_func_fit(self, shared_args, t, i, x, ys):
     shared = tools.DotDict(t=t, dt=self.dt, i=i)
     shared.update(shared_args)
```

## brainpy/math/__init__.py

```diff
@@ -1,25 +1,29 @@
 # -*- coding: utf-8 -*-
 
 
 # data structure
 from .ndarray import *
 from .delayvars import *
-from .arrayinterporate import *
+from .interoperability import *
 from .datatypes import *
 from .compat_numpy import *
 from .compat_tensorflow import *
 from .compat_pytorch import *
 
 # functions
 from .activations import *
 from . import activations
 
 # operators
-from .operators import *
+from .event_ops import *
+from .jitconn_ops import *
+from .pre_syn_post import *
+from .sparse_ops import *
+from .op_register import *
 from . import surrogate
 
 # Variable and Objects for object-oriented JAX transformations
 from .object_base import *
 from .object_transform import *
 
 # environment settings
@@ -56,10 +60,8 @@
 from . import random
 
 from brainpy._src.math.surrogate.compt import (
   spike_with_sigmoid_grad as spike_with_sigmoid_grad,
   spike_with_linear_grad as spike_with_linear_grad,
   spike_with_gaussian_grad as spike_with_gaussian_grad,
   spike_with_mg_grad as spike_with_mg_grad,
-  spike2_with_sigmoid_grad as spike2_with_sigmoid_grad,
-  spike2_with_linear_grad as spike2_with_linear_grad,
 )
```

## brainpy/math/environment.py

```diff
@@ -1,27 +1,29 @@
 # -*- coding: utf-8 -*-
 
 from brainpy._src.math.environment import (
+  environment as environment,
+  batching_environment as batching_environment,
+  training_environment as training_environment,
+  set as set,
+  set_environment as set_environment,
+
   set_float as set_float,
   get_float as get_float,
   set_int as set_int,
   get_int as get_int,
   set_bool as set_bool,
   get_bool as get_bool,
   set_complex as set_complex,
   get_complex as get_complex,
   set_dt as set_dt,
   get_dt as get_dt,
   set_mode as set_mode,
   get_mode as get_mode,
-  environment as environment,
-  batching_environment as batching_environment,
-  training_environment as training_environment,
-  set as set,
-  set_environment as set_environment,
+
   enable_x64 as enable_x64,
   disable_x64 as disable_x64,
   set_platform as set_platform,
   get_platform as get_platform,
   set_host_device_count as set_host_device_count,
   clear_buffer_memory as clear_buffer_memory,
   enable_gpu_memory_preallocation as enable_gpu_memory_preallocation,
```

## brainpy/math/ndarray.py

```diff
@@ -1,9 +1,8 @@
 # -*- coding: utf-8 -*-
 
 from brainpy._src.math.ndarray import (
   Array as Array,
   Array as Tensor,
   ndarray as ndarray,
   JaxArray as JaxArray,
-  VariableView as VariableView,
 )
```

## brainpy/math/object_base.py

```diff
@@ -1,14 +1,16 @@
 # -*- coding: utf-8 -*-
 
 from brainpy._src.math.object_transform.base import (BrainPyObject as BrainPyObject,
                                                      FunAsObject as FunAsObject)
-from brainpy._src.math.object_transform.base import (NodeList,
-                                                     NodeDict,
-                                                     ListVar,
-                                                     DictVar, )
-from brainpy._src.math.ndarray import (Variable as Variable,
-                                       Parameter as Parameter,
-                                       TrainVar as TrainVar)
-from brainpy._src.math.object_transform.function import (
-  Partial as Partial,
-)
+from brainpy._src.math.object_transform.function import (Partial as Partial)
+from brainpy._src.math.object_transform.base import (NodeList as NodeList,
+                                                     NodeDict as NodeDict,)
+from brainpy._src.math.object_transform.variables import (Variable as Variable,
+                                                          Parameter as Parameter,
+                                                          TrainVar as TrainVar,
+                                                          VariableView as VariableView,
+                                                          VarList as VarList,
+                                                          VarDict as VarDict,)
+
+
+
```

## brainpy/math/object_transform.py

```diff
@@ -5,30 +5,28 @@
   vector_grad as vector_grad,
   jacobian as jacobian,
   jacrev as jacrev,
   jacfwd as jacfwd,
   hessian as hessian,
 )
 
-from brainpy._src.math.object_transform.abstract import (
-  ObjectTransform as ObjectTransform
-)
-
 from brainpy._src.math.object_transform.controls import (
   make_loop as make_loop,
   make_while as make_while,
   make_cond as make_cond,
   cond as cond,
   ifelse as ifelse,
   for_loop as for_loop,
   while_loop as while_loop,
 )
 
-from brainpy._src.math.object_transform.function import (
-  to_object as to_object,
-  function as function,
-)
 
 from brainpy._src.math.object_transform.jit import (
   jit as jit,
+  cls_jit as cls_jit,
 )
 
+
+from brainpy._src.math.object_transform.function import (
+  to_object as to_object,
+  function as function,
+)
```

## brainpy/math/others.py

```diff
@@ -1,7 +1,11 @@
 # -*- coding: utf-8 -*-
 
 from brainpy._src.math.others import (
   shared_args_over_time as shared_args_over_time,
   remove_diag as remove_diag,
   clip_by_norm as clip_by_norm,
 )
+
+from brainpy._src.math.object_transform.naming import (
+  clear_name_cache,
+)
```

## Comparing `brainpy/_src/math/arrayinterporate.py` & `brainpy/_src/math/interoperability.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 # -*- coding: utf-8 -*-
 
 import jax.numpy as jnp
 import numpy as np
 
-from .ndarray import Array, Variable
+from .ndarray import Array
+
 
 __all__ = [
   'as_device_array', 'as_jax', 'as_ndarray', 'as_numpy', 'as_variable',
 ]
 
 
 def _as_jax_array_(obj):
@@ -86,8 +87,9 @@
 
   Returns
   -------
   out : ndarray
     Array interpretation of `tensor`.  No copy is performed if the input
     is already an ndarray with matching dtype.
   """
+  from .object_transform.variables import Variable
   return Variable(tensor, dtype=dtype)
```

## Comparing `brainpy/_src/tools/naming.py` & `brainpy/_src/math/object_transform/naming.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,16 +1,15 @@
 # -*- coding: utf-8 -*-
 
 import warnings
-from brainpy import errors
-from brainpy import check
 
+from brainpy import errors
 
 __all__ = [
-  'check_name_uniqueness', 'get_unique_name', 'clear_name_cache',
+  'clear_name_cache',
 ]
 
 
 _name2id = dict()
 _typed_names = {}
 
 
@@ -46,7 +45,25 @@
   """Clear the cached names."""
   _name2id.clear()
   _typed_names.clear()
   if not ignore_warn:
     warnings.warn(f'All named models and their ids are cleared.', UserWarning)
 
 
+_fun2stack = dict()
+
+
+def cache_stack(func, stack):
+  _fun2stack[func] = stack
+
+
+def clear_stack_cache():
+  for k in tuple(_fun2stack.keys()):
+    del _fun2stack[k]
+
+
+def get_stack_cache(func):
+  if func in _fun2stack:
+    return _fun2stack[func]
+  else:
+    return None
+
```

## Comparing `brainpy-2.3.8.dist-info/LICENSE` & `brainpy-2.4.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `brainpy-2.3.8.dist-info/METADATA` & `brainpy-2.4.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: brainpy
-Version: 2.3.8
+Version: 2.4.0
 Summary: BrainPy: Brain Dynamics Programming in Python
 Home-page: https://github.com/brainpy/BrainPy
 Author: BrainPy Team
 Author-email: chao.brain@qq.com
 License: GPL-3.0 license
 Project-URL: Bug Tracker, https://github.com/brainpy/BrainPy/issues
 Project-URL: Documentation, https://brainpy.readthedocs.io/
@@ -15,14 +15,15 @@
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Topic :: Scientific/Engineering :: Bio-Informatics
 Classifier: Topic :: Scientific/Engineering :: Mathematics
 Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
 Classifier: Topic :: Software Development :: Libraries
 Requires-Python: >=3.7
```

### html2text {}

```diff
@@ -1,28 +1,28 @@
-Metadata-Version: 2.1 Name: brainpy Version: 2.3.8 Summary: BrainPy: Brain
+Metadata-Version: 2.1 Name: brainpy Version: 2.4.0 Summary: BrainPy: Brain
 Dynamics Programming in Python Home-page: https://github.com/brainpy/BrainPy
 Author: BrainPy Team Author-email: chao.brain@qq.com License: GPL-3.0 license
 Project-URL: Bug Tracker, https://github.com/brainpy/BrainPy/issues Project-
 URL: Documentation, https://brainpy.readthedocs.io/ Project-URL: Source Code,
 https://github.com/brainpy/BrainPy Keywords: computational neuroscience,brain-
 inspired computation,dynamical systems,differential equations,brain
 modeling,brain dynamics modeling,brain dynamics programming Platform: UNKNOWN
 Classifier: Natural Language :: English Classifier: Operating System :: OS
 Independent Classifier: Programming Language :: Python Classifier: Programming
 Language :: Python :: 3 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8 Classifier: Programming
 Language :: Python :: 3.9 Classifier: Programming Language :: Python :: 3.10
-Classifier: Intended Audience :: Science/Research Classifier: License :: OSI
-Approved :: Apache Software License Classifier: Topic :: Scientific/Engineering
-:: Bio-Informatics Classifier: Topic :: Scientific/Engineering :: Mathematics
-Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
-Classifier: Topic :: Software Development :: Libraries Requires-Python: >=3.7
-Description-Content-Type: text/markdown License-File: LICENSE Requires-Dist:
-jax (>=0.3.0) Requires-Dist: msgpack Requires-Dist: numpy (>=1.15) Requires-
-Dist: tqdm
+Classifier: Programming Language :: Python :: 3.11 Classifier: Intended
+Audience :: Science/Research Classifier: License :: OSI Approved :: Apache
+Software License Classifier: Topic :: Scientific/Engineering :: Bio-Informatics
+Classifier: Topic :: Scientific/Engineering :: Mathematics Classifier: Topic ::
+Scientific/Engineering :: Artificial Intelligence Classifier: Topic :: Software
+Development :: Libraries Requires-Python: >=3.7 Description-Content-Type: text/
+markdown License-File: LICENSE Requires-Dist: jax (>=0.3.0) Requires-Dist:
+msgpack Requires-Dist: numpy (>=1.15) Requires-Dist: tqdm
        [Header image of BrainPy - brain dynamics programming in Python.]
 [Supported_Python_Version] [LICENSE] [Documentation] [PyPI_version] [Linux_CI]
                             [Windows_CI] [MacOS_CI]
 BrainPy is a flexible, efficient, and extensible framework for computational
 neuroscience and brain-inspired computation based on the Just-In-Time (JIT)
 compilation (built on top of [JAX](https://github.com/google/jax), [Numba]
 (https://github.com/numba/numba), and other JIT compilers). It provides an
```

## Comparing `brainpy-2.3.8.dist-info/RECORD` & `brainpy-2.4.0.dist-info/RECORD`

 * *Files 4% similar despite different names*

```diff
@@ -1,14 +1,14 @@
-brainpy/__init__.py,sha256=63OBmlGArCL3blYkWqzlDgp9B5mwxDbae3I365_kDHQ,9508
+brainpy/__init__.py,sha256=lu_oUaavc9U3gvA-55H7NZmmMvjJypZaonZy_FYZ4Vo,9247
 brainpy/analysis.py,sha256=1F9j_gVbbZeE4vbtnWm3aZQnsiRFQH5jawh8idpUI54,661
 brainpy/channels.py,sha256=_IghoZjZTtLWzb8eT6iCBY2zjZOLuRuo8FuQ51DAJgs,1308
-brainpy/check.py,sha256=-zxjNKWfQ9PuYafsgHv1OsCQB_KbrpLWqSFX7Mri_Gg,18712
+brainpy/check.py,sha256=E1quhDXU2npIgMgtF0Rj36wL-yIPzCCqG3svWhjSFWA,18712
 brainpy/checkpoints.py,sha256=QPhbn5QQC2a7lXiqQ3GQD70l0c_6-QRvP9TtXkSR21s,245
 brainpy/connect.py,sha256=xlZkOkM01D0DbtjbqNl5sCpbUQEpFT0cHeCcbfXTdXA,1243
-brainpy/dyn.py,sha256=7H9F8fSAC-FqTZGpDb-62j4Lyp9z7eEkqPl2UZJlY8M,144
+brainpy/dyn.py,sha256=wINlpjXo_hAN1eBoq8rDbsPurlTmLS-ng8JEqok4zBI,154
 brainpy/encoding.py,sha256=UAr-ouj1z3kktUUZUL79YL1TxkCI6cL0LhE4DiEAW2Q,324
 brainpy/errors.py,sha256=THoU1VxtWbvFH4Ijs2e97LKKg8190NF-QevhUayasY4,8306
 brainpy/experimental.py,sha256=Mln_QBtd3fD0ONY8p-nhXvk0sw5a5nGMEbH_eaajHzw,350
 brainpy/initialize.py,sha256=Vh-Oao7TunLnXLNLlhTJlAfVKWQ-2tLMNThBCj_g68E,1123
 brainpy/inputs.py,sha256=EieFIsSPhoYdC8w8RSFgDPHO8gpphZZqS1z3JOP58Q0,335
 brainpy/layers.py,sha256=ii9NAWoZWQUdjQ6x9oFbZnYiHMdx2agc1sbR26ti260,1890
 brainpy/losses.py,sha256=XKVUmkogSaZ5YXHob3zxu_nd2dWezWb3KzGlgMsZF0c,963
@@ -18,61 +18,61 @@
 brainpy/optim.py,sha256=ShG_NXD334Ns_wqh0L7e-sINzTEoPW7hLI1B-j8Clhs,1013
 brainpy/rates.py,sha256=viLA85gOdh_Ytq0DOr_PtcZJ6c66uoWYYCcY0IXvAcI,303
 brainpy/running.py,sha256=ZGjJH40qBJjNzo9WWuyd9CrMf1vNFd27cN9qwPoDnnw,466
 brainpy/synapses.py,sha256=rNS9-iVD9OVFtHu2qy1LAMa0tcmgUbTrDMLyJNHELhA,612
 brainpy/synouts.py,sha256=xwEH6cOzC9NuWPvogFI7DewmPmW7MGw6A33laQELtpk,180
 brainpy/synplast.py,sha256=yYoUV58coEBONG5nJqyfWL8eIt32kbeQgEFkbiDW6r8,117
 brainpy/testing.py,sha256=4unb3IJCji-0CO5PaZsP_9727UnKlbOEoJmTthCPFK8,51
-brainpy/tools.py,sha256=ZICeGf9veNzMg0XUKp3udx-HWCGqj20VIxj-kwPtRJY,1120
+brainpy/tools.py,sha256=3b1mi6rjbVibPNpjiuJJa1LovCZrYRKW_0ELGUgcepU,951
 brainpy/train.py,sha256=y18XPtDLwZFCCjyGUYfvt0TyAYxRip_U2ZuX6QWXutQ,72
 brainpy/types.py,sha256=R1V1eV0tSa8_0WDGkgEqg1ld7YVkSkbT6K2Z1aFGEsM,241
 brainpy/_src/__init__.py,sha256=iwhKnzeBJLKxpRVjvzwiRE63_zNpIBfaKLITauVph-0,24
 brainpy/_src/checking.py,sha256=XZcjpTOyjAVt2QEQVNWU4VVpUPS9hpi1mlIqHR03_Cw,924
 brainpy/_src/test_check.py,sha256=VyysbnG4CDSxE8cyogvnLD1HrLtIFtj0MQhq_hTGDIM,1359
-brainpy/_src/types.py,sha256=VjyjcV8bH3v3rCUSElFYSCZyeFv_znlLOP6rSPsC_hE,930
+brainpy/_src/types.py,sha256=YmZTriSbfJdQLLmq_y5VhRMFwfR7GVmaPq96wPHHbZw,976
 brainpy/_src/analysis/__init__.py,sha256=LvgnPFbrO99KqhQncgovd8qRSagRYjudppkyW3jjydk,846
 brainpy/_src/analysis/base.py,sha256=Elojhf3EVObjW0BHhXSivgrKO86lgYPDg-strF-Xefg,156
 brainpy/_src/analysis/constants.py,sha256=vh_jBcUaqVgsJWe8GxyJKMNOKa30F5ijPjj5BMjs2z0,1721
 brainpy/_src/analysis/plotstyle.py,sha256=3QPU2ZIHgEQtrXlr4-pKLy2NS4KXr8CiH9TLBGXblmY,3924
 brainpy/_src/analysis/stability.py,sha256=h6dY4j-zNI0r2nil5yHyVqkHErZcL6BYEtPUJ6s1yj0,5651
 brainpy/_src/analysis/highdim/__init__.py,sha256=VEjW7stN-EyTUIfh2bwZzMKip9N6TOrLtBtp7K5serA,52
-brainpy/_src/analysis/highdim/slow_points.py,sha256=e6k9V3Xt4Wy563Lh1vZh66M77xlIN4OZBhDsKbRYqVw,31123
+brainpy/_src/analysis/highdim/slow_points.py,sha256=cIc5C19rM5JZbuOlpg_h5mWZqqJt6ev20yVj-dRTGoA,30953
 brainpy/_src/analysis/lowdim/__init__.py,sha256=LmcgMjhR2WDLRlcGHiiVpYAKEDlHs-NF-XOT7B9Vi9M,93
-brainpy/_src/analysis/lowdim/lowdim_analyzer.py,sha256=0R18PZrqS8E5cFq5vcgMJtKIOV0WNiOk9nzkGI_UxHE,44705
-brainpy/_src/analysis/lowdim/lowdim_bifurcation.py,sha256=O7QnSiWj_afwuL-X2Mhabjw-aBONbOUO4Oj6l5vAQn4,24987
-brainpy/_src/analysis/lowdim/lowdim_phase_plane.py,sha256=rIV1rKhWv9ZpSkkSOnoF72jJ9n-K8Wh0Glg6chWlIqo,20261
+brainpy/_src/analysis/lowdim/lowdim_analyzer.py,sha256=wgDN3BM--mujrhazSyHHFEkM5FlXoH2zOeQUcj7W7bU,44742
+brainpy/_src/analysis/lowdim/lowdim_bifurcation.py,sha256=_YwjI6mq1I4d1RUKDiAGvBKLur_7VadSE6UMfdvlSdw,25000
+brainpy/_src/analysis/lowdim/lowdim_phase_plane.py,sha256=SUXjCKl-MyK1ugLDvprB-0dNLFWf596WfmN0NK8hZCw,20273
 brainpy/_src/analysis/utils/__init__.py,sha256=hsynCeksFHyhL0AMX3-IvPhcnVD0jjXAFO3G7K1UckM,199
 brainpy/_src/analysis/utils/function.py,sha256=bjVGfcoygD8HIrDLLpCcL1ii2i20rv9a-G6jVRodlJM,2840
 brainpy/_src/analysis/utils/measurement.py,sha256=w_CMQq7y0CDq_xzaxsC7yEIFKVSrNLF6CA1cQedUlc4,3054
-brainpy/_src/analysis/utils/model.py,sha256=DARELpYUazi-nAATJBhrZjhuN7TCW32mQxhuoKxwHw0,5295
-brainpy/_src/analysis/utils/optimization.py,sha256=rvK-pMxpiJ9mD_fDHoCfHby9--LHoySsfpYv68sgIF8,19551
-brainpy/_src/analysis/utils/others.py,sha256=BuS48V0eWk-yESx1eQbLuAmuH_rO3OrEFCwxLgschXk,5827
+brainpy/_src/analysis/utils/model.py,sha256=UJIfLbMyQcuM1V295W4EBXVCghVsLYMp0fpe8CL056w,5304
+brainpy/_src/analysis/utils/optimization.py,sha256=FuDKkx3pmoXZpoGRd22nsb0XoQBkHvaCq7xJRwFNDHw,19554
+brainpy/_src/analysis/utils/others.py,sha256=f64tjVHTrxnFQi6uN8RL4-sCuCzHpjn1GnvD3YbbEws,5822
 brainpy/_src/analysis/utils/outputs.py,sha256=7IsgRNIouanEpTUWRf9YnN-NSd3TzfT6vuXr_mE_0Vw,158
 brainpy/_src/analysis/utils/visualization.py,sha256=ZBUO4Lv_LpNzAVot8Jp7vyBQrA7U5wRCUV5cLdPHwQY,967
 brainpy/_src/base/__init__.py,sha256=-kWNcNsRCdUeOJjbY61hNxhfhC63i9YjJV2A_I6nnMg,175
 brainpy/_src/base/base.py,sha256=iwhKnzeBJLKxpRVjvzwiRE63_zNpIBfaKLITauVph-0,24
 brainpy/_src/base/collector.py,sha256=iwhKnzeBJLKxpRVjvzwiRE63_zNpIBfaKLITauVph-0,24
 brainpy/_src/base/function.py,sha256=O9CT1B2F-cVB8elT0EoCJbgkcffjvlmqteqavs4giDg,25
 brainpy/_src/base/io.py,sha256=LRPHp8IUd7wp7-iQJB6Kd7uxqyI8sonpzBf2EJpdarM,502
-brainpy/_src/base/naming.py,sha256=wSf5VsVGy-MKgetocSH5DE0gWJ00duZ1PG6hnY6usRc,289
+brainpy/_src/base/naming.py,sha256=N_HOta7wY7D5JQirksRw48AB43LjMtNP1E85OR8ULJk,305
 brainpy/_src/checkpoints/__init__.py,sha256=iwhKnzeBJLKxpRVjvzwiRE63_zNpIBfaKLITauVph-0,24
-brainpy/_src/checkpoints/io.py,sha256=5kKE6gBTSaozChVZbzUNGz9ridOPi5l9A1Ba7TXdJk8,12185
-brainpy/_src/checkpoints/serialization.py,sha256=9fdyLM8ZvRTyhdMG5NRxuNdNNw822yIq0wEdFVMPAAM,57502
+brainpy/_src/checkpoints/io.py,sha256=gQZbjzKM6o41bYjeAhf7uFTQwNG_HVZ9MTEzGTxR__I,12240
+brainpy/_src/checkpoints/serialization.py,sha256=yKxoTJhoGTe9OpioYFcj_IetQHn5Hx7Hxcw6WjCTnis,57388
 brainpy/_src/connect/__init__.py,sha256=BQDEgFkQ2WZPnLRUlc5OfDKHDhEgvMYdoBGtIXZUfKI,268
 brainpy/_src/connect/base.py,sha256=dR7zxftU48fBInhGMNKln81qzCjFW7bm-1k0vo0HV4Q,24303
 brainpy/_src/connect/custom_conn.py,sha256=a7C9F0nD8I_I5IGu5FId1KCueqJNJk1nAfXXjYa-hmQ,4210
 brainpy/_src/connect/random_conn.py,sha256=caLbwMt3D68QdEbOZUM_vIRiso8uIcDR3cN_Srv8x0E,39149
 brainpy/_src/connect/regular_conn.py,sha256=x1EV_1KwKPTiAyy7geODNmhogRUNvCg_8Pptcp5yqho,9173
 brainpy/_src/dyn/__init__.py,sha256=WIgllL8eZeXpS8dhz3oq55Iza-gRfyAQXSo_iXv7M3E,358
 brainpy/_src/dyn/_utils.py,sha256=dGm-K409kpoHuWoKUg8CkZZukvfoecIA9zR-i7263-Q,636
-brainpy/_src/dyn/base.py,sha256=K52yOC1epPQhD22_deVxaQLlPz1fC2rr_K83I9cqRjQ,48804
-brainpy/_src/dyn/context.py,sha256=9oFzhtqOO13aVhJp09vlwYgP82zl3H-Fj33FrF3WjCw,2290
+brainpy/_src/dyn/base.py,sha256=fx9yDzeVEUQzUFffNOs7gN7YfIeHDa07q0EcpejAzqo,48544
+brainpy/_src/dyn/context.py,sha256=mOjMWvzk3RB_tsICf6NcIMYGUKL5j4Scn0RSuysdtqg,2552
 brainpy/_src/dyn/delay.py,sha256=E6I0q9vBh7kvaEnyRd11xyzIUvlp4V_riONvtJJr2B8,9980
-brainpy/_src/dyn/runners.py,sha256=NhiDxA1DE00x2QQZqtmESqA9qwcAb14N9vcLMuDxMjI,25104
-brainpy/_src/dyn/transform.py,sha256=C9PA3H5u2jIUM_RnPDOtAvOBsRcacepwpstsFq9f7GE,10966
+brainpy/_src/dyn/runners.py,sha256=x_V1IK1yypaL0BNsur5buUP4kZpga5ac81ChxbiaVFg,24978
+brainpy/_src/dyn/transform.py,sha256=j0koYjhKDU-38LFzg3Cwz7bGKOffpzSbV1I_deHv984,10906
 brainpy/_src/dyn/channels/Ca.py,sha256=VuWlERIxafs-IFY3WMYq7-Z_4esCPHN2AIPREC0bCNE,40141
 brainpy/_src/dyn/channels/IH.py,sha256=Tf0D3V49EgFk9b3jBSb2ZxgX55knFNbfWACZ183tLVQ,9130
 brainpy/_src/dyn/channels/K.py,sha256=HHqKG8-7h7bvcd3tGeMj2Or4D4LS9Jxj6Wo8trY7n-o,35637
 brainpy/_src/dyn/channels/KCa.py,sha256=2kNF5cUHQBJNj-wEISxe0_Bisqvv4BWNAh_Dt_Id-M4,4491
 brainpy/_src/dyn/channels/Na.py,sha256=doSFKYMaXKiUFtz0vierNF2UT3FbJOwqP8cZNTxQajU,11936
 brainpy/_src/dyn/channels/__init__.py,sha256=PDPYmDDQCato2ZvBOXj0ueUSgkiW13hm4GNdQJn0kOI,423
 brainpy/_src/dyn/channels/base.py,sha256=MDktlOBAVK3bDc2tZ_f1OWE4sBTe7AsGnd8sE5OzCX8,4041
@@ -87,180 +87,186 @@
 brainpy/_src/dyn/layers/nvar.py,sha256=bQ47D1SOZXRTBx1wkA1GGmoU6UwOZzwwJ3EqbBE6zOE,6737
 brainpy/_src/dyn/layers/pooling.py,sha256=iF6SaiTor5EMyTavSRX4QqSba_o0-VdRk-Y24yLmEZ8,34199
 brainpy/_src/dyn/layers/reservoir.py,sha256=JSfZ6z4am8ddTgiZzin-CMXf6i-wgbjyuFuduDeApWs,8906
 brainpy/_src/dyn/layers/rnncells.py,sha256=HQeTfx8ZmT3PN4G3ss2dHtP8xG7goHab3Bd387P63JE,26998
 brainpy/_src/dyn/networks/__init__.py,sha256=iwhKnzeBJLKxpRVjvzwiRE63_zNpIBfaKLITauVph-0,24
 brainpy/_src/dyn/networks/cann.py,sha256=jfOdLefiKSPxzcpMmST1JzSp1HiNFP4yZig-OgNIG_s,252
 brainpy/_src/dyn/neurons/__init__.py,sha256=xlEq2G7WQWqMnTz7zLmRbCUPAXDl5xELJGpvEscFMQk,177
-brainpy/_src/dyn/neurons/biological_models.py,sha256=I6mW3lNfCOX5Bpz0iT-pPdnjS3n6hA7zZk2MREDRth4,48933
+brainpy/_src/dyn/neurons/biological_models.py,sha256=t4ELocuZvLLD92xVjYOqiy6uhpnyk-gtY1AaB7hBi3M,48955
 brainpy/_src/dyn/neurons/compat.py,sha256=YTPVRatOoivZ7C6YL4FAUf83WflrGYSX0GNyxrCzioA,595
 brainpy/_src/dyn/neurons/fractional_models.py,sha256=J_mpkQWQovmuqNyM-d2CXD0xje5fEpx16by3E-qfBiE,13060
-brainpy/_src/dyn/neurons/input_groups.py,sha256=2aK2NdlN9h5o8clAnj0jBuGWU5GNSEE3eLGJwH2rHbs,5687
+brainpy/_src/dyn/neurons/input_groups.py,sha256=OgvKmlU0dqYtluKOmSQm7Um3v9jVSNpntBZPpU6p7HU,5683
 brainpy/_src/dyn/neurons/noise_groups.py,sha256=-N_Hw_OXh3s4xbQqgCUeF0OaVcrNBfGl4RU7BXDpXX4,2317
 brainpy/_src/dyn/neurons/reduced_models.py,sha256=ZkOGosbv9Mv8_InsoyJxndOUGd1ukVIGd1jNTz9Ywb4,89375
 brainpy/_src/dyn/rates/__init__.py,sha256=biF71W-hlm9xRYQpbOWuA3jpDZ3WWGXoaOG7emElYSc,52
 brainpy/_src/dyn/rates/populations.py,sha256=LBMX5NyhH2QMVyfY3Y_X3fiY3YYZSYdBI5zy3QeU0Rk,41067
 brainpy/_src/dyn/synapses/__init__.py,sha256=vnhuo80o4KyGjetcCrEb8nVbOhe-MXnO5wOHUT9VYI8,223
-brainpy/_src/dyn/synapses/abstract_models.py,sha256=CjlQ12CuR-TQBLpWfANoQzgsnURSphctVhsmYb2z8nU,36146
+brainpy/_src/dyn/synapses/abstract_models.py,sha256=L6iSnzEqzYMKIsjKQ_HJNhJ6XrjU2HSP4bjRcxho5VI,36107
 brainpy/_src/dyn/synapses/biological_models.py,sha256=ZjBxsHPjoO62vElggEDrEUiK1ru1HZzeC7uzm3ba4Yk,21901
 brainpy/_src/dyn/synapses/compat.py,sha256=CVmrc8H7HxdkrlAcrIOqbGi7WQN0LvqIRz0zQEmFfbA,10252
 brainpy/_src/dyn/synapses/delay_couplings.py,sha256=GT2huBvdhPB6wxN_5MorrHqNCTiT0uKrdxj7z3v54Po,11139
 brainpy/_src/dyn/synapses/gap_junction.py,sha256=qFGYr6sslMw1SNImXV0FDHAlE0yuH0ZH_M_gBH2GzOw,2025
 brainpy/_src/dyn/synapses/learning_rules.py,sha256=Z0gk6eLNiaNQSz20rSB0hA54cW4t-ebeGr4ogrnGkmE,9214
 brainpy/_src/dyn/synapses_v2/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 brainpy/_src/dyn/synapses_v2/abstract_synapses.py,sha256=eu3tyWZekBbl83TvUMIgLGZpfE-51_sc3ry-UTUzkwg,13693
 brainpy/_src/dyn/synapses_v2/base.py,sha256=sn8j8PTasTmmxAfAiZ5qD8K9POFYzrsnw6lTCIZUsPE,4651
-brainpy/_src/dyn/synapses_v2/others.py,sha256=-94JH5zJmHYre5t32zb4RKW0FLib0g9qeHqnt4RQCC0,2666
+brainpy/_src/dyn/synapses_v2/others.py,sha256=WpNXA2VdXoOLTdAmc7GayaKVQzUMyFwzKP9L0glKW58,2627
 brainpy/_src/dyn/synapses_v2/syn_outs.py,sha256=y8tJR5_ZHkfEIgSGu9I9U7fs11J7bda_rppvcLlJWPo,2599
 brainpy/_src/dyn/synapses_v2/syn_plasticity.py,sha256=O8RJm9gR3CKUFN8LW42xDyVgUOBHRYs0pKhvHY5X7yE,4730
 brainpy/_src/dyn/synouts/__init__.py,sha256=0Z2hJcdyS_8FsPlHxP0oGhLj_tCS7FF5xt-rImFiIew,73
 brainpy/_src/dyn/synouts/conductances.py,sha256=x-R3v0TaUZ9xA3D2xLdyYJUcSDnw2OMIxiWyM9qfYHE,2636
 brainpy/_src/dyn/synouts/ions.py,sha256=fCsbAGyMbFtSdr7tHtvkZkbw7By88eabIqa_12ZeDKc,3281
 brainpy/_src/dyn/synplast/__init__.py,sha256=2So17UaLExSNKtLczYtfCo53b3agOcLjz2UCCPtB0S4,62
 brainpy/_src/dyn/synplast/long_term_plasticity.py,sha256=iwhKnzeBJLKxpRVjvzwiRE63_zNpIBfaKLITauVph-0,24
 brainpy/_src/dyn/synplast/short_term_plasticity.py,sha256=BsoIS9eThH2LArhuQViTe8Ogvbvvb6XlmyO3Ry7RP6Q,5324
 brainpy/_src/encoding/__init__.py,sha256=Y4USQ3gijv8QEyE8Kcnq7hIsY3xQiS2lr3I85OCakiE,114
 brainpy/_src/encoding/base.py,sha256=2-q2O9HyMG-f1Y-t-BImU-u-1x_ySKsD50BCqrzzcDE,364
-brainpy/_src/encoding/stateful_encoding.py,sha256=ySuCMQrVTdzNRJ50DA7hCEwPrRq1F_xQC3bF83nJjVQ,4786
+brainpy/_src/encoding/stateful_encoding.py,sha256=lOu0_fEwyLID5NASynahFbWOrfKjswyw-N-IUt0-cBU,4769
 brainpy/_src/encoding/stateless_encoding.py,sha256=vuOdVUeJdeMA6qUer_dzgLUSHhMiW4_Kt7AlrYiDmJk,2249
 brainpy/_src/initialize/__init__.py,sha256=BZnTMuwfTddVqmvLbwjczRYLPC_CN8yJZtu__wnZmZA,154
 brainpy/_src/initialize/base.py,sha256=xseZjikf7TWq6BL5C_WybpGHm1G9yQW-MCCvlfG0AQs,614
 brainpy/_src/initialize/decay_inits.py,sha256=OHY57x3qz30Ubx1D-Y87CQLDrJvW5VM8-o9-LQbx198,11571
 brainpy/_src/initialize/generic.py,sha256=efih0bG6yPTAmoL9OsKGA5SujfWA-GZyoCoJfwBDEZ8,9288
 brainpy/_src/initialize/others.py,sha256=4kD5tjDCC5ZhLah9b4Kkkfar7T4-F6F9YpvZ0MPdy2M,554
-brainpy/_src/initialize/random_inits.py,sha256=qAwVbWozM7hTaP0fDANmomwxkHICjLyRB6wGgtLal4s,13484
+brainpy/_src/initialize/random_inits.py,sha256=d9tHTwEaSiaVaThn36exKXq4cia-XqKv4K1vFQqaeb8,13534
 brainpy/_src/initialize/regular_inits.py,sha256=fXh7J2Rr0IfNA_MfbxbRlyCXylp0lDwpRgQSqIu062c,2266
 brainpy/_src/inputs/__init__.py,sha256=x-dZso4oLYPaO37Ajz3RgyexdM0MrkpE32xGIBHAMv8,173
-brainpy/_src/inputs/currents.py,sha256=ml313r7mIXI8J7Ai3mb-mkReBZjh9dc59cIVl3hyg2k,11425
+brainpy/_src/inputs/currents.py,sha256=MV_SOEWqA9yf0MWseBV7CRaYoFGrQ0Z84DfIZxMarLA,11406
 brainpy/_src/integrators/__init__.py,sha256=lPnfiLZ8kqEMgmy6vpreYmHSz5SvUBAqYfzwuFDuTJg,1189
 brainpy/_src/integrators/base.py,sha256=0TpLuvfkCwKBGnwttn5Ud3hkfEI26qHrVJgiMlo-RGU,4154
-brainpy/_src/integrators/constants.py,sha256=eHO-5FJNubTZj0BmsBhiqql5NweiW0AtY7AIF7x0hGM,2930
+brainpy/_src/integrators/constants.py,sha256=HnKOsxGXHYUILHgDSjaYgi-lOWrKFh-MnbypNdIt_UI,2946
 brainpy/_src/integrators/joint_eq.py,sha256=CCUtWv14nyimOc4NeSQAUXSZ_ldkPI6ZHLVzBS6tfIc,8158
-brainpy/_src/integrators/runner.py,sha256=ZFZ6oIlUfgAKq2gMWKth3kG7svBZ2UEA7g6zm09ZuuM,11874
+brainpy/_src/integrators/runner.py,sha256=IaTFJxtdZUZ92HVDbQq8AogmAhpDiEWnNscrptoDuTM,11802
 brainpy/_src/integrators/utils.py,sha256=JgwnAOGEwqrpa8XkZo30mZmOVbHib3Pp7_PSiLZyqwc,4455
-brainpy/_src/integrators/fde/Caputo.py,sha256=21PHCOn_YQkuljBxEUSz76lmh_neH2lVEkIw7dLjmnQ,15041
-brainpy/_src/integrators/fde/GL.py,sha256=-p-rNZC9FVQ4ylaedWH2Ln19JJ3qMB0kzQxFMhXM7_U,7220
+brainpy/_src/integrators/fde/Caputo.py,sha256=oW6_jWiFRNp4ZEnjWR3xFyVDODcYJ1K7qnAMY94VZpE,15058
+brainpy/_src/integrators/fde/GL.py,sha256=gzQBLjas2xihwgovuBSNNxLo1WXVennkVJnjzDVAuEM,7233
 brainpy/_src/integrators/fde/__init__.py,sha256=i3NIsv-0zacq2SILhbLoDykdnX1OIHnz7uVazFLv95I,110
 brainpy/_src/integrators/fde/base.py,sha256=YJLBNm7uIEA2GKf2vvLkT0z9uUYulMoISKdfOlXV0uw,2771
 brainpy/_src/integrators/fde/generic.py,sha256=zFfKmvOIyS8_CnWDKceRYK-FsHhfO_Jf-jGb2Nph6wY,2706
 brainpy/_src/integrators/ode/__init__.py,sha256=aX9ioVcUyyzTe55DJxjZMx54znbGjKpvt7y1KNJQRko,220
 brainpy/_src/integrators/ode/adaptive_rk.py,sha256=MHGcrraQG43A886TZcFD05eGFlTe6JKxURyrFmr1_5A,17892
 brainpy/_src/integrators/ode/base.py,sha256=YraM5qO9m5hsWvzmFbQ5p0pWpIaC2KsfZ4ddBD_8DZk,4845
 brainpy/_src/integrators/ode/common.py,sha256=shreGp53Qg8i602ZDQa0qurMWpAbOP7djSLsc1UZBqw,1493
 brainpy/_src/integrators/ode/explicit_rk.py,sha256=zNBYecP9JydLWxip49J-SQpP98sYHOi8OQzZVVEDsJk,25974
-brainpy/_src/integrators/ode/exponential.py,sha256=e2nyD0brmEACfNRkgpyDDD9D-O1PFGJVSPnmjpWspLo,13966
+brainpy/_src/integrators/ode/exponential.py,sha256=VXb1Y7wZhcSr7r__YCyhiZS8kv_yNKsKcM8JIWbAiJw,13764
 brainpy/_src/integrators/ode/generic.py,sha256=WnSD2LFE-Yj7nWOCN0DoY7ySG47Xc2fzR-8aMSuoVxw,4139
 brainpy/_src/integrators/pde/__init__.py,sha256=iwhKnzeBJLKxpRVjvzwiRE63_zNpIBfaKLITauVph-0,24
 brainpy/_src/integrators/pde/base.py,sha256=8lHCODxLITFBRTs1vHRNc2QpoS8VefHH3_izeyeltI4,98
 brainpy/_src/integrators/sde/__init__.py,sha256=s76hX5fgaP-zZXSf_Q03052NYzU_xkC9AUVgIreZXQA,184
-brainpy/_src/integrators/sde/base.py,sha256=-pYxwywxXqBY891EJFHGjIqa3P1UGeC5qnTIE0yDQeg,3429
+brainpy/_src/integrators/sde/base.py,sha256=-7cFMKWE5S-XPWBFWEKyGWuXna24ds8Fqn9QIrwyZBQ,3310
 brainpy/_src/integrators/sde/generic.py,sha256=LyBzeLCgrDLBnbiXtIAd6y_S6rVcjdgTUspXKUNdC5Q,3877
-brainpy/_src/integrators/sde/normal.py,sha256=GNzlR2_un2EkcgJmDctdof0y4j9qWz9RsR_Lih5QF9U,24705
+brainpy/_src/integrators/sde/normal.py,sha256=8JweJYKdjtQetySpjqKVyljhnCPj5S_fPQ0DbGYd-dA,24171
 brainpy/_src/integrators/sde/srk_scalar.py,sha256=_ZVx_lCOXp2ofh78lskyoljnj0NTr3jPJZdcTPJu8pw,17060
 brainpy/_src/integrators/sde/srk_strong.py,sha256=E60wXEcMLcC_Vx0t4tpRwCs4lFnVpmLWtKiFVa8nAlQ,17016
 brainpy/_src/losses/__init__.py,sha256=5c_OONbxlULz96DM8cXTgh0whPa1Kn83mWCktG7zqlE,276
 brainpy/_src/losses/comparison.py,sha256=--5PjPC1JILaQXauHoYijk7nv-kk7VH3ev6GdGUFcaQ,22010
 brainpy/_src/losses/regularization.py,sha256=xNWfCxMMuewW6_aqkqeFOXuph5CeSnlpo_cj9e4kdLY,2370
 brainpy/_src/losses/utils.py,sha256=36MfIfCZV2-zD19CPANwbwfl0hak7rpHl2bz_n3qUG8,792
-brainpy/_src/math/__init__.py,sha256=8oKBNjQcA_x-bbXKV9EagsQsiwJGbkcjwtafcQ_qads,1432
-brainpy/_src/math/_utils.py,sha256=UnSCt1rYVoabYWXOoeDKc0SwGJj9cbBFbNZVLdLwzIk,1788
+brainpy/_src/math/__init__.py,sha256=KXqkRoKQxVbpe2w80VcmGouFqvghjPzW-q2If1VR8-Q,1432
+brainpy/_src/math/_utils.py,sha256=uCb4a4MqgWuWb2Q90XQm1fOd2Gpy_zZr1_M4Cp73Bp0,1792
 brainpy/_src/math/activations.py,sha256=5uZw47081B_5K8RpaXzbZPHTxUaANGTGJbwO_dLSPxE,12797
-brainpy/_src/math/arrayinterporate.py,sha256=HZKYA_baJ737tVcZwTRd7QWMnNpxJodEn6sDrq_bFEU,2481
-brainpy/_src/math/compat_numpy.py,sha256=zVZDFOk-azFEAfRa0w66WCxn5zq-MpQ_37Wi0IS3p-c,29884
+brainpy/_src/math/compat_numpy.py,sha256=Iju_t16qGFigmvuCVU5azq8rx0_1o86Pd6S0h3ZDdkI,29884
 brainpy/_src/math/compat_pytorch.py,sha256=dGE5YU6UapyxwJFSehGACH7SF4R9oUZGuJKUUg3nL2U,6488
-brainpy/_src/math/compat_tensorflow.py,sha256=xfrbWFlyxXelwKQThON-kTJAmAlD-G6ZL4Hpx2FpnqQ,17877
+brainpy/_src/math/compat_tensorflow.py,sha256=T5qvfo-rtwhcxLyVwF0aJcqrfcKEAdQq6o-5tgeA8E0,17877
 brainpy/_src/math/datatypes.py,sha256=AgZZmDKVEqTpVTM85i6HPT9GUf_YPs_ymi4p7tuR_S4,911
-brainpy/_src/math/delayvars.py,sha256=PF753TGzRVTk0-fExB6oXEQpSq3bMF-hdsG13RaBV6Y,15945
-brainpy/_src/math/environment.py,sha256=KrG8dVX84I3QoXYdc4SGyB1Hwtw05rLBVU13fCHXF-s,16732
+brainpy/_src/math/delayvars.py,sha256=Imaei474tT8_fqGOM_yAVx5VXJZ182yRauXymTtKo_0,15918
+brainpy/_src/math/environment.py,sha256=4ChAaPrKAFeJ67bV5rGVtOdrivxkEAGu_fe7eOUkqgI,16825
 brainpy/_src/math/fft.py,sha256=NO5RqLkdor_8JXXB5cK7yQFEAVgoatk7q6T7KCvLp8k,1498
 brainpy/_src/math/index_tricks.py,sha256=tNZ63fVlO9M4hwRbztHiWwwdZ6V3dVchKoaPYC5Wb6U,8866
+brainpy/_src/math/interoperability.py,sha256=n1bWyu-QGfg9t2q6mMVitimbG-LU3TPogbigLWcdQGc,2523
 brainpy/_src/math/linalg.py,sha256=Q9Be3i9CNE8W8bK-4hKDAsz--O2zgw-U_xF0R6rGrg0,1792
 brainpy/_src/math/modes.py,sha256=2etZ5AlviGf2fGiQEd1VTCaRO-tbnWail4DCx3ie7x0,1903
-brainpy/_src/math/ndarray.py,sha256=U2u9RRtIdG_u_oxHLR_vodWWyx5fl5fchNMa8Cy75EU,54127
+brainpy/_src/math/ndarray.py,sha256=18VqFoiXz7FlUb4i9_hEW_jSxdZERWu8PdcUzzZ4xgU,44595
 brainpy/_src/math/others.py,sha256=QoseJ2WRoOcVw0iCQP0OfZmEj8XK_JfOLy_7Vdz8bH4,2255
-brainpy/_src/math/random.py,sha256=y_DNPihz-2euQYGR7nyqnNnyXSdybhaneOTqj_pij1E,77638
+brainpy/_src/math/random.py,sha256=08-DkMLGse1RRU-evFspkYr0m9niCkXAL0SVfelBuvo,78521
 brainpy/_src/math/remove_vmap.py,sha256=vlzDJgkMMXdAsBk3m-qeZLvZHH87WoNwgQEFmXakTvw,2119
-brainpy/_src/math/object_transform/__init__.py,sha256=tbe-zEimCDRsKLauGF_qenBxvi0AFsKQhFmIxP8e0u4,1085
-brainpy/_src/math/object_transform/_utils.py,sha256=xo3sxwqmmN9OnMXqDzBBybgK99syiMJECFXWkvfgHes,760
-brainpy/_src/math/object_transform/abstract.py,sha256=4djxMbV7UlLjeEXEtNgmNRNNCIMVd_Ux4kUpUtvlnsc,403
-brainpy/_src/math/object_transform/autograd.py,sha256=bUWYpNmJ4_x-AudEFw5F2JSs8AVo_58wDY5Pg32WpzU,36857
-brainpy/_src/math/object_transform/base.py,sha256=toQ4FLJawnJlxoGAED_3GAuf80_4NF96xX1XIs75ol8,30300
-brainpy/_src/math/object_transform/controls.py,sha256=oPoSukIQwGPUDKuSDHp4YIwL0p6wKpDG19v-i4s18PU,29841
-brainpy/_src/math/object_transform/function.py,sha256=uavAdrDoRcy5YW0VRTwm-hvpuN1Sj-AK2Ix5Ij4wt0Y,3014
-brainpy/_src/math/object_transform/jit.py,sha256=miHewQew0SFAy5yCLf1el3UyZ_O8MtGhED6tdvKjqpk,10117
-brainpy/_src/math/object_transform/parallels.py,sha256=yTKim7nzLG1TndNo1WsvsttpsmAP_NB_HYmaDN08sPQ,17779
+brainpy/_src/math/object_transform/__init__.py,sha256=iV3d2uYiGe0r2aVIxqmvIJwrTcqpC0pXysISGyr23yo,914
+brainpy/_src/math/object_transform/_tools.py,sha256=qGx6Hnv3MwnFsecDhfD2pN3dhpKuKvRi0yQJ5N7nPoc,2869
+brainpy/_src/math/object_transform/_utils.py,sha256=VMIQvLnpFkWoNdsDVigSnpgceNoDqcEEk_MMzkOwe3M,758
+brainpy/_src/math/object_transform/autograd.py,sha256=ifzXiN-UhHwg0MSEqVnvzKVsfnM0UYchn4tuvjGawBw,38682
+brainpy/_src/math/object_transform/base.py,sha256=Hrfu1vFDUgtxydFiUoOrt6yTAvRfuF4PlyEGFIhRvm8,22499
+brainpy/_src/math/object_transform/collectors.py,sha256=WHHC5VfpdNrqFYGoFV6pNmVfCB3_37v4udiSjxfKkc4,5581
+brainpy/_src/math/object_transform/controls.py,sha256=Es26v17dWIbSE99nsdNdEKxh23kL706-e_PJJ1-OW_o,27560
+brainpy/_src/math/object_transform/function.py,sha256=LqUH4_8LvbppNrYsNP1dzLXL-Tc9U3uNXrFzPXpIjhQ,2999
+brainpy/_src/math/object_transform/jit.py,sha256=3QTzOuk9IrQq_puL7dWkyuBIVDrvdudqm7tRvArcRvU,15077
+brainpy/_src/math/object_transform/naming.py,sha256=hA9pSorEw5EHYGRPZdEH51qA7v1A6ZPySwFG6YWLyb4,1637
+brainpy/_src/math/object_transform/parallels.py,sha256=t84hKHGPB0l4ddV79tvaJvIi42Bex0_qaCu21CuSCFo,17774
+brainpy/_src/math/object_transform/variables.py,sha256=56BuLb4g4Be0a29suTwpz82V79RtJtBDSZWZhWXB92Q,12059
 brainpy/_src/math/operators/__init__.py,sha256=dkBa6yenojUHGyZJq7ZEkUN6dq5CdByDbPvqq4v0V4k,208
 brainpy/_src/math/operators/event_ops.py,sha256=DX1uhFUwtApPzFYa2Sp4bknJAOgZ3QcvwIWCw65VU8A,1857
 brainpy/_src/math/operators/jitconn_ops.py,sha256=2_Z8Ostpis8XIj_7EhRLrYksThnqh-9sQ9Yz_1ip7rw,17399
 brainpy/_src/math/operators/op_registers.py,sha256=oOmy-Rr9maVpusxs4ztlpS4S7Yu6Ad7dLHxrQSrx7YY,3774
-brainpy/_src/math/operators/pre_syn_post.py,sha256=iHI__3jDMBz5qSKpxj_OkERGoPqaw-nuaXL8JQdR-Fw,17347
-brainpy/_src/math/operators/sparse_ops.py,sha256=LmnljAQmmLwTfALMCN1Sx9uwHJwLsjxQpzE8g5g-Jc0,9941
+brainpy/_src/math/operators/pre_syn_post.py,sha256=g0HyjHkUkPNrf1UPH1zruJ0U29CUZLkWFgJ_xsih6e8,17347
+brainpy/_src/math/operators/sparse_ops.py,sha256=PpDStJ0zpI6zVzZlJAOoj6rj2WOEE1erz1b8DxV7L4o,9941
 brainpy/_src/math/surrogate/__init__.py,sha256=mjBhrtPofizNYSadGdE952UD4qbVDoLNPxG16GfSCZc,77
 brainpy/_src/math/surrogate/_utils.py,sha256=CVhDyaqzK6ddXQNyz0YYaS-T1b8U4KOMXqveles0X68,3665
-brainpy/_src/math/surrogate/compt.py,sha256=tCD-t8IuJjeOatQenej_43NirLNqIP9rjLRqEZ5IYe8,7216
-brainpy/_src/math/surrogate/one_input.py,sha256=2c_ZmX6tB0gXKjegLMzR4_BMZjEHRRp8iE73cZu8Wa4,40745
-brainpy/_src/math/surrogate/two_inputs.py,sha256=cNXR1mieYCXRZGrHzGG-j2-FXguz7wt9SEQscGNdw5c,1492
+brainpy/_src/math/surrogate/compt.py,sha256=4PuAhWPW_fGLvEixK6gNQh0ahr_hAIupGMixv6k6ujU,7216
+brainpy/_src/math/surrogate/one_input.py,sha256=Sp_Fs02t4AAKFurKJ3hBjNLyzWk0Cb96IInLxvMCJpU,40745
+brainpy/_src/math/surrogate/two_inputs.py,sha256=lWyvtFUYk3FYq53zKGdW0gIYK88u26dWPUOJFz1tG_Q,1492
 brainpy/_src/measure/__init__.py,sha256=eOAgeUH97IPxsvg1_q8SjY-ZdD8nui3h2uiGS_F-8E0,287
-brainpy/_src/measure/correlation.py,sha256=6QRYASynZ_YUZ2uxmybXsjqCuzd5M8F-Dsm4FNxeejM,10162
+brainpy/_src/measure/correlation.py,sha256=oOwNSQO6ChaaTuzLd0erD8tU6g_DjdaexknDl2O29jw,10102
 brainpy/_src/measure/firings.py,sha256=ki5MhHL0vVeMYi9Yrms3BWOlZzZ9cL-NA3nvED5YB-E,1770
 brainpy/_src/measure/lfp.py,sha256=gYsAqzHcP4V9K43-d4EioFrI39iWcebKSyiv9ONx5ZQ,3896
 brainpy/_src/optimizers/__init__.py,sha256=ToxZhvkgFhL9St3jQESUSY57RsPQc_5rYFDjWSzWTsY,75
-brainpy/_src/optimizers/optimizer.py,sha256=_9oYTFtBK80n2EK011emce8T-X9AD0Ltyh1fc4U4l9s,41335
-brainpy/_src/optimizers/scheduler.py,sha256=KGVFZ2yzlEHOGS0fiFPA9K_VvQIuU_jg3hghu5dq-yo,13220
+brainpy/_src/optimizers/optimizer.py,sha256=_47vxjzn34oSa603oz8jeR_ops-l7gVbNPZUhakH6X0,41331
+brainpy/_src/optimizers/scheduler.py,sha256=e_W27P4M-ZPDEW1930d3C1BK2N4szpdjL4w4N2NjTBY,13240
 brainpy/_src/running/__init__.py,sha256=4EORFDW-JNEpvzsyNuBsj9Sa5Ie61TeUAY4JiRM57DY,525
 brainpy/_src/running/constants.py,sha256=ekB6jpM51xZnWCscVM1hLPw86WQtoQYnBBHpRs6SII8,269
 brainpy/_src/running/jax_multiprocessing.py,sha256=rmd_voTmREb4etkOODkPAdNcfkxKOk3-YsIHrT7V1Ao,4913
 brainpy/_src/running/native_multiprocessing.py,sha256=uJgl6qX1TTGOwT-OEiGuGRuRqjM3xSpu81AxJ1Qj8Ec,2976
 brainpy/_src/running/pathos_multiprocessing.py,sha256=sSnqtbzszxIHBamt5tcUTjK2yiYiO_3GoCT1QsXLdiM,6995
 brainpy/_src/running/runner.py,sha256=B9TivMhT_4yhM1Mog7ARs918ehxIRYziHFSrNA88vHo,9777
 brainpy/_src/testing/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 brainpy/_src/testing/base.py,sha256=uM1kn1G9zVPk6WmXdu-RHmet74GDcSg23myTvGCmVUQ,347
-brainpy/_src/tools/__init__.py,sha256=eg4E_NxA6rUkcgMt3lL4igGa_uR3K51l24t-5G57D4o,181
+brainpy/_src/tools/__init__.py,sha256=FoDJFbb3uo9xhvKaJcHVCUhOJgzZoc98pPXbLllDDBI,159
 brainpy/_src/tools/codes.py,sha256=s6veW1UF2vSTbS5dNFXbmxKPNx7Sm5-eKnRqy548O2c,7326
 brainpy/_src/tools/dicts.py,sha256=ctYh-jTVfsL2PSZ6Bg2g5pdj_etzHw5fq1hPLnT-7XQ,5882
 brainpy/_src/tools/math_util.py,sha256=afNqi1UZQmP9KXmSkaOLlwVDNDLxvWMY3dgYdUKn7w8,223
-brainpy/_src/tools/naming.py,sha256=fod6-5SWSUSqs90oHLp2eIvpCw6ITFxBeHcS__oiWic,1435
 brainpy/_src/tools/others.py,sha256=KqCRiNJzUyhmqP8YH69eKJySklDXS3UKNZkvCxbxj7o,4424
 brainpy/_src/tools/package.py,sha256=yLzMONm0C2syu4jML5QbBPnAHa-7E5Cp7_I1Sn2CCP4,1406
 brainpy/_src/train/__init__.py,sha256=LWAw8kdeEh4lPWRJ5CzgP0EgSkiQeQTUjXKbXHB0xk0,659
 brainpy/_src/train/_utils.py,sha256=1UrIeX8z7yJ_AB0gTE3e6pohck8Y7PMpFyvXFPIswys,1972
-brainpy/_src/train/back_propagation.py,sha256=4piFAXgH-H2gcncgdtxwhKyA2rLonXwMNZN-qbMPJHs,24649
+brainpy/_src/train/back_propagation.py,sha256=0AoTxFieL0JMXiKmaqtzog3tw6Sdd1S2Z_ElQBbzCxk,24073
 brainpy/_src/train/base.py,sha256=oGgHfrVFu8AXimIArKN1jEjChHll3qYc2ceyGOCks1Q,2980
-brainpy/_src/train/offline.py,sha256=kwV1Ojnsnytn8dXo6IdGSwVUmFwjvGdF2FHNKsCAKus,10067
-brainpy/_src/train/online.py,sha256=XE5RZv35QFWNJbLTz8ulwipf4i4kk6hCB4eI7mkeJvc,10514
+brainpy/_src/train/offline.py,sha256=fTRC006evWxdEisJchy2dHVmpYjb-EtsfTqbjYxFIJ0,10036
+brainpy/_src/train/online.py,sha256=ZT9jnjlDoL5Ju4mWmJYEsI7FPycDQ3ZgpbZ6TwGoqR0,10373
 brainpy/_src/visualization/__init__.py,sha256=9jcWciqRU4d1BH4bCjuUc7u9qx_E1gyAFJFx-yDxK20,77
 brainpy/_src/visualization/base.py,sha256=A8mBH_IYD5XJYgLI8DthEjTTx-Cl6ARvNsW5w5sYohw,3544
 brainpy/_src/visualization/figures.py,sha256=_Pq10YOBDzwdYwqG2qN5B4wTW6-z_f_ti_7cxUP_BMU,841
 brainpy/_src/visualization/plots.py,sha256=FwbsaeCWijBYYylvqu0HmwOcSgX9R_7ZM22HjSbaOoM,14603
 brainpy/_src/visualization/styles.py,sha256=MkrX9e8c3bsowczpbnlVq_jhX4BjajtV2lRcvQ7mQkw,1026
 brainpy/algorithms/__init__.py,sha256=NwSgRAiSJcAHBdeuqVG98t6S6phGd6gl5cLCUSKZQPY,90
 brainpy/algorithms/offline.py,sha256=lCKCjtLlXt2CiIwMeaoowq7nAOhKHHoBg79GNoKp1Do,17344
 brainpy/algorithms/online.py,sha256=P-r3xm9xef5jnx8mw_kCz4hZ3T-rexXPMM1pHZ-ryaA,6284
 brainpy/algorithms/utils.py,sha256=-CZfyZ_7mupjU6vjRNQIwOpc4bJjsQ62xDBAhz1Dz-o,2656
 brainpy/integrators/__init__.py,sha256=Cvh3lH346n1pgnra6SkLc92uBnFp-y7QXVew5TgL5lE,128
 brainpy/integrators/fde.py,sha256=l7AexMW_0mS8D6Euovn04Vs5aCFddB6QnT8QwwurTvQ,576
 brainpy/integrators/ode.py,sha256=NI80C2t_v8Fq6rTMBxtqW78Rxm5eiuR-Dho_p0wYFpI,1061
 brainpy/integrators/sde.py,sha256=6kYyp0FDyDWvVwTeqdWPZk6RK_ktXeku5c5SqaILv9M,679
-brainpy/math/__init__.py,sha256=O3sGqt1Z2b7H_7ZHLrgeQD5IGALfVJebLfoBVS431h4,1563
+brainpy/math/__init__.py,sha256=7w03H3n6ndT_AODwuLk-eizciWRKYmIZFty5b_e5Ndc,1561
 brainpy/math/activations.py,sha256=FGamOBARpRhm5DABaKAS71PVW07Bak_3Y9gM1EWHGLU,612
-brainpy/math/arrayinterporate.py,sha256=Ozo9cnbm3W-6JGv7Ob8TMxcAzvvG_x_OA_PUyaUx9Dg,217
 brainpy/math/compat_numpy.py,sha256=F830tznz3RM758Ay3ytCAWIB4JD2I7acBjiPNhqPE80,8074
 brainpy/math/compat_pytorch.py,sha256=KxWezO2uRPzXmZVmPo--qm_DQys2hpE9fq87HqOr3mI,469
 brainpy/math/compat_tensorflow.py,sha256=UzsRTjxcA2BzsuQ5IlERHIVivi8FcTvP3RY34tXArdg,932
 brainpy/math/datatypes.py,sha256=dVThvS9GyrDwNi9Cv01lpA6gb8b-BNxDAVzNGgHDDSI,498
 brainpy/math/delayvars.py,sha256=3_MY0HYjYKaZjt9JVxrQOKp51ZnodG8U8E1LK1Y4nRs,255
-brainpy/math/environment.py,sha256=jXqnDRHQUog3_jrde-B84rVr1nDQlAN6Wi4bS1jS6Q0,941
+brainpy/math/environment.py,sha256=J3v2zZmBnbImTRakYZl4hjDIASjAx3pCFa8J9NTkeQ0,943
+brainpy/math/event_ops.py,sha256=0WgvQmSWrve0PZIMBiGXV-9kZuU6p__6Af0NrdME9_I,89
 brainpy/math/fft.py,sha256=eZ0gTY081T7T4DfMrtWNCWRMglTjcgWKvg6EQ-_E5YE,402
+brainpy/math/interoperability.py,sha256=p9Zeotud2lkJ_h-8hpuA_fUcoyVJkAlkQuD5ZIzjDf0,217
+brainpy/math/jitconn_ops.py,sha256=Hnhfz-9bNF8mpnFGhwLBeL-NxrFzVk-IiEv0I0_O1EU,379
 brainpy/math/linalg.py,sha256=uV_S2R2W7N8__aKdSa7jaNJBioT56VKo8xOcdf5QLW4,470
 brainpy/math/modes.py,sha256=y1Iqpj7KJ9CvUbd080NHpCYoO4k8lOTLqxkr4sN6XzU,292
-brainpy/math/ndarray.py,sha256=T9daGG2AVf0su1pruYPg_ThshPGlS6Vkup0pD1Ff3CY,182
-brainpy/math/object_base.py,sha256=bFLcex6H8Gh85RivzTGN8IdhzI-mXMR1L-d5dUnK228,710
-brainpy/math/object_transform.py,sha256=Id-Abk0D4F-3pl99NDhi-Wvx-WR5ykU76GiazTIq0rI,726
-brainpy/math/operators.py,sha256=jBWPdAcwtomHsaKrJqlZ0IgdV9TuCsUkMXKEQ4BSap4,1113
-brainpy/math/others.py,sha256=OdtpsIy4FeMFJMNLWnXmKI_GlsryBQucnL29yK8v6oM,178
+brainpy/math/ndarray.py,sha256=Polh3tVZfHdHEt78tLJ25h2fDhvdU0tqW6NCnaa3saA,150
+brainpy/math/object_base.py,sha256=SGMa9vJA3-xcr3Gff1uGEqPGh4tcuVVmK9BY5RLpcHM,909
+brainpy/math/object_transform.py,sha256=srXOv7hVHhyshaUuLSdrX3sWBu7WKb6OJuwHb6g7Pfw,651
+brainpy/math/op_register.py,sha256=IFH9ecSt2e3NGTPUd_urNJ_Ov0pq2EHnHUsxGnVYiHw,137
+brainpy/math/others.py,sha256=Q5WaFgg2u8e3iuhXSaQq__OFvca-ZOy-BeLrwHasgfI,257
+brainpy/math/pre_syn_post.py,sha256=UBx3g3hHs-WmE30r7BjKyC91u7-p80fqyci_SZhHHyk,336
 brainpy/math/random.py,sha256=DevtUfAjobWASIsOgEq1JUBtwHino5r6okFIH_rjtM0,1770
+brainpy/math/sparse_ops.py,sha256=w80pBef171j6hpU8SCkVIfsirejAjgR-wbXALhdjlWU,175
 brainpy/math/surrogate.py,sha256=8oboUhc3Mfi9gaU1N1L4YRXiWHoO1ZYh-_4tZfvLgjY,1184
-brainpy-2.3.8.dist-info/LICENSE,sha256=awdTB1OZyMqrS8QDj8fyUDxz40eWjrqByUqj7MApebM,35100
-brainpy-2.3.8.dist-info/METADATA,sha256=X9AUs1pPW4og6fxk9DhoStrBAiSe9kq1DwwIJ47ST90,4438
-brainpy-2.3.8.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-brainpy-2.3.8.dist-info/top_level.txt,sha256=5oi55xrJaqccrIi7VVShKhvGx0MjnDl0efebGKr5Omc,8
-brainpy-2.3.8.dist-info/RECORD,,
+brainpy-2.4.0.dist-info/LICENSE,sha256=awdTB1OZyMqrS8QDj8fyUDxz40eWjrqByUqj7MApebM,35100
+brainpy-2.4.0.dist-info/METADATA,sha256=gBgsHJ_xiNjdhP5LRSpIRaRHMXA8GBdZpgh5GynHFLU,4489
+brainpy-2.4.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+brainpy-2.4.0.dist-info/top_level.txt,sha256=5oi55xrJaqccrIi7VVShKhvGx0MjnDl0efebGKr5Omc,8
+brainpy-2.4.0.dist-info/RECORD,,
```

