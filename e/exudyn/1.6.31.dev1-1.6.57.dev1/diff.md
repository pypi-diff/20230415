# Comparing `tmp/exudyn-1.6.31.dev1-cp39-cp39-win_amd64.whl.zip` & `tmp/exudyn-1.6.57.dev1-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,38 +1,38 @@
-Zip file size: 2201024 bytes, number of entries: 36
+Zip file size: 2203848 bytes, number of entries: 36
 -rw-rw-rw-  2.0 fat   203014 b- defN 23-Feb-16 08:35 exudyn/FEM.py
 -rw-rw-rw-  2.0 fat    42942 b- defN 23-Jan-12 07:22 exudyn/GUI.py
 -rw-rw-rw-  2.0 fat     6474 b- defN 23-Jan-12 22:51 exudyn/__init__.py
 -rw-rw-rw-  2.0 fat    16183 b- defN 23-Feb-13 16:15 exudyn/advancedUtilities.py
 -rw-rw-rw-  2.0 fat    15264 b- defN 23-Mar-20 11:48 exudyn/artificialIntelligence.py
 -rw-rw-rw-  2.0 fat    11393 b- defN 23-Feb-16 08:35 exudyn/basicUtilities.py
 -rw-rw-rw-  2.0 fat    35948 b- defN 23-Feb-13 08:08 exudyn/beams.py
 -rw-rw-rw-  2.0 fat     7288 b- defN 23-Mar-06 07:23 exudyn/demos.py
--rw-rw-rw-  2.0 fat  5758976 b- defN 23-Mar-29 09:39 exudyn/exudynCPP.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat  5756416 b- defN 23-Apr-15 13:53 exudyn/exudynCPP.cp39-win_amd64.pyd
 -rw-rw-rw-  2.0 fat    85436 b- defN 23-Mar-27 06:21 exudyn/graphicsDataUtilities.py
 -rw-rw-rw-  2.0 fat    53048 b- defN 23-Feb-16 08:35 exudyn/interactive.py
--rw-rw-rw-  2.0 fat   158831 b- defN 23-Mar-29 09:32 exudyn/itemInterface.py
+-rw-rw-rw-  2.0 fat   158659 b- defN 23-Apr-15 13:45 exudyn/itemInterface.py
 -rw-rw-rw-  2.0 fat    32746 b- defN 23-Mar-14 16:29 exudyn/kinematicTree.py
 -rw-rw-rw-  2.0 fat    21846 b- defN 23-Mar-27 18:51 exudyn/lieGroupBasics.py
 -rw-rw-rw-  2.0 fat    13557 b- defN 22-Jul-11 07:16 exudyn/lieGroupIntegration.py
 -rw-rw-rw-  2.0 fat     3165 b- defN 23-Jan-09 06:59 exudyn/machines.py
 -rw-rw-rw-  2.0 fat     6169 b- defN 23-Feb-20 07:14 exudyn/physics.py
 -rw-rw-rw-  2.0 fat    50407 b- defN 23-Feb-16 08:35 exudyn/plot.py
--rw-rw-rw-  2.0 fat    71064 b- defN 23-Mar-20 11:48 exudyn/processing.py
+-rw-rw-rw-  2.0 fat    71531 b- defN 23-Apr-06 12:54 exudyn/processing.py
 -rw-rw-rw-  2.0 fat    14646 b- defN 23-Jan-09 06:59 exudyn/resultsMonitor.py
 -rw-rw-rw-  2.0 fat    65543 b- defN 23-Mar-28 12:54 exudyn/rigidBodyUtilities.py
--rw-rw-rw-  2.0 fat    12363 b- defN 22-Jan-25 11:08 exudyn/signalProcessing.py
+-rw-rw-rw-  2.0 fat    15158 b- defN 23-Apr-15 13:44 exudyn/signalProcessing.py
 -rw-rw-rw-  2.0 fat    27593 b- defN 23-Feb-16 08:35 exudyn/solver.py
--rw-rw-rw-  2.0 fat    64279 b- defN 23-Jan-23 09:02 exudyn/utilities.py
+-rw-rw-rw-  2.0 fat    66527 b- defN 23-Apr-15 13:44 exudyn/utilities.py
 -rw-rw-rw-  2.0 fat      898 b- defN 21-Dec-03 09:28 exudyn/robotics/__init__.py
--rw-rw-rw-  2.0 fat    22786 b- defN 23-Mar-28 10:22 exudyn/robotics/future.py
+-rw-rw-rw-  2.0 fat    24507 b- defN 23-Apr-06 06:16 exudyn/robotics/future.py
 -rw-rw-rw-  2.0 fat      527 b- defN 21-Dec-03 09:28 exudyn/robotics/mobile.py
 -rw-rw-rw-  2.0 fat    32539 b- defN 23-Mar-29 09:16 exudyn/robotics/models.py
 -rw-rw-rw-  2.0 fat    26097 b- defN 22-Mar-01 19:40 exudyn/robotics/motion.py
--rw-rw-rw-  2.0 fat    97646 b- defN 23-Mar-29 09:16 exudyn/robotics/roboticsCore.py
--rw-rw-rw-  2.0 fat    15299 b- defN 23-Mar-28 10:22 exudyn/robotics/special.py
--rw-rw-rw-  2.0 fat      544 b- defN 21-Dec-03 09:28 exudyn/robotics/utilities.py
--rw-rw-rw-  2.0 fat     1653 b- defN 23-Mar-29 09:39 exudyn-1.6.31.dev1.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 23-Mar-29 09:39 exudyn-1.6.31.dev1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 23-Mar-29 09:39 exudyn-1.6.31.dev1.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     2905 b- defN 23-Mar-29 09:39 exudyn-1.6.31.dev1.dist-info/RECORD
-36 files, 6979176 bytes uncompressed, 2196496 bytes compressed:  68.5%
+-rw-rw-rw-  2.0 fat    97871 b- defN 23-Mar-29 16:14 exudyn/robotics/roboticsCore.py
+-rw-rw-rw-  2.0 fat    15166 b- defN 23-Apr-06 06:16 exudyn/robotics/special.py
+-rw-rw-rw-  2.0 fat     5171 b- defN 23-Apr-15 13:43 exudyn/robotics/utilities.py
+-rw-rw-rw-  2.0 fat     1653 b- defN 23-Apr-15 13:53 exudyn-1.6.57.dev1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      100 b- defN 23-Apr-15 13:53 exudyn-1.6.57.dev1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        7 b- defN 23-Apr-15 13:53 exudyn-1.6.57.dev1.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     2906 b- defN 23-Apr-15 13:53 exudyn-1.6.57.dev1.dist-info/RECORD
+36 files, 6988395 bytes uncompressed, 2199320 bytes compressed:  68.5%
```

## zipnote {}

```diff
@@ -90,20 +90,20 @@
 
 Filename: exudyn/robotics/special.py
 Comment: 
 
 Filename: exudyn/robotics/utilities.py
 Comment: 
 
-Filename: exudyn-1.6.31.dev1.dist-info/METADATA
+Filename: exudyn-1.6.57.dev1.dist-info/METADATA
 Comment: 
 
-Filename: exudyn-1.6.31.dev1.dist-info/WHEEL
+Filename: exudyn-1.6.57.dev1.dist-info/WHEEL
 Comment: 
 
-Filename: exudyn-1.6.31.dev1.dist-info/top_level.txt
+Filename: exudyn-1.6.57.dev1.dist-info/top_level.txt
 Comment: 
 
-Filename: exudyn-1.6.31.dev1.dist-info/RECORD
+Filename: exudyn-1.6.57.dev1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## exudyn/itemInterface.py

```diff
@@ -1230,31 +1230,29 @@
         yield 'show', self.show
         yield 'sectionGeometry', self.sectionGeometry
         yield 'color', self.color
 
     def __repr__(self):
         return str(dict(self))
 class ObjectANCFBeam:
-    def __init__(self, name = '', nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex()], physicsLength = 0., sectionData = exudyn.BeamSection(), crossSectionPenaltyFactor = [1.,1.,1.], testBeamRectangularSize = [-1.,-1.], visualization = {'show': True, 'sectionGeometry': exudyn.BeamSectionGeometry(), 'color': [-1.,-1.,-1.,-1.]}):
+    def __init__(self, name = '', nodeNumbers = [exudyn.InvalidIndex(), exudyn.InvalidIndex()], physicsLength = 0., sectionData = exudyn.BeamSection(), crossSectionPenaltyFactor = [1.,1.,1.], visualization = {'show': True, 'sectionGeometry': exudyn.BeamSectionGeometry(), 'color': [-1.,-1.,-1.,-1.]}):
         self.name = name
         self.nodeNumbers = nodeNumbers
         self.physicsLength = CheckForValidPReal(physicsLength,"physicsLength","ObjectANCFBeam")
         self.sectionData = sectionData
         self.crossSectionPenaltyFactor = crossSectionPenaltyFactor
-        self.testBeamRectangularSize = testBeamRectangularSize
         self.visualization = visualization
 
     def __iter__(self):
         yield 'objectType', 'ANCFBeam'
         yield 'name', self.name
         yield 'nodeNumbers', self.nodeNumbers
         yield 'physicsLength', self.physicsLength
         yield 'sectionData', self.sectionData
         yield 'crossSectionPenaltyFactor', self.crossSectionPenaltyFactor
-        yield 'testBeamRectangularSize', self.testBeamRectangularSize
         yield 'Vshow', dict(self.visualization)["show"]
         yield 'VsectionGeometry', dict(self.visualization)["sectionGeometry"]
         yield 'Vcolor', dict(self.visualization)["color"]
 
     def __repr__(self):
         return str(dict(self))
 #add typedef for short usage:
```

## exudyn/processing.py

```diff
@@ -114,24 +114,37 @@
     return globalCnt
     
 
 
 #**function: processes parameterFunction for given parameters in parameterList, see ParameterVariation
 #**input:
 #    parameterFunction: function, which takes the form parameterFunction(parameterDict) and which returns any values that can be stored in a list (e.g., a floating point number)
-#    parameterList: list of parameter sets (as dictionaries) which are fed into the parameter variation, e.g., [{'mass': 10}, {'mass':20}, ...]
-#    addComputationIndex: if True, key 'computationIndex' is added to every parameterDict in the call to parameterFunction(), which allows to generate independent output files for every parameter, etc.
+#    parameterList: list of parameter sets (as dictionaries) which are fed into the parameter variation, see example 
 #    useMultiProcessing: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
 #    numberOfThreads: default: same as number of cpus (threads); used for multiprocessing lib;
 #    resultsFile: if provided, output is immediately written to resultsFile during processing
 #    clusterHostNames: list of hostnames, e.g. clusterHostNames=['123.124.125.126','123.124.125.127'] providing a list of strings with IP addresses or host names, see dispy documentation. If list is non-empty and useMultiProcessing==True and dispy is installed, cluster computation is used; NOTE that cluster computation speedup factors shown are not fully true, as they include a significant overhead; thus, only for computations which take longer than 1-5 seconds and for sufficient network bandwith, the speedup is roughly true
 #    useDispyWebMonitor: if given in **kwargs, a web browser is startet in case of cluster computation to manage the cluster during computation
 #**output: returns values containing the results according to parameterList
 #**notes: options are passed from Parametervariation
-def ProcessParameterList(parameterFunction, parameterList, addComputationIndex, useMultiProcessing, clusterHostNames=[], **kwargs):
+#**example:
+#def PF(parameterSet):
+#    #in reality, value will be result of a complex exudyn simulation:
+#    value = sin(parameterSet['mass']) * parameterSet['stiffness']
+#    return value
+#
+#values=ProcessParameterList(parameterFunction=PF, 
+#                            parameterList=[{'m':1, 's':100},
+#                                          {'m':2, 's':100},
+#                                          {'m':3, 's':100},
+#                                          {'m':1, 's':200},
+#                                          {'m':2, 's':250},
+#                                          {'m':3, 's':300},
+#                                          ], useMultiProcessing=False )
+def ProcessParameterList(parameterFunction, parameterList, useMultiProcessing, clusterHostNames=[], **kwargs):
     values = [] #create empty list
     nVariations = len(parameterList)
     #print("pl=",parameterList)
     showProgress = False
     if 'showProgress' in kwargs: 
         showProgress = kwargs['showProgress']
 
@@ -342,20 +355,23 @@
 #    addComputationIndex: if True, key 'computationIndex' is added to every parameterDict in the call to parameterFunction(), which allows to generate independent output files for every parameter, etc.
 #    useMultiProcessing: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
 #    showProgress: if True, shows for every iteration the progress bar (requires tqdm library)
 #    resultsFile: if provided, output is immediately written to resultsFile during processing
 #    numberOfThreads: default(None): same as number of cpus (threads); used for multiprocessing lib;
 #    parameterFunctionData: dictionary containing additional data passed to the parameterFunction inside the parameters with dict key 'functionData'; use this e.g. for passing solver parameters or other settings
 #    clusterHostNames: list of hostnames, e.g. clusterHostNames=['123.124.125.126','123.124.125.127'] providing a list of strings with IP addresses or host names, see dispy documentation. If list is non-empty and useMultiProcessing==True and dispy is installed, cluster computation is used; NOTE that cluster computation speedup factors shown are not fully true, as they include a significant overhead; thus, only for computations which take longer than 1-5 seconds and for sufficient network bandwith, the speedup is roughly true
-#    useDispyWebMonitor: if given in **kwargs, a web browser is startet in case of cluster computation to manage the cluster during computation
+#    useDispyWebMonitor: if given in **kwargs, a web browser is started in case of cluster computation to manage the cluster during computation
 #**output:
-#    returns [parameterList, values], containing, e.g., parameterList={'mass':[1,1,1,2,2,2,3,3,3], 'stiffness':[4,5,6, 4,5,6, 4,5,6]} and the result values of the parameter variation accoring to the parameterList, 
+#    returns [parameterList, values], containing, e.g., parameterList=\{'mass':[1,1,1,2,2,2,3,3,3], 'stiffness':[4,5,6, 4,5,6, 4,5,6]\} and the result values of the parameter variation accoring to the parameterList, 
 #           values=[7,8,9 ,3,4,5, 6,7,8] (depends on solution of problem ..., can also contain tuples, etc.)
 #**example:
-#   ParameterVariation(parameters={'mass':(1,10,10), 'stiffness':(1000,10000,10)}, parameterFunction=Test, useMultiProcessing=True)
+#if __name__ == '__main__':
+#    ParameterVariation(parameterFunction=Test, 
+#                       parameters={'mass':(1,10,10), 'stiffness':(1000,10000,10)}, 
+#                       useMultiProcessing=True)
 def ParameterVariation(parameterFunction, parameters, 
                        useLogSpace=False, debugMode=False, addComputationIndex=False,
                        useMultiProcessing=False, showProgress = True, parameterFunctionData={}, clusterHostNames=[],
                        numberOfThreads=None, resultsFile='', **kwargs):
     
     if 'multiprocessing' in sys.modules:
         from multiprocessing import cpu_count
@@ -457,15 +473,15 @@
             cnt += 1
         if parameterFunctionData != {}:
             parameterSet['functionData'] = parameterFunctionData
             #not needed: parameterSet['functionData'] = copy.deepcopy(parameterFunctionData)
             
         parameterList += [parameterSet]
 
-    values = ProcessParameterList(parameterFunction, parameterList, addComputationIndex, useMultiProcessing, 
+    values = ProcessParameterList(parameterFunction, parameterList, useMultiProcessing, 
                                   showProgress = showProgress, numberOfThreads=numberOfThreads,
                                   resultsFile = resultsFile, parameters=parameters, 
                                   clusterHostNames=clusterHostNames, **kwargs)
     
     return [parameterDict, values]
     
 
@@ -497,15 +513,15 @@
 #    clusterHostNames: list of hostnames, e.g. clusterHostNames=['123.124.125.126','123.124.125.127'] providing a list of strings with IP addresses or host names, see dispy documentation. If list is non-empty and useMultiProcessing==True and dispy is installed, cluster computation is used; NOTE that cluster computation speedup factors shown are not fully true, as they include a significant overhead; thus, only for computations which take longer than 1-5 seconds and for sufficient network bandwith, the speedup is roughly true
 #    useDispyWebMonitor: if given in **kwargs, a web browser is startet in case of cluster computation to manage the cluster during computation
 #**output:
 #    returns [optimumParameter, optimumValue, parameterList, valueList], containing the optimum parameter set 'optimumParameter', optimum value 'optimumValue', the whole list of parameters parameterList with according objective values 'valueList'
 #           values=[7,8,9 ,3,4,5, 6,7,8] (depends on solution of problem ..., can also contain tuples, etc.)
 #**notes: This function is still under development and shows an experimental state! 
 #**example:
-#   GeneticOptimization(objectiveFunction = fOpt, parameters={'mass':(1,10), 'stiffness':(1000,10000)})
+#GeneticOptimization(objectiveFunction = fOpt, parameters={'mass':(1,10), 'stiffness':(1000,10000)})
 def GeneticOptimization(objectiveFunction, parameters, 
                         populationSize=100,
                         numberOfGenerations=10,
                         elitistRatio = 0.1,
                         crossoverProbability=0.25,
                         crossoverAmount=0.5,
                         rangeReductionFactor=0.7,
@@ -638,15 +654,15 @@
     resultsFileCnt = 0 #counter for output file
 
     for popCnt in range(numberOfGenerations):
         if debugMode:
             print("===============\nevaluate population", popCnt, ":")
 
         totalEvaluations += len(currentGeneration)
-        values = ProcessParameterList(objectiveFunction, currentGeneration, addComputationIndex, useMultiProcessing, showProgress = showProgress, numberOfThreads=numberOfThreads,
+        values = ProcessParameterList(objectiveFunction, currentGeneration, useMultiProcessing, showProgress = showProgress, numberOfThreads=numberOfThreads,
                                       clusterHostNames=clusterHostNames, useDispyWebMonitor=useDispyWebMonitor)
 
         if (showProgress and useMultiProcessing and popCnt < numberOfGenerations-1): print("            #"+str(popCnt+1), end='')
         #print("values=",values)
         multiProcessingMode = ''
         if useMultiProcessing:
             multiProcessingMode = 'multiprocessing.Pool, numberOfThreads='+str(numberOfThreads)
@@ -1125,15 +1141,15 @@
         for cnt in range(1, len(parameterList)): 
             parameterList[cnt]['computationIndex'] = cnt
         
     if parameterFunctionData != {}:
         for cnt in range(0, len(parameterList)): 
             parameterList[cnt]['functionData'] = parameterFunctionData
 
-    values = ProcessParameterList(parameterFunction, parameterList, addComputationIndex, useMultiProcessing, 
+    values = ProcessParameterList(parameterFunction, parameterList, useMultiProcessing, 
                                   showProgress = showProgress, numberOfThreads=numberOfThreads,
                                   resultsFile = resultsFile, parameters=parameters)
 
 
     # calculate sensitivity of the parameter by forward/central difference
     sensitivity = np.zeros([len(nVar), len(values[0])])
     valuesSorted = {paramKeys[0]: []}
```

## exudyn/signalProcessing.py

```diff
@@ -9,14 +9,15 @@
 # Notes:    This module is still under construction and should be used with care!
 #
 # Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
 #
 #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
 import numpy as np
+from exudyn.advancedUtilities import IsListOrArray
 
 #**function: filter output of sensors (using numpy savgol filter) as well as numerical differentiation to compute derivative of signal
 #**input:
 #   signal: numpy array (2D array with column-wise storage of signals, as exported by EXUDYN position, displacement, etc. sensors); first column = time, other columns = signals to operate on; note that it is assumed, that time devided in almost constant steps!
 #   derivative: 0=no derivative, 1=first derivative, 2=second derivative, etc. (>2 only possible with filter)
 #   polyOrder: order of polynomial for interpolation filtering
 #   filterWindow: if zero: produces unfiltered derivative; if positive, must be ODD integer {1,3,5,...} and > polyOrder; filterWindow determines the length of the filter window (e.g., to get rid of noise)
@@ -145,28 +146,30 @@
     
     # compute phase vector in (rad)
     phase = np.angle( Y[0:halfNumberOfDataPoints+1] )
     
     return [frequency, magnitude, phase]      
 
 
+
+
 #**function: Interpolate signal having time values with constant sampling rate in timeArray and according data in dataArray
 #**input: 
 #  time: time at which the data should be evaluated
 #  dataArray: 1D numpy array containing data values to be interpolated [alternatively: 2D numpy array, rows containg the data of the according time point; use dataArrayColumnIndex to specify the column of requested data]
 #  timeArray: 1D numpy array containing time values with CONSTANT SAMPLING RATE to be interpolated [alternatively: 2D numpy array, rows containg the time and data of the according time point; use timeArrayColumnIndex to specify the column representing time]; if timeArray is empty list [], dataArray is used instead!
 #  rangeWarning: print warning if resulting index gets out of range
 #  dataArrayColumnIndex: in case of 2D arrays, this represents the column of the requested data
 #  timeArrayColumnIndex: in case of 2D arrays, this represents the column of time values
 #  tolerance: this tolerance is used to check, if the timeArray has equidistant interpolation and if the found indices are correct; use e.g. 1e10 in order to ignore this tolerance
 #**notes: for interpolation of data WITHOUT constant data rate, use numpy.interp(time, timeArray, dataArray) in case that timeArray and dataArray are 1D arrays
 #**output: interpolated value
-def GetInterpolatedSignalValue(time, dataArray, timeArray=[], timeArrayIndex = -1, dataArrayIndex = -1, rangeWarning=True, tolerance=1e-6):
+def GetInterpolatedSignalValue(time, dataArray, timeArray=[], dataArrayIndex = -1, timeArrayIndex = -1, rangeWarning=True, tolerance=1e-6):
 
-    if type(timeArray) == list and len(timeArray) == 0:
+    if IsListOrArray(timeArray) and len(timeArray) == 0:
         timeArray=dataArray
     if dataArray.ndim != 1 and dataArrayIndex == -1:
         raise ValueError('GetInterpolatedSignalValue: in case of 2D dataArray, dataArrayIndex must be provided!')
     if timeArray.ndim != 1 and timeArrayIndex == -1:
         raise ValueError('GetInterpolatedSignalValue: in case of 2D timeArray, timeArrayIndex must be provided!')
 
     t0 = -1 #time of first value
@@ -207,28 +210,92 @@
             value = dataArray[-1,dataArrayIndex]
     else:
         
         #interpolate
         tA = dt*index + t0
         tB = tA+dt 
         #check if time index is correct:
-        if timeArrayIndex == -1:
+        if timeArrayIndex == -1: #1D array
+            if abs(tA-timeArray[index]) > tolerance or abs(tB-timeArray[index+1]) > tolerance :
+                print('Warning: GetInterpolatedSignalValue: timeArray does not seem to have constant sampling rate; use larger tolerance or numpy.interp(...) instead')
+        else: #2D array
             if (abs(tA-timeArray[index,timeArrayIndex]) > tolerance or 
                 abs(tB-timeArray[index+1,timeArrayIndex]) > tolerance):
                 print('Warning: GetInterpolatedSignalValue: timeArray does not seem to have constant sampling rate; use larger tolerance or numpy.interp(...) instead')
-        else:
-            if abs(tA-timeArray[index]) > tolerance or abs(tB-timeArray[index+1]) > tolerance :
-                print('Warning: GetInterpolatedSignalValue: timeArray does not seem to have constant sampling rate; use larger tolerance or numpy.interp(...) instead')
             
 
         if dataArrayIndex == -1: #1D array
             valueA = dataArray[index]
             valueB = dataArray[index+1]
         else: #2D array
             valueA = dataArray[index,dataArrayIndex]
             valueB = dataArray[index+1,dataArrayIndex]
 
         #print('tA=', tA, ', tB=', tB, ', valueA=', valueA, ', valueB=', valueB)
         value = valueA*(tB-time)/dt + valueB*(time-tA)/dt
 
     return value
 
+
+
+#simple tests:
+if __name__ == '__main__':
+    
+    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #GetInterpolatedSignalValue
+    #%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    #create 1D signal
+    t = np.linspace(1,10,40)
+    x = np.sin(t)
+    
+    #coarsen
+    t2 = np.linspace(0,11,15)
+    x2 = np.array([GetInterpolatedSignalValue(ti, x, t, rangeWarning=False) for ti in t2])
+
+    #refine
+    t3 = np.linspace(0,11,90)
+    x3 = np.array([GetInterpolatedSignalValue(ti, x, t, rangeWarning=False) for ti in t3])
+    
+    from exudyn.plot import PlotSensor
+    PlotSensor(None, sensorNumbers=[np.vstack((t,x)).T, np.vstack((t2,x2)).T, np.vstack((t3,x3)).T], closeAll=True, title='1D array')
+    
+    #create 2D signal
+    t = np.linspace(1,10,40)
+    x = np.sin(t)
+    y = np.cos(t)
+    data = np.vstack((t,np.vstack((x,y)))).T
+    
+    #coarsen, data is 2D
+    t2 = np.linspace(0,11,15)
+    x2 = np.array([GetInterpolatedSignalValue(ti, dataArray=data, dataArrayIndex=1, timeArrayIndex=0, rangeWarning=False) for ti in t2])
+
+    #refine, data is 2D
+    t3 = np.linspace(0,11,90)
+    x3 = np.array([GetInterpolatedSignalValue(ti, dataArray=data, dataArrayIndex=2, timeArrayIndex=0, rangeWarning=False) for ti in t3])
+
+    #refine, use 'different' time and data arrays; both arrays are 2D arrays
+    t4 = np.linspace(0,11,45)
+    x4 = np.array([GetInterpolatedSignalValue(ti, dataArray=data, timeArray=data, dataArrayIndex=1, timeArrayIndex=0, rangeWarning=False) for ti in t4])
+    
+    #refine, use different time and data arrays; data is 2D, time is 1D
+    t5 = np.linspace(0,11,45)
+    x5 = np.array([GetInterpolatedSignalValue(ti, dataArray=data, timeArray=t, dataArrayIndex=2, rangeWarning=False) for ti in t5])
+
+    #refine, use different time and data arrays; data is 1D, time is 2D
+    t6 = np.linspace(0,11,45)
+    x6 = np.array([GetInterpolatedSignalValue(ti, dataArray=y, timeArray=data, timeArrayIndex=0, rangeWarning=False) for ti in t6])
+    
+    PlotSensor(None, sensorNumbers=[np.vstack((t,x)).T, np.vstack((t,y)).T, 
+                                    np.vstack((t2,x2)).T, np.vstack((t3,x3)).T, np.vstack((t4,x4)).T, np.vstack((t5,x5)).T, np.vstack((t6,x6)).T
+                                    ], newFigure=True, title='2D array')
+    
+    import time
+    ts = -time.time()    
+    t2 = np.linspace(0,11,500000)
+    x2 = np.array([GetInterpolatedSignalValue(ti, x, t, rangeWarning=False) for ti in t2])
+
+    #about 1.4 seconds on 3GHz i7 processor
+    print('5e5 x GetInterpolatedSignalValue takes', time.time()+ts, 'seconds')
+
+
+
+
```

## exudyn/utilities.py

```diff
@@ -141,59 +141,87 @@
 
         mbs.SetObjectParameter(graphicsObject,'referencePosition',p0 + factLen*(d*np.array(Normalize(dirSensor))) )
         if hasRotation:
             mbs.SetObjectParameter(graphicsObject,'referenceRotation', A0)
             
     return rv
 
+
+
+#**function: Add geometry for distance sensor given by points and triangles (point indices) to mbs; use a rigid body marker where the geometry is put on; 
+#           Creates a GeneralContact for efficient search on background. If you have several sets of points and trigs, first merge them or add them manually to the contact
+#**input: 
+#  mbs: MainSystem where contact is created
+#  meshPoints: list of points (3D), as returned by GraphicsData2PointsAndTrigs()
+#  meshTrigs: list of trigs (3 node indices each), as returned by GraphicsData2PointsAndTrigs()
+#  rigidBodyMarkerIndex: rigid body marker to which the triangles are fixed on (ground or moving object)
+#  searchTreeCellSize: size of search tree (X,Y,Z); use larger values in directions where more triangles are located
+#**output: returns [ngc, gContact]: ngc is the number of GeneralContact in mbs, to be used in AddDistanceSensor; keep the gContact as deletion may corrupt data
+#**notes: should be used by AddDistanceSensor(...) and AddLidar(...) for simple initialization of GeneralContact
+def DistanceSensorSetupGeometry(mbs, meshPoints, meshTrigs, rigidBodyMarkerIndex, searchTreeCellSize=[8,8,8]):
+    gContact = mbs.AddGeneralContact()
+    gContact.SetFrictionPairings(0*np.eye(1)) #may not be empty
+    gContact.SetSearchTreeCellSize(numberOfCells=searchTreeCellSize)
+    # [meshPoints, meshTrigs] = RefineMesh(meshPoints, meshTrigs) #just to have more triangles on floor
+    gContact.AddTrianglesRigidBodyBased(rigidBodyMarkerIndex=rigidBodyMarkerIndex,
+                                        contactStiffness=1, contactDamping=1, #dummy values
+                                        frictionMaterialIndex=0, pointList=meshPoints, triangleList=meshTrigs)
+    gContact.isActive=False #no contact computation; could also be done later on, if many moving objects are used ...
+    ngc = mbs.NumberOfGeneralContacts()-1
+    gContact = mbs.GetGeneralContact(ngc) #keeps reference to gContact, while other functions work with automatic ...
+
+    return ngc
+
 #**function: Function to add distance sensor based on GeneralContact to mbs; sensor can be either placed on absolute position or attached to rigid body marker; in case of marker, dirSensor is relative to the marker
 #**input:
 #  generalContactIndex: the number of the GeneralContact object in mbs; the index of the GeneralContact object which has been added with last AddGeneralContact(...) command is generalContactIndex=mbs.NumberOfGeneralContacts()-1
 #  positionOrMarker: either a 3D position as list or np.array, or a MarkerIndex with according rigid body marker
 #  dirSensor: the direction (no need to normalize) along which the distance is measured (must not be normalized); in case of marker, the direction is relative to marker orientation if marker contains orientation (BodyRigid, NodeRigid)
 #  minDistance: the minimum distance which is accepted; smaller distance will be ignored
 #  maxDistance: the maximum distance which is accepted; items being at maxDistance or futher are ignored; if no items are found, the function returns maxDistance
 #  cylinderRadius: in case of spheres (selectedTypeIndex=ContactTypeIndex.IndexSpheresMarkerBased), a cylinder can be used which measures the shortest distance at a certain radius (geometrically interpreted as cylinder)
 #  selectedTypeIndex: either this type has default value, meaning that all items in GeneralContact are measured, or there is a specific type index, which is the only type that is considered during measurement
 #  storeInternal: like with any SensorUserFunction, setting to True stores sensor data internally
 #  fileName: if defined, recorded data of SensorUserFunction is written to specified file
 #  measureVelocity: if True, the sensor measures additionally the velocity (component 0=distance, component 1=velocity); velocity is the velocity in direction 'dirSensor' and does not account for changes in geometry, thus it may be different from the time derivative of the distance!
 #  addGraphicsObject: if True, the distance sensor is also visualized graphically in a simplified manner with a red line having the length of dirSensor; NOTE that updates are ONLY performed during computation, not in visualization; for this reason, solutionSettings.sensorsWritePeriod should be accordingly small
 #  drawDisplaced: if True, the red line is drawn backwards such that it moves along the measured surface; if False, the beam is fixed to marker or position
+#  color: optional color for 'laser beam' to be drawn
 #**output: creates sensor and returns according sensor number of SensorUserFunction
+#**notes: use generalContactIndex = DistanceSensorSetupGeometry(...) before to create GeneralContact module containing geometry
 def AddDistanceSensor(mbs, generalContactIndex,
                       positionOrMarker, dirSensor, minDistance=-1e7, 
                       maxDistance=1e7, cylinderRadius=0, 
                       selectedTypeIndex=exudyn.ContactTypeIndex.IndexEndOfEnumList,
                       storeInternal = False, fileName = '', measureVelocity = False,
-                      addGraphicsObject=False, drawDisplaced=True):
+                      addGraphicsObject=False, drawDisplaced=True, color=color4red):
     
     markerNumber = -1
     p0list = [0,0,0]
     if type(positionOrMarker) == list or type(positionOrMarker) == np.ndarray:
         p0list = list(positionOrMarker)
     elif type(positionOrMarker)==exudyn.MarkerIndex:
         markerNumber = float(int(positionOrMarker))
         try:
-            p0list = mbs.GetMarkerOutput(markerNumber=0,variableType=exu.OutputVariableType.Position, configuration=exu.ConfigurationType.Reference)
+            p0list = mbs.GetMarkerOutput(markerNumber=positionOrMarker,variableType=exu.OutputVariableType.Position, configuration=exu.ConfigurationType.Reference)
             p0list = list(p0list)
         except:
             p0list = [0,0,0] #this was just a trial, otherwise initialize with zeros (e.g. for special objects where this does not work)
     else:
         raise ValueError('AddDistanceSensor: positionOrMarker must be either MarkerIndex or 3D position as list or numpy.array')
 
     graphicsObject = -1 #signals that there is no graphics object
     sign = 1.
     if drawDisplaced:
         sign = -1.
     if addGraphicsObject:
         if cylinderRadius == 0:
-            gData = GraphicsDataLine([[0,0,0],list(sign*np.array(dirSensor))], color = color4red)
+            gData = GraphicsDataLine([[0,0,0],list(sign*np.array(dirSensor))], color = color)
         else: 
-            gData = GraphicsDataCylinder([0,0,0],sign*np.array(dirSensor), radius=cylinderRadius, color = color4red)
+            gData = GraphicsDataCylinder([0,0,0],sign*np.array(dirSensor), radius=cylinderRadius, color = color)
             
         graphicsObject=mbs.AddObject(ObjectGround(referencePosition= p0list,
                                       visualization=VObjectGround(graphicsData=[gData])))
 
     flags = int(drawDisplaced)
     dataUF = [float(generalContactIndex)]
     dataUF += [markerNumber] + p0list + list(dirSensor)
@@ -203,19 +231,14 @@
     sUF = mbs.AddSensor(SensorUserFunction(sensorNumbers=[], factors=dataUF,
                                               storeInternal=True,
                                               sensorUserFunction=__UFsensorDistance))
 
     return sUF
 
 
-
-
-
-
-
 #**function: DEPRECATED: Internal SensorUserFunction, used in function AddSensorRecorder
 #**notes: Warning: this method is DEPRECATED, use storeInternal in Sensors, which is much more performant; Note, that a sensor usually just passes through values of an existing sensor, while recording the values to a numpy array row-wise (time in first column, data in remaining columns)
 def UFsensorRecord(mbs, t, sensorNumbers, factors, configuration):
     iSensor = sensorNumbers[0]
     val = mbs.GetSensorValues(iSensor, configuration=configuration) #get all values
     if type(val) == float:# or type(x) == nd.float64:
         val = np.array([val]) #for scalar values
```

## exudyn/robotics/future.py

```diff
@@ -71,30 +71,29 @@
 #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 #            INVERSE KINEMATICS
 #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
 #**function: calculates the analytical inverse kinematics for 3R elbow type serial robot manipulator
 #**input:
-#  robot: robot structure
+#  robotDic: robot dictionary
 #  HT: desired position and orientation for the end effector as 4x4 homogeneous transformation matrix as list of lists or np.array
 #**output: solutions, list of lists with posible joint angles [q1,q2,q3] (in radiant)
-#          to achive the desired position and orientation (4 posible solutions,schoulder left/right, ellbow up/down )
-#          left/down, left/up, right/up, right/down
+#          to achive the desired position (4 posible solutions,schoulder left/right, ellbow up/down ) in following order: left/down, left/up, right/up, right/down
 #**author: Martin Sereinig
 #**notes:  only applicable for standard Denavit-Hartenberg parameters
 #**status: testet with various configurations and joint angels
-def ComputeIK3R(robot, HT):
+def ComputeIK3R(robotDic, HT):
     ZERO = 10e-10
     # DH-parameters: [theta, d, a, alpha], according to P. Corke page 138
     qSolutions = np.empty((4, 3))
 
-    d1 = robot['links'][0]['stdDH'][1]
-    a2 = robot['links'][1]['stdDH'][2]
-    a3 = robot['links'][2]['stdDH'][2]
+    d1 = robotDic['links'][0]['stdDH'][1]
+    a2 = robotDic['links'][1]['stdDH'][2]
+    a3 = robotDic['links'][2]['stdDH'][2]
 
     Px = HT[0][3]
     Py = HT[1][3]
     Pz = HT[2][3]
 
     # calculations following the steps by De Luca / Standard geometric approach
     # calculations for theta 1
@@ -103,15 +102,15 @@
         qSolutions[1, 0] = np.arctan2(-Py, -Px)
         qSolutions[2, 0] = np.arctan2(Py, Px)
         qSolutions[3, 0] = np.arctan2(-Py, -Px)
     else:
         print('infinite solutions for th1,it is undefined but here set to 0')
     
     for i in range(len(qSolutions)):
-        HT01 = rob.DH2HT([qSolutions[i, 0]]+robot['links'][0]['stdDH'][1:4])
+        HT01 = rob.DH2HT([qSolutions[i, 0]]+robotDic['links'][0]['stdDH'][1:4])
         #print(HT01)
         Dhelp = ((Px-HT01[0][3])**2+(Py-HT01[1][3])**2+(Pz-HT01[2][3])**2-a2**2-a3**2)/(2*a2*a3)
         #print(Dhelp)
         if np.abs(Dhelp)<=1:
            if i <= 1:
                 qSolutions[i,2] = np.arctan2(np.sqrt((1-Dhelp**2)), Dhelp)
                 qSolutions[i,1] = np.arctan2(Pz-HT01[2][3], np.sqrt((Px)**2+(Py)**2))-np.arctan2(a3*np.sin(qSolutions[i,2]), a2+a3*np.cos(qSolutions[i,2]))
@@ -126,66 +125,66 @@
             qSolutions[i,2]=np.nan
             qSolutions[i,1]=np.nan
         
 
     solutionsarray = np.array(qSolutions)
     index2delete = []
     for i in range(len(solutionsarray)):
-        TSol = rob.ComputeJointHT(robot, solutionsarray[i])[2]
+        TSol = rob.ComputeJointHT(robotDic, solutionsarray[i])[2]
         errorSolution = np.linalg.det(HT)-np.linalg.det(TSol)
 
         # print(errorSolution)
         if errorSolution > ZERO or np.isnan(errorSolution):
             index2delete += [i]
 
 
     #solutionsarray=np.delete(solutionsarray,index2delete,axis=0)   # to delete a row of wrong or nan solutions
     #print(['Solutions to delete: ']+[str((index2delete))])
 
     return solutionsarray
 
 
 
-#**function: calculates the analytical inverse kinematics for Puma560 serial 6R robot manipulator
+#**function: calculates the analytical inverse kinematics for Puma560 serial 6R robotDic manipulator
 #**input:
-#  robot: robot structure
+#  robotDic: robotDictionary
 #  HT: desired position and orientation for the end effector as 4x4 homogeneous transformation matrix as list of lists or np.array
 #**output: qSolutions, list of lists with posible joint angles [q1,q2,q3,q4,q5,q6] (in radiant)
 #          to achive the desired position and orientation (8 posible solutions,schoulder left/right, ellbow up/down, wrist flipped/notflipped (rotated by pi) )
 #          left/down/notflipped, left/down/flipped, left/up/notflipped, left/up/flipped, right/up/notflipped, right/up/flipped, right/down/notflipped, right/down/flipped
 #**author: Martin Sereinig
 #**notes:  Usage for different manipulators with sperical wrist posible, only applicable for standard Denavit-Hartenberg parameters
-#**status: tested (compared with Robotcs, Vision and Control book of P. Corke
-def ComputeIKPuma560(robot, HT):
+#**status: tested (compared with robotDiccs, Vision and Control book of P. Corke
+def ComputeIKPuma560(robotDic, HT):
     # - Inverse kinematics for a PUMA 560,
     #   Paul and Zhang,
     #   The International Journal of Robotics Research,
     #   Vol. 5, No. 2, Summer 1986, p. 32-44
     # Solve for theta(1)
     # r is defined in equation 38, p. 39.
     # theta(1) uses equations 40 and 41, p.39,
 
 
     # DH-parameters: [theta, d, a, alpha], according to P. Corke page 138
 
-    a2 = robot['links'][1]['stdDH'][2]
-    a3 = robot['links'][2]['stdDH'][2]
-    d3 = robot['links'][2]['stdDH'][1]
-    d4 = robot['links'][3]['stdDH'][1]
+    a2 = robotDic['links'][1]['stdDH'][2]
+    a3 = robotDic['links'][2]['stdDH'][2]
+    d3 = robotDic['links'][2]['stdDH'][1]
+    d4 = robotDic['links'][3]['stdDH'][1]
 
-    a5= robot['links'][4]['stdDH'][2]
-    d6= robot['links'][5]['stdDH'][1]
+    a5= robotDic['links'][4]['stdDH'][2]
+    d6= robotDic['links'][5]['stdDH'][1]
 
 
     # The following parameters are extracted from the homogeneous
     # transformation as defined in equation 1, p. 34
     # Positon of Wrist Center
     Px = HT[0][3]
     Py = HT[1][3]
-    Pz= HT[2][3] - robot['links'][0]['stdDH'][1]
+    Pz= HT[2][3] - robotDic['links'][0]['stdDH'][1]
 
     # Solve for theta(1)
     r = np.sqrt(Px**2 + Py**2)
 
 
     theta1_1 = np.arctan2(Py, Px) + np.pi - np.arcsin(d3/r) # base left
     theta1_2 = np.arctan2(Py, Px) + np.arcsin(d3/r)         # base right
@@ -245,64 +244,64 @@
 
 
     qSolutions = []
     # spherical wrist inverse orientation
     for i in range(len(qSolution)):
         # we need to account for some random translations between the first and last 3
         # joints (d4) and also d6,a6,alpha6 in the final frame.
-        T13_1= rob.ComputeJointHT(robot, [qSolution[i][0], qSolution[i][1], qSolution[i][2], 0, 0, 0])[2]
+        T13_1= rob.ComputeJointHT(robotDic, [qSolution[i][0], qSolution[i][1], qSolution[i][2], 0, 0, 0])[2]
         # print(T13_1)
         Td4 = rob.HTtranslate([0, 0, d4])
         # print(Td4)
-        Tt = rob.HTtranslate([a5, 0, d6]) @ rob.HTrotateX(robot['links'][5]['stdDH'][3])
+        Tt = rob.HTtranslate([a5, 0, d6]) @ rob.HTrotateX(robotDic['links'][5]['stdDH'][3])
         # print(Tt)
         TR = np.linalg.inv(Td4)  @  np.linalg.inv(T13_1) @ HT @ np.linalg.inv(Tt)
 
         R = HT2rotationMatrix(TR)
         # print(R)
         eul= [RotationMatrix2RotZYZ(R, flip=True)]
         eul.append(RotationMatrix2RotZYZ(R, flip=False))
 
-        if (robot['links'][3]['stdDH'][3]) > 0:
+        if (robotDic['links'][3]['stdDH'][3]) > 0:
             eul[0][1] = -1*eul[0][1]
             eul[1][1] = -1*eul[1][1]
         qSolutions += ([[qSolution[i][0], qSolution[i][1], qSolution[i][2], eul[0][0], eul[0][1], eul[0][2]],
                        [qSolution[i][0], qSolution[i][1], qSolution[i][2], eul[1][0], eul[1][1], eul[1][2]]])
 
     return qSolutions
 
 #**function: calculates the analytical inverse kinematics for UR type serial 6R robot manipulator without sperical wrist
 #**input:
-#  robot: robot structure
+#  robotDic: robot dictionary
 #  HT: desired position and orientation for the end effector as 4x4 homogeneous transformation matrix as list of lists or np.array
 #**output: solutions, list of lists with posible joint angles [q1,q2,q3,q4,q5,q6] (in radiant)
 #          to achive the desired position and orientation (8 posible solutions,schoulder left/right, ellbow up/down, wrist flipped/notflipped (rotated by pi) )
 #          [left/down/notflipped, left/down/flipped, left/up/notflipped, left/up/flipped, right/up/notflipped, right/up/flipped, right/down/notflipped, right/down/flipped]
 #**notes:  Usage for different manipulators without sperical wrist posible UR3,UR5,UR10, only applicable for standard Denavit-Hartenberg parameters
 #**author: Martin Sereinig
 #**status: under development, works for most configurations, singularities not checked -> ZeroConfiguration not working
-def ComputeIKUR(robot, HTdes):
+def ComputeIKUR(robotDic, HTdes):
     # - Inverse kinematics for a URType
     ZERO = 10e-8
     SolWarning = ['NoWarning']*4
 
     # DH-parameters: [theta, d, a, alpha], according to P. Corke page 138
-    a1 = robot['links'][0]['stdDH'][2]
-    a2 = robot['links'][1]['stdDH'][2]
-    a3 = robot['links'][2]['stdDH'][2]
-    a4 = robot['links'][3]['stdDH'][2]
-    a5 = robot['links'][4]['stdDH'][2]
-    a6 = robot['links'][5]['stdDH'][2]
-
-    d1 = robot['links'][0]['stdDH'][1]
-    d2 = robot['links'][1]['stdDH'][1]
-    d3 = robot['links'][2]['stdDH'][1]
-    d4 = robot['links'][3]['stdDH'][1]
-    d5 = robot['links'][4]['stdDH'][1]
-    d6 = robot['links'][5]['stdDH'][1]
+    a1 = robotDic['links'][0]['stdDH'][2]
+    a2 = robotDic['links'][1]['stdDH'][2]
+    a3 = robotDic['links'][2]['stdDH'][2]
+    a4 = robotDic['links'][3]['stdDH'][2]
+    a5 = robotDic['links'][4]['stdDH'][2]
+    a6 = robotDic['links'][5]['stdDH'][2]
+
+    d1 = robotDic['links'][0]['stdDH'][1]
+    d2 = robotDic['links'][1]['stdDH'][1]
+    d3 = robotDic['links'][2]['stdDH'][1]
+    d4 = robotDic['links'][3]['stdDH'][1]
+    d5 = robotDic['links'][4]['stdDH'][1]
+    d6 = robotDic['links'][5]['stdDH'][1]
     # The following parameters are extracted from the Homogeneous
     # Transformation as defined in equation 1, p. 34
     # Positon of Wrist Center
     Px = HTdes[0][3]
     Py = HTdes[1][3]
     Pz = HTdes[2][3]
 
@@ -379,18 +378,18 @@
                 Solutions[i, 5] = (np.arctan2((-HTinv[1][0]*np.sin(Solutions[i, 0])+HTinv[1][1]*np.cos(Solutions[i, 0]))/np.sin(Solutions[i, 4]),
                                            (HTinv[0][0]*np.sin(Solutions[i, 0])-HTinv[0][1]*np.cos(Solutions[i, 0]))/np.sin(Solutions[i, 4]))
                                 )
 
 
         # Solve for theta(3), elbow up and elbow down
         for i in range(8):
-            HTJoint = rob.ComputeJointHT(robot, [Solutions[i, 0], 0*Solutions[i, 1], 0*Solutions[i, 2], 0*Solutions[i, 3], Solutions[i, 4], Solutions[i, 5]])
+            HTJoint = rob.ComputeJointHT(robotDic, [Solutions[i, 0], 0*Solutions[i, 1], 0*Solutions[i, 2], 0*Solutions[i, 3], Solutions[i, 4], Solutions[i, 5]])
             T01 = HTJoint[0]
-            T45 = rob.DH2HT([Solutions[i, 4]]+robot['links'][4]['stdDH'][1:4])
-            T56 = rob.DH2HT([Solutions[i, 5]]+robot['links'][5]['stdDH'][1:4])
+            T45 = rob.DH2HT([Solutions[i, 4]]+robotDic['links'][4]['stdDH'][1:4])
+            T56 = rob.DH2HT([Solutions[i, 5]]+robotDic['links'][5]['stdDH'][1:4])
             T14 = np.linalg.inv(T01) @ HTdes @ np.linalg.inv(T45 @ T56)
             argumentCosine= ((np.linalg.norm(T14[0:2, 3]))**2-a2**2-a3**2) / (2*(a2)*(a3))
             print(argumentCosine)
             if argumentCosine <= 1 and argumentCosine >= -1:
                 solTheta3= np.arccos(argumentCosine)
 
                 if i % 2 == 0:
@@ -401,30 +400,30 @@
                 # Solve for theta(2)
                 Solutions[i, 1] = np.arctan2(-T14[1][3], -T14[0][3])-np.arcsin(-(a3)*np.sin(Solutions[i, 2])/(np.linalg.norm(T14[0:2, 3])))
                 # T14[1][3] not totaly clear, schould be [2][3]
 
 
                 # Solve for theta(4)
                 for i in range(8):
-                    HTJoint = rob.ComputeJointHT(robot, [Solutions[i, 0], Solutions[i, 1], Solutions[i, 2], 0*Solutions[i, 3], Solutions[i, 4], Solutions[i, 5]])
+                    HTJoint = rob.ComputeJointHT(robotDic, [Solutions[i, 0], Solutions[i, 1], Solutions[i, 2], 0*Solutions[i, 3], Solutions[i, 4], Solutions[i, 5]])
                     T03 = HTJoint[2]
-                    T45 = rob.DH2HT([Solutions[i, 4]]+robot['links'][4]['stdDH'][1:4])
-                    T56 = rob.DH2HT([Solutions[i, 5]]+robot['links'][5]['stdDH'][1:4])
+                    T45 = rob.DH2HT([Solutions[i, 4]]+robotDic['links'][4]['stdDH'][1:4])
+                    T56 = rob.DH2HT([Solutions[i, 5]]+robotDic['links'][5]['stdDH'][1:4])
                     T34 = np.linalg.inv(T03) @ HTdes @ np.linalg.inv(T45 @ T56)
                     Solutions[i, 3]= np.arctan2(T34[1][0], T34[0][0])
             else:
                 # print('No Solutions for theta 2, theta 3 and theta 4') # solutions not existing
                 SolWarning[3] = ['No Solutions for theta 2, theta 3 and theta 4']
                 Solutions[i, 2]= np.nan
                 Solutions[i, 3]= np.nan
                 Solutions[i, 1]= np.nan
     solutionsarray = np.array(Solutions)
     index2delete = []
     for i in range(len(solutionsarray)):
-        TSol = rob.ComputeJointHT(robot, solutionsarray[i])[5]
+        TSol = rob.ComputeJointHT(robotDic, solutionsarray[i])[5]
         errorSolution = np.linalg.det(HTdes)-np.linalg.det(TSol)
 
         # print(errorSolution)
         if errorSolution > ZERO or np.isnan(errorSolution):
             index2delete += [i]
 
 
@@ -457,17 +456,15 @@
     graphicsToolList+= [GraphicsDataOrthoCubePoint([0,0,0], toolSize, color4grey)]
 
     basePose2HT= HTtranslate([0,0,0]) @ HTrotateZ(0)    #robot base position and orientation  
     toolPose2HT=HTtranslate([0,0,0]) @ HTrotateZ(0)      #robot tool position and orientation 
 
     
     # choose robot to test 
-    robotModel= 'Puma560' # '3R'   'Puma560'    'UR'
-    
-    
+    robotModel= '3R' # '3R'   'Puma560'    'UR'
     
     if robotModel == '3R':
         # build robot from exudyn models
         myRobotDic = models.Manipulator3RSimple() 
 
     elif robotModel == 'Puma560':
         # build robot from exudyn models
@@ -492,41 +489,63 @@
     corkeRobot = MakeCorkeRobot(myRobotDic)
     # set joint values
     numberOfJoints= len(myRobotDic['referenceConfiguration'])
     qZero = np.zeros(numberOfJoints)
     qRand = (np.random.rand(numberOfJoints)*2 - np.ones(numberOfJoints) ) * np.pi
     
     # calculate forwarde kinematics    
-    HT0Corke = corkeRobot.fkine(qZero)
+    HTZeroCorke = corkeRobot.fkine(qZero)
     HTRandCorke = corkeRobot.fkine(qRand)
 
-    HT0Link = myRobotModel.LinkHT(qZero)
-    HTRandLink = myRobotModel.LinkHT(qRand)
-     
+    HTZeroExu = myRobotModel.LinkHT(qZero)
+    HTRandExu = myRobotModel.LinkHT(qRand)
      
-    # calculate inverse kinematics 
-    #MS Todo: compare inverse kinematics solution
-
+    HTZeroError = HTZeroCorke - HTZeroExu[-1]
+    HTRandError = HTRandCorke - HTRandExu[-1]
     
-   
-    
-
-
-
-
-
+    print('Forward kinematics check:\n zero config error = \n',HTZeroError)
+    print('Forward kinematics check:\n rand config error = \n',HTRandError)
 
+    # calculate inverse kinematics corke 
 
+    ikSolutionCorkeZero = corkeRobot.ikine_LM(HTZeroCorke,q0=qZero)
+    if ikSolutionCorkeZero.success==True:
+        print('corke solution found: \n qSolution=',ikSolutionCorkeZero.q)
+       
+    ikSolutionCorkeRand = corkeRobot.ikine_LM(HTRandCorke,q0=qRand-0.5)
+    if ikSolutionCorkeRand.success==True:
+        print('corke solution found: \n qSolution=',ikSolutionCorkeRand.q)
+    else:
+        print('corke no solution found for rand configuratio!')
+   
 
 
+    # calculate inverse kinematics exu 
 
+    if robotModel == '3R':
+        ikSolutionZeroExu = ComputeIK3R(myRobotDic, HTZeroExu[-1])
+        ikSolutionRandExu = ComputeIK3R(myRobotDic, HTRandExu[-1])
+        
+    elif robotModel == 'Puma560':
+        ikSolutionZeroExu = ComputeIK3R(myRobotDic, HTZeroExu[-1])
+        ikSolutionRandExu = ComputeIK3R(myRobotDic, HTRandExu[-1])
+        
+    # elif robotModel == 'UR':
+    #     ikSolutionZeroExu = ComputeIK3R(myRobotDic, HTZeroExu[-1])
+    #     ikSolutionRandExu = ComputeIK3R(myRobotDic, HTRandExu[-1])
 
 
 
+    #MS Todo: compare inverse kinematics solution  PUMA560 and UR
 
+    for sol in ikSolutionRandExu:
+        HTRandExuCheck = myRobotModel.LinkHT(sol)[-1]
+        HTErrorExu = HTRandExu[-1] - HTRandExuCheck
+        print('Error in position for solution q='+str(sol)+' \n Error=', HTErrorExu[0:3,3])
+        print('Error in orientation for solution q='+str(sol)+' \n Error=\n', HTErrorExu[0:3,0:3])
```

## exudyn/robotics/roboticsCore.py

```diff
@@ -1068,25 +1068,27 @@
     qProj = q1 - 2*np.pi*(q1 > np.pi)
     return qProj
 
 
 #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 #+++
 #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-#**function: This class can be used to solve the inverse kinematics problem using a multibody system 
+#**class: This class can be used to solve the inverse kinematics problem using a multibody system 
 #            by solving the static problem of a serial robot
-#**input:
-#  robot: robot class
-#  jointStiffness: the stiffness used for the robot's model joints
-#  useRenderer: when solving the inverse kinematics the renderer is used to show the starting/end 
-#               configuration of the robot using the graphics objects definded in the robot object
-#**author: Peter Manzl
+#**author: Peter Manzl, Johannes Gerstmayr
 #**notes: still under development; errors in orientations of solution may occure. proviedes mtehods to calculate inverse Kinematics 
 class InverseKinematicsNumerical(): 
     # initialize system
+    #**classFunction: initialize RigidBodyInertia with scalar mass, 3x3 inertiaTensor (w.r.t. reference point!!!) and center of mass com
+    #**input:
+    #  robot: robot class
+    #  jointStiffness: the stiffness used for the robot's model joints
+    #  useRenderer: when solving the inverse kinematics the renderer is used to show the starting/end 
+    #               configuration of the robot using the graphics objects definded in the robot object
+    #**author: Peter Manzl
     def __init__(self, robot, jointStiffness = 1e0, useRenderer=False, flagDebug=False, 
                  useAlternativeConstraints=False): 
         self.SC = exudyn.SystemContainer()
         self.mbsIK = self.SC.AddSystem()
         self.robot = robot
         self.nLinks = len(self.robot.links)
         self.useRenderer = useRenderer
@@ -1165,25 +1167,25 @@
     def createVector(p0, p01): 
         x = [p0[0], p0[0] + p01[0]]
         y = [p0[1], p0[1] + p01[1]]
         z = [p0[2], p0[2] + p01[2]]
         return x, y, z
 
 
-    #**function: Utility function to get current Homogeneous transformation of the robot to check inverse Kinematics solution
+    #**classFunction: Utility function to get current Homogeneous transformation of the robot to check inverse Kinematics solution
     # ** output: 
     #   T: 4x4 homogeneous Transformation matrix of the current TCP pose
     def GetCurrentRobotHT(self): 
         # self.robot.JointHT(q)[-1]  @ self.robot.tool.HT # proviedes same functionality as reading sensors...
         posFKine = self.mbsIK.GetSensorValues(self.sToolTrans) 
         RotFkine = self.mbsIK.GetSensorValues(self.sToolRot).reshape((3,3))
         T = erb.HomogeneousTransformation(RotFkine, posFKine) # global HT
         return T
 
-    #**function: 
+    #**classFunction: 
     #**input:
     #  T1: 4x4 homogeneous transformation matrix representing the first Pose
     #  T2: 4x4 homogeneous transformation matrix representing the second Pose
     #  rotStep: the max. size of steps to take for the orientation
     #  minSteps: minimum number of substeps to interpolate
     #**output: 
     # T: a List of homogeneous Transformations for each step between
@@ -1216,24 +1218,24 @@
             # Ri = Ri /np.linalg.det(Ri) # avoid
             ti = t1 + (t2-t1)*(i+1)/n 
             Ti = erb.HomogeneousTransformation(Ri, ti)    
             T += [Ti]
         T += [T2] # to satisfy the boundry condition
         return T
     
-    #**function: This Method can be used to solve the inverse kinematics problem by solving 
+    #**classFunction: This Method can be used to solve the inverse kinematics problem by solving 
     #            the static problem of a serial robot using steps to interpolate between start and end position close to the function Solve. 
     #            This helps the function Solve() to find the correct solutions. 
     #**input:
     #  T: the 4x4 homogeneous transformation matrix representing the desired position and orientation of the Endeffector
     #  q0: The configuration (joint angles/positions) of the robot from which the numerical methods start so calculate the solution; q0=None indicates that the stored solution (from model or previous solution) shall be used for initialization
     #**output: [q, success]; q: The solution for the joint angles in which the robot's tool center point (TCP) reaches the desired homogeneous transformation matrix T; success=False indicates that all trials for inverse kinematics failed, leading to q=None
     # success: flag to indicate if method was successful
     #**author: Peter Manzl, Johannes Gerstmayr
-    #**notes: still under development; errors in orientations of solution may occure. works similar to ikine_LM function of the robotics toolbox from peter corke
+    #**notes: still under development; errors in orientations of solution may occure. works similar to ikine\_LM function of the robotics toolbox from peter corke
     def SolveSafe(self, T, q0 = None):
         T0 = self.GetCurrentRobotHT()
         TInterp = self.InterpolateHTs(T0, T, rotStep=np.pi/3) # no steps in between needed!
         q = q0
         for Ti in TInterp:
             [q, success] = self.Solve(Ti, q)
             if not success: 
@@ -1267,23 +1269,23 @@
                     success = False
 
         if not success:
             q = None
 
         return [q, success]
     
-    #**function: This Method can be used to solve the inverse kinematics problem by solving 
+    #**classFunction: This Method can be used to solve the inverse kinematics problem by solving 
     #            the static problem of a serial robot using steps to interpolate between start and end position close to the function Solve. 
     #           T his helps the fucntion Solve to find the correct solutions. 
     #**input:
     #  T: the 4x4 homogeneous transformation matrix representing the desired position and orientation of the Endeffector
     #  q0: The configuration (joint angles/positions) of the robot from which the numerical methods start so calculate the solution; q0=None indicates that the stored solution (from model or previous solution) shall be used for initialization
     #**output: [q, success]; q: The solution for the joint angles in which the robot's tool center point (TCP) reaches the desired homogeneous transformation matrix T; success=False indicates that all trials for inverse kinematics failed, leading to q=None
     #**author: Peter Manzl, Johannes Gerstmayr
-    #**notes: still under development; errors in orientations of solution may occure. works similar to ikine_LM function of the robotics toolbox from peter corke
+    #**notes: still under development; errors in orientations of solution may occure. works similar to ikine\_LM function of the robotics toolbox from peter corke
     def Solve(self, T, q0 = None): 
         # check type of T 
         T = np.array(T)
         if T.shape != (4,4) or round(np.linalg.det(T[0:3, 0:3]),10) != 1.0:  # check if is homogeneous TF
             raise ValueError('inverse Kinematics only possible for homogeneous transformations, represented by a 4x4 array with structure of [[R, t], [0,0,0,1]].')
         q = None
         if not(hasattr(q0, '__iter__')) and q0 == None: #replace with: q0 is None
```

## exudyn/robotics/special.py

```diff
@@ -21,31 +21,27 @@
 #+++
 #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 #**function: compute velocity manipulability measure for given pose (homogeneous  transformation)
 #**input:
 #  robot: robot class
 #  HT: actual pose as homogeneous transformaton matrix
 #  mode: rotational or translational part of the movement
-#  singularWeight: Weighting of singular configurations where the value would be infinity,default value=100
 #**output: velocity manipulability measure as scalar value, defined as $\sqrt(det(JJ^T))$
 #**author: Martin Sereinig
 #**notes: compute velocity dependent manipulability definded by Yoshikawa, see \cite{Yoshikawa1985}
 def VelocityManipulability(robot, HT, mode):
     if mode == 'all':
         J = robot.Jacobian(HT, [], 'all')
 
-
     elif mode == 'rot':
         J = robot.Jacobian(HT, [], 'rot')
 
-
     elif mode == 'trans':
         J = robot.Jacobian(HT, [], 'trans')
-        
-        
+
     #check for singular Matrix not needed, no inverse is used
     mv2 = np.linalg.det(J@J.T)
     mv3 = np.max([0, mv2]) # to avoid negative values they are set to zero, same as corke
     #mv3 = np.abs(mv2)  #to avoid negative values, the absolute value of the determinat is used should be better
     mv = np.sqrt(mv3)
 
     return np.real(mv)
@@ -58,15 +54,15 @@
 #  robot: robot class
 #  HT: actual pose as hoogenious transformaton matrix
 #  singularWeight: Weighting of singular configurations where the value would be infinity, default value=100
 #  mode: rotational or translational part of the movement
 #**output: force manipulability measure as scalar value, defined as $\sqrt((det(JJ^T))^{-1})$
 #**author: Martin Sereinig
 #**notes: compute force dependent manipulability definded by Yoshikawa, see \cite{Yoshikawa1985}
-def ForceManipulability(robot, HT, mode,singular_weight=100):
+def ForceManipulability(robot, HT, mode,singularWeight=100):
     if mode == 'all':
         J = robot.Jacobian( HT, [], 'all')
 
 
     elif mode == 'rot':
         J = robot.Jacobian(HT, [], 'rot')
 
@@ -82,15 +78,15 @@
         #mf3 = np.abs(mf2) #to avoid negative values, the absolute value of the determinat is used should be better 
         mf = np.sqrt(mf3)
     else:   #matrix is singular for this joint configuration, force manipulability is set to a high value
         #alternative idea to handle singular matrix inversion(not working yet)
         #JhelpPinv=np.linalg.pinv(Jhelp)
         #mf2 = np.linalg.det(JhelpPinv)
         #mf = np.max([0, mf2])      # to avoid negative values they are set to zero, same as corke
-        mf =singular_weight
+        mf =singularWeight
     return np.real(mf)
 
 
 #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 #+++
 #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 #**function: compute cartesian stiffness measure for given pose (homogeneous transformation)
```

## exudyn/robotics/utilities.py

```diff
@@ -1,12 +1,65 @@
 #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 # This is a submodule of the EXUDYN python robotics library
 #
 # Details:  The utilities contains general helper functions for the robotics module
 #
-# Authors:  ...
-# Date:     2021-12-02
+# Authors:  Johannes Gerstmayr
+# Date:     2023-04-15
 #
 # Copyright:This file is part of Exudyn. Exudyn is free software. You can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
 #
 #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
+import numpy as np
+from math import sin, cos
+import exudyn
+from exudyn.utilities import AddDistanceSensor
+
+#**function: Function to add many distance sensors to represent Lidar; sensors can be either placed on absolute position or attached to rigid body marker
+#**input:
+#  generalContactIndex: the number of the GeneralContact object in mbs; the index of the GeneralContact object which has been added with last AddGeneralContact(...) command is generalContactIndex=mbs.NumberOfGeneralContacts()-1
+#  positionOrMarker: either a 3D position as list or np.array, or a MarkerIndex with according rigid body marker
+#  minDistance: the minimum distance which is accepted; smaller distance will be ignored
+#  maxDistance: the maximum distance which is accepted; items being at maxDistance or futher are ignored; if no items are found, the function returns maxDistance
+#  cylinderRadius: in case of spheres (selectedTypeIndex=ContactTypeIndex.IndexSpheresMarkerBased), a cylinder can be used which measures the shortest distance at a certain radius (geometrically interpreted as cylinder)
+#  lineLength: length of line to be drawn; note that this length is drawn from obstacle towards sensor if drawDisplaced=True, but the length is always constant
+#  numberOfSensors: number of sensors arranged between angleStart and angleEnd; higher numbers give finer resolution (but requires more CPU time)
+#  angleStart: starting rangle of angles to be used (in radiant)
+#  angleEnd: end of range for angle to be used (in radiant)
+#  inclination: angle of inclination (radiant), positive values showing upwards if placed
+#  rotation: a 3x3 rotation matrix (numpy); the sensor is placed in the X-Y plane of the marker where it is added to; however, you can use this rotation matrix to change the orientation
+#  selectedTypeIndex: either this type has default value, meaning that all items in GeneralContact are measured, or there is a specific type index, which is the only type that is considered during measurement
+#  storeInternal: like with any SensorUserFunction, setting to True stores sensor data internally
+#  fileName: if defined, recorded data of SensorUserFunction is written to specified file
+#  measureVelocity: if True, the sensor measures additionally the velocity (component 0=distance, component 1=velocity); velocity is the velocity in direction 'dirSensor' and does not account for changes in geometry, thus it may be different from the time derivative of the distance!
+#  addGraphicsObject: if True, the distance sensor is also visualized graphically in a simplified manner with a red line having the length of dirSensor; NOTE that updates are ONLY performed during computation, not in visualization; for this reason, solutionSettings.sensorsWritePeriod should be accordingly small
+#  drawDisplaced: if True, the red line is drawn backwards such that it moves along the measured surface; if False, the beam is fixed to marker or position
+#  color: optional color for 'laser beam' to be drawn
+#**output: creates sensor and returns list of sensor numbers for all laser sensors
+#**notes: use generalContactIndex = DistanceSensorSetupGeometry(...) before to create GeneralContact module containing geometry
+def AddLidar(mbs, generalContactIndex,
+            positionOrMarker, minDistance=-1e7, 
+            maxDistance=1e7, cylinderRadius=0, lineLength=1,
+            numberOfSensors=100, angleStart=0, angleEnd=2*np.pi,
+            inclination=0, rotation=np.eye(3),
+            selectedTypeIndex=exudyn.ContactTypeIndex.IndexEndOfEnumList,
+            storeInternal = False, fileName = '', measureVelocity = False,
+            addGraphicsObject=False, drawDisplaced=True, color=[1.0, 0.0, 0.0, 1.0]):
+
+    a=inclination
+    L=lineLength
+    phiRange=angleEnd-angleStart
+    sensorList = []
+    for i in range(numberOfSensors):
+        phi = i/numberOfSensors*phiRange+angleStart
+        dirSensor = np.array([L*sin(phi)*cos(a), L*cos(phi)*cos(a),L*sin(a)])#@rotation
+        #print(dirSensor, positionOrMarker)
+        sensorList += [AddDistanceSensor(mbs, generalContactIndex, positionOrMarker=positionOrMarker, 
+                                         dirSensor=dirSensor,minDistance=0, maxDistance=maxDistance, 
+                                         cylinderRadius=0, storeInternal=True, 
+                                         fileName=fileName, measureVelocity=True, addGraphicsObject=True,
+                                         selectedTypeIndex=selectedTypeIndex,
+                                         color=color)]
+
+    return sensorList
+
```

## Comparing `exudyn-1.6.31.dev1.dist-info/METADATA` & `exudyn-1.6.57.dev1.dist-info/METADATA`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: exudyn
-Version: 1.6.31.dev1
+Version: 1.6.57.dev1
 Summary: EXUDYN flexible multibody dynamics simulation in C++ and Python
 Home-page: https://github.com/jgerstmayr/EXUDYN
 Author: Johannes Gerstmayr
 Author-email: reply.exudyn@gmail.com
 License: BSD
 Platform: any
 Classifier: Development Status :: 4 - Beta
```

## Comparing `exudyn-1.6.31.dev1.dist-info/RECORD` & `exudyn-1.6.57.dev1.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -2,35 +2,35 @@
 exudyn/GUI.py,sha256=oBceXvJB9TTjyNMPieZnf9ICe6xunAVhcg2A06S72rI,42942
 exudyn/__init__.py,sha256=Vjdo4IwlQvcFeApZVT1eCyl81vH97RZxvjRjfQfZZds,6474
 exudyn/advancedUtilities.py,sha256=L6rPWNGiXodPKGftQLkBOtn8ZwD1dVb1WZQDqGCyLfY,16183
 exudyn/artificialIntelligence.py,sha256=s1TbljwSBtSNWk45m5__Nb3SZ2qC5yNH3_PgcftlSSs,15264
 exudyn/basicUtilities.py,sha256=zG5iN5W3IEc3fH1koAJ84nnKZyHcKWK1UbHTrL1_zcU,11393
 exudyn/beams.py,sha256=6onNzmq1ZP2Bn8-tCHzaetuOV9NtIW7WoVcXNRJuTLw,35948
 exudyn/demos.py,sha256=3sAMnfaAAHPk1i3TSmNLWkMCQ0J7v9h7olQsw5qP_uw,7288
-exudyn/exudynCPP.cp39-win_amd64.pyd,sha256=ZVpabTybZbDoRnPcDYU_mMgrPBT_pPk-0MLelJw-a_Q,5758976
+exudyn/exudynCPP.cp39-win_amd64.pyd,sha256=VMG2esMQIM_EkJCq3Jd-PQIwZHidVty8SuRZ3gnrc5o,5756416
 exudyn/graphicsDataUtilities.py,sha256=pgxtbOP_Gt7_JMibYpBZquGfvv9i6xScsIt8Fq_5lio,85436
 exudyn/interactive.py,sha256=A-bFzHVV4ScLfoZvfwUuf_7GDXZ7OI6DB8JtO3LQMME,53048
-exudyn/itemInterface.py,sha256=dnbC9QLDTc2czW02vYps-ciA_roqYyXkBcPtaf4i1Ko,158831
+exudyn/itemInterface.py,sha256=6JU3CwKuvdhbw6kyEF0WpJ2xooFU5palJBD-0z9sUBI,158659
 exudyn/kinematicTree.py,sha256=ltAKaZeW_7KZTdhq2Zh4SxpZw2mMf-OQIniNdi5iVqw,32746
 exudyn/lieGroupBasics.py,sha256=XpkhHFRrHgkwtNoEvtPXN-52Mpu4AbJzH8u-sQpGk2s,21846
 exudyn/lieGroupIntegration.py,sha256=svUYTow5b2JRWQ7EOZsSk8pkItqzGDyyKz0RZFU9Byg,13557
 exudyn/machines.py,sha256=YJ-Wepm3bXgPZuyVSc5_TB414IaUF9bZcSrp41sy5gc,3165
 exudyn/physics.py,sha256=uQp30quLIxQiraHpaqLX-RJi4xc964FqDk8df8czNhU,6169
 exudyn/plot.py,sha256=TkNGmmx75_QHql4eSb7XXnUVG1tVoYhKIMRkWM-H84w,50407
-exudyn/processing.py,sha256=NTgR52BZKzKuuTpeY-z9mwN3vsmNI_1wK-zFLQmXM6U,71064
+exudyn/processing.py,sha256=Oq_9fNK4l5dqtp6Nar5X4lfDgQhJlKCTWvTA_EV5LnE,71531
 exudyn/resultsMonitor.py,sha256=i1wZdH7M279jN9z1U0FFZAzVlr9gX1VO7d_vfcSmrTg,14646
 exudyn/rigidBodyUtilities.py,sha256=6JuoLiCQbcNE2jLeqCT9BMG0P4v-9HoiNtHtLUBeG3o,65543
-exudyn/signalProcessing.py,sha256=6cDmzFBR0kkt4e7paYpdN1f8SzRwaPLSEzJvC8prM_Y,12363
+exudyn/signalProcessing.py,sha256=3QZAnQT9BMLts5hVlJMKhkvbA4SDB9KJ1sK-IqAhYLI,15158
 exudyn/solver.py,sha256=ZoU8FPU9B1TKnyX1RnXHzOqkjECCKAzHQkCtCrH7Om0,27593
-exudyn/utilities.py,sha256=L3gLXQFPkl-GPxYdstxSvC0BNVxeqLye4fDtg-8lgtM,64279
+exudyn/utilities.py,sha256=1fRIDk8x8h9J6kQ-xjw5lOqyTxHyexx2bsu25NWzDuI,66527
 exudyn/robotics/__init__.py,sha256=Pzu7pcW4qLUaw3nY2sPTkav4N2PrDgNFmB_1gzeNwLs,898
-exudyn/robotics/future.py,sha256=Yg-xend8uZlC5_EgrBXWBQPN7cx-G-OvH-0M_gxrmo4,22786
+exudyn/robotics/future.py,sha256=T9Tc_5zzo_LrFI2QZZBK2fBmxjVOKtR3IdUyH2El0mo,24507
 exudyn/robotics/mobile.py,sha256=npw-Qr4cXeNLKjvmkVf0JJFActlimPa1mlC-6s7SSGQ,527
 exudyn/robotics/models.py,sha256=23uffRQWvGSAnH5Vx9BUcRTMj9fkMRSkxDI1Wrkb97E,32539
 exudyn/robotics/motion.py,sha256=ccBje_jiBoulEPp7cxekOmR9BnaIxH_-LoTkMTUNQls,26097
-exudyn/robotics/roboticsCore.py,sha256=3HQlLvZUYxrcdVkrQIxg1ChZbOtMYicOkOZNiKK1QIk,97646
-exudyn/robotics/special.py,sha256=_9KBu1OM5JnZaXgMVJVeahQu0qAWN499b47DH0Zhiv0,15299
-exudyn/robotics/utilities.py,sha256=vto-r4akJymZBdFU9eOncV5y9lpiHdZqEmuDvyBxiGY,544
-exudyn-1.6.31.dev1.dist-info/METADATA,sha256=GDblGtMxlyuLLg6YDtajv2sY7IQnn8jURNQLVyWWioE,1653
-exudyn-1.6.31.dev1.dist-info/WHEEL,sha256=fVcVlLzi8CGi_Ul8vjMdn8gER25dn5GBg9E6k9z41-Y,100
-exudyn-1.6.31.dev1.dist-info/top_level.txt,sha256=w4EYVbsh-zIfLBaDyrwYdU7hMcmaIS3OhFvBmSgkFO4,7
-exudyn-1.6.31.dev1.dist-info/RECORD,,
+exudyn/robotics/roboticsCore.py,sha256=zbk3VJ5SMUs015UpvGY7X_XM7N-8z29XLAJQBN6eQE0,97871
+exudyn/robotics/special.py,sha256=FSGl9VeXLDfgFNHhGh0Wm8pCbRgTVffWq2b2O4042hc,15166
+exudyn/robotics/utilities.py,sha256=7Kp_Ce-b2O3RvQGHtDw50uN3iFew19p_9RLGzsOODa8,5171
+exudyn-1.6.57.dev1.dist-info/METADATA,sha256=u2lAOxuujXzIJGaBk7Lzy961oYAbAUW55sfmHfroC7U,1653
+exudyn-1.6.57.dev1.dist-info/WHEEL,sha256=fVcVlLzi8CGi_Ul8vjMdn8gER25dn5GBg9E6k9z41-Y,100
+exudyn-1.6.57.dev1.dist-info/top_level.txt,sha256=w4EYVbsh-zIfLBaDyrwYdU7hMcmaIS3OhFvBmSgkFO4,7
+exudyn-1.6.57.dev1.dist-info/RECORD,,
```

